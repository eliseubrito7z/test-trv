(function(){"use strict";try{if(typeof document<"u"){var e=document.createElement("style");e.appendChild(document.createTextNode('.codemirror-container[data-v-9f50a430]{width:100%;height:100%;padding-top:4px;min-height:76px;background:var(--theme-background-2, var(--default-theme-background-2));color:var(--theme-color-1, var(--default-theme-color-1));display:flex;align-items:stretch}.copy-to-clipboard-button[data-v-9f50a430]{background:red}.codemirror{flex-grow:1;max-width:100%;cursor:text;font-size:var(--theme-small, var(--default-theme-small));-webkit-text-size-adjust:100%}.cm-focused{outline:none!important}.modal-layout[data-v-a06b8e92]{position:fixed;width:100vw;height:100vh;top:0;left:0;z-index:1001;background:#00000070;padding:20px;opacity:0;animation:modal-fade-a06b8e92 .2s forwards}.modal-body[data-v-a06b8e92]{padding:24px 24px 18px;max-height:calc(100vh - 240px);background:var(--theme-background-1, var(--default-theme-background-1));border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));font-family:var(--theme-font, var(--default-theme-font));position:relative}.modal[data-v-a06b8e92]{margin:80px auto 0;position:relative;background:var(--theme-background-2, var(--default-theme-background-2));border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));color:var(--theme-color-1, var(--default-theme-color-1));width:100%;text-align:left;line-height:1.4;opacity:0;transform:scale(.98);animation:modal-pop-a06b8e92 .15s .15s forwards;display:flex;flex-direction:column}.modal[data-v-a06b8e92]:before{content:"";display:block;width:100%;height:100%;position:absolute;z-index:0;border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg))}.dark-mode .modal[data-v-a06b8e92]:before{background:#1a1a1a}.light-mode .modal[data-v-a06b8e92]:before{background:#fff}.modal-content-history[data-v-a06b8e92]{background:var(--theme-background-1, var(--default-theme-background-1))}.modal-content-history[data-v-a06b8e92],.modal-content-large[data-v-a06b8e92]{max-width:800px}.modal-content-normal[data-v-a06b8e92]{max-width:640px}.modal-content-small[data-v-a06b8e92]{max-width:480px}@keyframes modal-fade-a06b8e92{0%{opacity:0}to{opacity:1}}@keyframes modal-pop-a06b8e92{0%{opacity:0}to{opacity:1;transform:scale(1)}}.modal-header[data-v-a06b8e92]{padding:12px 24px;color:var(--theme-color-1, var(--default-theme-color-1));font-size:var(--theme-font-size-4, var(--default-theme-font-size-4));text-align:left;font-weight:600;margin:0;border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg)) var(--theme-radius-lg, var(--default-theme-radius-lg)) 0 0;z-index:1}.modal-content-history .modal-header[data-v-a06b8e92]{padding-bottom:0;padding-top:24px}.modal-content-history .modal-body[data-v-a06b8e92]{padding-top:12px}.modal-content-search[data-v-a06b8e92]{max-width:540px}.modal-content-search .modal-body[data-v-a06b8e92]{padding:0;overflow:hidden;display:flex;flex-direction:column;max-height:440px}.navtable-item-time[data-v-fd992042]{text-transform:capitalize}.navtable-item__active[data-v-fd992042]{background:var(--theme-background-2, var(--default-theme-background-2));cursor:default}.navtable-mock{background-repeat:repeat;width:100%;background-size:31px 31px;background-position:center 1px;flex:1;position:relative;z-index:0;border-top:1px solid var(--theme-border-color, var(--default-theme-border-color));background:repeating-linear-gradient(var(--theme-background-1, var(--default-theme-background-1)),var(--theme-background-1, var(--default-theme-background-1)) 34.8px,var(--theme-border-color, var(--default-theme-border-color)) 34.8px,var(--theme-border-color, var(--default-theme-border-color)) 35.8px)}.navtable-mock .navtable-item{position:absolute;width:100%;height:100%;left:0;top:0;background:transparent;box-shadow:none}.radio{height:10px;max-width:10px;width:10px;max-height:10px;background:transparent;border:var(--border, var(--default-border));flex-shrink:0;margin-right:6px;margin-left:0;border-radius:50%;display:flex;align-items:center;justify-content:center;outline:none;padding:0}.radio:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;cursor:pointer}.navtable-item__active:before{content:"";display:block;box-shadow:0 0 0 1px var(--theme-color-1, var(--default-theme-color-1))!important;width:100%;position:absolute;top:0;left:0;height:100%}.radio.post{background:var(--theme-color-green, var(--default-theme-color-green))}.radio.delete{background:var(--theme-color-red, var(--default-theme-color-red))}.radio.patch{background:var(--theme-color-yellow, var(--default-theme-color-yellow))}.radio.get{background:var(--theme-color-blue, var(--default-theme-color-blue))}.radio.put{background:var(--theme-color-orange, var(--default-theme-color-orange))}.navtable-item-request span{border:none;outline:none;font-size:var(--theme-micro, var(--default-theme-micro));color:var(--theme-color-1, var(--default-theme-color-1));width:100%;display:block;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.navtable-item-request span em{text-transform:uppercase;font-style:normal;font-family:var(--theme-font-code, var(--default-theme-font-code));font-size:var(--theme-micro, var(--default-theme-micro));margin-right:6px;font-weight:var(--theme-semibold, var(--default-theme-semibold));color:var(--theme-color-3, var(--default-theme-color-3))}.request-method-select[data-v-f4f13406]{position:relative;display:flex}.request-method-select select[data-v-f4f13406]{border:none;outline:none;cursor:pointer;background:var(--theme-background-3, var(--default-theme-background-3));box-shadow:-2px 0 0 0 var(--theme-background-3, var(--default-theme-background-3));position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;-moz-appearance:none;-webkit-appearance:none;appearance:none}.request-method-select select[disabled][data-v-f4f13406]{pointer-events:none}.request-method[data-v-f4f13406]{display:flex;align-items:center;color:var(--theme-color-3, var(--default-theme-color-3));-moz-appearance:none;appearance:none;-webkit-appearance:none;padding:0 12px;border-right:1px solid var(--theme-border-color, var(--default-theme-border-color));position:relative}.request-method span[data-v-f4f13406]{font-family:var(--theme-font-code, var(--default-theme-font-code));font-size:500;font-size:var(--theme-micro, var(--default-theme-micro));text-transform:uppercase;display:flex;align-items:center}.request-method:not(.request-method--disabled) span[data-v-f4f13406]:after{content:"";width:7px;height:7px;transform:rotate(45deg) translate3d(-2px,-2px,0);display:block;margin-left:6px;box-shadow:1px 1px 0 currentColor}.request-method i[data-v-f4f13406]{width:10px;height:10px;border-radius:50%;margin-right:6px;text-align:center;line-height:18px;font-style:normal;flex-shrink:0;display:inline-block;color:var(--theme-color-disabled, var(--default-theme-color-disabled));background:var( --scalar-api-client-color, var(--default-scalar-api-client-color) )}.api-client-url-variable{color:var(--scalar-api-client-color, var(--default-scalar-api-client-color))}.loader[data-v-7050af3f]{position:absolute;z-index:3;height:2px;background:var( --scalar-api-client-color, var(--default-scalar-api-client-color) );animation:loading-7050af3f 5s cubic-bezier(0,.5,.25,1)}@keyframes loading-7050af3f{0%{width:0}to{width:100%}}.address-bar[data-v-7050af3f]{width:100%;padding:12px 12px 10px;display:flex;align-items:center;position:relative;background:var(--theme-background-1, var(--default-theme-background-1))}.url-form[data-v-7050af3f]{display:flex;width:100%;align-items:stretch;border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg))}.url-form[data-v-7050af3f] .cm-content{display:flex;align-items:center}.url-form-field[data-v-7050af3f]{border-right:0;background:var(--theme-background-2, var(--default-theme-background-2));border-radius:var(--theme-radius, var(--default-theme-radius)) 0 0 var(--theme-radius, var(--default-theme-radius));display:flex;align-items:stretch;width:100%;overflow:hidden;min-height:31px}.url-form-input[data-v-7050af3f]{color:var(--theme-color-1, var(--default-theme-color-1))}.url-form-input[data-v-7050af3f]{font-weight:var(--theme-semibold, var(--default-theme-semibold));min-height:auto;padding-top:0}.url-form-input[data-v-7050af3f] .cm-scroller{overflow-y:hidden}.history[data-v-7050af3f]{-moz-appearance:none;appearance:none;-webkit-appearance:none;background:transparent;color:var(--theme-color-2, var(--default-theme-color-2));display:flex;align-items:center;border-radius:var(--theme-radius, var(--default-theme-radius));height:100%}.send-button[type=submit][data-v-7050af3f]{font-size:var(--theme-micro, var(--default-theme-micro));letter-spacing:.25px;font-weight:var(--theme-semibold, var(--default-theme-semibold));color:#fff;border:none;white-space:nowrap;padding:0 12px;text-transform:uppercase;cursor:pointer;outline:none;font-family:(--theme-font,var(--default-theme-font));border-radius:0 var(--theme-radius, var(--default-theme-radius)) var(--theme-radius, var(--default-theme-radius)) 0;background:var( --scalar-api-client-color, var(--default-scalar-api-client-color) );position:relative;display:flex;align-items:center;overflow:hidden;flex-shrink:0}.send-button[data-v-7050af3f]:before{content:"";position:absolute;top:-5%;left:-5%;width:110%;height:110%;pointer-events:none;cursor:pointer;border-radius:var(--theme-radius, var(--default-theme-radius));background:linear-gradient(#0000001a,#0003)}.send-button[data-v-7050af3f]:hover:before{background:linear-gradient(#0003,#0000001a)}.send-button svg[data-v-7050af3f]{width:12px;height:12px;flex-shrink:0;margin-right:6px;position:relative}.send-button span[data-v-7050af3f]{position:relative}@media screen and (max-width: 720px){.history-toggle span[data-v-7050af3f],.send-button span[data-v-7050af3f]{display:none}.history-toggle svg[data-v-7050af3f],.send-button svg[data-v-7050af3f]{margin-right:0}}.send-button[disabled][data-v-7050af3f]{pointer-events:none;color:var(--theme-color-2, var(--default-theme-color-2));background:var(--theme-background-3, var(--default-theme-background-3));border:1px solid var(--default-theme-border-color)}.history-toggle[data-v-7050af3f]{padding:0 12px;line-height:30px;color:var(--theme-color-3, var(--default-theme-color-3));font-size:var(--theme-micro, var(--default-theme-micro));letter-spacing:.125px;font-weight:var(--theme-semibold, var(--default-theme-semibold));text-transform:uppercase;height:100%;display:flex;align-items:center;cursor:pointer;white-space:nowrap;box-shadow:0 0 0 1px var(--theme-border-color, var(--default-theme-border-color));margin-left:12px;border-radius:var(--theme-radius, var(--default-theme-radius));-webkit-user-select:none;user-select:none}.history-toggle[data-v-7050af3f]:hover{background:var(--theme-background-2, var(--default-theme-background-2))}.history-toggle svg[data-v-7050af3f]{height:13px;width:13px;margin-right:6px;color:var(--theme-color-3, var(--default-theme-color-3))}.address-bar-content[data-v-7050af3f]{width:640px;height:100%;background:var(--theme-background-1, var(--default-theme-background-1));position:fixed;top:0;right:0;z-index:1000;transform:translate3d(640px,0,0);opacity:0;transition:transform .5s cubic-bezier(.77,0,.175,1),opacity .01s ease-in-out .5s;pointer-events:none}.address-bar--with-history[data-v-7050af3f]{z-index:100000}.address-bar--with-history .address-bar-content[data-v-7050af3f]{transform:translateZ(0);opacity:1;pointer-events:all;transition:transform .5s cubic-bezier(.77,0,.175,1)}.address-bar--with-history .address-bar-close[data-v-7050af3f]{opacity:1;pointer-events:all;cursor:pointer}.address-bar-close[data-v-7050af3f]{width:100%;height:100%;position:fixed;top:0;left:0;pointer-events:none;opacity:0;transition:all .1s ease-in-out;z-index:1000}.scalar-api-client__item{border-radius:var(--theme-radius, var(--default-theme-radius));margin-bottom:6px;position:relative}.scalar-api-client__item button{background-color:transparent;text-align:left}.scalar-api-client__item:hover{cursor:pointer}.scalar-api-client__toggle:after{content:"";position:absolute;bottom:-6.5px;width:100%;height:6px;left:0}.scalar-api-client__item--open .scalar-api-client__toggle:after{display:none}.scalar-api-client__item:hover,.scalar-api-client__item--open{background:var(--theme-background-2, var(--default-theme-background-2))}.scalar-api-client__item--open .scalar-api-client__item__content{display:flex}.scalar-api-client__item--open:hover{cursor:default}.scalar-api-client__item--open .scalar-api-client__toggle__icon{transform:rotate(90deg)}.scalar-api-client__toggle{padding:6px;min-height:37px;display:flex;align-items:center;justify-content:space-between;position:relative;width:100%;-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:0;border:none;font-family:(--theme-font,var(--default-theme-font));cursor:pointer}.scalar-api-client__item .scalar-api-client__item__title{color:var(--theme-color-1, var(--default-theme-color-1));font-size:var(--theme-small, var(--default-theme-small));font-weight:var(--theme-semibold, var(--default-theme-semibold));font-family:(--theme-font,var(--default-theme-font));-webkit-user-select:none;user-select:none;flex:1;position:relative;z-index:1}.scalar-api-client__item .scalar-api-client__toggle__icon{width:10px;margin-right:6px;color:var(--theme-color-3, var(--default-theme-color-3));z-index:1;position:relative}.scalar-api-client__toggle:hover .scalar-api-client__toggle__icon{color:var(--theme-color-1, var(--default-theme-color-1))}.scalar-api-client__item__options{position:relative;z-index:1}.scalar-api-client__item__options span{background:transparent;padding:2px 0;border-radius:3px;font-size:var(--theme-small, var(--default-theme-small));pointer-events:none;color:var(--theme-color-2, var(--default-theme-color-2));display:flex;align-items:center;justify-content:center}.scalar-api-client__item__options:hover span{color:var(--theme-color-1, var(--default-theme-color-1));border-color:currentColor}.scalar-api-client__item__options span svg{width:15px;height:15px;margin-left:3px}.scalar-api-client__item__options select{position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;cursor:pointer;-moz-appearance:none;-webkit-appearance:none;appearance:none}.scalar-api-client__item__content .scalar-api-client__codemirror__wrapper{padding-top:0}.table{border:1px solid var(--theme-border-color, var(--default-theme-border-color));background:transparent;border-radius:var(--theme-radius, var(--default-theme-radius));width:100%}.table-row{border-bottom:1px solid var(--theme-border-color, var(--default-theme-border-color));display:flex;position:relative}.table-row__add{border-radius:0 0 var(--theme-radius-lg, var(--default-theme-radius-lg)) var(--theme-radius-lg, var(--default-theme-radius-lg));border-bottom:none}.table-row.required-parameter .table-row-item:nth-of-type(2):after{content:"Required";position:absolute;top:4px;right:0;padding:5px 9px 5px 6px;font-weight:var(--theme-semibold, var(--default-theme-semibold));font-size:var(--theme-micro, var(--default-theme-micro));background:var(--theme-background-2, var(--default-theme-background-2));box-shadow:-2px 0 4px var(--theme-background-2, var(--default-theme-background-2))}.table-row.required-parameter .table-row-item:nth-of-type(2):focus-within:after{display:none}.table-row:last-of-type{border-bottom:none}.table-row__active{border-radius:0 0 var(--theme-radius-lg, var(--default-theme-radius-lg)) var(--theme-radius-lg, var(--default-theme-radius-lg))}.table-row-drag{width:20px;flex-shrink:0;border-right:1px solid var(--theme-border-color, var(--default-theme-border-color));align-items:center;justify-content:center;display:none}.table-row-drag svg{width:6px;fill:var(--theme-color-3, var(--default-theme-color-3))}.table-row-drag .table-row-drag-add{width:8px}.table-row-item{width:100%;border-right:1px solid var(--theme-border-color, var(--default-theme-border-color));position:relative}.table-row-item-menu{position:absolute;right:6px;background:var(--theme-background-2, var(--default-theme-background-2));width:24px;height:24px;top:50%;transform:translate3d(0,-50%,0);border-radius:50%;display:flex;align-items:center;justify-content:center;opacity:0;cursor:pointer}.table-row-item input:focus+.table-row-item-menu,.table-row-item:hover .table-row-item-menu{opacity:1}.table-row-item-menu svg{height:12px;width:initial;fill:var(--theme-color-3, var(--default-theme-color-3))}.table-row-item-menu:hover svg{fill:var(--theme-color-1, var(--default-theme-color-1))}.table-row-item input{border:none;-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:none;padding:9px;width:100%;min-height:100%;color:var(--theme-color-1, var(--default-theme-color-1));font-size:var(--theme-micro, var(--default-theme-micro));background:transparent;font-family:var(--theme-font, var(--default-theme-font))}.table-row-item input[disabled]{background:transparent;font-family:var(--theme-font-code, var(--default-theme-font-code))}.table-row-item input:focus{box-shadow:0 0 0 1px var(--theme-color-1, var(--default-theme-color-1))}.table-row-item label{background:transparent;text-transform:uppercase;display:block;padding:9px;font-weight:var(--theme-semibold, var(--default-theme-semibold));color:var(--theme-color-2, var(--default-theme-color-2));font-size:var(--theme-micro, var(--default-theme-micro))}.table-row-meta{overflow:hidden;flex-shrink:0;transition:all .15s ease-in-out;display:flex;align-items:center;justify-content:center;width:51px;-webkit-user-select:none;user-select:none}.table-row-meta-check{width:18px;height:18px;border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));background:#2fb1e41a}.table-row-meta svg{width:13px;height:13px;margin:0 1px;color:var(--theme-color-3, var(--default-theme-color-3));cursor:pointer}.table-row-meta svg:hover{color:var(--theme-color-2, var(--default-theme-color-2))}.meta-check{display:flex;position:relative;cursor:pointer;align-items:center;font-size:var(--theme-micro, var(--default-theme-micro));border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));-webkit-user-select:none;user-select:none;margin:0 1px;transition:all .15s ease-in-out}.meta-check input{position:absolute;opacity:0;cursor:pointer;height:0;width:0}.meta-checkmark{height:17px;width:17px;background:var(--theme-background-3, var(--default-theme-background-3));border-radius:3px;display:flex;align-items:center;justify-content:center;position:relative}.meta-checkmark:hover{background:var(--theme-background-3, var(--default-theme-background-3))}.meta-check:focus-within .meta-checkmark{box-shadow:0 0 0 1px var(--theme-color-1, var(--default-theme-color-1))}.meta-check .meta-checkmark:after{content:"";display:none;width:5px;height:8px;border:solid var(--theme-color-1, var(--default-theme-color-1));border-width:0 1.5px 1.5px 0;transform:rotate(45deg) translate3d(0,-1px,0)}.meta-check input:checked~.meta-checkmark:after{display:block}.meta-check input:checked~.meta-checkmark:hover{background:transparent}.navtable{width:100%}.navtable-follow{background-color:#000;color:#fff;font-size:9px;padding:6px;display:-webkit-box;max-width:250px;-webkit-line-clamp:12;border-radius:3px;-webkit-box-orient:vertical;overflow:hidden;line-height:1.24;transform:translate3d(10px,0,0)}.navtable-follow:after{content:"";position:absolute;bottom:0;width:100%;height:6px;background-color:#000}.navtable-follow *{font-family:var( --theme-font-code, var(--default-theme-font-code) )!important}.navtable-table{position:relative;display:flex;flex-direction:column;min-height:389px;border-radius:var(--theme-radius, var(--default-theme-radius));border:1px solid var(--theme-border-color, var(--default-theme-border-color))}.navtable-radios{z-index:1;border-top:1px solid var(--theme-border-color, var(--default-theme-border-color))}.navtable-item{display:flex;position:relative;color:var(--theme-color-1, var(--default-theme-color-1));font-size:var(--theme-micro, var(--default-theme-micro));border-top:1px solid var(--theme-border-color, var(--default-theme-border-color));font-weight:var(--theme-semibold, var(--default-theme-semibold))}.navtable-item:first-of-type{border-top:none}.navtable-item>div{word-wrap:break-word}.navtable-item>div:not(:first-child){border-left:1px solid var(--theme-border-color, var(--default-theme-border-color))}.navtable-item-action{color:var(--theme-color-2, var(--default-theme-color-2));font-size:var(--theme-micro, var(--default-theme-micro));font-weight:var(--theme-bold, var(--default-theme-bold));background:var( --scalar-api-client-bg3, var(--default-scalar-api-client-bg3) );border:none;border-radius:30px;-webkit-appearance:none;-moz-appearance:none;appearance:none;max-height:25px;margin-left:12px;margin-right:6px;padding:4px 8px;outline:none;cursor:pointer;opacity:0;transition:opacity .15s ease-in-out;white-space:nowrap;position:relative}.navtable-item-action:hover{color:var(--theme-color-1, var(--default-theme-color-1));background:var( --scalar-api-client-gradient, var(--default-scalar-api-client-gradient) );box-shadow:0 0 0 1px var(--theme-border-color, var(--default-theme-border-color))}.navtable-item-action:focus{background:var(--theme-background-2, var(--default-theme-background-2))}.navtable-item:hover,.navtable-item:focus-within .navtable-item-action{opacity:1}.navtable-item-add{display:flex;align-items:center;padding:9px;font-weight:var(--theme-bold, var(--default-theme-bold));outline:none;border:none;-webkit-appearance:none;-moz-appearance:none;appearance:none;background:transparent;color:var(--theme-color-1, var(--default-theme-color-1))}.navtable-item-add:hover{background:var(--theme-background-2, var(--default-theme-background-2));cursor:pointer}.navtable-item-25{width:25%;font-size:var(--theme-micro, var(--default-theme-micro));display:flex;align-items:center}.navtable-item-33{width:33.33333%;display:flex;font-size:var(--theme-micro, var(--default-theme-micro));align-items:center}.navtable-item-66{width:66.6666%;display:flex;font-size:var(--theme-micro, var(--default-theme-micro));align-items:center}.navtable-item-75{width:75%;display:flex;align-items:center}.navtable-item-75:focus-within{background:var(--theme-background-2, var(--default-theme-background-2))}.navtable-item-40{width:40%;display:flex;align-items:center;padding:9px}.navtable-item-20{width:20%;display:flex;align-items:center;padding:9px}.navtable-item-50{width:50%;display:flex;align-items:center}.navtable-item-50:focus-within{background:var(--theme-background-2, var(--default-theme-background-2))}.navtable-item p{padding:9px}.navtable-item input{padding:12px 6px;border:none;outline:none;-webkit-appearance:none;-moz-appearance:none;appearance:none;font-size:var(--theme-micro, var(--default-theme-micro));color:var(--theme-color-1, var(--default-theme-color-1));background:transparent;width:100%}.navtable-item input:focus{background:var(--theme-background-2, var(--default-theme-background-2))}.navtable-item-select{position:relative}.navtable-item-select select{background:transparent;outline:none;border:none;font-size:var(--theme-micro, var(--default-theme-micro));-moz-appearance:none;-webkit-appearance:none;appearance:none;width:100%;padding:12px 6px;top:0;position:relative;cursor:pointer;color:var(--theme-color-2, var(--default-theme-color-2))}.navtable-item-select svg{position:absolute;right:6px;color:var(--theme-color-ghost, var(--default-theme-color-ghost));width:6px;top:12px;pointer-events:none}.navtable-item .option{padding:12px 6px;font-size:var(--theme-micro, var(--default-theme-micro));color:var(--theme-color-1, var(--default-theme-color-1));width:100%}.navtable-item label{color:var(--theme-color-3, var(--default-theme-color-3));font-size:var(--theme-micro, var(--default-theme-micro));font-weight:var(--theme-semibold, var(--default-theme-semibold));text-transform:uppercase;display:block;width:100%}.navtable-item-response{padding:0 9px}.navtable-item-response span{font-size:var(--theme-micro, var(--default-theme-micro));display:flex;align-items:center;margin-right:9px;min-width:40px}.scalar-api-client__status--1xx:before,.scalar-api-client__status--2xx:before,.scalar-api-client__status--3xx:before,.scalar-api-client__status--4xx:before,.scalar-api-client__status--5xx:before,.scalar-api-client__status--6xx:before{content:"";width:10px;height:10px;border-radius:50%;margin-right:4px;background:var(--theme-background-2, var(--default-theme-background-2))}.scalar-api-client__status--2xx:before{background:var(--theme-color-green, var(--default-theme-color-green))}.scalar-api-client__status--3xx:before{background:var(--theme-color-orange, var(--default-theme-color-orange))}.scalar-api-client__status--4xx:before{background:var(--theme-color-red, var(--default-theme-color-red))}.navtable-item-response span:empty{display:none}.simpletable.navtable{padding:0}.simpletable.navtable .navtable-item-66,.simpletable.navtable .navtable-item-33{display:block}.simpletable.navtable .navtable-table{height:fit-content}.meta-delete{position:absolute;right:-9px;background:var( --theme-background-3, var(--default-theme-background-3) )!important;height:20px;width:20px;border:none;outline:none;border-radius:50%;opacity:0;padding:5px;display:flex;align-items:center;justify-content:center;cursor:pointer}.meta-delete svg{width:11px;height:11px;color:var(--theme-color-3, var(--default-theme-color-3))}.meta-delete:hover svg{color:var(--theme-color-red, var(--default-theme-color-red))}.meta-delete:focus svg{color:var(--theme-color-1, var(--default-theme-color-1))}.meta-delete:focus{border-color:var(--theme-color-1, var(--default-theme-color-1));color:var(--theme-color-1, var(--default-theme-color-1))}.table-row:hover .meta-delete{opacity:1}@media (pointer: coarse){.table-row:hover .meta-delete{opacity:1}}.meta-actions-item{border:none;font-weight:var(--theme-semibold, var(--default-theme-semibold));padding:9px;width:100%;-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:none;font-size:var(--theme-micro, var(--default-theme-micro));font-family:var(--theme-font, var(--default-theme-font));color:var(--theme-color-3, var(--default-theme-color-3));cursor:pointer;display:flex;align-items:center;gap:6px}.meta-actions{width:100%;display:flex;justify-content:space-between}.meta-actions-item:nth-of-type(2){display:flex;justify-content:flex-end}.meta-actions-item:nth-of-type(2) i{filter:drop-shadow(0 .125px 0 currentColor) drop-shadow(0 -.125px 0 currentColor)}.meta-actions-item-icon{width:12px;height:12px}.meta-actions-item:hover,.meta-actions-item:focus{color:var(--theme-color-1, var(--default-theme-color-1))}.scalar-api-client-add{color:var(--theme-color-2, var(--default-theme-color-2));padding:6px;width:fit-content;border-radius:var(--theme-radius, var(--default-theme-radius));cursor:pointer;font-size:var(--theme-micro, var(--default-theme-micro));font-weight:var(--theme-semibold, var(--default-theme-semibold));text-decoration:none;margin:0 6px;border:none;font-family:var(--theme-font);-webkit-appearance:none;-moz-appearance:none;appearance:none;display:flex;align-items:center}.scalar-api-client-add svg{width:12px;height:12px;margin-right:6px}.scalar-api-client-add:hover{color:var(--theme-color-1, var(--default-theme-color-1))}.scalar-api-client-add:focus-within{background:var(--theme-background-3, var(--default-theme-background-3))}.scalar-api-client__main__left{width:50%;border-right:1px solid var(--theme-border-color, var(--default-theme-border-color));padding:0 18px 12px}@media screen and (max-width: 820px){.scalar-api-client__main__left{width:100%;border-right:none;padding:0 12px 12px}}.scalar-api-client__item__content{flex-flow:wrap;padding:3px 9px 9px;border-radius:3px;color:var(--theme-color-3, var(--default-theme-color-3));font-size:var(--theme-micro, var(--default-theme-micro));margin-top:-3px;justify-content:space-between;overflow:auto}.scalar-api-client__item__content .scalar-api-client__codemirror__wrapper{width:100%;min-height:63px}.scalar-api-client__item__content .scalar-codeblock-pre,.scalar-api-client__item__content .cm-s-default{border:1px solid var(--theme-border-color, var(--default-theme-border-color));border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg))}.scalar-api-client__item__content .scalar-codeblock-pre,.scalar-api-client__item__content .codemirror-container{width:100%;max-height:calc(100vh - 300px);overflow:auto}.scalar-api-client__item__content .cm-scroller{border:1px solid var(--theme-border-color, var(--default-theme-border-color));border-radius:3px}.scalar-api-client__item__content .cm-editor{outline:none!important}.scalar-api-client__item__content .cm-editor .cm-gutters,.scalar-api-client__item__content .cm-scroll{background:transparent}.scalar-api-client__item__content .cm-editor *{font-size:var(--theme-micro, var(--default-theme-micro))}.scalar-api-client__item__content .cm-editor .cm-line{color:var(--theme-color-1, var(--default-theme-color-1))}.scalar-api-client__item__content-button{-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;outline:none;font-size:var(--theme-micro, var(--default-theme-micro));background:var( --scalar-api-client-color, var(--default-scalar-api-client-color) )!important;text-align:center;font-weight:var(--theme-semibold, var(--default-theme-semibold));font-family:var(--theme-font, var(--default-theme-font));padding:6px;width:fit-content;margin:3px 3px 3px auto;text-transform:uppercase;border-radius:var(--theme-radius, var(--default-theme-radius));color:#fff;cursor:pointer;text-align:center!important;position:relative}.scalar-api-client__item__content-button span{position:relative}.scalar-api-client__item__content-button:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;cursor:pointer;border-radius:var(--theme-radius, var(--default-theme-radius));background:linear-gradient(#0000001a,#0003)}.scalar-api-client__item__content-button:hover:before{background:linear-gradient(#0003,#0000001a)}.scalar-api-client__item__content__split{justify-content:space-between}.scalar-collapsible-section-flex{width:100%}.input{background:transparent;position:relative;width:100%;text-align:left;display:flex;box-shadow:0 1px 0 var(--theme-border-color, var(--default-theme-border-color))}.input:focus-within{box-shadow:0 0 0 1px var(--theme-color-1, var(--default-theme-color-1))!important;z-index:10}.input:first-of-type{border-radius:var(--theme-radius, var(--default-theme-radius)) var(--theme-radius, var(--default-theme-radius)) 0 0}.input:first-child:last-child{border-radius:var(--theme-radius, var(--default-theme-radius))}.input:last-child{box-shadow:none;border-radius:0 0 var(--theme-radius, var(--default-theme-radius)) var(--theme-radius, var(--default-theme-radius))}.input__half:first-of-type{border-radius:var(--theme-radius, var(--default-theme-radius)) 0 0 0}.input__half:nth-of-type(2){border-radius:0 var(--theme-radius, var(--default-theme-radius)) 0 0}.authentication-form{box-shadow:0 0 0 1px var(--theme-border-color, var(--default-theme-border-color));border-radius:var(--theme-radius, var(--default-theme-radius));width:100%;display:flex;flex-flow:wrap}.input__half{width:50%}.input__half+.input__half{border-left:1px solid var(--theme-border-color, var(--default-theme-border-color))}.input__half:focus-within{border-color:transparent}.input label,.input input{padding:9px;border:0;outline:none;font-size:var(--theme-micro, var(--default-theme-micro));color:var(--theme-color-2, var(--default-theme-color-2));width:100%;background:transparent;-moz-appearance:none;appearance:none;-webkit-appearance:none;left:0}.input label{color:var(--theme-color-1, var(--default-theme-color-1));width:fit-content;padding-right:0;white-space:nowrap;cursor:text}.input input{position:relative;z-index:99}.input input:not(:placeholder-shown)+label{color:var(--theme-color-2, var(--default-theme-color-2))}.select{background:--theme-background-1;border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));font-size:var(--theme-micro, var(--default-theme-micro));border:1px solid var(--theme-border-color, var(--default-theme-border-color));width:100%;position:relative;margin-bottom:6px}.select:focus-within{background:var(--theme-background-3, var(--default-theme-background-3))}.select:hover{background:var(--theme-background-3, var(--default-theme-background-3))}.select svg{position:absolute;right:9px;pointer-events:none;color:var(--theme-color-2, var(--default-theme-color-2));width:6px;top:10px}.select label{display:block;font-size:10px;color:var(--theme-color-2, var(--default-theme-color-2));position:absolute;left:9px;top:6px}.select select{background:transparent;outline:none;border:none;-moz-appearance:none;-webkit-appearance:none;appearance:none;font-size:var(--theme-micro, var(--default-theme-micro));color:var(--theme-color-1, var(--default-theme-color-1));width:100%;padding:14px 9px 4px;top:0;position:relative;cursor:pointer}.check{display:flex;position:relative;cursor:pointer;align-items:center;font-size:var(--theme-micro, var(--default-theme-micro));padding:6px 9px;border-radius:0 0 var(--theme-radius, var(--default-theme-radius)) var(--theme-radius, var(--default-theme-radius));-webkit-user-select:none;user-select:none;width:100%;outline:none}.check:focus-within{box-shadow:0 0 0 1px var(--theme-color-1, var(--default-theme-color-1))}.checkmark:hover{background:var(--theme-background-3, var(--default-theme-background-3))}.check:focus-within{border-color:var(--theme-color-1, var(--default-theme-color-1))}.check p{color:var(--theme-color-3, var(--default-theme-color-3))}.check input{position:absolute;opacity:0;cursor:pointer;height:0;width:0}.checkmark{height:17px;width:17px;background:var(--theme-background-3, var(--default-theme-background-3));margin-right:10px;border-radius:3px;display:flex;align-items:center;justify-content:center;position:relative}.check input:checked~p{color:var(--theme-color-1, var(--default-theme-color-1))}.check .checkmark:after{content:"";display:none;width:5px;height:8px;border:solid var(--theme-color-1, var(--default-theme-color-1));border-width:0 1.5px 1.5px 0;transform:rotate(45deg) translate3d(0,-1px,0)}.check input:checked~.checkmark:after{display:block}.scalar-api-client__main__scroll-container{height:calc(100vh - 320px)}.scalar-api-client__request-name{outline:none;border:none;-moz-appearance:none;appearance:none;-webkit-appearance:none;font-size:var(--theme-small, var(--default-theme-small));font-weight:var(--theme-semibold, var(--default-theme-semibold));color:var(--theme-color-3, var(--default-theme-color-3));width:100%;padding:0;background:transparent;font-family:var(--theme-font, var(--default-theme-font))}.scalar-api-client__request-name::-webkit-input-placeholder{font-weight:var(--theme-semibold, var(--default-theme-semibold))}.scalar-api-client__request-name:-ms-input-placeholder{font-weight:var(--theme-semibold, var(--default-theme-semibold))}.scalar-api-client__request-name::placeholder{font-weight:var(--theme-semibold, var(--default-theme-semibold))}a[data-v-d11ff062]{color:var(--theme-color-3, var(--default-theme-color-3));text-decoration:underline;text-decoration-color:var( --theme-border-color, var(--default-theme-border-color) );text-underline-offset:2px;cursor:help}.simple-cell[data-v-01fffd78]{all:unset;display:table-cell;border-right:1px solid var(--theme-border-color, var(--default-theme-border-color));position:relative;padding:9px!important;color:var(--theme-color-1, var(--default-theme-color-1));white-space:nowrap}.simple-cell a[data-v-01fffd78]{color:var(--theme-color-1, var(--default-theme-color-1))!important}.simple-cell[data-v-01fffd78]:last-of-type{border-right:none}.simple-cell.wrap[data-v-01fffd78]{white-space:normal}.simple-cell.strong[data-v-01fffd78]{font-weight:var(--theme-semibold, var(--default-theme-semibold))}.simple-header[data-v-b2232089]{color:var(--theme-color-3, var(--default-theme-color-3));font-weight:var(--theme-semibold, var(--default-theme-semibold));text-transform:uppercase}.simple-row[data-v-0982ade4]{all:unset;display:table-row;box-shadow:0 -1px var(--theme-border-color, var(--default-theme-border-color))}.simple-row[data-v-0982ade4]:first-of-type{box-shadow:none}.simple-table[data-v-28fcbcb6]{all:unset;display:table;width:100%;border-spacing:0;box-shadow:0 0 0 1px var(--theme-border-color, var(--default-theme-border-color));border-radius:var(--theme-radius, var(--default-theme-radius))}.scalar-api-client__main__right{width:50%;padding:0 18px 12px}@media screen and (max-width: 820px){.scalar-api-client__main__right{width:100%;border-right:none;padding:0 12px 12px}}.scalar-api-client__main__right :deep(.scalar-copilot__header-button){position:absolute;top:6px;right:12px}.scalar-api-client,#headlessui-portal-root{background:var(--theme-background-1, var(--default-theme-background-1));position:relative;height:100%;overflow:hidden!important;display:flex;flex-direction:column;font-family:var(--theme-font, var(--default-theme-font));box-sizing:border-box}.scalar-api-client *,.scalar-api-client *:before,.scalar-api-client *:after,#headlessui-portal-root *,#headlessui-portal-root *:before,#headlessui-portal-root *:after{box-sizing:inherit}.scalar-api-client{flex:1;max-height:100vh}@media screen and (max-width: 1000px){.scalar-api-client{width:100%}}.scalar-api-client pre{font-family:var(--theme-font-code, var(--default-theme-font-code))}.scalar-api-client__mobile-navigation{padding:12px 12px 0;display:flex;font-size:var(--theme-small, var(--default-theme-small));color:var(--theme-color-2, var(--default-theme-color-2));font-weight:var(--theme-bold, var(--default-theme-bold))}.scalar-api-client__mobile-navigation__toggle{-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;outline:none;background:transparent;font-size:var(--theme-font-size-2);color:var(--theme-color-2);font-weight:var(--theme-semibold, var(--default-theme-semibold));font-family:var(--theme-font, var(--default-theme-font));padding:0;margin-right:9px;cursor:pointer}.scalar-api-client__mobile-navigation--active{color:var(--theme-color-1, var(--default-theme-color-1))}.scalar-api-client__mobile-navigation--active:hover{cursor:pointer}.scalar-api-client__main{display:flex;height:100%;min-height:0;background:var(--theme-background-1, var(--default-theme-background-1));border-top:1px solid var(--theme-border-color, var(--default-theme-border-color))}@media screen and (max-width: 820px){.scalar-api-client__main{flex-direction:column}}.scalar-api-client__main__content{padding:12px 6px;background:var(--theme-background-1, var(--default-theme-background-1));top:0;position:sticky;z-index:100}.scalar-api-client__main__content label{font-size:var(--theme-small, var(--default-theme-small));color:var(--theme-color-1, var(--default-theme-color-1));font-weight:var(--theme-semibold, var(--default-theme-semibold));display:flex;align-items:center}@media screen and (max-width: 820px){.scalar-api-client__main__content{padding:3px 0 12px}.scalar-api-client__main__content label{display:none}}.meta{display:flex;margin-top:3px;font-size:var(--theme-font-size-2, var(--default-theme-font-size-2));font-weight:var(--theme-font-size-2, var(--default-theme-font-size-2));color:var( --scalar-api-client-color2, var(--default-scalar-api-client-color2) )}.meta-item svg{fill:var(--theme-color-ghost, var(--default-theme-color-ghost));height:14px;width:14px;margin-right:6px}.meta-item{display:flex;align-items:center;margin-right:12px;white-space:nowrap;font-weight:var(--theme-semibold, var(--default-theme-semibold));font-size:var(--theme-small, var(--default-theme-small));color:var(--theme-color-3, var(--default-theme-color-3));min-height:17px}.meta-item__input{background:transparent;width:100%;margin-right:0}.types{margin:auto;width:580px;display:flex;align-items:center;justify-content:center;flex-flow:wrap}.types-heading{width:100%;text-align:center}.types-heading b{font-size:42px}.types-heading p{margin-bottom:20px;margin-top:12px;font-size:24px}.scalar-api-client__empty-state{border:1px dashed var(--theme-border-color, var(--default-theme-border-color));width:100%;text-align:center;border-radius:var(--theme-radius, var(--default-theme-radius));font-size:var(--theme-small, var(--default-theme-small));min-height:58px;display:flex;align-items:center;justify-content:center}.sidebar-heading[data-v-feffd927]{display:flex;gap:6px;color:var(--sidebar-color-2, var(--default-theme-color-2, var(--theme-color-2, var(--default-theme-color-2))));font-size:var(--theme-mini, var(--default-theme-mini));font-weight:var(--theme-semibold, var(--default-theme-semibold));word-break:break-word;line-height:1.385;max-width:100%;position:relative;cursor:pointer;border-radius:var(--theme-radius, var(--default-theme-radius));flex:1;padding-right:9px;-webkit-user-select:none;user-select:none}.sidebar-heading.deprecated .sidebar-heading-link-title[data-v-feffd927]{text-decoration:line-through}.sidebar-heading[data-v-feffd927]:hover{background:var(--sidebar-item-hover-background, var(--default-sidebar-item-hover-background, var(--theme-background-2, var(--default-theme-background-2))))}.sidebar-heading:hover span[data-v-feffd927]{color:var( --sidebar-item-hover-color, var( --default-sidebar-item-hover-color, var(--theme-color-accent, var(--default-theme-color-accent)) ) )}.active_page.sidebar-heading[data-v-feffd927]:hover,.active_page.sidebar-heading[data-v-feffd927]{color:var(--sidebar-color-active, var(--default-sidebar-color-active, var(--theme-color-accent, var(--default-theme-color-accent))));background:var(--sidebar-item-active-background, var(--default-sidebar-item-active-background, var(--theme-background-accent, var(--default-theme-background-accent))))}.sidebar-heading-link[data-v-feffd927]{text-decoration:none;color:inherit;padding:6px 0;display:flex;flex:1;justify-content:space-between;gap:2px}.sidebar-heading p[data-v-feffd927]{height:fit-content;display:flex;align-items:center}.sidebar-heading p[data-v-feffd927]:empty{display:none}.link-icon[data-v-feffd927]{position:relative;left:4px}.sidebar-icon[data-v-feffd927]{display:flex;align-items:center;justify-content:center;margin-right:6px;width:13px;height:13px}.sidebar-icon>svg[data-v-feffd927]{width:13px;height:13px}.sidebar-group-item[data-v-feffd927]{position:relative}.sidebar-heading-chevron[data-v-feffd927]{margin:5px -5.5px 5px -9px}.toggle-nested-icon[data-v-feffd927]{border:none;color:currentColor;padding:2px;color:var(--sidebar-color-2, var(--default-sidebar-color-2))}.active_page .toggle-nested-icon[data-v-feffd927]{color:var( --sidebar-color-active, var( --default-sidebar-color-active, var(--theme-color-accent, var(--default-theme-color-accent)) ) )}.toggle-nested-icon[data-v-feffd927]:hover,.toggle-nested-icon[data-v-feffd927]:focus-visible{color:currentColor}.action-menu[data-v-feffd927]{position:absolute;top:5px;right:5px;display:flex;gap:6px}.action-menu[data-v-feffd927] .button-wrapper button{opacity:0;width:20px;height:20px;padding:4px}.action-menu[data-v-feffd927]:hover .button-wrapper button,.action-menu[data-v-feffd927] .button-wrapper button:hover,.sidebar-heading:hover~.action-menu[data-v-feffd927] .button-wrapper button,.action-menu[data-v-feffd927] .button-wrapper button[aria-expanded=true]{opacity:1}.sidebar-heading[data-v-feffd927]:has(~.action-menu:hover){color:var(--sidebar-color-1, var(--default-sidebar-color-1), var(--theme-color-1, var(--default-theme-color-1)));background:var(--sidebar-item-hover-background, var(--default-sidebar-item-hover-background), var(--theme-background-2, var(--default-theme-background-2)))}.sidebar-heading-type[data-v-feffd927]{min-width:3.9em;overflow:hidden;border-radius:30px;padding:0 3px;line-height:14px;flex-shrink:0;color:var( --sidebar-background-1, var( --default-sidebar-background-1, var(--theme-background-1, var(--default-theme-background-1)) ) );background:var( --method-color, var(--theme-color-2, var(--default-theme-color-2)) );text-transform:uppercase;font-size:8.5px;font-weight:700;text-align:center;position:relative;font-family:var(--theme-font-code, var(--default-theme-font-code));white-space:nowrap}.active_page .sidebar-heading-type[data-v-feffd927]{background:transparent;box-shadow:inset 0 0 0 1px var( --sidebar-color-active, var( --default-sidebar-color-active, var(--theme-color-accent, var(--default-theme-color-accent)) ) );color:var( --sidebar-color-active, var( --default-sidebar-color-active, var(--theme-color-accent, var(--default-theme-color-accent)) ) )}.sidebar-group-item__folder[data-v-feffd927]{color:var( --sidebar-color-1, var( --default-sidebar-color-1, var(--theme-color-1, var(--default-theme-color-1)) ) )}.sidebar-group-item__folder .sidebar-heading-type[data-v-feffd927]{display:none}.sidebar-group[data-v-3fac4969]{list-style:none;width:100%}.sidebar-indent-nested[data-v-3fac4969] .sidebar-heading{padding-left:calc((var(--sidebar-level, var(--default-sidebar-level)) * var(--theme-sidebar-indent-base, var(--default-theme-sidebar-indent-base))) + 12px)!important}.sidebar-indent-nested[data-v-3fac4969] .sidebar-heading .toggle-nested-icon{left:calc((var(--sidebar-level, var(--default-sidebar-level)) * var(--theme-sidebar-indent-base, var(--default-theme-sidebar-indent-base))) + 2px)!important}:where(.sidebar-indent-nested[data-v-3fac4969]) .sidebar-heading{color:var(--sidebar-color-1, var(--default-sidebar-color-1, var(--theme-color-1, var(--default-theme-color-1))))}:where(.sidebar-indent-nested[data-v-3fac4969]) :where(.sidebar-indent-nested) .sidebar-heading{color:var(--sidebar-color-2, var(--default-sidebar-color-2, var(--theme-color-2, var(--default-theme-color-2))))}.sidebar[data-v-38ea937d]{--default-theme-sidebar-indent-base: 12px}.sidebar[data-v-38ea937d]{flex:1;height:100%;display:flex;flex-direction:column;border-right:1px solid var( --sidebar-border-color, var( --default-sidebar-border-color, var(--theme-border-color, var(--default-theme-border-color)) ) );background:var(--sidebar-background-1, var(--default-sidebar-background-1, var(--theme-background-1, var(--default-theme-background-1))));--default-sidebar-level: 0}.sidebar-pages[data-v-38ea937d]{flex:1;padding:9px 12px}@media (max-width: 1000px){.sidebar[data-v-38ea937d]{min-height:0}.sidebar-pages[data-v-38ea937d]{padding-top:12px}}.api-client-container .scalar-api-client[data-v-47da1305]{width:calc(100% - var(--refs-sidebar-width))}@media screen and (max-width: 1000px){.api-client-container .scalar-api-client[data-v-47da1305]{width:100%}}.api-client-container[data-v-47da1305]{position:absolute;right:0;left:0;bottom:0;top:0;z-index:9;border-radius:0;box-shadow:none;opacity:1;pointer-events:all;background:var( --theme-background-1, var(--default-theme-background-1) )!important;border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));box-shadow:var(--theme-shadow-1, var(--default-theme-shadow-1));height:100%;overflow:hidden;display:flex;flex-direction:column}.scalar-api-client__navigation[data-v-47da1305]{width:100%;display:flex;align-items:center;padding:11px 12px;height:var(--refs-header-height);background-color:var( --theme-background-1, var(--default-theme-background-1) );z-index:10;position:sticky;border-bottom:1px solid var(--theme-border-color, var(--default-theme-border-color));top:0}.scalar-api-client__close[data-v-47da1305]{-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;outline:none;display:flex;align-items:center;background:transparent;font-size:var(--theme-small, var(--default-theme-small));color:var(--theme-color-1, var(--default-theme-color-1));font-weight:var(--theme-semibold, var(--default-theme-semibold))}.scalar-api-client__close[data-v-47da1305]:hover{cursor:pointer}.api-client-drawer[data-v-47da1305]{background:var(--theme-background-1, var(--default-theme-background-1));height:calc(100% - 58px);width:calc(100% - 8px);border-radius:12px;overflow:hidden;visibility:visible;position:fixed;bottom:4px;left:4px;z-index:1001;opacity:0;animation:apiclientfadein-47da1305 .35s forwards}.api-client-drawer[data-v-47da1305]:before{content:"";display:block;width:100%;height:100%;position:absolute;z-index:0}.dark-mode .api-client-drawer[data-v-47da1305]:before{background:#1a1a1a}.light-mode .api-client-drawer[data-v-47da1305]:before{background:#fff}@keyframes apiclientfadein-47da1305{0%{transform:translate3d(0,20px,0) scale(.985);opacity:0}to{transform:translateZ(0) scale(1);opacity:1}}.api-client-drawer-exit[data-v-47da1305]{position:fixed;top:0;left:0;width:100vw;height:100vh;background:#00000070;transition:all .3s ease-in-out;z-index:1000;cursor:pointer;animation:drawerexitfadein-47da1305 .35s forwards}.api-client-drawer-exit[data-v-47da1305]:before{content:"Ã—";font-family:sans-serif;position:absolute;top:0;font-size:30px;font-weight:100;line-height:50px;right:12px;text-align:center;color:#fff;opacity:.6}.api-client-drawer-exit[data-v-47da1305]:hover:before{opacity:1}@keyframes drawerexitfadein-47da1305{0%{opacity:0}to{opacity:1}}.scalar-api-client-height[data-v-47da1305]{height:100%;display:flex}.scalar-api-client-height .sidebar[data-v-47da1305]{flex:1 1 0%;flex-grow:1;flex-shrink:1;flex-basis:0%;height:100%;display:flex;flex-direction:column;width:var(--refs-sidebar-width);max-width:var(--refs-sidebar-width);border-right:1px solid var( --sidebar-border-color, var( --default-sidebar-border-color, var(--theme-border-color, var(--default-theme-border-color)) ) )}.toaster[data-sonner-toast][data-styled=true]{padding:18px;background:var(--theme-background-1, var(--default-theme-background-1));border-color:var(--theme-background-3, var(--default-theme-background-3));border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));font-size:var(--theme-font-size-3, var(--default-theme-font-size-3));color:var(--theme-color-1, var(--default-theme-color-1))}.scalar-card[data-v-f9d4a1f3]{all:unset;font-family:var(--theme-font, var(--default-theme-font));border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));overflow:hidden;border:1px solid var(--theme-border-color, var(--default-theme-border-color));background:var(--theme-background-2, var(--default-theme-background-2));display:flex;flex-direction:column;max-height:calc(((var(--full-height) - var(--refs-header-height)) - 60px) / 2);position:relative}.scalar-card-sticky[data-v-f9d4a1f3]{position:sticky;top:calc(var(--refs-header-height) + 24px)}.scalar-card-content[data-v-47a41f7c]{overflow:auto;border-bottom:1px solid var(--theme-border-color, var(--default-theme-border-color))}.scalar-card-content[data-v-47a41f7c] .simple-table .simple-header{display:none}.scalar-card-content[data-v-47a41f7c]:last-of-type,.scalar-card-content.scalar-card--borderless[data-v-47a41f7c]{border-bottom:none}.scalar-card--muted[data-v-47a41f7c]{background:var(--theme-background-2, var(--default-theme-background-2))}.scalar-card--contrast[data-v-47a41f7c]{background:var(--theme-background-3, var(--default-theme-background-3))}.scalar-card--frameless[data-v-47a41f7c]{padding:0}.scalar-card--transparent[data-v-47a41f7c]{background:var(--theme-background-1, var(--default-theme-background-1))}.scalar-card-header[data-v-403cccd4]{font-weight:var(--theme-semibold, var(--default-theme-semibold));font-size:var(--theme-mini, var(--default-theme-mini));color:var(--theme-color-3, var(--default-theme-color-3));padding:9px 0 9px 12px;flex-shrink:0}.scalar-card-header.scalar-card--borderless[data-v-403cccd4]+.scalar-card-content{margin-top:-9px}.scalar-card-header-slots[data-v-403cccd4]{display:flex;justify-content:space-between;line-height:1.35}.scalar-card-header-title[data-v-403cccd4]{text-transform:uppercase;flex:1;min-width:0;text-overflow:ellipsis;overflow:hidden}.scalar-card-header-actions[data-v-403cccd4]{display:flex}.scalar-card-footer[data-v-c179b8a4]{flex-shrink:0}.tab-list[data-v-6a91b57c]{display:flex;gap:6px;position:relative;flex:1;padding:9px 12px;overflow:auto}.scalar-card-header-tabs[data-v-6a91b57c]{padding:0}.tab[data-v-d044c876]{background:none;border:none;font-size:var(--theme-mini, var(--default-theme-mini));font-family:var(--theme-font, var(--default-theme-font));color:var(--theme-color-2, var(--default-theme-color-2));font-weight:var(--theme-semibold, var(--default-theme-semibold));line-height:calc(var(--theme-mini, var(--default-theme-mini)) + 2px);white-space:nowrap;cursor:pointer;padding:0;margin-right:3px;text-transform:uppercase;position:relative;line-height:1.35}.tab[data-v-d044c876]:before{content:"";position:absolute;z-index:0;left:-6px;top:-6px;width:calc(100% + 12px);height:calc(100% + 12px);border-radius:var(--theme-radius, var(--default-theme-radius));background:var(--theme-background-3, var(--default-theme-background-3));opacity:0}.tab[data-v-d044c876]:hover:before{opacity:1}.tab span[data-v-d044c876]{z-index:1;position:relative}.tab-selected[data-v-d044c876]{color:var(--theme-color-1, var(--default-theme-color-1));text-decoration:underline;text-underline-offset:var(--theme-micro, var(--default-theme-micro))}.markdown[data-v-61251c75]{color:var(--theme-color-1, var(--default-theme-color-1));all:unset;word-break:break-word}.markdown[data-v-61251c75] *{all:unset;margin:12px 0;font-family:var(--theme-font, var(--default-theme-font));color:var(--theme-color-1, var(--default-theme-color-1))}.markdown[data-v-61251c75] details{margin:12px 0;color:var(--theme-color-1, var(--default-theme-color-1))}.markdown[data-v-61251c75] summary{margin:12px 0;font-weight:var(--theme-semibold, var(--default-theme-semibold))}.markdown[data-v-61251c75] img{overflow:hidden;border-radius:var(--theme-radius, var(--default-theme-radius));max-width:100%}.markdown[data-v-61251c75]>:first-child{margin-top:0}.markdown[data-v-61251c75] h1,.markdown[data-v-61251c75] h2,.markdown[data-v-61251c75] h3,.markdown[data-v-61251c75] h4,.markdown[data-v-61251c75] h5,.markdown[data-v-61251c75] h6{font-size:var(--font-size, var(--default-font-size));margin:24px 0 6px;font-weight:var(--theme-bold, var(--default-theme-bold));display:block;line-height:1.45}.markdown[data-v-61251c75] b,.markdown[data-v-61251c75] strong{font-weight:var(--theme-bold, var(--default-theme-bold))}.markdown[data-v-61251c75] p{font-size:var( --font-size, var(--default-font-size), var(--theme-paragraph, var(--default-theme-paragraph)) );color:var(--theme-color-1, var(--default-theme-color-1));font-weight:var( --font-weight, var(--default-font-weight), var(--theme-small, var(--default-theme-small)) );line-height:1.5;margin-bottom:0;display:block}.markdown[data-v-61251c75] ul,.markdown[data-v-61251c75] ol{padding-left:24px;line-height:1.5;margin:12px 0;display:block}.markdown[data-v-61251c75] ul{list-style:disc}.markdown[data-v-61251c75] ol{list-style:decimal}.markdown[data-v-61251c75] ul.contains-task-list{list-style:none;padding-left:0}.markdown[data-v-61251c75] li{margin:6px 0;display:list-item}.markdown[data-v-61251c75] a{color:var( --theme-color-accent, var(--default-theme-color-accent) )!important;text-decoration:none!important;cursor:pointer}.markdown[data-v-61251c75] a:hover{text-decoration:underline!important}.markdown[data-v-61251c75] em{font-style:italic}.markdown[data-v-61251c75] del{text-decoration:line-through}.markdown[data-v-61251c75] code{font-family:var(--theme-font-code, var(--default-theme-font-code));background-color:var( --theme-background-2, var(--default-theme-background-2) );box-shadow:0 0 0 1px var(--theme-border-color, var(--default-theme-border-color));font-size:var(--theme-micro, var(--default-theme-micro));border-radius:2px;padding:0 3px}.markdown[data-v-61251c75] pre code{display:block;white-space:pre;padding:12px;line-height:1.5;margin:12px 0;-webkit-overflow-scrolling:touch;overflow-x:auto;max-width:100%;min-width:100px}.markdown[data-v-61251c75] blockquote{border-left:3px solid var(--theme-border-color, var(--default-theme-border-color));padding-left:12px;margin:0;display:block}.markdown[data-v-61251c75] table{display:table;position:relative;border-collapse:collapse;table-layout:fixed;width:100%;margin:1em 0;overflow:hidden;box-shadow:0 0 0 1px var(--theme-border-color, var(--default-theme-border-color));border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg))}.markdown[data-v-61251c75] tbody{display:table-row-group;vertical-align:middle}.markdown[data-v-61251c75] thead{display:table-header-group;vertical-align:middle}.markdown[data-v-61251c75] tr{display:table-row;border-color:inherit;vertical-align:inherit}.markdown[data-v-61251c75] td,.markdown[data-v-61251c75] th{display:table-cell;vertical-align:inherit;min-width:1em;padding:6px 9px;vertical-align:top;box-sizing:border-box;position:relative;word-break:break-all;border-right:1px solid var(--theme-border-color, var(--default-theme-border-color));border-bottom:1px solid var(--theme-border-color, var(--default-theme-border-color))}.markdown[data-v-61251c75] td>*,.markdown[data-v-61251c75] th>*{margin-bottom:0}.markdown[data-v-61251c75] th:empty{display:none}.markdown[data-v-61251c75] td:first-of-type,.markdown[data-v-61251c75] th:first-of-type{border-left:none}.markdown[data-v-61251c75] td:last-of-type,.markdown[data-v-61251c75] th:last-of-type{border-right:none}.markdown[data-v-61251c75] tr:last-of-type td{border-bottom:none}.markdown[data-v-61251c75] th{font-weight:var(--theme-semibold, var(--default-theme-semibold))!important;text-align:left;border-left-color:transparent;background:var(--theme-background-2, var(--default-theme-background-2))}.markdown[data-v-61251c75] tr>[align=left]{text-align:left}.markdown[data-v-61251c75] tr>[align=right]{text-align:right}.markdown[data-v-61251c75] tr>[align=center]{text-align:center}.markdown pre code.hljs{display:block;overflow-x:auto;padding:12px}.markdown pre *{font-size:var(--theme-small, var(--default-theme-small))!important;font-family:var( --theme-font-code, var(--default-theme-font-code) )!important}.markdown code.hljs{padding:3px 5px}.markdown .hljs{background:var(--theme-background-4, var(--default-theme-background-4));color:var(--theme-color-1, var(--default-theme-color-1))}.markdown .hljs-comment,.markdown .hljs-quote{color:var(--theme-color-3, var(--default-theme-color-3));font-style:italic}.markdown .hljs-addition,.markdown .hljs-keyword,.markdown .hljs-literal,.markdown .hljs-selector-tag,.markdown .hljs-type{color:var(--theme-color-green, var(--default-theme-color-green))}.markdown .hljs-number,.markdown .hljs-selector-attr,.markdown .hljs-selector-pseudo{color:var(--theme-color-orange, var(--default-theme-color-orange))}.markdown .hljs-doctag,.markdown .hljs-regexp,.markdown .hljs-string{color:var(--theme-color-blue, var(--default-theme-color-blue))}.markdown .hljs-built_in,.markdown .hljs-name,.markdown .hljs-section,.markdown .hljs-title,.markdown .hljs-class .hljs-title,.markdown .hljs-selector-id,.markdown .hljs-template-variable,.markdown .hljs-title.class_,.markdown .hljs-variable{color:var(--theme-color-1, var(--default-theme-color-1))}.markdown .hljs-name,.markdown .hljs-section,.markdown .hljs-strong{font-weight:var(--theme-semibold, var(--default-theme-semibold))}.markdown .hljs-bullet,.markdown .hljs-link,.markdown .hljs-meta,.markdown .hljs-subst,.markdown .hljs-symbol{color:var(--theme-color-blue, var(--default-theme-color-blue))}.markdown .hljs-deletion{color:var(--theme-color-red, var(--default-theme-color-red))}.markdown .hljs-formula{background:var(--theme-color-1, var(--default-theme-color-1))}.markdown .hljs-attr,.markdown .hljs-attribute{color:var(--theme-color-1, var(--default-theme-color-1))}.markdown .hljs-emphasis{font-style:italic}.card-form[data-v-d0caa558]{--input-radius: var(--theme-radius-lg, var(--default-theme-radius-lg));border-color:var(--theme-border-color, var(--default-theme-border-color));color:var(--theme-color-1, var(--default-theme-color-1))}.card-form[data-v-d0caa558]>:first-child{border-top-left-radius:var(--input-radius);border-top-right-radius:var(--input-radius)}.card-form[data-v-d0caa558]>:last-child{border-bottom-left-radius:var(--input-radius);border-bottom-right-radius:var(--input-radius)}.card-form[data-v-d0caa558]>*+*{margin-top:-1px;border-top-color:transparent}.card-form-button[data-v-05ca8905]{display:flex;align-items:center;position:relative;background:transparent;cursor:pointer;border-style:solid;border-width:1px;border-color:inherit;padding:9px;outline:none;white-space:nowrap;font-family:var(--theme-font, var(--default-theme-font));font-size:var(--theme-micro, var(--default-theme-micro));font-weight:var(--theme-semibold, var(--default-theme-semibold));color:var(--theme-color-1, var(--default-theme-color-1))}.card-form-button[data-v-05ca8905]:hover{background:var(--theme-background-2, var(--default-theme-background-2));border-color:var(--theme-border-color, var(--default-theme-border-color))}:where(.card-form-group[data-v-cadb0c16]){display:flex;border-color:inherit}.card-form-group>*[data-v-cadb0c16]{border-color:inherit}.card-form-group[data-v-cadb0c16]>:first-child{border-top-left-radius:inherit;border-bottom-left-radius:inherit}.card-form-group[data-v-cadb0c16]>:last-child{border-top-right-radius:inherit;border-bottom-right-radius:inherit}.card-form-group[data-v-cadb0c16]>*+*{margin-left:-1px;border-left-color:transparent}:where(.card-form-input[data-v-88939d2d]){background:transparent;position:relative;width:100%;text-align:left;display:flex;border-style:solid;border-width:1px;border-color:inherit}.card-form-input[data-v-88939d2d]:focus-within{border-color:var(--theme-color-3, var(--default-theme-color-3))}.card-form-input label[data-v-88939d2d],.card-form-input input[data-v-88939d2d]{padding:9px;border:0;outline:none;font-size:var(--theme-micro, var(--default-theme-micro));color:var(--theme-color-2, var(--default-theme-color-2));width:100%;background:transparent;-moz-appearance:none;appearance:none;-webkit-appearance:none;left:0}.card-form-input label[data-v-88939d2d]{color:var(--theme-color-1, var(--default-theme-color-1));width:fit-content;padding-right:0;white-space:nowrap;cursor:text}.card-form-input input[data-v-88939d2d]{position:relative;z-index:99}.card-form-input input:not(:placeholder-shown)+label[data-v-88939d2d]{color:var(--theme-color-2, var(--default-theme-color-2))}.badge[data-v-08c68ac3]{color:var(--theme-color-2, var(--default-theme-color-2));font-size:var(--theme-micro, var(--default-theme-micro));background:var(--theme-background-2, var(--default-theme-background-2));padding:2px 6px;border-radius:12px;font-weight:var(--theme-semibold, var(--default-theme-semibold));display:inline-block;text-transform:uppercase}:where(.wrapper[data-v-9ad9d97a]){display:grid;border-color:inherit}.scopes-label[data-v-9ad9d97a]{display:inline-flex;align-items:center;height:1em;line-height:1;gap:4px}.scopes-label-badge[data-v-9ad9d97a]{display:inline-flex;align-items:center;gap:2px}.scopes-label-badge em[data-v-9ad9d97a]{transform:rotate(10deg) translateY(-.9px);color:var(--theme-color-3, var(--default-theme-color-3))}.floating[data-v-9ad9d97a]{position:relative;z-index:100}.dropdown[data-v-9ad9d97a]{background:var(--theme-background-1, var(--default-theme-background-1));filter:brightness(var(--theme-lifted-brightness, var(--default-theme-lifted-brightness)));border-radius:var(--theme-radius, var(--default-theme-radius));box-shadow:var(--theme-shadow-2, var(--default-theme-shadow-2));padding:4px;font-style:normal;display:flex;flex-direction:column;gap:10px}.dropdown-item[data-v-9ad9d97a]{display:grid;grid-template-areas:"check title" "check description";grid-template-columns:auto 1fr;padding:6px 10px 8px 6px;row-gap:2px;column-gap:8px;border-radius:var(--theme-radius, var(--default-theme-radius));font-size:var(--theme-mini, var(--default-theme-mini));cursor:pointer}.dropdown-item[data-headlessui-state=active][data-v-9ad9d97a],.dropdown-item[data-headlessui-state="active selected"][data-v-9ad9d97a]{background:var(--theme-background-2, var(--default-theme-background-2))}.dropdown-item-title[data-v-9ad9d97a]{grid-area:title;color:var(--theme-color-1, var(--default-theme-color-1));font-weight:var(--theme-semibold, var(--default-theme-semibold))}.dropdown-item-description[data-v-9ad9d97a]{grid-area:description;color:var(--theme-color-2, var(--default-theme-color-2));line-height:initial}.dropdown-item-check[data-v-9ad9d97a]{all:unset;position:relative;grid-area:check;width:20px;height:20px;color:var(--theme-color-2, var(--default-theme-color-2));background:var(--theme-background-1, var(--default-theme-background-1));border:1px solid var(--theme-border-color, var(--default-theme-border-color));border-radius:var(--theme-radius, var(--default-theme-radius))}.dropdown-item-check[data-v-9ad9d97a]:checked:after{content:"";position:absolute;border-bottom:1.5px solid currentColor;border-right:1.5px solid currentColor;width:6px;height:12px;top:calc(50% - 1.5px);left:50%;transform:translate(-50%,-50%) rotate(45deg)}.dropdown-item-check[data-v-9ad9d97a]:checked{background:var(--theme-color-accent, var(--default-theme-color-accent));color:var(--theme-background-1, var(--default-theme-background-1));border:1px solid currentColor}.description[data-v-936d99bd]{padding:12px 4px 4px;font-size:var(--theme-mini, var(--default-theme-mini))}.security-scheme-selector[data-v-e8bd7046]{position:relative;border-radius:var(--theme-radius, var(--default-theme-radius));color:var(--theme-color-2, var(--default-theme-color-2));display:flex;align-items:center;gap:4px;cursor:pointer}.security-scheme-selector[data-v-e8bd7046]:hover{color:var(--theme-color-1, var(--default-theme-color-1))}.security-scheme-selector span[data-v-e8bd7046]{font-size:var(--theme-mini, var(--default-theme-mini))}.security-scheme-selector select[data-v-e8bd7046]{opacity:0;position:absolute;top:0;bottom:0;left:0;right:0;cursor:pointer;-moz-appearance:none;-webkit-appearance:none;appearance:none}.security-scheme-selector svg[data-v-e8bd7046]{width:12px;stroke:currentColor}.authentication-header[data-v-7d6a7d2e]{white-space:nowrap}.authentication-content[data-v-7d6a7d2e]{padding:9px}.selector[data-v-7d6a7d2e]{margin-right:12px}.base-url-variable{color:var(--theme-color-1, var(--default-theme-color-1))}.base-url[data-v-3be410d7]{color:var(--theme-color-2, var(--default-theme-color-2));cursor:pointer;font-family:var(--theme-font-code, var(--default-theme-font-code));display:inline-block;padding:10px 0;font-size:var(--theme-micro, var(--default-theme-micro));min-width:0;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.input select[data-v-d9d597ef]{position:absolute;top:0;left:0;right:0;bottom:0;opacity:0;-moz-appearance:none;-webkit-appearance:none;appearance:none}.input-value[data-v-d9d597ef]{color:var(--theme-color-1, var(--default-theme-color-1));font-size:var(--theme-micro, var(--default-theme-micro));padding:9px}.variable-description[data-v-d9d597ef]{padding:6px 12px;font-size:var(--theme-small, var(--default-theme-small))}.variable-description[data-v-d9d597ef] .markdown{font-size:var(--theme-micro, var(--default-theme-micro));font-weight:var(--theme-semibold, var(--default-theme-semibold));color:var(--theme-color--1, var(--default-theme-color-1));padding:4px 0;display:block}.variable-description[data-v-d9d597ef] .markdown>*:first-child{margin-top:0}.input[data-v-d9d597ef]{align-items:center}.input[data-v-d9d597ef]:first-of-type{border-radius:0;border-top:1px solid var(--theme-border-color, var(--default-theme-border-color))}.server-item[data-v-66aa4425]{padding:0 9px}.scalar-card-serverlist[data-v-66aa4425]{padding:9px}.server-selector[data-v-66aa4425]{position:relative;display:flex;align-items:center;min-width:0;overflow:hidden;gap:2px;color:var(--theme-color-2, var(--default-theme-color-2))}.description[data-v-66aa4425]{padding:6px 12px;font-size:var(--theme-small, var(--default-theme-small))}.description[data-v-66aa4425] .markdown{font-size:var(--theme-micro, var(--default-theme-micro));font-weight:var(--theme-semibold, var(--default-theme-semibold));color:var(--theme-color--1, var(--default-theme-color-1));padding:4px 0;display:block}.description[data-v-66aa4425] .markdown>*:first-child{margin-top:0}.server-selector select[data-v-66aa4425]{position:absolute;bottom:0;left:0;right:0;opacity:0;top:0;-moz-appearance:none;-webkit-appearance:none;appearance:none}.server-selector svg[data-v-66aa4425]{width:12px}.scalar-card-serverlist-container[data-v-66aa4425]{box-shadow:0 0 0 1px var(--theme-border-color, var(--default-theme-border-color));border-radius:var(--theme-radius, var(--default-theme-radius))}.client-libraries-content[data-v-b11e68cd]{display:flex;justify-content:center;gap:6px;padding:0 12px;overflow:hidden}.code-languages[data-v-b11e68cd]{display:flex;align-items:center;justify-content:center;flex-direction:column;max-width:60px;width:100%;padding:12px 0;position:relative;cursor:pointer;white-space:nowrap}@media screen and (max-width: 450px){.code-languages[data-v-b11e68cd]:nth-of-type(4),.code-languages[data-v-b11e68cd]:nth-of-type(6){display:none}}.code-languages-icon[data-v-b11e68cd]{max-width:42px;width:100%;max-height:42px;aspect-ratio:1;padding:9px;display:flex;align-items:center;justify-content:center;position:relative;box-sizing:border-box;color:var( --theme-code-language-color-supersede, var(--default-theme-code-language-color-supersede, #fff) )}.code-languages-background[data-v-b11e68cd]{border-radius:9px;position:relative;background:var( --theme-code-languages-background-supersede, var( --default-theme-code-languages-background-supersede, var(--code-languages-background) ) );box-shadow:0 0 0 1px var( --theme-code-languages-border-color, var(--default-theme-code-languages-border-color) )}.code-languages-background[data-v-b11e68cd]:before{content:"";width:calc(100% + 2px);height:calc(100% + 2px);position:absolute;top:-1px;left:-1px;pointer-events:none;border-radius:12px;background:var( --theme-code-languages-background-supersede, var(--default-theme-code-languages-background-supersede) )}.code-languages-icon__shell[data-v-b11e68cd]{--code-languages-background: #000}.code-languages-icon__ruby[data-v-b11e68cd]{--code-languages-background: #d91404}.code-languages-icon__php[data-v-b11e68cd]{--code-languages-background: #6181b6}.code-languages-icon__python[data-v-b11e68cd]{--code-languages-background: #306998}.code-languages-icon__node[data-v-b11e68cd]{--code-languages-background: #83cd29}.code-languages-icon__c[data-v-b11e68cd]{--code-languages-background: #03599c}.code-languages-icon__csharp[data-v-b11e68cd]{--code-languages-background: #68217a}.code-languages-icon__cplusplus[data-v-b11e68cd]{--code-languages-background: #9c033a}.code-languages-icon__clojure[data-v-b11e68cd]{--code-languages-background: #5881d8}.code-languages-icon__go[data-v-b11e68cd]{--code-languages-background: #00acd7}.code-languages-icon__http[data-v-b11e68cd]{--code-languages-background: #005b9b}.code-languages-icon__java[data-v-b11e68cd]{--code-languages-background: #ea2d2e}.code-languages-icon__javascript[data-v-b11e68cd]{--code-languages-background: #f0db4f}.code-languages-icon__kotlin[data-v-b11e68cd]{--code-languages-background: #7f6cb1}.code-languages-icon__objc[data-v-b11e68cd]{--code-languages-background: #0b5a9d}.code-languages-icon__ocaml[data-v-b11e68cd]{--code-languages-background: #f29100}.code-languages-icon__powershell[data-v-b11e68cd]{--code-languages-background: #2671be}.code-languages-icon__r[data-v-b11e68cd]{--code-languages-background: #cbced0}.code-languages-icon__swift[data-v-b11e68cd]{--code-languages-background: #f05138}.code-languages-icon__more[data-v-b11e68cd]{--code-languages-background: var( --theme-background-3, var(--default-theme-background-3) )}.code-languages-icon__more svg[data-v-b11e68cd]{height:initial}.code-languages__active[data-v-b11e68cd]:after{content:"";position:absolute;bottom:0;height:2px;width:100%;background:var(--theme-color-1, var(--default-theme-color-1))}@keyframes codeloader-b11e68cd{0%{transform:rotate(0)}to{transform:rotate(1turn)}}.code-languages span[data-v-b11e68cd]{margin-top:6px;color:var(--theme-color-2, var(--default-theme-color-2));font-size:var(--theme-micro, var(--default-theme-micro))}.code-languages__active span[data-v-b11e68cd]{color:var(--theme-color-1, var(--default-theme-color-1))}.code-languages__select select[data-v-b11e68cd]{opacity:0;width:100%;aspect-ratio:1;position:absolute;top:0;left:0;cursor:pointer;z-index:1;-moz-appearance:none;-webkit-appearance:none;appearance:none}.code-languages__select span[data-v-b11e68cd]{position:relative;display:flex;align-items:center}.code-languages__select span[data-v-b11e68cd]:after{content:"";width:8px;height:8px;background:var(--theme-background-1, var(--default-theme-background-1));box-shadow:1px 1px 0 currentColor;display:block;transform:rotate(45deg);margin-left:5px;margin-top:-7px}.references-classic .code-languages[data-v-b11e68cd]{flex-direction:row;gap:9px;max-width:initial;padding:10px 0;font-weight:var(--theme-semibold, var(--default-theme-semibold))}.references-classic .code-languages span[data-v-b11e68cd]{margin-top:0}.references-classic .code-languages-icon[data-v-b11e68cd]{width:24px;padding:3px}.references-classic .code-languages-background[data-v-b11e68cd]{border-radius:var(--theme-radius, var(--default-theme-radius))}.selected-client[data-v-6359a4ee]{color:var(--theme-color-1, var(--default-theme-color-1));font-size:var(--theme-small, var(--default-theme-small));font-family:var(--theme-font-code, var(--default-theme-font-code));padding:10px 12px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.section[data-v-167724b9]{position:relative;display:flex;flex-direction:column;max-width:var(--refs-content-max-width);margin:auto;padding:calc(90px + var(--refs-header-height)) 0 90px 0;margin-top:calc(-1 * var(--refs-header-height))}.references-classic .section[data-v-167724b9]{padding:48px 0;gap:24px}@container narrow-references-container (max-width: 900px){.references-classic .section[data-v-167724b9],.section[data-v-167724b9]{padding:calc(48px + var(--refs-header-height)) 24px 48px 24px}}.section[data-v-167724b9]:not(:last-of-type){border-bottom:1px solid var(--theme-border-color, var(--default-theme-border-color))}.section-wrapper[data-v-d82ba6d9]{color:var(--theme-color-1, var(--default-theme-color-1));padding-top:12px;margin-top:-12px}.section-accordion[data-v-d82ba6d9]{display:flex;flex-direction:column;border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));background:var(--theme-background-2, var(--default-theme-background-2))}.section-accordion-transparent[data-v-d82ba6d9]{background:transparent;border:1px solid var(--theme-border-color, var(--default-theme-border-color))}.section-accordion-button[data-v-d82ba6d9]{padding:6px}.section-accordion-button[data-v-d82ba6d9]{display:flex;align-items:center;gap:6px;cursor:pointer}.section-accordion-button-content[data-v-d82ba6d9]{flex:1;min-width:0}.section-accordion-button-actions[data-v-d82ba6d9]{display:flex;align-items:center;gap:6px;color:var(--theme-color-3, var(--default-theme-color-3))}.section-accordion-chevron[data-v-d82ba6d9]{margin-right:4px;width:24px;cursor:pointer;opacity:1;color:var(--theme-color-3, var(--default-theme-color-3))}.section-accordion-button:hover .section-accordion-chevron[data-v-d82ba6d9]{color:var(--theme-color-1, var(--default-theme-color-1))}.section-accordion-content[data-v-d82ba6d9]{border-top:1px solid var(--theme-border-color, var(--default-theme-border-color));display:flex;flex-direction:column}.section-accordion-description[data-v-d82ba6d9]{font-weight:var(--theme-semibold, var(--default-theme-semibold));font-size:var(--theme-mini, var(--default-theme-mini));color:var(--theme-color--1, var(--default-theme-color-1));padding:10px 12px 0}.section-accordion-content-card[data-v-d82ba6d9] .property:last-of-type{padding-bottom:9px}.section-column[data-v-d64e7382]{flex:1;min-width:0}.section-column[data-v-d64e7382]:nth-of-type(2){padding-top:48px}@container narrow-references-container (max-width: 900px){.section-column[data-v-d64e7382]:nth-of-type(2){padding-top:0}}.section-columns[data-v-8b9602bf]{display:flex;gap:48px}@container narrow-references-container (max-width: 900px){.section-columns[data-v-8b9602bf]{flex-direction:column;gap:24px}}.section-container[data-v-b630668c]{position:relative;padding:0 60px;width:100%}.section-container[data-v-b630668c]:last-of-type{border-top:1px solid var(--theme-border-color, var(--default-theme-border-color))}@container narrow-references-container (max-width: 900px){.section-container[data-v-b630668c]{padding:0}}.section-accordion-wrapper[data-v-02cdcc1e]{padding:0 60px}.section-accordion[data-v-02cdcc1e]{position:relative;width:100%;max-width:var(--refs-content-max-width);margin:auto}.section-accordion-content[data-v-02cdcc1e]{display:flex;flex-direction:column;gap:12px;padding-top:12px}.section-accordion-button[data-v-02cdcc1e]{width:100%;display:flex;cursor:pointer;padding:6px 0;margin:-6px 0;border-radius:var(--theme-radius, var(--default-theme-radius))}.section-accordion-chevron[data-v-02cdcc1e]{width:24px;position:absolute;left:-24px;height:auto;top:10px;color:var(--theme-color-3, var(--default-theme-color-3))}.section-accordion-button:hover .section-accordion-chevron[data-v-02cdcc1e]{color:var(--theme-color-1, var(--default-theme-color-1))}.section-accordion-title[data-v-02cdcc1e]{display:flex;flex-direction:column;align-items:start;flex:1;padding:0 6px}.section-accordion-title[data-v-02cdcc1e] .section-header{margin-bottom:0}@container narrow-references-container (max-width: 900px){.section-accordion-chevron[data-v-02cdcc1e]{width:16px;left:-16px;top:14px}.section-accordion-wrapper[data-v-02cdcc1e]{padding:calc(var(--refs-header-height)) 24px 0 24px}}.loading[data-v-99d52311]{background:var(--theme-background-3, var(--default-theme-background-3));animation:loading-skeleton-99d52311 1.5s infinite alternate;border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));min-height:1.6em;margin:.6em 0;max-width:100%}.loading[data-v-99d52311]:first-of-type{min-height:3em;margin-bottom:24px;margin-top:0}.loading[data-v-99d52311]:last-of-type{width:60%}.loading.single-line[data-v-99d52311]{min-height:3em;margin:.6em 0;max-width:80%}@keyframes loading-skeleton-99d52311{0%{opacity:1}to{opacity:.33}}@container narrow-references-container (max-width: 900px){.section-content--with-columns[data-v-9735459e]{flex-direction:column;gap:24px}}.section-header[data-v-9e0df4d5]{font-size:var( --font-size, var( --default-font-size, var(--theme-heading-2, var(--default-theme-heading-2)) ) );font-weight:var( --font-weight, var(--default-font-weight, var(--theme-bold, var(--default-theme-bold))) );color:var(--theme-color-1, var(--default-theme-color-1));word-wrap:break-word;line-height:1.45;margin-top:0;margin-bottom:12px}.section-header.tight[data-v-9e0df4d5]{margin-bottom:6px}.section-header.loading[data-v-9e0df4d5]{width:80%}.introduction-description-heading[data-v-18921431]{scroll-margin-top:64px}.download-cta[data-v-903fee61]{margin-bottom:24px}.download-cta .download-button[data-v-903fee61]{color:var(--theme-color-accent, var(--default-theme-color-accent));text-decoration:none;font-size:var(--theme-paragraph, var(--default-theme-paragraph))}.download-cta .download-button[data-v-903fee61]:hover{text-decoration:underline}.heading[data-v-a408c8e6]{margin-top:0!important;word-wrap:break-word}.loading[data-v-a408c8e6]{background:var(--theme-background-3, var(--default-theme-background-3));animation:loading-skeleton 1.5s infinite alternate;border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg))}.badges[data-v-a408c8e6]{display:flex;align-items:center;gap:4px;margin-bottom:3px}.heading.loading[data-v-a408c8e6]{width:80%}.introduction-section[data-v-a408c8e6]{gap:48px}.sticky-cards[data-v-a408c8e6]{display:flex;flex-direction:column;position:sticky;top:calc(var(--refs-header-height) + 24px)}.section-flare[data-v-a408c8e6]{position:absolute;top:0;right:0;pointer-events:none}.screenreader-only[data-v-681ebf2c]{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.label[data-v-6dd4d525]{position:relative;display:inline-block}.anchor[data-v-6dd4d525]{position:relative;display:inline-block;opacity:0}.anchor-copy[data-v-6dd4d525]{position:absolute;left:0;top:50%;transform:translateY(-50%);cursor:pointer;padding:0 6px;color:var(--theme-color-3, var(--default-theme-color-3));font-weight:var(--theme-semibold, var(--default-theme-semibold));font-size:.8em}.anchor-copy[data-v-6dd4d525]:hover,.anchor-copy[data-v-6dd4d525]:focus-visible{color:var(--theme-color-2, var(--default-theme-color-2))}.label:hover .anchor[data-v-6dd4d525]{opacity:1}.text-select{position:relative;height:fit-content}.text-select--single-option{pointer-events:none}.text-select select{border:none;outline:none;cursor:pointer;background:var(--theme-background-3, var(--default-theme-background-3));box-shadow:-2px 0 0 0 var(--theme-background-3, var(--default-theme-background-3));position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;-moz-appearance:none;-webkit-appearance:none;appearance:none}.text-select span{font-size:var(--theme-mini, var(--default-theme-mini));color:var(--theme-color-2, var(--default-theme-color-2));font-weight:var(--theme-semibold, var(--default-theme-semibold));white-space:nowrap;display:flex;align-items:center;justify-content:center}.text-select:hover span{color:var(--theme-color-1, var(--default-theme-color-1))}.text-select:not(.text-select--single-option) span:after{content:"";width:7px;height:7px;transform:rotate(45deg) translate3d(-2px,-2px,0);display:block;margin-left:6px;box-shadow:1px 1px 0 currentColor}.text-select span:hover{background:var(--theme-background-2, var(--default-theme-background-2))}.request[data-v-3ea9bca2]{display:flex;flex-wrap:nowrap}.request-header[data-v-3ea9bca2]{display:flex;gap:6px;text-transform:initial}.request-method[data-v-3ea9bca2]{font-family:var(--theme-font-code, var(--default-theme-font-code));text-transform:uppercase;white-space:nowrap}.request-client-picker[data-v-3ea9bca2]{padding-left:12px;padding-right:9px;border-right:1px solid var(--theme-border-color, var(--default-theme-border-color))}.copy-button[data-v-3ea9bca2]{-moz-appearance:none;appearance:none;-webkit-appearance:none;outline:none;background:transparent;cursor:pointer;color:var(--theme-color-3, var(--default-theme-color-3));margin-left:6px;margin-right:10.5px;border:none;border-radius:3px;padding:0;display:flex;align-items:center;height:fit-content}.copy-button[data-v-3ea9bca2]:after{content:".";color:transparent;font-size:var(--theme-mini, var(--default-theme-mini));line-height:1.35;width:0px}.copy-button[data-v-3ea9bca2]:hover{color:var(--theme-color-1, var(--default-theme-color-1))}.copy-button svg[data-v-3ea9bca2]{width:13px;height:13px}.scalar-card-header-actions[data-v-3ea9bca2]{display:flex}.scalar-card-footer[data-v-3ea9bca2]{display:flex;justify-content:flex-end;padding:6px}.request-editor-section[data-v-3ea9bca2]{display:flex;flex:1}.schema-type-icon[data-v-c00c09cf]{color:var(--theme-color-1, var(--default-theme-color-1))}.schema-type[data-v-c00c09cf]{font-family:var(--theme-font-code, var(--default-theme-font-code))}.property[data-v-ce33abd5]{color:var(--theme-color-1, var(--default-theme-color-1));padding:10px;font-size:var(--theme-mini, var(--default-theme-mini))}.property[data-v-ce33abd5]:last-of-type{padding-bottom:0}.property--compact.property--level-0[data-v-ce33abd5]{padding:10px 0}.property--deprecated[data-v-ce33abd5]{background:repeating-linear-gradient(-45deg,var(--theme-background-2, var(--default-theme-background-2)) 0,var(--theme-background-2, var(--default-theme-background-2)) 2px,transparent 2px,transparent 5px);background-size:100%}.property--deprecated>*[data-v-ce33abd5]{opacity:.75}.property-information[data-v-ce33abd5]{display:flex;align-items:center;gap:9px;white-space:nowrap}.property-description[data-v-ce33abd5]{margin-top:6px;line-height:1.4}[data-v-ce33abd5] .property-description *{color:var(--theme-color-2, var(--default-theme-color-2))!important}.property[data-v-ce33abd5]:not(:last-of-type){border-bottom:1px solid var(--theme-border-color, var(--default-theme-border-color))}.children[data-v-ce33abd5]{display:flex;flex-direction:column;padding-top:8px}.property-name[data-v-ce33abd5]{font-family:var(--theme-font-code, var(--default-theme-font-code))}.required[data-v-ce33abd5],.optional[data-v-ce33abd5]{color:var(--theme-color-2, var(--default-theme-color-2))}.required[data-v-ce33abd5]{text-transform:uppercase;color:var(--theme-color-orange, var(--default-theme-color-orange))}.read-only[data-v-ce33abd5],.write-only[data-v-ce33abd5]{font-size:var(--theme-font-size-3, var(--default-theme-font-size-3));color:var(--theme-color-blue, var(--default-theme-color-blue))}.property-type[data-v-ce33abd5]{font-size:var(--theme-font-size-3, var(--default-theme-font-size-3));color:var(--theme-color-2, var(--default-theme-color-2))}.property-example[data-v-ce33abd5]{font-family:var(--theme-font-code, var(--default-theme-font-code))}.property-example-value[data-v-ce33abd5]{box-shadow:0 0 0 1px var(--theme-border-color, var(--default-theme-border-color));background:var(--theme-background-2, var(--default-theme-background-2));border-radius:var(--theme-radius, var(--default-theme-radius));padding:2px 5px;font-family:var(--theme-font-code, var(--default-theme-font-code));font-size:var( --default-theme-font-size-5, var(--default-default-theme-font-size-5) )}.pattern[data-v-ce33abd5]{font-family:var(--theme-font-code, var(--default-theme-font-code));font-size:var(--theme-font-size-3, var(--default-theme-font-size-3));color:var(--theme-color-2, var(--default-theme-color-2));background:var(--theme-background-3, var(--default-theme-background-3));padding:1px 3px;border-radius:var(--theme-radius, var(--default-theme-radius))}.property-rule[data-v-ce33abd5]{display:flex;flex-direction:column;gap:6px;margin-top:12px;border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg))}.property-enum-value[data-v-ce33abd5]{padding:3px 0;color:var(--theme-color-2, var(--default-theme-color-2))}.property-enum-value[data-v-ce33abd5]:before{content:"â—¼";margin-right:6px;color:var(--theme-color-3, var(--default-theme-color-3))}.property-enum-values[data-v-ce33abd5]{margin-top:8px;list-style:none}.property-read-only[data-v-ce33abd5]{font-family:var(--theme-font-code, var(--default-theme-font-code))}.property-nullable[data-v-ce33abd5]{font-size:var(--theme-font-size-3, var(--default-theme-font-size-3));color:var(--theme-color-2, var(--default-theme-color-2))}.property--compact .property-example[data-v-ce33abd5]{display:none}.error[data-v-30a3168e]{background-color:red}.schema-card[data-v-30a3168e]{z-index:0;position:relative;font-size:var(--theme-font-size-3, var(--default-theme-font-size-3));color:var(--theme-color-1, var(--default-theme-color-1))}.schema-card-title[data-v-30a3168e]{--schema-title-height: 38px;height:var(--schema-title-height);padding:10px 12px;display:flex;align-items:center;gap:4px;color:var(--theme-color-2, var(--default-theme-color-2));font-weight:var(--theme-semibold, var(--default-theme-semibold));font-size:var(--theme-micro, var(--default-theme-micro));background:var(--theme-background-1, var(--default-theme-background-1));border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));border-bottom:1px solid transparent}button.schema-card-title[data-v-30a3168e]{cursor:pointer}button.schema-card-title[data-v-30a3168e]:hover{color:var(--theme-color-1, var(--default-theme-color-1))}.schema-card-title-icon[data-v-30a3168e]{margin-left:-4px}.schema-card-title-icon--open[data-v-30a3168e]{transform:rotate(90deg)}.schema-properties-open>.schema-card-title[data-v-30a3168e]{z-index:1;position:sticky;top:var(--refs-header-height);border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom:1px solid var(--theme-border-color, var(--default-theme-border-color))}.schema-card .property[data-v-30a3168e]:last-of-type{padding-bottom:10px}.schema-properties[data-v-30a3168e]{display:flex;flex-direction:column;border:1px solid var(--theme-border-color, var(--default-theme-border-color));border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg))}.schema-card--compact[data-v-30a3168e]{align-self:start}.schema-card--compact.schema-card--open[data-v-30a3168e]{align-self:initial}.schema-card-title--compact[data-v-30a3168e]{color:var(--theme-color-3, var(--default-theme-color-3));padding:6px 10px;height:auto;border-bottom:none}.schema-card--compact>.schema-properties[data-v-30a3168e],.schema-card-title--compact[data-v-30a3168e]{border-radius:13.5px}.schema-card-title--compact>.schema-card-title-icon[data-v-30a3168e]{width:10px;height:10px;margin:0}.schema-card-title--compact>.schema-card-title-icon--open[data-v-30a3168e]{transform:rotate(45deg)}.schema-properties-open>.schema-card-title--compact[data-v-30a3168e]{position:static}.schema-card--compact.schema-card--level-0>.schema-properties[data-v-30a3168e]{border:none}.parameter-item[data-v-163ee83c]{border-top:1px solid var(--theme-border-color, var(--default-theme-border-color))}.parameter-item:last-of-type .parameter-schema[data-v-163ee83c]{padding-bottom:0}.parameter-item-container[data-v-163ee83c]{padding:0}.parameter-item-name[data-v-163ee83c]{font-weight:500;margin-right:6px;font-family:var(--theme-font-code, var(--default-theme-font-code));font-size:var(--theme-mini, var(--default-theme-mini));color:var(--theme-color-1, var(--default-theme-color-1))}.parameter-item-type[data-v-163ee83c],.parameter-item-required-optional[data-v-163ee83c]{color:var(--theme-color-3, var(--default-theme-color-3));font-weight:var(--theme-semibold, var(--default-theme-semibold));margin-right:6px;position:relative}.parameter-item--required[data-v-163ee83c]{text-transform:uppercase;font-size:var(--theme-micro, var(--default-theme-micro));font-weight:var(--theme-semibold, var(--default-theme-semibold));color:var(--theme-color-orange, var(--default-theme-color-orange))}.parameter-item-description[data-v-163ee83c]{margin-top:3px!important;font-size:var(--theme-small, var(--default-theme-small));color:var(--theme-color-2, var(--default-theme-color-2));line-height:1.4}.parameter-item-description[data-v-163ee83c] p{margin-top:4px;font-size:var(--theme-small, var(--default-theme-small));color:var(--theme-color-2, var(--default-theme-color-2));line-height:1.4}.parameter-schema[data-v-163ee83c]{padding-bottom:9px;margin-top:3px}.parameters[data-v-763a1ede]{margin-top:24px}.parameters-title[data-v-763a1ede]{font-size:var(--theme-heading-4, var(--default-theme-heading-4));font-weight:var(--theme-semibold, var(--default-theme-semibold));color:var(--theme-color-1, var(--default-theme-color-1));line-height:1.45;margin-top:12px;margin-bottom:12px}.parameter-list[data-v-763a1ede]{list-style:none;padding:0;margin:0 0 12px;font-size:var(--theme-small, var(--default-theme-small))}.request-body-title[data-v-64cd513c]{display:flex;align-items:center;font-size:var(--theme-heading-4, var(--default-theme-heading-4));font-weight:var(--theme-semibold, var(--default-theme-semibold));color:var(--theme-color-1, var(--default-theme-color-1));line-height:1.45;margin-top:24px;padding-bottom:12px;border-bottom:1px solid var(--theme-border-color, var(--default-theme-border-color))}.request-body-title-select[data-v-64cd513c]{position:relative;padding-left:9px;height:fit-content;color:var(--theme-color-2, var(--default-theme-color-2));font-size:var(--theme-font-size-3, var(--default-theme-font-size-3));display:flex;align-items:center}.request-body-title-no-select.request-body-title-select[data-v-64cd513c]{pointer-events:none}.request-body-title-no-select.request-body-title-select[data-v-64cd513c]:after{display:none}.request-body-title-select span[data-v-64cd513c]{display:flex;align-items:center}.request-body-title-select[data-v-64cd513c]:after{content:"";width:7px;height:7px;transform:rotate(45deg) translate3d(-2px,-4px,0);display:block;margin-left:7px;box-shadow:1px 1px 0 currentColor}.request-body-title-select select[data-v-64cd513c]{border:none;outline:none;cursor:pointer;background:var(--theme-background-3, var(--default-theme-background-3));box-shadow:-2px 0 0 0 var(--theme-background-3, var(--default-theme-background-3));position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;-webkit-appearance:none;-moz-appearance:none;appearance:none}.request-body-title-select[data-v-64cd513c]:hover{color:var(--theme-color-1, var(--default-theme-color-1))}@media (max-width: 460px){.request-body-title-select[data-v-64cd513c]{margin-left:auto;padding-right:3px}}.endpoint-path[data-v-08374039]{overflow:hidden;word-wrap:break-word;font-weight:var(--theme-bold, var(--default-theme-bold))}.deprecated[data-v-08374039]{text-decoration:line-through}.example-selector[data-v-652a7e14]{padding:4px}.request[data-v-aadec75b]{display:flex;flex-wrap:nowrap}.request-header[data-v-aadec75b]{display:flex;gap:6px;text-transform:initial}.request-method[data-v-aadec75b]{font-family:var(--theme-font-code, var(--default-theme-font-code));text-transform:uppercase}.request-client-picker[data-v-aadec75b]{padding-left:12px;padding-right:9px;border-right:1px solid var(--theme-border-color, var(--default-theme-border-color))}.copy-button[data-v-aadec75b]{-moz-appearance:none;appearance:none;-webkit-appearance:none;outline:none;background:transparent;cursor:pointer;color:var(--theme-color-3, var(--default-theme-color-3));margin-left:6px;margin-right:10.5px;border:none;border-radius:3px;padding:0;display:flex;align-items:center;height:fit-content}.copy-button[data-v-aadec75b]:after{content:".";color:transparent;font-size:var(--theme-mini, var(--default-theme-mini));line-height:1.35;width:0px}.copy-button[data-v-aadec75b]:hover{color:var(--theme-color-1, var(--default-theme-color-1))}.copy-button svg[data-v-aadec75b]{width:13px;height:13px}.request-card-footer[data-v-aadec75b]{display:flex;justify-content:end;padding:6px;flex-shrink:0}.request-card-footer-addon[data-v-aadec75b]{display:flex;align-items:center;flex:1;min-width:0}.request-editor-section[data-v-aadec75b]{display:flex;flex:1}.code-snippet[data-v-aadec75b]{display:flex;flex-direction:column;width:100%}.empty-state[data-v-2a82252b]{margin:10px 0 10px 12px;text-align:center;font-size:var(--theme-micro, var(--default-theme-micro));min-height:56px;display:flex;align-items:center;justify-content:center;border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));color:var(--theme-color-2, var(--default-theme-color-2))}.rule-title[data-v-2a82252b]{font-family:var(--theme-font-code, var(--default-theme-font-code));color:var(--theme-color-1, var(--default-theme-color-1));display:inline-block;margin:12px 0 6px;border-radius:var(--theme-radius, var(--default-theme-radius))}.rule[data-v-2a82252b]{margin:0 12px;border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg))}.rule-items[data-v-2a82252b]{counter-reset:list-number;display:flex;flex-direction:column;gap:12px;border-left:1px solid var(--theme-border-color, var(--default-theme-border-color));padding:12px 0}.rule-item[data-v-2a82252b]{counter-increment:list-number;border:1px solid var(--theme-border-color, var(--default-theme-border-color));border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));overflow:hidden;margin-left:24px}.rule-item[data-v-2a82252b]:before{border:1px solid var(--theme-border-color, var(--default-theme-border-color));border-top:0;border-right:0;content:" ";display:block;width:24px;height:6px;border-radius:0 0 0 var(--theme-radius-lg, var(--default-theme-radius-lg));margin-top:6px;color:var(--theme-color-2, var(--default-theme-color-2));transform:translate(-25px);color:var(--theme-color-1, var(--default-theme-color-1));position:absolute}.markdown[data-v-f2d04186] *{margin:0}.code-copy[data-v-f2d04186]{display:flex;align-items:center;justify-content:center;-moz-appearance:none;appearance:none;-webkit-appearance:none;outline:none;background:transparent;cursor:pointer;color:var(--theme-color-3, var(--default-theme-color-3));border:none;padding:0;margin-right:12px}.code-copy[data-v-f2d04186]:hover{color:var(--theme-color-1, var(--default-theme-color-1))}.code-copy svg[data-v-f2d04186]{width:13px;height:13px}.response-card-footer[data-v-f2d04186]{display:flex;flex-direction:column;flex-shrink:0;padding:10px 12px;gap:8px;border-top:1px solid var(--theme-border-color, var(--default-theme-border-color))}.response-example-selector[data-v-f2d04186]{align-self:start;margin:-4px}.response-description[data-v-f2d04186]{font-weight:var(--theme-semibold, var(--default-theme-semibold));font-size:var(--theme-micro, var(--default-theme-micro));color:var(--theme-color--1, var(--default-theme-color-1));display:flex;align-items:center;box-sizing:border-box}.schema-type[data-v-f2d04186]{font-size:var(--theme-micro, var(--default-theme-micro));color:var(--theme-color-2, var(--default-theme-color-2));font-weight:var(--theme-semibold, var(--default-theme-semibold));background:var(--theme-background-3, var(--default-theme-background-3));padding:2px 4px;border-radius:4px;margin-right:4px}.schema-example[data-v-f2d04186]{font-size:var(--theme-micro, var(--default-theme-micro));color:var(--theme-color-2, var(--default-theme-color-2));font-weight:var(--theme-semibold, var(--default-theme-semibold))}.example-response-tab[data-v-f2d04186]{display:block;margin:6px}.scalar-card-container[data-v-f2d04186]{flex:1;background:var(--theme-background-2, var(--default-theme-background-2))}.scalar-card-container[data-v-f2d04186] .cm-scroller{overflow-y:hidden}.scalar-card-checkbox[data-v-f2d04186]{display:flex;align-items:center;justify-content:center;position:relative;min-height:17px;cursor:pointer;-webkit-user-select:none;user-select:none;font-weight:var(--theme-semibold, var(--default-theme-semibold));font-size:var(--theme-mini, var(--default-theme-mini));color:var(--theme-color-2, var(--default-theme-color-2));width:fit-content;white-space:nowrap;margin-right:9px;gap:6px}.scalar-card-checkbox[data-v-f2d04186]:hover{color:var(--theme-color--1, var(--default-theme-color-1))}.scalar-card-checkbox .scalar-card-checkbox-input[data-v-f2d04186]{position:absolute;opacity:0;cursor:pointer;height:0;width:0}.scalar-card-checkbox-checkmark[data-v-f2d04186]{height:17px;width:17px;border-radius:var(--theme-radius, var(--default-theme-radius));background-color:transparent;background-color:var( --theme-background-3, var(--default-theme-background-3) );box-shadow:inset 0 0 0 1px var(--theme-border-color, var(--default-theme-border-color))}.scalar-card-checkbox[data-v-f2d04186]:has(.scalar-card-checkbox-input:checked){color:var(--theme-color-1, var(--default-theme-color-1))}.scalar-card-checkbox .scalar-card-checkbox-input:checked~.scalar-card-checkbox-checkmark[data-v-f2d04186]{background-color:var(--theme-color-1, var(--default-theme-color-1));box-shadow:none}.scalar-card-checkbox-checkmark[data-v-f2d04186]:after{content:"";position:absolute;display:none}.scalar-card-checkbox .scalar-card-checkbox-input:checked~.scalar-card-checkbox-checkmark[data-v-f2d04186]:after{display:block}.scalar-card-checkbox .scalar-card-checkbox-checkmark[data-v-f2d04186]:after{right:6px;top:36.5%;width:5px;height:9px;border:solid var(--theme-background-1, var(--default-theme-background-1));border-width:0 1.5px 1.5px 0;transform:rotate(45deg)}.show-api-client-button[data-v-be432808]{-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:none;border:none;padding:6px;height:23px;white-space:nowrap;border-radius:var(--theme-radius, var(--default-theme-radius));text-transform:uppercase;display:flex;justify-content:center;align-items:center;font-weight:var(--theme-semibold, var(--default-theme-semibold));font-size:var(--theme-micro, var(--default-theme-micro));color:var(--theme-background-2, var(--default-background-2));font-family:var(--theme-font, var(--default-theme-font));position:relative;cursor:pointer;box-sizing:border-box;box-shadow:inset 0 0 0 1px #0000001a}.show-api-client-button span[data-v-be432808],.show-api-client-button svg[data-v-be432808]{color:#fff;z-index:1}.show-api-client-button[data-v-be432808]:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;cursor:pointer;border-radius:var(--theme-radius, var(--default-theme-radius))}.show-api-client-button[data-v-be432808]:before{background:linear-gradient(#0000001a,#0003)}.show-api-client-button[data-v-be432808]:hover:before{background:linear-gradient(#0003,#0000001a)}.show-api-client-button svg[data-v-be432808]{height:12px;width:auto;margin-left:9px}.examples[data-v-6a096129]{position:sticky;top:calc(var(--refs-header-height) + 24px)}.deprecated *[data-v-6a096129]{text-decoration:line-through}.example-path[data-v-6a096129]{color:var(--theme-color-2, var(--default-theme-color-2));font-family:var(--theme-font-code, var(--default-theme-font-code))}.example-path[data-v-6a096129] em{color:var(--theme-color-1, var(--default-theme-color-1))}.endpoint-details-card[data-v-0f5233d6]{display:flex;flex-direction:column;gap:12px}.endpoint-details-card-item[data-v-0f5233d6]{border:1px solid var(--theme-border-color, var(--default-theme-border-color));border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));margin-top:0}.endpoint-details-card[data-v-0f5233d6] .parameter-list:first-of-type:last-of-type{margin:0}.endpoint-details-card[data-v-0f5233d6] .parameter-item:last-of-type .parameter-schema{padding-bottom:12px}.endpoint-details-card[data-v-0f5233d6] .parameter-list .parameter-list{margin-bottom:12px}.endpoint-details-card[data-v-0f5233d6] .parameter-list li{margin:0;padding:0 9px}.endpoint-details-card[data-v-0f5233d6] .property{padding:9px;margin:0}.endpoint-details-card[data-v-0f5233d6] .endpoint-title,.endpoint-details-card[data-v-0f5233d6] .parameters-title,.endpoint-details-card[data-v-0f5233d6] .request-body-title{text-transform:uppercase;font-weight:var(--theme-bold, var(--default-theme-bold));font-size:var(--theme-mini, var(--default-theme-mini));color:var(--theme-color-2, var(--default-theme-color-2));line-height:1.33;padding:9px;margin:0}.endpoint-details-card[data-v-0f5233d6] .request-body-title-select{text-transform:initial;font-weight:initial;margin-left:auto}.endpoint-header[data-v-e5fa534a]{display:flex;justify-content:space-between}.endpoint-details[data-v-e5fa534a]{display:flex;align-items:center;margin-top:0;gap:9px;min-width:0;flex-shrink:1}.endpoint-type[data-v-e5fa534a]{display:flex;align-items:center;justify-content:center;gap:6px;position:relative;z-index:0;width:60px;padding:6px;flex-shrink:0;font-size:var(--theme-small, var(--default-theme-small));text-transform:uppercase;font-weight:var(--default-theme-bold);font-family:var(--default-theme-font)}.endpoint-type[data-v-e5fa534a]:after{content:"";position:absolute;top:0;right:0;bottom:0;left:0;z-index:-1;background:currentColor;opacity:.15;border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg))}.endpoint-anchor[data-v-e5fa534a]{display:flex;align-items:center;min-width:0;flex-shrink:1;font-size:20px}.endpoint-label[data-v-e5fa534a]{display:flex;align-items:baseline;gap:9px;min-width:0;flex-shrink:1;color:var(--theme-color-1, var(--default-theme-color-1))}.endpoint-label-path[data-v-e5fa534a]{font-family:var(--default-theme-font-code);font-size:var(--theme-mini, var(--default-theme-mini));text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.endpoint-label-path[data-v-e5fa534a] em{color:var(--theme-color-2, var(--default-theme-color-2))}.endpoint-label-name[data-v-e5fa534a]{color:var(--theme-color-2, var(--default-theme-color-2));font-size:var(--theme-small, var(--default-theme-small));flex-shrink:1000000000;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.endpoint-try-hint[data-v-e5fa534a]{padding:6px;height:24px;width:24px;flex-shrink:0;opacity:.44}.endpoint-copy[data-v-e5fa534a],.endpoint-copy[data-v-e5fa534a]:hover{color:currentColor}.endpoint-copy[data-v-e5fa534a]{opacity:.44}.endpoint-copy[data-v-e5fa534a]:hover{opacity:1}.endpoint-content[data-v-e5fa534a]{display:grid;grid-template-columns:repeat(3,1fr);gap:9px;padding:9px}@container (max-width: 900px){.endpoint-content[data-v-e5fa534a]{grid-template-columns:1fr}}.endpoint-content>*[data-v-e5fa534a]{max-height:unset}.show-more[data-v-c0788f2e]{background:var(--theme-background-1, var(--default-theme-background-1));-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;border:1px solid var(--theme-border-color, var(--default-theme-border-color));margin:-48px auto 48px;padding:8px 12px;border-radius:30px;color:var(--theme-color-1, var(--default-theme-color-1));font-weight:var(--theme-semibold, var(--default-theme-semibold));font-size:var(--theme-small, var(--default-theme-small));display:flex;align-items:center;justify-content:center;position:relative}.show-more[data-v-c0788f2e]:hover{color:var(--theme-color-2, var(--default-theme-color-2));cursor:pointer}.show-more-icon[data-v-c0788f2e]{width:14px;height:14px;margin-left:3px}.show-more[data-v-c0788f2e]:active{box-shadow:0 0 0 1px var(--theme-border-color, var(--default-theme-border-color))}@container narrow-references-container (max-width: 900px){.show-more[data-v-c0788f2e]{margin-top:-25px;margin-bottom:25px}}@media (max-width: 1165px){.show-more[data-v-c0788f2e]{margin-top:-24px;margin-bottom:24px}}.endpoints[data-v-45f15e70]{overflow:auto;background:var(--theme-background-2, var(--default-theme-background-2));padding:10px 12px}@media (max-width: 580px){.endpoints[data-v-45f15e70]{max-height:calc(100vh - 150px)}}.endpoints span+span[data-v-45f15e70]{text-align:left;margin-left:12px;text-transform:initial}.endpoint[data-v-45f15e70]{display:flex;white-space:nowrap;cursor:pointer}.endpoint span[data-v-45f15e70]:first-of-type{text-transform:uppercase}.endpoint .post[data-v-45f15e70],.endpoint .get[data-v-45f15e70],.endpoint .delete[data-v-45f15e70],.endpoint .put[data-v-45f15e70]{white-space:nowrap}.endpoint span[data-v-45f15e70]{color:var(--theme-color-1, var(--default-theme-color-1));min-width:62px;display:inline-block;text-align:right;line-height:1.55;font-family:var(--theme-font-code, var(--default-theme-font-code));font-size:var(--theme-small, var(--default-theme-small));cursor:pointer}.section-container[data-v-0090f16b]{border-top:1px solid var(--theme-border-color, var(--default-theme-border-color))}.tag-section[data-v-b06f5cf1]{margin-bottom:48px}.tag-name[data-v-b06f5cf1]{text-transform:capitalize}.tag-description[data-v-b06f5cf1]{padding-bottom:4px}.references-loading{position:absolute;top:0;left:0;right:0;z-index:1;grid-area:rendered;background:var(--theme-background-1, var(--default-theme-background-1))}.references-loading-top-spacer{top:calc(var(--refs-header-height) - 1px)}.references-loading-hidden-tag .section-container .section:first-child{display:none}.show-more[data-v-f4d0cefa]{margin-top:24px}.reference-models[data-v-c31dbd07]{margin-bottom:48px}.reference-models-anchor[data-v-c31dbd07]{display:flex;align-items:center;font-size:20px;padding-left:6px;color:var(--theme-color-1, var(--default-theme-color-1))}.reference-models-label[data-v-c31dbd07]{font-size:var(--theme-mini, var(--default-theme-mini))}.reference-models-label[data-v-c31dbd07] em{font-weight:var(--theme-bold, var(--default-theme-bold))}.narrow-references-container{container-name:narrow-references-container;container-type:inline-size}.render-loading[data-v-16370f36]{height:calc(var(--full-height) - var(--refs-header-height));display:flex;align-items:center;justify-content:center}.introduction-cards[data-v-16370f36]{display:flex;flex-direction:column;gap:12px}.introduction-cards-row[data-v-16370f36]{flex-flow:row wrap;gap:24px}.introduction-cards-row>*[data-v-16370f36]{flex:1}@media (min-width: 600px){.introduction-cards-row>*[data-v-16370f36]{min-width:min-content}}@media (max-width: 600px){.introduction-cards-row>*[data-v-16370f36]{max-width:100%}}@container (max-width: 900px){.introduction-cards-row[data-v-16370f36]{flex-direction:column;align-items:stretch}}.references-classic .introduction-cards-row[data-v-16370f36] .card-footer,.references-classic .introduction-cards-row[data-v-16370f36] .scalar-card,.references-classic .introduction-cards-row[data-v-16370f36] .scalar-card--muted{background:var(--theme-background-1, var(--default-theme-background-1))}.references-classic .introduction-cards-row[data-v-16370f36] .scalar-card:nth-of-type(2) .scalar-card-header{display:none}.references-classic .introduction-cards-row[data-v-16370f36] .scalar-card:nth-of-type(2) .scalar-card-header.scalar-card--borderless+.scalar-card-content{margin-top:0}.start[data-v-ca77ea59]{padding:24px;display:flex;flex-flow:wrap;justify-content:space-between;position:relative;z-index:0}.swagger-editor .start[data-v-ca77ea59]{padding-top:24px}.start-h1[data-v-ca77ea59]{font-size:var(--theme-heading-2, var(--default-theme-heading-2));margin-top:0;line-height:1.45;margin-bottom:0;font-weight:var(--theme-bold, var(--default-theme-bold));color:var(--theme-color-1, var(--default-theme-color-1));width:100%;position:relative}.start-h3[data-v-ca77ea59]{font-size:var(--theme-paragraph, var(--default-theme-paragraph));margin-top:0;margin-bottom:6px;display:block;line-height:1.45;font-weight:var(--theme-bold, var(--default-theme-bold));color:var(--theme-color-1, var(--default-theme-color-1));width:100%}.start-h1[data-v-ca77ea59]:not(:first-of-type){margin-top:24px}.start-p[data-v-ca77ea59]{font-size:var(--theme-paragraph, var(--default-theme-paragraph));color:var(--theme-color-2, var(--default-theme-color-2));line-height:1.5;width:100%;margin-top:12px}.start-ul[data-v-ca77ea59]{margin-top:12px;font-size:var(--theme-paragraph, var(--default-theme-paragraph));line-height:1.5;padding-left:0;list-style:initial;display:flex;flex-flow:wrap;gap:24px}.start-ul li[data-v-ca77ea59]{margin:0;padding:0;list-style:none;width:calc(50% - 24px);color:var(--theme-color-2, var(--default-theme-color-2))}.start-ul li[data-v-ca77ea59]:first-of-type{margin-top:0}.start-section[data-v-ca77ea59]{width:100%;margin-bottom:12px;border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg));border:1px solid var(--theme-border-color, var(--default-theme-border-color));display:flex;flex-flow:wrap;background:var(--theme-background-2, var(--default-theme-background-2))}.start-section[data-v-ca77ea59]:last-of-type{margin-bottom:48px}.start-h2[data-v-ca77ea59]{padding:9px;color:var(--theme-color-3, var(--default-theme-color-3));font-size:var(--theme-mini, var(--default-theme-mini));font-weight:var(--theme-semibold, var(--default-theme-semibold));width:100%;border-bottom:1px solid var(--theme-border-color, var(--default-theme-border-color))}.start-item[data-v-ca77ea59]{padding:9px;display:flex;align-items:center;-webkit-user-select:none;user-select:none;cursor:pointer;color:var(--theme-color-1, var(--default-theme-color-1));font-weight:var(--theme-semibold, var(--default-theme-semibold));font-size:var(--theme-mini, var(--default-theme-mini));flex:1;text-transform:capitalize}.start-section-colors .start-item[data-v-ca77ea59]{min-width:33.33%}.start-item[data-v-ca77ea59]:not(:last-of-type){border-right:1px solid var(--theme-border-color, var(--default-theme-border-color))}.start-section-colors .start-item[data-v-ca77ea59]:not(:last-of-type){border-right:none}.start-section-colors .start-item[data-v-ca77ea59]:not(:nth-of-type(3n)){border-right:1px solid var(--default-theme-border-color)}.start-section-colors .start-item[data-v-ca77ea59]:nth-of-type(n+4){border-top:1px solid var(--default-theme-border-color)}.start-item[data-v-ca77ea59]:empty{pointer-events:none}.start-item svg[data-v-ca77ea59]{width:14px;height:14px;margin-right:6px}.start-item[data-v-ca77ea59]:hover{background:var(--theme-background-2, var(--default-theme-background-2))}.start-item-active[data-v-ca77ea59]{box-shadow:0 0 0 1px var(--theme-color-1, var(--default-theme-color-1));z-index:10;position:relative;color:var(--theme-color-1, var(--default-theme-color-1))}.start-section-color .start-item[data-v-ca77ea59]{text-transform:capitalize}.start-cta[data-v-ca77ea59]{display:flex;gap:12px;width:100%;margin-top:24px;margin-bottom:0}.start-section[data-v-ca77ea59]:nth-of-type(2){border-left:1px solid var(--theme-border-color, var(--default-theme-border-color));border-right:1px solid var(--theme-border-color, var(--default-theme-border-color))}.start-row[data-v-ca77ea59]{width:100%;margin-top:12px;overflow:hidden}.start-hero-copy[data-v-ca77ea59]{background:var(--theme-background-2, var(--default-theme-background-2));padding:12px;border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg))}.start-p-small[data-v-ca77ea59]{font-weight:var(--theme-semibold, var(--default-theme-semibold));font-size:var(--theme-mini, var(--default-theme-mini));color:var(--theme-color-2, var(--default-theme-color-2));margin-bottom:12px;line-height:1.4}.start-cta[data-v-ca77ea59]{margin-bottom:12px;width:fit-content;white-space:nowrap}.start-copy[data-v-ca77ea59]{padding:76px 48px 48px;display:flex;justify-content:center;align-items:center;flex-direction:column;text-align:center}.start-logo[data-v-ca77ea59]{color:var(--theme-color-1, var(--default-theme-color-1));margin-bottom:24px;width:72px;aspect-ratio:1;position:relative;box-shadow:var(--theme-shadow-2, var(--default-theme-shadow-2));border-radius:50%}.start-logo[data-v-ca77ea59]:before{content:"";width:300%;aspect-ratio:1;left:-100%;top:-100%;position:absolute;z-index:-1;border-radius:50%;background-size:24px 24px;box-shadow:inset 0 0 50px var(--theme-background-1, var(--default-theme-background-1)),inset 0 0 50px var(--theme-background-1, var(--default-theme-background-1));background-image:linear-gradient(to right,var(--theme-border-color, var(--default-theme-border-color)) 1px,transparent 1px),linear-gradient(to bottom,var(--theme-border-color, var(--default-theme-border-color)) 1px,transparent 1px)}.start-logo svg[data-v-ca77ea59]{width:100%;height:auto;background:var(--theme-background-1, var(--default-theme-background-1));padding:3px;border-radius:50%;position:relative}@media screen and (max-width: 600px){.start-section-colors .start-item[data-v-ca77ea59],.start-item[data-v-ca77ea59]{width:100%;border-radius:0;border-right:none;border-top:1px solid var(--theme-border-color, var(--default-theme-border-color))}.start-item[data-v-ca77ea59]:empty{display:none}.start-h2[data-v-ca77ea59]{border-bottom:none}.start li[data-v-ca77ea59]{width:100%}.start-copy[data-v-ca77ea59]{padding:48px 0 24px}}@media screen and (max-width: 1000px){.start[data-v-ca77ea59]{padding:0;overflow:auto}}.scalar-api-reference[data-v-f5b83f9d]{--refs-sidebar-width: var(--theme-sidebar-width, 0px);--refs-header-height: var(--theme-header-height, 0px);--refs-content-max-width: var(--theme-content-max-width, 1540px)}.scalar-api-reference.references-classic[data-v-f5b83f9d]{--refs-content-max-width: var(--theme-content-max-width, 1420px)}.references-layout[data-v-f5b83f9d]{height:100dvh;max-height:100%;width:100dvw;max-width:100%;flex:1;overflow-y:auto;overflow-x:hidden;--full-height: 100dvh;display:grid;grid-template-rows:var(--refs-header-height) repeat(2,auto);grid-template-columns:var(--refs-sidebar-width) 1fr;grid-template-areas:"header header" "navigation rendered" "footer footer";background:var(--theme-background-1, var(--default-theme-background-1))}.references-header[data-v-f5b83f9d]{grid-area:header;position:sticky;top:0;z-index:10;height:var(--refs-header-height)}.references-editor[data-v-f5b83f9d]{grid-area:editor;display:flex;min-width:0;background:var(--theme-background-1, var(--default-theme-background-1));z-index:1}.references-navigation[data-v-f5b83f9d]{grid-area:navigation}.references-rendered[data-v-f5b83f9d]{position:relative;grid-area:rendered;min-width:0;background:var(--theme-background-1, var(--default-theme-background-1))}.scalar-api-reference.references-classic[data-v-f5b83f9d],.references-classic .references-rendered[data-v-f5b83f9d]{--full-height: fit-content !important;height:initial!important;max-height:initial!important}.references-navigation-list[data-v-f5b83f9d]{position:sticky;top:var(--refs-header-height);height:calc(var(--full-height) - var(--refs-header-height));background:var( --sidebar-background-1, var( --default-sidebar-background-1, var(--theme-background-1, var(--default-theme-background-1)) ) );overflow-y:auto;display:flex;flex-direction:column}.references-editor-textarea[data-v-f5b83f9d]{position:sticky;top:var(--refs-header-height);height:calc(var(--full-height) - var(--refs-header-height));display:flex;min-width:0;flex:1}.references-editable[data-v-f5b83f9d]{grid-template-columns:var(--refs-sidebar-width) 1fr 1fr;grid-template-areas:"header header header" "navigation editor rendered" "footer footer footer"}.references-sidebar[data-v-f5b83f9d]{--refs-sidebar-width: var(--theme-sidebar-width, 280px)}.references-footer[data-v-f5b83f9d]{grid-area:footer}@media (max-width: 1150px){.references-layout[data-v-f5b83f9d]{grid-template-columns:var(--refs-sidebar-width) 1fr 0px}}@media (max-width: 1000px){.references-layout[data-v-f5b83f9d]{grid-template-columns:auto;grid-template-rows:var(--refs-header-height) 0px auto auto;grid-template-areas:"header" "navigation" "rendered" "footer"}.references-sidebar[data-v-f5b83f9d]{overflow-y:hidden}.references-editable[data-v-f5b83f9d]{grid-template-areas:"header" "navigation" "editor"}.references-navigation[data-v-f5b83f9d],.references-rendered[data-v-f5b83f9d]{max-height:unset}.references-rendered[data-v-f5b83f9d]{position:static}.references-navigation[data-v-f5b83f9d]{position:sticky;top:var(--refs-header-height);height:0px;z-index:10}.references-navigation-list[data-v-f5b83f9d]{position:absolute;top:-1px;height:calc(var(--full-height) - var(--refs-header-height) + 1px);width:100%;border-top:1px solid var(--theme-border-color, var(--default-theme-border-color));display:flex;flex-direction:column}}.references-classic-header[data-v-1c1eb708]{display:flex;align-items:center;justify-content:space-between;gap:12px;max-width:var(--refs-content-max-width);margin:auto;padding:12px 0}.references-classic-header-container[data-v-1c1eb708]{padding:0 60px}@container narrow-references-container (max-width: 900px){.references-classic-header[data-v-1c1eb708]{padding:12px 24px}.references-classic-header-container[data-v-1c1eb708]{padding:0}}.references-classic-header-icon[data-v-1c1eb708]{height:24px;color:var(--theme-color-1, var(--default-theme-color-1))}.darklight[data-v-0acd62b8]{font-family:var(--theme-font, var(--default-theme-font));border:none;border-top:1px solid var( --sidebar-border-color, var( --default-sidebar-border-color, var(--theme-border-color, var(--default-theme-border-color)) ) );color:var( --sidebar-color-2, var( --default-sidebar-color-2, var(--theme-color-2, var(--default-theme-color-2)) ) );font-size:var(--theme-mini, var(--default-theme-mini));font-weight:var(--theme-semibold, var(--default-theme-semibold));-webkit-appearance:none;-moz-appearance:none;appearance:none;background:transparent;outline:none;padding:18px 24px 0;display:flex;align-items:center;text-indent:9px;width:100%}.darklight-reference[data-v-0acd62b8]{width:100%;margin-top:auto}.darklight[data-v-0acd62b8]:hover{cursor:pointer;color:var( --sidebar-color-1, var( --default-sidebar-color-1, var(--theme-color-1, var(--default-theme-color-1)) ) )}.darklight svg[data-v-0acd62b8]{stroke:currentColor;height:12px;width:12px}.darklight-reference-promo[data-v-0acd62b8]{padding:6px 24px 12px;display:flex;align-items:center;font-size:var(--theme-mini, var(--default-theme-mini));text-decoration:none;color:var( --sidebar-color-2, var( --default-sidebar-color-2, var(--theme-color-2, var(--default-theme-color-2)) ) )}.darklight-reference-promo[data-v-0acd62b8]:hover{text-decoration:underline}.darklight[data-v-b04e89bc]{color:var( --sidebar-color-2, var( --default-sidebar-color-2, var(--theme-color-2, var(--default-theme-color-2)) ) );display:flex;align-items:center;height:24px;width:24px;padding:4px}.darklight[data-v-b04e89bc]:hover{cursor:pointer;color:var( --sidebar-color-1, var( --default-sidebar-color-1, var(--theme-color-1, var(--default-theme-color-1)) ) )}a[data-v-6b991279]{text-decoration:none}.ref-search-input[data-v-6b991279]{width:100%;background:transparent;padding:12px;font-size:var(--theme-font-size-4, var(--default-theme-font-size-4));outline:none;border:1px solid var(--theme-border-color, var(--default-theme-border-color));border-radius:var(--theme-radius, var(--default-theme-radius));color:var(--theme-color-1, var(--default-theme-color-1));font-weight:var(--theme-semibold, var(--default-theme-semibold));font-size:var(--theme-font-size-3, var(--default-theme-font-size-3));font-family:var(--theme-font, var(--default-theme-font));-webkit-appearance:none;-moz-appearance:none;appearance:none}.ref-search-input[data-v-6b991279]:focus{border-color:var(--theme-color-1, var(--default-theme-color-1))}.item-entry[data-v-6b991279]{-webkit-appearance:none;-moz-appearance:none;appearance:none;background:transparent;border:none;outline:none;padding:9px 12px;width:100%;color:var(--theme-color-3, var(--default-theme-color-3));text-align:left;border-radius:var(--theme-radius, var(--default-theme-radius));align-items:center;font-family:var(--theme-font);min-height:31px;display:flex;gap:6px;overflow:hidden}.item-entry-http-verb[data-v-6b991279]:empty{display:none}.ref-search-list[data-v-6b991279]{padding:0 12px 12px}.ref-search-container[data-v-6b991279]{padding:12px}.item-entry--active[data-v-6b991279],.item-entry[data-v-6b991279]:hover{background:var(--theme-background-2, var(--default-theme-background-2));cursor:pointer}.item-entry--tag .item-entry-description[data-v-6b991279]:before{content:"â€“";margin-right:6px}.item-entry-description[data-v-6b991279],.item-entry-title[data-v-6b991279]{font-weight:var(--theme-semibold, var(--default-theme-semibold));color:var(--theme-color-1, var(--default-theme-color-1));font-size:var(--theme-font-size-4, var(--default-theme-font-size-4));min-width:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.item-entry-title[data-v-6b991279]{min-width:fit-content}.item-entry-http-verb[data-v-6b991279],.item-entry-subtitle[data-v-6b991279]{display:flex;font-size:var(--theme-font-size-4, var(--default-theme-font-size-4));font-family:var(--theme-font-code, var(--default-theme-font-code));min-width:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.item-entry-http-verb[data-v-6b991279]{text-transform:uppercase;min-width:45px;position:relative;top:.5px}.item-entry-path[data-v-6b991279]{color:var(--theme-color-3, var(--default-theme-color-3));font-size:var(--theme-font-size-4, var(--default-theme-font-size-4));min-width:0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ref-search-meta[data-v-6b991279]{background:var(--theme-background-3, var(--default-theme-background-3));padding:6px 12px;font-size:var(--theme-font-size-4, var(--default-theme-font-size-4));color:var(--theme-color-3, var(--default-theme-color-3));font-weight:var(--theme-semibold, var(--default-theme-semibold));display:flex;gap:12px}.sidebar-search[data-v-fdb2c36b]{display:flex;align-items:center;position:relative;padding:0 3px 0 9px;min-width:254px;max-width:100%;font-family:var(--theme-font, var(--default-theme-font));background:var( --sidebar-search-background, var( --default-sidebar-search-background, var(--theme-background-1, var(--default-theme-background-1)) ) );color:var( --sidebar-color-2, var( --default-sidebar-color-2, var(--theme-color-2, var(--default-theme-color-2)) ) );outline:none;border-radius:var(--theme-radius, var(--default-theme-radius));box-shadow:0 0 0 1px var( --sidebar-search-border-color, var( --default-sidebar-search-border-color, var(--theme-border-color, var(--default-theme-border-color)) ) );cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none}.sidebar-search-input[data-v-fdb2c36b]{font-size:var(--theme-mini, var(--default-theme-mini));font-weight:var(--theme-semibold, var(--default-theme-semibold));height:31px;-webkit-user-select:none;user-select:none;z-index:10;position:relative;display:flex;width:100%;justify-content:space-between;align-items:center}.sidebar-search-shortcut[data-v-fdb2c36b]{text-transform:uppercase}.sidebar-search-key[data-v-fdb2c36b]{background-color:var( --theme-background-2, var(--default-theme-background-2) );padding:3px 5px;margin:2px;border-radius:var(--theme-radius, var(--default-theme-radius));color:var( --sidebar-color-2, var(--default-sidebar-color-2), var(--theme-color-2, var(--default-theme-color-2)) )}.search-icon[data-v-fdb2c36b]{padding:0;margin-right:6px;width:12px}.references-mobile-header[data-v-f34d1ece]{display:flex;align-items:center;gap:12px;height:100%;width:100%;padding:0 8px;background:var(--theme-background-1, var(--default-theme-background-1));border-bottom:1px solid var(--theme-border-color, var(--default-theme-border-color))}.references-mobile-breadcrumbs[data-v-f34d1ece]{flex:1;min-width:0;font-size:var(--theme-small, var(--default-theme-small));font-weight:var(--theme-semibold, var(--default-theme-semibold));color:var(--theme-color-1, var(--default-theme-color-1));overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.references-mobile-header-actions[data-v-f34d1ece]{display:flex;flex-direction:row;gap:4px;height:24px;align-items:center;padding-left:4px}.scalar-api-references-standalone-mobile{--theme-header-height: 50px}.scalar-api-references-standalone-search[data-v-a00acb42]{display:flex;flex-direction:column;padding:12px 12px 6px}body{margin:0}')),document.head.appendChild(e)}}catch(a){console.error("vite-plugin-css-injected-by-js",a)}})();
var F5 = Object.defineProperty;
var H5 = (t, e, r) => e in t ? F5(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;
var Zd = (t, e, r) => (H5(t, typeof e != "symbol" ? e + "" : e, r), r);
import { defineComponent as G, openBlock as k, createBlock as Y, resolveDynamicComponent as Oi, withCtx as I, createTextVNode as re, toDisplayString as te, unref as v, createCommentVNode as H, useCssModule as Yb, renderSlot as se, onMounted as Xn, reactive as vn, readonly as Yp, ref as ge, computed as fe, normalizeStyle as Eo, normalizeProps as Ir, guardReactiveProps as jr, watch as Ve, onBeforeUnmount as G5, toValue as Pt, toRef as an, createElementBlock as C, createElementVNode as x, createVNode as Z, normalizeClass as $e, Fragment as ee, renderList as _e, createStaticVNode as gs, pushScopeId as fr, popScopeId as hr, withDirectives as Ne, withModifiers as hl, vModelSelect as Bb, vModelText as xt, vModelCheckbox as Ca, defineAsyncComponent as Fb, useAttrs as K5, mergeProps as Bp, nextTick as _c, h as Hb, useCssVars as J5, vShow as mn, toRaw as e3, withKeys as t3, Teleport as r3, createSlots as Fp } from "vue";
import { Dialog as n3, DialogPanel as i3, DialogTitle as s3, DialogDescription as o3, Disclosure as zu, DisclosureButton as Xu, DisclosurePanel as Wu, TabGroup as Gb, TabList as Kb, Tab as Gf, TabPanels as a3, TabPanel as k0, Listbox as l3, ListboxButton as c3, ListboxOptions as u3, ListboxOption as d3 } from "@headlessui/vue";
import { useMagicKeys as Uu, whenever as Hs, useMediaQuery as Vu, useEventBus as Jb, useResizeObserver as ev, useIntersectionObserver as f3, useElementHover as h3, computedAsync as p3, useDebounceFn as m3 } from "@vueuse/core";
import g3, { AxiosHeaders as O3 } from "axios";
import y3 from "@vcarl/remark-headings";
import b3, { slug as Hp } from "github-slugger";
import tv from "remark-parse";
import v3 from "remark-stringify";
import { unified as rv } from "unified";
import { availableTargets as w3, HTTPSnippet as $3 } from "httpsnippet-lite";
import { createHead as S3, useSeoMeta as k3 } from "unhead";
import { Toaster as _3, toast as P3 } from "vue-sonner";
import x3 from "rehype-external-links";
import T3 from "rehype-format";
import C3 from "rehype-highlight";
import Q3 from "rehype-raw";
import A3, { defaultSchema as _0 } from "rehype-sanitize";
import E3 from "rehype-stringify";
import R3 from "remark-gfm";
import I3 from "remark-rehype";
import { useFloating as j3, autoUpdate as Z3, offset as M3, flip as q3, shift as N3 } from "@floating-ui/vue";
import D3 from "fuse.js";
(function() {
  try {
    if (typeof document < "u") {
      var t = document.createElement("style");
      t.appendChild(document.createTextNode('@import"https://fonts.googleapis.com/css2?family=Inter:wght@100..900";@import"https://fonts.googleapis.com/css?family=JetBrains%20Mono";:root{--default-theme-border-width: 1px;--default-theme-radius: 3px;--default-theme-radius-lg: 6px;--default-theme-radius-xl: 8px;--default-theme-header-height: 50px;--default-theme-sidebar-width: 280px;--default-theme-toc-width: 280px;--default-theme-font: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;--default-theme-font-code: "JetBrains Mono", ui-monospace, Menlo, Monaco, "Cascadia Mono", "Segoe UI Mono", "Roboto Mono", "Oxygen Mono", "Ubuntu Monospace", "Source Code Pro", "Fira Mono", "Droid Sans Mono", "Courier New", monospace;--default-theme-heading-1: 40px;--default-theme-page-description: 24px;--default-theme-heading-2: 24px;--default-theme-heading-3: 20px;--default-theme-heading-4: 16px;--default-theme-heading-5: 16px;--default-theme-heading-6: 16px;--default-theme-paragraph: 16px;--default-theme-small: 14px;--default-theme-mini: 13px;--default-theme-micro: 12px;--default-theme-bold: 600;--default-theme-semibold: 500;--default-theme-regular: 400;--default-theme-font-size-1: 24px;--default-theme-font-size-2: 16px;--default-theme-font-size-3: 14px;--default-theme-font-size-4: 13px;--default-theme-font-size-5: 12px;--default-theme-line-height-1: 32px;--default-theme-line-height-2: 24px;--default-theme-line-height-3: 20px;--default-theme-line-height-4: 18px;--default-theme-line-height-5: 16px;--default-theme-font-medium: 500;--default-theme-font-bold: 700}.dark-mode{color-scheme:dark;--default-theme-scrollbar-color: rgba(255, 255, 255, .18);--default-theme-scrollbar-color-active: rgba(255, 255, 255, .36);--default-theme-button-1: rgba(255, 255, 255, 1);--default-theme-button-1-hover: rgba(255, 255, 255, .9);--default-theme-button-1-color: black;--default-theme-shadow-1: 0 1px 3px 0 rgb(0, 0, 0, .1);--default-theme-shadow-2: rgba(15, 15, 15, .2) 0px 3px 6px, rgba(15, 15, 15, .4) 0px 9px 24px, 0 0 0 1px rgba(255, 255, 255, .1)}.light-mode{color-scheme:light;--default-theme-scrollbar-color-active: rgba(0, 0, 0, .36);--default-theme-scrollbar-color: rgba(0, 0, 0, .18);--default-theme-button-1: rgba(0, 0, 0, 1);--default-theme-button-1-hover: rgba(0, 0, 0, .8);--default-theme-button-1-color: rgba(255, 255, 255, .9);--default-theme-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, .11);--default-theme-shadow-2: rgba(0, 0, 0, .08) 0px 13px 20px 0px, rgba(0, 0, 0, .08) 0px 3px 8px 0px, #eeeeed 0px 0 0 1px}.light-mode .dark-mode{color-scheme:dark!important}@media (max-width: 460px){:root{--default-theme-font-size-1: 22px;--default-theme-font-size-2: 14px;--default-theme-font-size-3: 12px}}@media (max-width: 720px){:root{--default-theme-heading-1: 24px;--default-theme-page-description: 20px}}:where(._reset_78zw5_3){font-family:var(--theme-font, var(--default-theme-font));line-height:1.15;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4}:where(._reset_78zw5_3) *,:where(._reset_78zw5_3) *:before,:where(._reset_78zw5_3) *:after{box-sizing:border-box}:where(._reset_78zw5_3) *{text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}:where(._reset_78zw5_3) h1,:where(._reset_78zw5_3) h2,:where(._reset_78zw5_3) h3,:where(._reset_78zw5_3) h4,:where(._reset_78zw5_3) h5,:where(._reset_78zw5_3) h6,:where(._reset_78zw5_3) i,:where(._reset_78zw5_3) p,:where(._reset_78zw5_3) ol,:where(._reset_78zw5_3) ul,:where(._reset_78zw5_3) dl,:where(._reset_78zw5_3) dd,:where(._reset_78zw5_3) dt,:where(._reset_78zw5_3) em,:where(._reset_78zw5_3) strong,:where(._reset_78zw5_3) button{margin:unset;padding:unset;color:unset;font-weight:unset;font-style:unset}:where(._reset_78zw5_3) button{border:unset;background:unset;-webkit-appearance:unset;-moz-appearance:unset;appearance:unset;font-family:var(--theme-font, var(--default-theme-font))}:where(._reset_78zw5_3) input::placeholder{color:var(--theme-color-3, var(--default-theme-color-3));font-family:var(--theme-font, var(--default-theme-font))}:where(._reset_78zw5_3) input:-ms-input-placeholder{color:var(--theme-color-3, var(--default-theme-color-3));font-family:var(--theme-font, var(--default-theme-font))}:where(._reset_78zw5_3) input::-webkit-input-placeholder{color:var(--theme-color-3, var(--default-theme-color-3));font-family:var(--theme-font, var(--default-theme-font))}:where(._scrollbars_1wuqs_3) ._cm-scroller_1wuqs_4,:where(._scrollbars_1wuqs_3) ._custom-scroll_1wuqs_5{overflow-y:auto;scrollbar-color:transparent transparent;scrollbar-width:thin;-webkit-overflow-scrolling:touch}:where(._scrollbars_1wuqs_3) ._custom-scroll-self-contain-overflow_1wuqs_11{overscroll-behavior:contain}@supports (-moz-appearance: none){:where(._scrollbars_1wuqs_3) ._cm-scroller_1wuqs_4,:where(._scrollbars_1wuqs_3) ._custom-scroll_1wuqs_5{padding-right:12px}}:where(._scrollbars_1wuqs_3) ._cm-scroller_1wuqs_4:hover,:where(._scrollbars_1wuqs_3) ._custom-scroll_1wuqs_5:hover{scrollbar-color:var( --theme-scrollbar-color, var(--default-theme-scrollbar-color) ) transparent}:where(._scrollbars_1wuqs_3) ._cm-scroller_1wuqs_4:hover::-webkit-scrollbar-thumb,:where(._scrollbars_1wuqs_3) ._custom-scroll_1wuqs_5:hover::-webkit-scrollbar-thumb{background:var( --theme-scrollbar-color, var(--default-theme-scrollbar-color) );background-clip:content-box;border:3px solid transparent}:where(._scrollbars_1wuqs_3) ._cm-scroller_1wuqs_4::-webkit-scrollbar-thumb:active,:where(._scrollbars_1wuqs_3) ._custom-scroll_1wuqs_5::-webkit-scrollbar-thumb:active{background:var( --theme-scrollbar-color-active, var(--default-theme-scrollbar-color-active) );background-clip:content-box;border:3px solid transparent}:where(._scrollbars_1wuqs_3) ._cm-scroller_1wuqs_4::-webkit-scrollbar-corner,:where(._scrollbars_1wuqs_3) ._custom-scroll_1wuqs_5::-webkit-scrollbar-corner{background:transparent}:where(._scrollbars_1wuqs_3) ._cm-scroller_1wuqs_4::-webkit-scrollbar,:where(._scrollbars_1wuqs_3) ._custom-scroll_1wuqs_5::-webkit-scrollbar{height:12px;width:12px}:where(._scrollbars_1wuqs_3) ._cm-scroller_1wuqs_4::-webkit-scrollbar-track,:where(._scrollbars_1wuqs_3) ._custom-scroll_1wuqs_5::-webkit-scrollbar-track{background:transparent}:where(._scrollbars_1wuqs_3) ._cm-scroller_1wuqs_4::-webkit-scrollbar-thumb,:where(._scrollbars_1wuqs_3) ._custom-scroll_1wuqs_5::-webkit-scrollbar-thumb{border-radius:20px;background:transparent;background-clip:content-box;border:3px solid transparent}@media (pointer: coarse){:where(._scrollbars_1wuqs_3) ._cm-scroller_1wuqs_4,:where(._scrollbars_1wuqs_3) ._custom-scroll_1wuqs_5{padding-right:12px}}')), document.head.appendChild(t);
    }
  } catch (e) {
    console.error("vite-plugin-css-injected-by-js", e);
  }
})();
const z3 = ".light-mode,.light-mode .dark-mode{--default-theme-background-1: #f9f9f9;--default-theme-background-2: #f1f1f1;--default-theme-background-3: #e7e7e7;--default-theme-background-card: #fff;--default-theme-color-1: #2a2f45;--default-theme-color-2: #757575;--default-theme-color-3: #8e8e8e;--default-theme-color-accent: var(--default-theme-color-1);--default-theme-background-accent: var(--default-theme-background-3);--default-theme-border-color: rgba(0, 0, 0, .1);--default-theme-code-languages-background-supersede: var( --default-theme-background-1 );--default-theme-code-language-color-supersede: var(--default-theme-color-1)}.dark-mode{--default-theme-background-1: #131313;--default-theme-background-2: #1d1d1d;--default-theme-background-3: #272727;--default-theme-background-card: #1d1d1d;--default-theme-color-1: rgba(255, 255, 255, .9);--default-theme-color-2: rgba(255, 255, 255, .62);--default-theme-color-3: rgba(255, 255, 255, .44);--default-theme-color-accent: var(--default-theme-color-1);--default-theme-background-accent: var(--default-theme-background-3);--default-theme-border-color: rgba(255, 255, 255, .1);--default-theme-code-languages-background-supersede: var( --default-theme-background-3 );--default-theme-code-language-color-supersede: var(--default-theme-color-3)}.light-mode .t-doc__sidebar,.dark-mode .t-doc__sidebar{--default-sidebar-background-1: var(--default-theme-background-1);--default-sidebar-color-1: var(--default-theme-color-1);--default-sidebar-color-2: var(--default-theme-color-2);--default-sidebar-border-color: var(--default-theme-border-color);--default-sidebar-item-hover-background: var(--default-theme-background-2);--default-sidebar-item-hover-color: currentColor;--default-sidebar-item-active-background: var( --default-theme-background-accent );--default-sidebar-color-active: var(--default-theme-color-accent);--default-sidebar-search-background: transparent;--default-sidebar-search-color: var(--default-theme-color-3);--default-sidebar-search-border-color: var(--default-theme-border-color)}.light-mode{--default-theme-color-green: #069061;--default-theme-color-red: #ef0006;--default-theme-color-yellow: #edbe20;--default-theme-color-blue: #0082d0;--default-theme-color-orange: #fb892c;--default-theme-color-purple: #5203d1}.dark-mode{--default-theme-color-green: #00b648;--default-theme-color-red: #dd2f2c;--default-theme-color-yellow: #ffc90d;--default-theme-color-blue: #4eb3ec;--default-theme-color-orange: #ff8d4d;--default-theme-color-purple: #b191f9}.code-languages-background:before{box-shadow:inset 0 0 0 1px var(--default-theme-border-color)!important}.scalar-api-client__item,.scalar-card,.dark-mode .dark-mode.scalar-card{--default-theme-background-1: var(--default-theme-background-card);--default-theme-background-2: var(--default-theme-background-1);--default-theme-background-3: var(--default-theme-background-1)}.dark-mode .dark-mode.scalar-card{--default-theme-background-3: var(--default-theme-background-3)}.dark-mode .show-api-client-button span,.dark-mode .show-api-client-button svg{color:var(--default-theme-background-3)}.dark-mode .show-api-client-button{background:var(--default-theme-color-1)!important}.t-doc__sidebar{--default-theme-color-green: var(--default-theme-color-1);--default-theme-color-red: var(--default-theme-color-1);--default-theme-color-yellow: var(--default-theme-color-1);--default-theme-color-blue: var(--default-theme-color-1);--default-theme-color-orange: var(--default-theme-color-1);--default-theme-color-purple: var(--default-theme-color-1)}.download-cta a,.references-rendered .markdown a{color:var(--default-theme-color-1)!important;text-decoration:underline!important}", X3 = '.light-mode{--default-theme-background-1: #f0f2f5;--default-theme-background-2: #eaecf0;--default-theme-background-3: #e0e2e6;--default-theme-border-color: rgb(228, 228, 231);--default-theme-color-1: rgb(9, 9, 11);--default-theme-color-2: rgb(113, 113, 122);--default-theme-color-3: rgba(25, 25, 28, .5);--default-theme-color-accent: var(--default-theme-color-1);--default-theme-background-accent: #8ab4f81f;--default-theme-code-language-color-supersede: var(--default-theme-color-1)}.light-mode .scalar-card.dark-mode,.dark-mode{--default-theme-background-1: #000e23;--default-theme-background-2: #01132e;--default-theme-background-3: #03193b;--default-theme-border-color: rgba(255, 255, 255, .12);--default-theme-color-1: #fafafa;--default-theme-color-2: rgb(161, 161, 170);--default-theme-color-3: rgba(255, 255, 255, .533);--default-theme-color-accent: var(--default-theme-color-1);--default-theme-background-accent: #8ab4f81f;--default-theme-code-language-color-supersede: var(--default-theme-color-1)}.light-mode .t-doc__sidebar,.dark-mode .t-doc__sidebar{--default-sidebar-background-1: transparent;--default-sidebar-color-1: var(--default-theme-color-1);--default-sidebar-color-2: var(--default-theme-color-2);--default-sidebar-border-color: var(--default-theme-border-color);--default-sidebar-item-hover-background: var(--default-theme-background-2);--default-sidebar-item-hover-color: currentColor;--default-sidebar-item-active-background: var(--default-theme-background-3);--default-sidebar-color-active: var(--default-theme-color-accent);--default-sidebar-search-background: rgba(255, 255, 255, .1);--default-sidebar-search-border-color: var(--default-theme-border-color);--default-sidebar-search-color: var(--default-theme-color-3);z-index:1}.light-mode .t-doc__sidebar{--default-sidebar-search-background: white}.light-mode{--default-theme-color-green: #069061;--default-theme-color-red: #ef0006;--default-theme-color-yellow: #edbe20;--default-theme-color-blue: #0082d0;--default-theme-color-orange: #fb892c;--default-theme-color-purple: #5203d1}.dark-mode{--default-theme-color-green: rgba(69, 255, 165, .823);--default-theme-color-red: #ff8589;--default-theme-color-yellow: #ffcc4d;--default-theme-color-blue: #6bc1fe;--default-theme-color-orange: #f98943;--default-theme-color-purple: #b191f9}.show-api-client-button:before{background:#fff!important}.show-api-client-button span,.show-api-client-button svg{color:#000!important}.download-cta,.references-rendered .markdown a{text-decoration:underline!important}@keyframes headerbackground{0%{background:transparent;-webkit-backdrop-filter:none;backdrop-filter:none}to{background:var(--header-background-1);-webkit-backdrop-filter:blur(12px);backdrop-filter:blur(12px)}}.dark-mode h2.t-editor__heading,.dark-mode .t-editor__page-title h1,.dark-mode h1.section-header,.dark-mode .markdown h1,.dark-mode .markdown h2,.dark-mode .markdown h3,.dark-mode .markdown h4,.dark-mode .markdown h5,.dark-mode .markdown h6{-webkit-text-fill-color:transparent;background-image:linear-gradient(to right bottom,#fff 30%,#ffffff61);-webkit-background-clip:text;background-clip:text}.code-languages-background{background:var(--default-theme-background-1)!important}.code-languages-background:before{box-shadow:inset 0 0 0 2px var(--default-theme-border-color);background:linear-gradient(to right top,#d3e1f91f,#d1dff71c,#dfe9fb4a)!important}.light-mode .code-languages-background:before{background:linear-gradient(to right top,#00000014,#00000012,#00000030)!important}.code-languages__active .code-languages-background:before{background:var(--default-theme-background-1)!important}.sidebar-heading-type{color:var(--default-theme-background-1)!important}.active_page .sidebar-heading-type{color:var(--default-sidebar-color-1)!important}.sidebar-heading-type:after{content:"";position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(9deg,var(--default-theme-background-1),transparent);border-radius:30px;opacity:.3}.code-languages span{margin-top:5px!important}.section-flare-item:nth-of-type(1){--c1: #ffffff;--c2: #babfd8;--c3: #2e8bb2;--c4: #1a8593;--c5: #0a143e;--c6: #0a0f52;--c7: #2341b8;--solid: var(--c1), var(--c2), var(--c3), var(--c4), var(--c5), var(--c6), var(--c7);--solid-wrap: var(--solid), var(--c1);--trans: var(--c1), transparent, var(--c2), transparent, var(--c3), transparent, var(--c4), transparent, var(--c5), transparent, var(--c6), transparent, var(--c7);--trans-wrap: var(--trans), transparent, var(--c1);background:radial-gradient(circle,var(--trans)),conic-gradient(from 180deg,var(--trans-wrap)),radial-gradient(circle,var(--trans)),conic-gradient(var(--solid-wrap));width:70vw;height:700px;border-radius:50%;filter:blur(100px);z-index:0;right:0;position:absolute;transform:rotate(-45deg);top:-300px;opacity:.3}.section-flare-item:nth-of-type(3){--star-color: #6b9acc;--star-color2: #446b8d;--star-color3: #3e5879;background-image:radial-gradient(2px 2px at 20px 30px,var(--star-color2),rgba(0,0,0,0)),radial-gradient(2px 2px at 40px 70px,var(--star-color),rgba(0,0,0,0)),radial-gradient(2px 2px at 50px 160px,var(--star-color3),rgba(0,0,0,0)),radial-gradient(2px 2px at 90px 40px,var(--star-color),rgba(0,0,0,0)),radial-gradient(2px 2px at 130px 80px,var(--star-color),rgba(0,0,0,0)),radial-gradient(2px 2px at 160px 120px,var(--star-color3),rgba(0,0,0,0));background-repeat:repeat;background-size:200px 200px;width:100%;height:100%;-webkit-mask-image:radial-gradient(ellipse at 100% 0%,black 40%,transparent 70%);mask-image:radial-gradient(ellipse at 100% 0%,black 40%,transparent 70%)}.section-flare{top:-150px!important;height:100vh;background:linear-gradient(#000,var(--default-theme-background-1));width:100vw}.light-mode .section-flare{display:none}.light-mode .scalar-card{--default-theme-background-1: #fff;--default-theme-background-2: #fff;--default-theme-background-3: #fff}', W3 = '.light-mode{--default-theme-color-1: rgb(9, 9, 11);--default-theme-color-2: rgb(113, 113, 122);--default-theme-color-3: rgba(25, 25, 28, .5);--default-theme-color-accent: var(--default-theme-color-1);--default-theme-background-1: #fff;--default-theme-background-2: #f4f4f5;--default-theme-background-3: #e3e3e6;--default-theme-background-accent: #8ab4f81f;--default-theme-border-color: rgb(228, 228, 231);--default-theme-code-language-color-supersede: var(--default-theme-color-1)}.dark-mode{--default-theme-color-1: #fafafa;--default-theme-color-2: rgb(161, 161, 170);--default-theme-color-3: rgba(255, 255, 255, .533);--default-theme-color-accent: var(--default-theme-color-1);--default-theme-background-1: #09090b;--default-theme-background-2: #18181b;--default-theme-background-3: #2c2c30;--default-theme-background-accent: #8ab4f81f;--default-theme-border-color: rgba(255, 255, 255, .12);--default-theme-code-language-color-supersede: var(--default-theme-color-1)}.light-mode .t-doc__sidebar,.dark-mode .t-doc__sidebar{--sidebar-background-1: var(--default-theme-background-1);--sidebar-item-hover-color: currentColor;--sidebar-item-hover-background: var(--default-theme-background-2);--sidebar-item-active-background: var(--default-theme-background-3);--sidebar-border-color: var(--default-theme-border-color);--sidebar-color-1: var(--default-theme-color-1);--sidebar-color-2: var(--default-theme-color-2);--sidebar-color-active: var(--default-theme-color-accent);--sidebar-search-background: transparent;--sidebar-search-border-color: var(--default-theme-border-color);--sidebar-search-color: var(--default-theme-color-3)}.light-mode .t-doc__sidebar{--sidebar-item-active-background: #09090b;--sidebar-color-active: var(--sidebar-background-1)}.light-mode{--default-theme-button-1: rgb(49 53 56);--default-theme-button-1-color: #fff;--default-theme-button-1-hover: rgb(28 31 33);--default-theme-color-green: #069061;--default-theme-color-red: #ef0006;--default-theme-color-yellow: #edbe20;--default-theme-color-blue: #0082d0;--default-theme-color-orange: #fb892c;--default-theme-color-purple: #5203d1;--default-theme-scrollbar-color: rgba(0, 0, 0, .18);--default-theme-scrollbar-color-active: rgba(0, 0, 0, .36)}.dark-mode{--default-theme-button-1: #f6f6f6;--default-theme-button-1-color: #000;--default-theme-button-1-hover: #e7e7e7;--default-theme-color-green: rgba(69, 255, 165, .823);--default-theme-color-red: #ff8589;--default-theme-color-yellow: #ffcc4d;--default-theme-color-blue: #6bc1fe;--default-theme-color-orange: #f98943;--default-theme-color-purple: #b191f9;--default-theme-scrollbar-color: rgba(255, 255, 255, .24);--default-theme-scrollbar-color-active: rgba(255, 255, 255, .48)}.dark-mode h2.t-editor__heading,.dark-mode .t-editor__page-title h1,.dark-mode h1.section-header,.dark-mode .markdown h1,.dark-mode .markdown h2,.dark-mode .markdown h3,.dark-mode .markdown h4,.dark-mode .markdown h5,.dark-mode .markdown h6{-webkit-text-fill-color:transparent;background-image:linear-gradient(to right bottom,#fff 30%,#ffffff61);-webkit-background-clip:text;background-clip:text}.examples .scalar-card-footer{--default-theme-background-3: transparent;padding-top:0}.show-api-client-button:before{background:#fff!important}.show-api-client-button span,.show-api-client-button svg{color:#000!important}.download-cta,.references-rendered .markdown a{text-decoration:underline!important}.code-languages-background{background:var(--default-theme-background-1)!important}.code-languages-background:before{box-shadow:inset 0 0 0 2px var(--default-theme-border-color);background:linear-gradient(to right top,#d3e1f91f,#d1dff71c,#dfe9fb4a)!important}.light-mode .code-languages-background:before{background:linear-gradient(to right top,#00000014,#00000012,#00000030)!important}.code-languages__active .code-languages-background:before{background:var(--default-theme-background-1)!important}.sidebar-heading-type:after{content:"";position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(9deg,var(--default-theme-background-1),transparent);border-radius:30px;opacity:.3}.code-languages span{margin-top:5px!important}.section-flare{width:100vw;height:550px;position:relative}.section-flare-item:nth-of-type(1){position:absolute;width:100vw;height:550px;--stripesDark: repeating-linear-gradient( 100deg, #000 0%, #000 7%, transparent 10%, transparent 12%, #000 16% );--rainbow: repeating-linear-gradient( 100deg, #fff 10%, #fff 16%, #fff 22%, #fff 30% );background-image:var(--stripesDark),var(--rainbow);background-size:300%,200%;background-position:50% 50%,50% 50%;filter:invert(100%);-webkit-mask-image:radial-gradient(ellipse at 100% 0%,black 40%,transparent 70%);mask-image:radial-gradient(ellipse at 100% 0%,black 40%,transparent 70%);pointer-events:none;opacity:.07}.dark-mode .section-flare-item:nth-of-type(1){background-image:var(--stripesDark),var(--rainbow);filter:opacity(50%) saturate(200%);opacity:.25;height:350px}.section-flare-item:nth-of-type(1):after{content:"";position:absolute;top:0;right:0;bottom:0;left:0;background-image:var(--stripesDark),var(--rainbow);background-size:200%,100%;background-attachment:fixed;mix-blend-mode:difference}.dark-mode .section-flare:after{background-image:var(--stripesDark),var(--rainbow)}.section-flare-item:nth-of-type(2){--star-color: #fff;--star-color2: #fff;--star-color3: #fff;width:100%;height:100%;position:absolute;background-image:radial-gradient(2px 2px at 20px 30px,var(--star-color2),rgba(0,0,0,0)),radial-gradient(2px 2px at 40px 70px,var(--star-color),rgba(0,0,0,0)),radial-gradient(2px 2px at 50px 160px,var(--star-color3),rgba(0,0,0,0)),radial-gradient(2px 2px at 90px 40px,var(--star-color),rgba(0,0,0,0)),radial-gradient(2px 2px at 130px 80px,var(--star-color),rgba(0,0,0,0)),radial-gradient(2px 2px at 160px 120px,var(--star-color3),rgba(0,0,0,0));background-repeat:repeat;background-size:200px 200px;-webkit-mask-image:radial-gradient(ellipse at 100% 0%,black 40%,transparent 70%);mask-image:radial-gradient(ellipse at 100% 0%,black 40%,transparent 70%);opacity:.2}', nv = ".light-mode{--default-theme-background-1: #fff;--default-theme-background-2: #f6f6f6;--default-theme-background-3: #e7e7e7;--default-theme-background-accent: #8ab4f81f;--default-theme-color-1: #2a2f45;--default-theme-color-2: #757575;--default-theme-color-3: #8e8e8e;--default-theme-color-accent: #0099ff;--default-theme-border-color: rgba(0, 0, 0, .1)}.dark-mode{--default-theme-background-1: #0f0f0f;--default-theme-background-2: #1a1a1a;--default-theme-background-3: #272727;--default-theme-color-1: rgba(255, 255, 255, .9);--default-theme-color-2: rgba(255, 255, 255, .62);--default-theme-color-3: rgba(255, 255, 255, .44);--default-theme-color-accent: #3ea6ff;--default-theme-background-accent: #3ea6ff1f;--default-theme-border-color: rgba(255, 255, 255, .1)}.light-mode .t-doc__sidebar,.dark-mode .t-doc__sidebar{--default-sidebar-background-1: var(--default-theme-background-1);--default-sidebar-color-1: var(--default-theme-color-1);--default-sidebar-color-2: var(--default-theme-color-2);--default-sidebar-border-color: var(--default-theme-border-color);--default-sidebar-item-hover-background: var(--default-theme-background-3);--default-sidebar-item-hover-color: currentColor;--default-sidebar-item-active-background: var( --default-theme-background-accent );--default-sidebar-color-active: var(--default-theme-color-accent);--default-sidebar-search-background: transparent;--default-sidebar-search-color: var(--default-theme-color-3);--default-sidebar-search-border-color: var(--default-theme-border-color)}.light-mode{--default-theme-color-green: #069061;--default-theme-color-red: #ef0006;--default-theme-color-yellow: #edbe20;--default-theme-color-blue: #0082d0;--default-theme-color-orange: #fb892c;--default-theme-color-purple: #5203d1}.dark-mode{--default-theme-color-green: #00b648;--default-theme-color-red: #dc1b19;--default-theme-color-yellow: #ffc90d;--default-theme-color-blue: #4eb3ec;--default-theme-color-orange: #ff8d4d;--default-theme-color-purple: #b191f9}", U3 = '.light-mode{--default-theme-color-1: #2a2f45;--default-theme-color-2: #757575;--default-theme-color-3: #8e8e8e;--default-theme-color-accent: #7070ff;--default-theme-background-1: #fff;--default-theme-background-2: #f6f6f6;--default-theme-background-3: #e7e7e7;--default-theme-background-accent: #7070ff1f;--default-theme-border-color: rgba(0, 0, 0, .1);--default-theme-code-language-color-supersede: var(--default-theme-color-3)}.dark-mode{--default-theme-color-1: #f7f8f8;--default-theme-color-2: rgb(180, 188, 208);--default-theme-color-3: #b4bcd099;--default-theme-color-accent: #828fff;--default-theme-background-1: #000212;--default-theme-background-2: rgba(255, 255, 255, .05);--default-theme-background-3: rgba(255, 255, 255, .05);--default-theme-background-accent: #8ab4f81f;--default-theme-border-color: #242537;--default-theme-code-language-color-supersede: var(--default-theme-color-3)}.light-mode .t-doc__sidebar{--default-sidebar-background-1: var(--default-theme-background-1);--default-sidebar-item-hover-color: currentColor;--default-sidebar-item-hover-background: var(--default-theme-background-2);--default-sidebar-item-active-background: var( --default-theme-background-accent );--default-sidebar-border-color: var(--default-theme-border-color);--default-sidebar-color-1: var(--default-theme-color-1);--default-sidebar-color-2: var(--default-theme-color-2);--default-sidebar-color-active: var(--default-theme-color-accent);--default-sidebar-search-background: rgba(0, 0, 0, .05);--default-sidebar-search-border-color: 1px solid rgba(0, 0, 0, .05);--default-sidebar-search-color: var(--default-theme-color-3);--default-theme-background-2: rgba(0, 0, 0, .03)}.dark-mode .t-doc__sidebar{--default-sidebar-background-1: var(--default-theme-background-1);--default-sidebar-item-hover-color: currentColor;--default-sidebar-item-hover-background: var(--default-theme-background-2);--default-sidebar-item-active-background: rgba(255, 255, 255, .1);--default-sidebar-border-color: var(--default-theme-border-color);--default-sidebar-color-1: var(--default-theme-color-1);--default-sidebar-color-2: var(--default-theme-color-2);--default-sidebar-color-active: var(--default-theme-color-accent);--default-sidebar-search-background: rgba(255, 255, 255, .1);--default-sidebar-search-border-color: 1px solid rgba(255, 255, 255, .05);--default-sidebar-search-color: var(--default-theme-color-3)}.light-mode{--default-theme-button-1: rgb(49 53 56);--default-theme-button-1-color: #fff;--default-theme-button-1-hover: rgb(28 31 33);--default-theme-color-green: #069061;--default-theme-color-red: #ef0006;--default-theme-color-yellow: #edbe20;--default-theme-color-blue: #0082d0;--default-theme-color-orange: #fb892c;--default-theme-color-purple: #5203d1;--default-theme-scrollbar-color: rgba(0, 0, 0, .18);--default-theme-scrollbar-color-active: rgba(0, 0, 0, .36)}.dark-mode{--default-theme-button-1: #f6f6f6;--default-theme-button-1-color: #000;--default-theme-button-1-hover: #e7e7e7;--default-theme-color-green: #00b648;--default-theme-color-red: #dc1b19;--default-theme-color-yellow: #ffc90d;--default-theme-color-blue: #4eb3ec;--default-theme-color-orange: #ff8d4d;--default-theme-color-purple: #b191f9;--default-theme-scrollbar-color: rgba(255, 255, 255, .24);--default-theme-scrollbar-color-active: rgba(255, 255, 255, .48)}.dark-mode h2.t-editor__heading,.dark-mode .t-editor__page-title h1,.dark-mode h1.section-header,.dark-mode .markdown h1,.dark-mode .markdown h2,.dark-mode .markdown h3,.dark-mode .markdown h4,.dark-mode .markdown h5,.dark-mode .markdown h6{-webkit-text-fill-color:transparent;background-image:linear-gradient(to right bottom,#fff 30%,#ffffff61);-webkit-background-clip:text;background-clip:text}.sidebar-search{-webkit-backdrop-filter:blur(12px);backdrop-filter:blur(12px)}@keyframes headerbackground{0%{background:transparent;-webkit-backdrop-filter:none;backdrop-filter:none}to{background:var(--header-background-1);-webkit-backdrop-filter:blur(12px);backdrop-filter:blur(12px)}}.dark-mode .scalar-card{background:#ffffff0d!important}.dark-mode .scalar-card *{--default-theme-background-2: transparent !important;--default-theme-background-1: transparent !important}.light-mode .dark-mode.scalar-card *,.light-mode .dark-mode.scalar-card{--default-theme-background-1: #0d0f1e !important;--default-theme-background-2: #0d0f1e !important;--default-theme-background-3: #191b29 !important}.light-mode .dark-mode.scalar-card{background:#191b29!important}.sidebar-heading-type:before{z-index:10;position:relative}.sidebar-heading-type:after{content:"";position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(9deg,var(--default-theme-background-1),transparent);border-radius:30px;opacity:.3}.show-api-client-button:before{background-color:var(--default-theme-color-accent)!important}.badge{box-shadow:0 0 0 1px var(--default-theme-border-color);margin-right:6px}.table-row.required-parameter .table-row-item:nth-of-type(2):after{background:transparent;box-shadow:none}.code-languages__active{--default-theme-code-language-color-supersede: var(--default-theme-color-1)}.code-languages-background{background:linear-gradient(#fff0,#ffffff0d)!important;box-shadow:inset 0 0 0 1px var(--default-theme-border-color)!important}.section-flare{width:100vw;background:radial-gradient(ellipse 80% 50% at 50% -20%,rgba(120,119,198,.3),transparent);height:100%}', V3 = '.light-mode{--default-theme-background-1: #f9f6f0;--default-theme-background-2: #f2efe8;--default-theme-background-3: #e9e7e2;--default-theme-border-color: rgba(203, 165, 156, .6);--default-theme-color-1: #c75549;--default-theme-color-2: #c75549;--default-theme-color-3: #c75549;--default-theme-color-accent: #c75549;--default-theme-background-accent: #dcbfa81f;--default-theme-code-language-color-supersede: var(--default-theme-color-1)}.dark-mode{--default-theme-background-1: #140507;--default-theme-background-2: #20090c;--default-theme-background-3: #321116;--default-theme-border-color: rgba(255, 255, 255, .1);--default-theme-color-1: rgba(255, 255, 255, .9);--default-theme-color-2: rgba(255, 255, 255, .62);--default-theme-color-3: rgba(255, 255, 255, .44);--default-theme-color-accent: rgba(255, 255, 255, .9);--default-theme-background-accent: #441313;--default-theme-code-language-color-supersede: var(--default-theme-color-1)}.light-mode .t-doc__sidebar,.dark-mode .t-doc__sidebar{--default-sidebar-background-1: transparent;--default-sidebar-color-1: var(--default-theme-color-1);--default-sidebar-color-2: var(--default-theme-color-2);--default-sidebar-border-color: var(--default-theme-border-color);--default-sidebar-item-hover-color: currentColor;--default-sidebar-item-hover-background: var(--default-theme-background-2);--default-sidebar-item-active-background: var(--default-theme-background-3);--default-sidebar-color-active: var(--default-theme-color-accent);--default-sidebar-search-background: rgba(255, 255, 255, .1);--default-sidebar-search-color: var(--default-theme-color-3);--default-sidebar-search-border-color: var(--default-theme-border-color);z-index:1}.light-mode{--default-theme-color-green: #09533a;--default-theme-color-red: #aa181d;--default-theme-color-yellow: #ab8d2b;--default-theme-color-blue: #19689a;--default-theme-color-orange: #b26c34;--default-theme-color-purple: #4c2191}.dark-mode{--default-theme-color-green: rgba(69, 255, 165, .823);--default-theme-color-red: #ff8589;--default-theme-color-yellow: #ffcc4d;--default-theme-color-blue: #6bc1fe;--default-theme-color-orange: #f98943;--default-theme-color-purple: #b191f9}.dark-mode h2.t-editor__heading,.dark-mode .t-editor__page-title h1,.dark-mode h1.section-header,.dark-mode .markdown h1,.dark-mode .markdown h2,.dark-mode .markdown h3,.dark-mode .markdown h4,.dark-mode .markdown h5,.dark-mode .markdown h6{-webkit-text-fill-color:transparent;background-image:linear-gradient(to right bottom,#fff 30%,#ffffff61);-webkit-background-clip:text;background-clip:text}.light-mode .t-doc__sidebar{--default-sidebar-search-background: white}.examples .scalar-card-footer{--default-theme-background-3: transparent;padding-top:0}.show-api-client-button:before{background:#fff!important}.show-api-client-button span,.show-api-client-button svg{color:#000!important}.code-languages-background{background:var(--default-theme-background-1)!important}.code-languages-background:before{box-shadow:inset 0 0 0 2px var(--default-theme-border-color);background:linear-gradient(to right top,#d3e1f91f,#d1dff71c,#dfe9fb4a)!important}.light-mode .code-languages-background:before{background:linear-gradient(to right top,#00000014,#00000012,#00000030)!important}.code-languages__active .code-languages-background:before{background:var(--default-theme-background-1)!important}.sidebar-heading-type{color:var(--default-theme-background-1)!important}.active_page .sidebar-heading-type{color:var(--default-sidebar-color-active)!important}.sidebar-heading-type:after{content:"";position:absolute;top:0;left:0;width:100%;height:100%;background:linear-gradient(9deg,var(--default-theme-background-1),transparent);border-radius:30px;opacity:.3}.code-languages span{margin-top:5px!important}.section-flare-item:nth-of-type(1){background:#d25019;width:80vw;height:500px;margin-top:-150px;border-radius:50%;filter:blur(100px);z-index:0}.light-mode .section-flare{display:none}.section-flare{top:-150px!important;height:100vh;right:-400px!important;left:initial}.download-cta a,.section .markdown a{text-decoration:underline!important}', L3 = ".light-mode{color-scheme:light;--default-theme-color-1: #000000;--default-theme-color-2: #000000;--default-theme-color-3: #000000;--default-theme-color-accent: #645b0f;--default-theme-background-1: #ccc9b3;--default-theme-background-2: #c2bfaa;--default-theme-background-3: #b8b5a1;--default-theme-background-accent: #000000;--default-theme-border-color: rgba(0, 0, 0, .2);--default-theme-scrollbar-color: rgba(0, 0, 0, .18);--default-theme-scrollbar-color-active: rgba(0, 0, 0, .36);--default-theme-lifted-brightness: 1;--default-theme-backdrop-brightness: 1;--default-theme-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, .11);--default-theme-shadow-2: rgba(0, 0, 0, .08) 0px 13px 20px 0px, rgba(0, 0, 0, .08) 0px 3px 8px 0px, var(--default-theme-border-color) 0px 0 0 1px;--default-theme-button-1: rgb(49 53 56);--default-theme-button-1-color: #fff;--default-theme-button-1-hover: rgb(28 31 33);--default-theme-color-red: #b91c1c;--default-theme-color-orange: #a16207;--default-theme-color-green: #047857;--default-theme-color-blue: #1d4ed8;--default-theme-color-orange: #c2410c;--default-theme-color-purple: #6d28d9;--default-theme-code-languages-background-supersede: var( --default-theme-background-3 );--default-theme-code-language-color-supersede: var(--default-theme-color-1)}.dark-mode{color-scheme:dark;--default-theme-color-1: #fffef3;--default-theme-color-2: #fffef3;--default-theme-color-3: #fffef3;--default-theme-color-accent: #c3b531;--default-theme-background-1: #313332;--default-theme-background-2: #393b3a;--default-theme-background-3: #414342;--default-theme-background-accent: #fffef3;--default-theme-border-color: rgba(255, 255, 255, .1);--default-theme-scrollbar-color: rgba(255, 255, 255, .24);--default-theme-scrollbar-color-active: rgba(255, 255, 255, .48);--default-theme-lifted-brightness: 1.45;--default-theme-backdrop-brightness: .5;--default-theme-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, .11);--default-theme-shadow-2: rgba(15, 15, 15, .2) 0px 3px 6px, rgba(15, 15, 15, .4) 0px 9px 24px, 0 0 0 1px rgba(255, 255, 255, .1);--default-theme-button-1: #f6f6f6;--default-theme-button-1-color: #000;--default-theme-button-1-hover: #e7e7e7;--default-theme-color-green: #00b648;--default-theme-color-red: #dc1b19;--default-theme-color-yellow: #ffc90d;--default-theme-color-blue: #4eb3ec;--default-theme-color-orange: #ff8d4d;--default-theme-color-purple: #b191f9;--default-theme-code-languages-background-supersede: var( --default-theme-background-3 );--default-theme-code-language-color-supersede: var(--default-theme-color-1)}.light-mode .t-doc__sidebar,.dark-mode .sidebar{--default-sidebar-background-1: var(--default-theme-background-1);--default-sidebar-item-hover-color: currentColor;--default-sidebar-item-hover-background: var(--default-theme-background-2);--default-sidebar-item-active-background: var( --default-theme-background-accent );--default-sidebar-border-color: var(--default-theme-border-color);--default-sidebar-color-1: var(--default-theme-color-1);--default-sidebar-color-2: var(--default-theme-color-2);--default-sidebar-color-active: var(--default-sidebar-background-1);--default-sidebar-search-background: var(--default-theme-background-3);--default-sidebar-search-border-color: var( --default-sidebar-search-background );--default-sidebar-search--color: var(--default-theme-color-3)}", Y3 = ".light-mode{--default-theme-background-1: #fff;--default-theme-background-2: #f5f6f8;--default-theme-background-3: #eceef1;--default-theme-color-1: #2a2f45;--default-theme-color-2: #757575;--default-theme-color-3: #8e8e8e;--default-theme-color-accent: #5469d4;--default-theme-background-accent: #5469d41f;--default-theme-border-color: rgba(215, 215, 206, .5)}.dark-mode{--default-theme-background-1: #15171c;--default-theme-background-2: #1c1e24;--default-theme-background-3: #22252b;--default-theme-color-1: #fafafa;--default-theme-color-2: #c9ced8;--default-theme-color-3: #8c99ad;--default-theme-color-accent: #5469d4;--default-theme-background-accent: #5469d41f;--default-theme-border-color: rgba(255, 255, 255, .12)}.light-mode .t-doc__sidebar,.dark-mode .t-doc__sidebar{--sidebar-background-1: var(--default-theme-background-1);--sidebar-color-1: var(--default-theme-color-1);--sidebar-color-2: var(--default-theme-color-2);--sidebar-border-color: var(--default-theme-border-color);--sidebar-item-hover-color: currentColor;--sidebar-item-hover-background: var(--default-theme-background-3);--sidebar-item-active-background: var(--default-theme-background-accent);--sidebar-color-active: var(--default-theme-color-accent);--sidebar-search-background: var(--default-theme-background-1);--sidebar-search-color: var(--default-theme-color-3);--sidebar-search-border-color: var(--default-theme-border-color)}.light-mode{--default-theme-color-green: #17803d;--default-theme-color-red: #e10909;--default-theme-color-yellow: #edbe20;--default-theme-color-blue: #1763a6;--default-theme-color-orange: #e25b09;--default-theme-color-purple: #5c3993}.dark-mode{--default-theme-color-green: #30a159;--default-theme-color-red: #dc1b19;--default-theme-color-yellow: #eec644;--default-theme-color-blue: #2b7abf;--default-theme-color-orange: #f07528;--default-theme-color-purple: #7a59b1}", B3 = ".light-mode{--default-theme-background-1: #f3f3ee;--default-theme-background-2: #e8e8e3;--default-theme-background-3: #e4e4df;--default-theme-border-color: rgba(215, 215, 206, .5);--default-theme-color-1: #2a2f45;--default-theme-color-2: #757575;--default-theme-color-3: #8e8e8e;--default-theme-color-accent: #1763a6;--default-theme-background-accent: #1f648e1f;--default-theme-code-language-color-supersede: var(--default-theme-color-1);--default-theme-code-languages-background-supersede: var( --default-theme-background-2 )}.dark-mode{--default-theme-background-1: #09090b;--default-theme-background-2: #18181b;--default-theme-background-3: #2c2c30;--default-theme-border-color: rgba(255, 255, 255, .12);--default-theme-color-1: #fafafa;--default-theme-color-2: rgb(161, 161, 170);--default-theme-color-3: rgba(255, 255, 255, .533);--default-theme-color-accent: #4eb3ec;--default-theme-background-accent: #8ab4f81f;--default-theme-code-language-color-supersede: var(--default-theme-color-1);--default-theme-code-languages-background-supersede: var( --default-theme-background-2 )}.light-mode .t-doc__sidebar,.dark-mode .t-doc__sidebar{--default-sidebar-background-1: var(--default-theme-background-1);--default-sidebar-color-1: var(--default-theme-color-1);--default-sidebar-color-2: var(--default-theme-color-2);--default-sidebar-border-color: var(--default-theme-border-color);--default-sidebar-item-hover-background: var(--default-theme-background-3);--default-sidebar-item-hover-color: currentColor;--default-sidebar-item-active-background: var(--default-theme-background-3);--default-sidebar-color-active: var(--default-theme-color-1);--default-sidebar-search-background: var(--default-theme-background-1);--default-sidebar-search-border-color: var(--default-theme-border-color);--default-sidebar-search-color: var(--default-theme-color-3)}.light-mode{--default-theme-color-green: #17803d;--default-theme-color-red: #e10909;--default-theme-color-yellow: #edbe20;--default-theme-color-blue: #1763a6;--default-theme-color-orange: #e25b09;--default-theme-color-purple: #5c3993}.dark-mode{--default-theme-color-green: #30a159;--default-theme-color-red: #dc1b19;--default-theme-color-yellow: #eec644;--default-theme-color-blue: #2b7abf;--default-theme-color-orange: #f07528;--default-theme-color-purple: #7a59b1}.dark-mode h2.t-editor__heading,.dark-mode .t-editor__page-title h1,.dark-mode h1.section-header,.dark-mode .markdown h1,.dark-mode .markdown h2,.dark-mode .markdown h3,.dark-mode .markdown h4,.dark-mode .markdown h5,.dark-mode .markdown h6{-webkit-text-fill-color:transparent;background-image:linear-gradient(to right bottom,#fff 30%,#ffffff61);-webkit-background-clip:text;background-clip:text}", F3 = ".light-mode{color-scheme:light;--default-theme-color-1: #584c27;--default-theme-color-2: #616161;--default-theme-color-3: #a89f84;--default-theme-color-accent: #b58900;--default-theme-background-1: #fdf6e3;--default-theme-background-2: #eee8d5;--default-theme-background-3: #ddd6c1;--default-theme-background-accent: #b589001f;--default-theme-border-color: #ded8c8;--default-theme-scrollbar-color: rgba(0, 0, 0, .18);--default-theme-scrollbar-color-active: rgba(0, 0, 0, .36);--default-theme-lifted-brightness: 1;--default-theme-backdrop-brightness: 1;--default-theme-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, .11);--default-theme-shadow-2: rgba(0, 0, 0, .08) 0px 13px 20px 0px, rgba(0, 0, 0, .08) 0px 3px 8px 0px, #eeeeed 0px 0 0 1px;--default-theme-button-1: rgb(49 53 56);--default-theme-button-1-color: #fff;--default-theme-button-1-hover: rgb(28 31 33);--default-theme-color-red: #b91c1c;--default-theme-color-orange: #a16207;--default-theme-color-green: #047857;--default-theme-color-blue: #1d4ed8;--default-theme-color-orange: #c2410c;--default-theme-color-purple: #6d28d9}.dark-mode{color-scheme:dark;--default-theme-color-1: #fff;--default-theme-color-2: #cccccc;--default-theme-color-3: #6d8890;--default-theme-color-accent: #007acc;--default-theme-background-1: #00212b;--default-theme-background-2: #012b36;--default-theme-background-3: #004052;--default-theme-background-accent: #015a6f;--default-theme-border-color: rgba(255, 255, 255, .1);--default-theme-scrollbar-color: rgba(255, 255, 255, .24);--default-theme-scrollbar-color-active: rgba(255, 255, 255, .48);--default-theme-lifted-brightness: 1.45;--default-theme-backdrop-brightness: .5;--default-theme-shadow-1: 0 1px 3px 0 rgb(0, 0, 0, .1);--default-theme-shadow-2: rgba(15, 15, 15, .2) 0px 3px 6px, rgba(15, 15, 15, .4) 0px 9px 24px, 0 0 0 1px rgba(255, 255, 255, .1);--default-theme-button-1: #f6f6f6;--default-theme-button-1-color: #000;--default-theme-button-1-hover: #e7e7e7;--default-theme-color-green: #00b648;--default-theme-color-red: #dc1b19;--default-theme-color-yellow: #ffc90d;--default-theme-color-blue: #4eb3ec;--default-theme-color-orange: #ff8d4d;--default-theme-color-purple: #b191f9}.light-mode .t-doc__sidebar{--default-sidebar-background-1: var(--default-theme-background-1);--default-sidebar-item-hover-color: currentColor;--default-sidebar-item-hover-background: var(--default-theme-background-2);--default-sidebar-item-active-background: var( --default-theme-background-accent );--default-sidebar-border-color: var(--default-theme-border-color);--default-sidebar-color-1: var(--default-theme-color-1);--default-sidebar-color-2: var(--default-theme-color-2);--default-sidebar-color-active: var(--default-theme-color-accent);--default-sidebar-search-background: var(--default-theme-background-2);--default-sidebar-search-border-color: var(--sidebar-search-background);--default-sidebar-search--color: var(--default-theme-color-3)}.dark-mode .sidebar{--default-sidebar-background-1: var(--default-theme-background-1);--default-sidebar-item-hover-color: currentColor;--default-sidebar-item-hover-background: var(--default-theme-background-2);--default-sidebar-item-active-background: var( --default-theme-background-accent );--default-sidebar-border-color: var(--default-theme-border-color);--default-sidebar-color-1: var(--default-theme-color-1);--default-sidebar-color-2: var(--default-theme-color-2);--default-sidebar-color-active: var(--default-sidebar-color-1);--default-sidebar-search-background: var(--default-theme-background-2);--default-sidebar-search-border-color: var(--sidebar-search-background);--default-sidebar-search--color: var(--default-theme-color-3)}", iv = /* @__PURE__ */ G({
  __name: "ThemeStyles",
  props: {
    id: {}
  },
  setup(t) {
    return (e, r) => e.id !== "none" ? (k(), Y(Oi("style"), { key: 0 }, {
      default: I(() => [
        re(te(v(o_)(e.id)), 1)
      ]),
      _: 1
    })) : H("", !0);
  }
});
function sv(t, e) {
  Xn(() => {
    if (!document.body)
      return;
    const r = document.querySelector(t);
    r == null || r.classList.add(e);
  });
}
const H3 = /* @__PURE__ */ G({
  __name: "ResetStyles",
  setup(t) {
    const { reset: e } = Yb();
    return sv("#headlessui-portal-root", e), (r, n) => se(r.$slots, "default", { styles: v(e) });
  }
}), G3 = "_reset_78zw5_3", K3 = {
  reset: G3
}, ov = (t, e) => {
  const r = t.__vccOpts || t;
  for (const [n, i] of e)
    r[n] = i;
  return r;
}, J3 = {
  $style: K3
}, av = /* @__PURE__ */ ov(H3, [["__cssModules", J3]]), e_ = /* @__PURE__ */ G({
  __name: "ScrollbarStyles",
  setup(t) {
    const { scrollbars: e } = Yb();
    return sv("#headlessui-portal-root", e), (r, n) => se(r.$slots, "default", { styles: v(e) });
  }
}), t_ = "_scrollbars_1wuqs_3", r_ = {
  scrollbars: t_,
  "cm-scroller": "_cm-scroller_1wuqs_4",
  "custom-scroll": "_custom-scroll_1wuqs_5",
  "custom-scroll-self-contain-overflow": "_custom-scroll-self-contain-overflow_1wuqs_11"
}, n_ = {
  $style: r_
}, i_ = /* @__PURE__ */ ov(e_, [["__cssModules", n_]]), s_ = {
  alternate: z3,
  default: nv,
  moon: L3,
  purple: Y3,
  solarized: F3,
  bluePlanet: X3,
  deepSpace: W3,
  saturn: B3,
  kepler: U3,
  mars: V3
}, o_ = (t = "default") => t === "none" ? "" : s_[t] ?? nv;
function a_() {
  return {
    showApiClient: !1,
    activeApiClientEndpointId: "",
    activeItem: {},
    snippetType: "javascript"
  };
}
const si = vn(a_());
function l_(t, e = !1) {
  e ? si.showApiClient = !0 : si.showApiClient = !si.showApiClient, t && (si.activeItem = t);
}
function c_() {
  si.showApiClient = !1;
}
function u_(t) {
  si.activeApiClientEndpointId = t;
}
function d_(t) {
  si.snippetType = t;
}
const Gp = () => ({
  state: Yp(si),
  toggleApiClient: l_,
  setActiveApiClientEndpointId: u_,
  setSnippetType: d_,
  hideApiClient: c_
}), f_ = () => ({
  name: "",
  url: "",
  type: "GET",
  path: "",
  variables: [],
  headers: [],
  query: [],
  body: "",
  formData: []
}), h_ = () => ({
  type: "none",
  basic: {
    username: "",
    password: "",
    active: !0
  },
  oauthTwo: {
    generatedToken: "",
    discoveryURL: "",
    authURL: "",
    accessTokenURL: "",
    clientID: "",
    clientSecret: "",
    scope: "",
    active: !0
  },
  bearer: {
    token: "",
    active: !0
  },
  digest: {
    username: "",
    password: "",
    active: !0
  }
}), p_ = vn(h_()), Lu = vn({}), lv = ge([]), fo = ge(""), Kp = vn(f_()), m_ = (t) => {
  Lu[t.responseId] = t, fo.value = t.responseId, lv.value.unshift(t.responseId);
}, g_ = (t) => {
  fo.value = t;
  const { request: e } = Lu[t], r = JSON.parse(JSON.stringify(e));
  r.body = JSON.stringify(e.body, null, 2), Object.assign(Kp, r);
}, O_ = fe(
  () => fo.value ? Lu[fo.value].response : null
), y_ = (t) => {
  Object.assign(Kp, t);
}, b_ = () => {
  fo.value = "";
}, v_ = ge(!0), pr = () => ({
  authState: p_,
  readOnly: v_,
  activeRequest: Kp,
  activeResponse: O_,
  requestHistory: Lu,
  requestHistoryOrder: lv,
  activeRequestId: fo,
  setActiveResponse: g_,
  resetActiveResponse: b_,
  addRequestToHistory: m_,
  setActiveRequest: y_
}), w_ = [
  {
    name: "Accept",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept"
  },
  {
    name: "Accept-CH",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-CH"
  },
  {
    name: "Accept-CH-Lifetime",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-CH-Lifetime"
  },
  {
    name: "Accept-Charset",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Charset"
  },
  {
    name: "Accept-Encoding",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding"
  },
  {
    name: "Accept-Language",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language"
  },
  {
    name: "Accept-Patch",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Patch"
  },
  {
    name: "Accept-Post",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Post"
  },
  {
    name: "Accept-Ranges",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Ranges"
  },
  {
    name: "Access-Control-Allow-Credentials",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials"
  },
  {
    name: "Access-Control-Allow-Headers",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers"
  },
  {
    name: "Access-Control-Allow-Methods",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Methods"
  },
  {
    name: "Access-Control-Allow-Origin",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin"
  },
  {
    name: "Access-Control-Expose-Headers",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers"
  },
  {
    name: "Access-Control-Max-Age",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Max-Age"
  },
  {
    name: "Access-Control-Request-Headers",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Request-Headers"
  },
  {
    name: "Access-Control-Request-Method",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Request-Method"
  },
  {
    name: "Age",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Age"
  },
  {
    name: "Allow",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Allow"
  },
  {
    name: "Alt-Svc",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Alt-Svc"
  },
  {
    name: "Alt-Used",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Alt-Used"
  },
  {
    name: "Authorization",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization"
  },
  {
    name: "Cache-Control",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control"
  },
  {
    name: "Clear-Site-Data",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Clear-Site-Data"
  },
  {
    name: "Connection",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Connection"
  },
  {
    name: "Content-Disposition",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition"
  },
  {
    name: "Content-DPR",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-DPR"
  },
  {
    name: "Content-Encoding",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding"
  },
  {
    name: "Content-Language",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Language"
  },
  {
    name: "Content-Length",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Length"
  },
  {
    name: "Content-Location",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Location"
  },
  {
    name: "Content-Range",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Range"
  },
  {
    name: "Content-Security-Policy",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy"
  },
  {
    name: "Content-Security-Policy-Report-Only",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy-Report-Only"
  },
  {
    name: "Content-Type",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type"
  },
  {
    name: "Cookie",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cookie"
  },
  {
    name: "Critical-CH",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Critical-CH"
  },
  {
    name: "Cross-Origin-Embedder-Policy",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Embedder-Policy"
  },
  {
    name: "Cross-Origin-Opener-Policy",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Opener-Policy"
  },
  {
    name: "Cross-Origin-Resource-Policy",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Resource-Policy"
  },
  {
    name: "Date",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Date"
  },
  {
    name: "Device-Memory",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Device-Memory"
  },
  {
    name: "Digest",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Digest"
  },
  {
    name: "DNT",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/DNT"
  },
  {
    name: "Downlink",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Downlink"
  },
  {
    name: "DPR",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/DPR"
  },
  {
    name: "Early-Data",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Early-Data"
  },
  {
    name: "ECT",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ECT"
  },
  {
    name: "ETag",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag"
  },
  {
    name: "Expect",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expect"
  },
  {
    name: "Expect-CT",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expect-CT"
  },
  {
    name: "Expires",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires"
  },
  {
    name: "Forwarded",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Forwarded"
  },
  {
    name: "From",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/From"
  },
  {
    name: "Host",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Host"
  },
  {
    name: "If-Match",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Match"
  },
  {
    name: "If-Modified-Since",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since"
  },
  {
    name: "If-None-Match",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match"
  },
  {
    name: "If-Range",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Range"
  },
  {
    name: "If-Unmodified-Since",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Unmodified-Since"
  },
  {
    name: "Keep-Alive",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Keep-Alive"
  },
  {
    name: "Large-Allocation",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Large-Allocation"
  },
  {
    name: "Last-Modified",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Last-Modified"
  },
  {
    name: "Link",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Link"
  },
  {
    name: "Location",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Location"
  },
  {
    name: "Max-Forwards",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Max-Forwards"
  },
  {
    name: "NEL",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/NEL"
  },
  {
    name: "Origin",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin"
  },
  {
    name: "Permissions-Policy",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Permissions-Policy"
  },
  {
    name: "Pragma",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Pragma"
  },
  {
    name: "Proxy-Authenticate",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Proxy-Authenticate"
  },
  {
    name: "Proxy-Authorization",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Proxy-Authorization"
  },
  {
    name: "Range",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range"
  },
  {
    name: "Referer",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer"
  },
  {
    name: "Referrer-Policy",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy"
  },
  {
    name: "Retry-After",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After"
  },
  {
    name: "RTT",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/RTT"
  },
  {
    name: "Save-Data",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Save-Data"
  },
  {
    name: "Sec-CH-Prefers-Reduced-Motion",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-Prefers-Reduced-Motion"
  },
  {
    name: "Sec-CH-Prefers-Reduced-Transparency",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-Prefers-Reduced-Transparency"
  },
  {
    name: "Sec-CH-UA",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-UA"
  },
  {
    name: "Sec-CH-UA-Arch",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-UA-Arch"
  },
  {
    name: "Sec-CH-UA-Bitness",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-UA-Bitness"
  },
  {
    name: "Sec-CH-UA-Full-Version",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-UA-Full-Version"
  },
  {
    name: "Sec-CH-UA-Full-Version-List",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-UA-Full-Version-List"
  },
  {
    name: "Sec-CH-UA-Mobile",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-UA-Mobile"
  },
  {
    name: "Sec-CH-UA-Model",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-UA-Model"
  },
  {
    name: "Sec-CH-UA-Platform",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-UA-Platform"
  },
  {
    name: "Sec-CH-UA-Platform-Version",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-UA-Platform-Version"
  },
  {
    name: "Sec-Fetch-Dest",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Dest"
  },
  {
    name: "Sec-Fetch-Mode",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Mode"
  },
  {
    name: "Sec-Fetch-Site",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Site"
  },
  {
    name: "Sec-Fetch-User",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-User"
  },
  {
    name: "Sec-GPC",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-GPC"
  },
  {
    name: "Sec-Purpose",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Purpose"
  },
  {
    name: "Sec-WebSocket-Accept",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-WebSocket-Accept"
  },
  {
    name: "Server",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Server"
  },
  {
    name: "Server-Timing",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Server-Timing"
  },
  {
    name: "Service-Worker-Navigation-Preload",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Service-Worker-Navigation-Preload"
  },
  {
    name: "Set-Cookie",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie"
  },
  {
    name: "SourceMap",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/SourceMap"
  },
  {
    name: "Strict-Transport-Security",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security"
  },
  {
    name: "TE",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/TE"
  },
  {
    name: "Timing-Allow-Origin",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Timing-Allow-Origin"
  },
  {
    name: "Tk",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Tk"
  },
  {
    name: "Trailer",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Trailer"
  },
  {
    name: "Transfer-Encoding",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding"
  },
  {
    name: "Upgrade",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade"
  },
  {
    name: "Upgrade-Insecure-Requests",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade-Insecure-Requests"
  },
  {
    name: "User-Agent",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent"
  },
  {
    name: "Vary",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Vary"
  },
  {
    name: "Via",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Via"
  },
  {
    name: "Viewport-Width",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Viewport-Width"
  },
  {
    name: "Want-Digest",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Want-Digest"
  },
  {
    name: "Warning",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Warning"
  },
  {
    name: "Width",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Width"
  },
  {
    name: "WWW-Authenticate",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/WWW-Authenticate"
  },
  {
    name: "X-Content-Type-Options",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options"
  },
  {
    name: "X-DNS-Prefetch-Control",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-DNS-Prefetch-Control"
  },
  {
    name: "Non-standard",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Non-standard"
  },
  {
    name: "X-Forwarded-For",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For"
  },
  {
    name: "Non-standard",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Non-standard"
  },
  {
    name: "X-Forwarded-Host",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host"
  },
  {
    name: "Non-standard",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Non-standard"
  },
  {
    name: "X-Forwarded-Proto",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Proto"
  },
  {
    name: "Non-standard",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Non-standard"
  },
  {
    name: "X-Frame-Options",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options"
  },
  {
    name: "X-XSS-Protection",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection"
  },
  {
    name: "Cf-Cache-Status",
    url: "https://developers.cloudflare.com/cache/concepts/default-cache-behavior/#cloudflare-cache-responses"
  },
  {
    name: "Cf-Ray",
    url: "https://developers.cloudflare.com/fundamentals/get-started/reference/http-request-headers/#cf-ray"
  },
  {
    name: "Report-To",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/report-to"
  }
], $_ = [
  "GET",
  "POST",
  "PUT",
  "HEAD",
  "DELETE",
  "PATCH",
  "OPTIONS",
  "CONNECT",
  "TRACE"
];
function Kf(t) {
  return $_.includes(t);
}
const S_ = {
  POST: "var(--theme-color-green, var(--default-theme-color-green))",
  DELETE: "var(--theme-color-red, var(--default-theme-color-red))",
  PATCH: "var(--theme-color-yellow, var(--default-theme-color-yellow))",
  GET: "var(--theme-color-blue, var(--default-theme-color-blue))",
  PUT: "var(--theme-color-orange, var(--default-theme-color-orange))",
  OPTIONS: "var(--theme-color-purple, var(--default-theme-color-purple))",
  HEAD: "var(--theme-color-2, var(--default-theme-color-2))",
  CONNECT: "var(--theme-color-2, var(--default-theme-color-2))",
  TRACE: "var(--theme-color-2, var(--default-theme-color-2))"
}, k_ = {
  POST: "POST",
  DELETE: "DEL",
  PATCH: "PATCH",
  GET: "GET",
  PUT: "PUT",
  OPTIONS: "OPTS",
  HEAD: "HEAD",
  CONNECT: "CONN",
  TRACE: "TRACE"
}, __ = {
  100: {
    name: "Continue",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/100"
  },
  101: {
    name: "Switching Protocols",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/101"
  },
  102: {
    name: "Processing",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/102"
  },
  103: {
    name: "Early Hints",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/103"
  },
  200: {
    name: "OK",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/200"
  },
  201: {
    name: "Created",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/201"
  },
  202: {
    name: "Accepted",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/202"
  },
  203: {
    name: "Non-Authoritative Information",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/203"
  },
  204: {
    name: "No Content",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/204"
  },
  205: {
    name: "Reset Content",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/205"
  },
  206: {
    name: "Partial Content",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/206"
  },
  207: {
    name: "Multi-Status",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/207"
  },
  208: {
    name: "Already Reported",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/208"
  },
  226: {
    name: "IM Used",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/226"
  },
  300: {
    name: "Multiple Choices",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/300"
  },
  301: {
    name: "Moved Permanently",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/301"
  },
  302: {
    name: "Found",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/302"
  },
  303: {
    name: "See Other",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/303"
  },
  304: {
    name: "Not Modified",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/304"
  },
  305: {
    name: "Use Proxy",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/305"
  },
  306: {
    name: "(Unused)",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/306"
  },
  307: {
    name: "Temporary Redirect",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/307"
  },
  308: {
    name: "Permanent Redirect",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/308"
  },
  400: {
    name: "Bad Request",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/400"
  },
  401: {
    name: "Unauthorized",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401"
  },
  402: {
    name: "Payment Required",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/402"
  },
  403: {
    name: "Forbidden",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/403"
  },
  404: {
    name: "Not Found",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/404"
  },
  405: {
    name: "Method Not Allowed",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405"
  },
  406: {
    name: "Not Acceptable",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/406"
  },
  407: {
    name: "Proxy Authentication Required",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/407"
  },
  408: {
    name: "Request Timeout",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/408"
  },
  409: {
    name: "Conflict",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/409"
  },
  410: {
    name: "Gone",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/410"
  },
  411: {
    name: "Length Required",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/411"
  },
  412: {
    name: "Precondition Failed",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/412"
  },
  413: {
    name: "Content Too Large",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/413"
  },
  414: {
    name: "URI Too Long",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/414"
  },
  415: {
    name: "Unsupported Media Type",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/415"
  },
  416: {
    name: "Range Not Satisfiable",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/416"
  },
  417: {
    name: "Expectation Failed",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/417"
  },
  421: {
    name: "Misdirected Request",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/421"
  },
  422: {
    name: "Unprocessable Content",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/422"
  },
  423: {
    name: "Locked",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/423"
  },
  424: {
    name: "Failed Dependency",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/424"
  },
  425: {
    name: "Too Early",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/425"
  },
  426: {
    name: "Upgrade Required",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/426"
  },
  428: {
    name: "Precondition Required",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/428"
  },
  429: {
    name: "Too Many Requests",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429"
  },
  431: {
    name: "Request Header Fields Too Large",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431"
  },
  451: {
    name: "Unavailable For Legal Reasons",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/451"
  },
  500: {
    name: "Internal Server Error",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/500"
  },
  501: {
    name: "Not Implemented",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/501"
  },
  502: {
    name: "Bad Gateway",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/502"
  },
  503: {
    name: "Service Unavailable",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/503"
  },
  504: {
    name: "Gateway Timeout",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/504"
  },
  505: {
    name: "HTTP Version Not Supported",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/505"
  },
  506: {
    name: "Variant Also Negotiates",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/506"
  },
  507: {
    name: "Insufficient Storage",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/507"
  },
  508: {
    name: "Loop Detected",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/508"
  },
  510: {
    name: "Not Extended",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/510"
  },
  511: {
    name: "Network Authentication Required",
    url: "https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/511"
  }
}, xi = /* @__PURE__ */ G({
  __name: "HttpMethod",
  props: {
    as: {},
    property: {},
    short: { type: Boolean },
    method: {}
  },
  setup(t) {
    const e = t, r = fe(() => e.method.trim().toUpperCase()), n = fe(() => Kf(r.value) ? k_[r.value] : r.value.slice(0, 4)), i = fe(() => Kf(r.value) ? S_[r.value] : "var(--theme-color-ghost, var(--default-theme-color-ghost))");
    return (s, o) => (k(), Y(Oi(s.as ?? "span"), {
      style: Eo({ [s.property || "color"]: i.value })
    }, {
      default: I(() => [
        se(s.$slots, "default", Ir(jr({ normalized: r.value, abbreviated: n.value, color: i.value })), () => [
          re(te(s.short ? n.value : r.value), 1)
        ])
      ]),
      _: 3
    }, 8, ["style"]));
  }
});
class Xe {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, r, n) {
    [e, r] = ho(this, e, r);
    let i = [];
    return this.decompose(
      0,
      e,
      i,
      2
      /* Open.To */
    ), n.length && n.decompose(
      0,
      n.length,
      i,
      3
      /* Open.To */
    ), this.decompose(
      r,
      this.length,
      i,
      1
      /* Open.From */
    ), cn.from(i, this.length - (r - e) + n.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, r = this.length) {
    [e, r] = ho(this, e, r);
    let n = [];
    return this.decompose(e, r, n, 0), cn.from(n, r - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let r = this.scanIdentical(e, 1), n = this.length - this.scanIdentical(e, -1), i = new Qa(this), s = new Qa(e);
    for (let o = r, a = r; ; ) {
      if (i.next(o), s.next(o), o = 0, i.lineBreak != s.lineBreak || i.done != s.done || i.value != s.value)
        return !1;
      if (a += i.value.length, i.done || a >= n)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new Qa(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, r = this.length) {
    return new cv(this, e, r);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, r) {
    let n;
    if (e == null)
      n = this.iter();
    else {
      r == null && (r = this.lines + 1);
      let i = this.line(e).from;
      n = this.iterRange(i, Math.max(i, r == this.lines + 1 ? this.length : r <= 1 ? 0 : this.line(r - 1).to));
    }
    return new uv(n);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? Xe.empty : e.length <= 32 ? new ut(e) : cn.from(ut.split(e, []));
  }
}
class ut extends Xe {
  constructor(e, r = P_(e)) {
    super(), this.text = e, this.length = r;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, r, n, i) {
    for (let s = 0; ; s++) {
      let o = this.text[s], a = i + o.length;
      if ((r ? n : a) >= e)
        return new x_(i, a, n, o);
      i = a + 1, n++;
    }
  }
  decompose(e, r, n, i) {
    let s = e <= 0 && r >= this.length ? this : new ut(P0(this.text, e, r), Math.min(r, this.length) - Math.max(0, e));
    if (i & 1) {
      let o = n.pop(), a = Pc(s.text, o.text.slice(), 0, s.length);
      if (a.length <= 32)
        n.push(new ut(a, o.length + s.length));
      else {
        let l = a.length >> 1;
        n.push(new ut(a.slice(0, l)), new ut(a.slice(l)));
      }
    } else
      n.push(s);
  }
  replace(e, r, n) {
    if (!(n instanceof ut))
      return super.replace(e, r, n);
    [e, r] = ho(this, e, r);
    let i = Pc(this.text, Pc(n.text, P0(this.text, 0, e)), r), s = this.length + n.length - (r - e);
    return i.length <= 32 ? new ut(i, s) : cn.from(ut.split(i, []), s);
  }
  sliceString(e, r = this.length, n = `
`) {
    [e, r] = ho(this, e, r);
    let i = "";
    for (let s = 0, o = 0; s <= r && o < this.text.length; o++) {
      let a = this.text[o], l = s + a.length;
      s > e && o && (i += n), e < l && r > s && (i += a.slice(Math.max(0, e - s), r - s)), s = l + 1;
    }
    return i;
  }
  flatten(e) {
    for (let r of this.text)
      e.push(r);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, r) {
    let n = [], i = -1;
    for (let s of e)
      n.push(s), i += s.length + 1, n.length == 32 && (r.push(new ut(n, i)), n = [], i = -1);
    return i > -1 && r.push(new ut(n, i)), r;
  }
}
class cn extends Xe {
  constructor(e, r) {
    super(), this.children = e, this.length = r, this.lines = 0;
    for (let n of e)
      this.lines += n.lines;
  }
  lineInner(e, r, n, i) {
    for (let s = 0; ; s++) {
      let o = this.children[s], a = i + o.length, l = n + o.lines - 1;
      if ((r ? l : a) >= e)
        return o.lineInner(e, r, n, i);
      i = a + 1, n = l + 1;
    }
  }
  decompose(e, r, n, i) {
    for (let s = 0, o = 0; o <= r && s < this.children.length; s++) {
      let a = this.children[s], l = o + a.length;
      if (e <= l && r >= o) {
        let c = i & ((o <= e ? 1 : 0) | (l >= r ? 2 : 0));
        o >= e && l <= r && !c ? n.push(a) : a.decompose(e - o, r - o, n, c);
      }
      o = l + 1;
    }
  }
  replace(e, r, n) {
    if ([e, r] = ho(this, e, r), n.lines < this.lines)
      for (let i = 0, s = 0; i < this.children.length; i++) {
        let o = this.children[i], a = s + o.length;
        if (e >= s && r <= a) {
          let l = o.replace(e - s, r - s, n), c = this.lines - o.lines + l.lines;
          if (l.lines < c >> 4 && l.lines > c >> 6) {
            let u = this.children.slice();
            return u[i] = l, new cn(u, this.length - (r - e) + n.length);
          }
          return super.replace(s, a, l);
        }
        s = a + 1;
      }
    return super.replace(e, r, n);
  }
  sliceString(e, r = this.length, n = `
`) {
    [e, r] = ho(this, e, r);
    let i = "";
    for (let s = 0, o = 0; s < this.children.length && o <= r; s++) {
      let a = this.children[s], l = o + a.length;
      o > e && s && (i += n), e < l && r > o && (i += a.sliceString(e - o, r - o, n)), o = l + 1;
    }
    return i;
  }
  flatten(e) {
    for (let r of this.children)
      r.flatten(e);
  }
  scanIdentical(e, r) {
    if (!(e instanceof cn))
      return 0;
    let n = 0, [i, s, o, a] = r > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; i += r, s += r) {
      if (i == o || s == a)
        return n;
      let l = this.children[i], c = e.children[s];
      if (l != c)
        return n + l.scanIdentical(c, r);
      n += l.length + 1;
    }
  }
  static from(e, r = e.reduce((n, i) => n + i.length + 1, -1)) {
    let n = 0;
    for (let h of e)
      n += h.lines;
    if (n < 32) {
      let h = [];
      for (let p of e)
        p.flatten(h);
      return new ut(h, r);
    }
    let i = Math.max(
      32,
      n >> 5
      /* Tree.BranchShift */
    ), s = i << 1, o = i >> 1, a = [], l = 0, c = -1, u = [];
    function d(h) {
      let p;
      if (h.lines > s && h instanceof cn)
        for (let g of h.children)
          d(g);
      else
        h.lines > o && (l > o || !l) ? (f(), a.push(h)) : h instanceof ut && l && (p = u[u.length - 1]) instanceof ut && h.lines + p.lines <= 32 ? (l += h.lines, c += h.length + 1, u[u.length - 1] = new ut(p.text.concat(h.text), p.length + 1 + h.length)) : (l + h.lines > i && f(), l += h.lines, c += h.length + 1, u.push(h));
    }
    function f() {
      l != 0 && (a.push(u.length == 1 ? u[0] : cn.from(u, c)), c = -1, l = u.length = 0);
    }
    for (let h of e)
      d(h);
    return f(), a.length == 1 ? a[0] : new cn(a, r);
  }
}
Xe.empty = /* @__PURE__ */ new ut([""], 0);
function P_(t) {
  let e = -1;
  for (let r of t)
    e += r.length + 1;
  return e;
}
function Pc(t, e, r = 0, n = 1e9) {
  for (let i = 0, s = 0, o = !0; s < t.length && i <= n; s++) {
    let a = t[s], l = i + a.length;
    l >= r && (l > n && (a = a.slice(0, n - i)), i < r && (a = a.slice(r - i)), o ? (e[e.length - 1] += a, o = !1) : e.push(a)), i = l + 1;
  }
  return e;
}
function P0(t, e, r) {
  return Pc(t, [""], e, r);
}
class Qa {
  constructor(e, r = 1) {
    this.dir = r, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [r > 0 ? 1 : (e instanceof ut ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, r) {
    for (this.done = this.lineBreak = !1; ; ) {
      let n = this.nodes.length - 1, i = this.nodes[n], s = this.offsets[n], o = s >> 1, a = i instanceof ut ? i.text.length : i.children.length;
      if (o == (r > 0 ? a : 0)) {
        if (n == 0)
          return this.done = !0, this.value = "", this;
        r > 0 && this.offsets[n - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((s & 1) == (r > 0 ? 0 : 1)) {
        if (this.offsets[n] += r, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (i instanceof ut) {
        let l = i.text[o + (r < 0 ? -1 : 0)];
        if (this.offsets[n] += r, l.length > Math.max(0, e))
          return this.value = e == 0 ? l : r > 0 ? l.slice(e) : l.slice(0, l.length - e), this;
        e -= l.length;
      } else {
        let l = i.children[o + (r < 0 ? -1 : 0)];
        e > l.length ? (e -= l.length, this.offsets[n] += r) : (r < 0 && this.offsets[n]--, this.nodes.push(l), this.offsets.push(r > 0 ? 1 : (l instanceof ut ? l.text.length : l.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class cv {
  constructor(e, r, n) {
    this.value = "", this.done = !1, this.cursor = new Qa(e, r > n ? -1 : 1), this.pos = r > n ? e.length : 0, this.from = Math.min(r, n), this.to = Math.max(r, n);
  }
  nextInner(e, r) {
    if (r < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, r < 0 ? this.pos - this.to : this.from - this.pos);
    let n = r < 0 ? this.pos - this.from : this.to - this.pos;
    e > n && (e = n), n -= e;
    let { value: i } = this.cursor.next(e);
    return this.pos += (i.length + e) * r, this.value = i.length <= n ? i : r < 0 ? i.slice(i.length - n) : i.slice(0, n), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class uv {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: r, lineBreak: n, value: i } = this.inner.next(e);
    return r && this.afterBreak ? (this.value = "", this.afterBreak = !1) : r ? (this.done = !0, this.value = "") : n ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = i, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (Xe.prototype[Symbol.iterator] = function() {
  return this.iter();
}, Qa.prototype[Symbol.iterator] = cv.prototype[Symbol.iterator] = uv.prototype[Symbol.iterator] = function() {
  return this;
});
class x_ {
  /**
  @internal
  */
  constructor(e, r, n, i) {
    this.from = e, this.to = r, this.number = n, this.text = i;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
function ho(t, e, r) {
  return e = Math.max(0, Math.min(t.length, e)), [e, Math.max(e, Math.min(t.length, r))];
}
let Gs = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((t) => t ? parseInt(t, 36) : 1);
for (let t = 1; t < Gs.length; t++)
  Gs[t] += Gs[t - 1];
function T_(t) {
  for (let e = 1; e < Gs.length; e += 2)
    if (Gs[e] > t)
      return Gs[e - 1] <= t;
  return !1;
}
function x0(t) {
  return t >= 127462 && t <= 127487;
}
const T0 = 8205;
function fn(t, e, r = !0, n = !0) {
  return (r ? dv : C_)(t, e, n);
}
function dv(t, e, r) {
  if (e == t.length)
    return e;
  e && fv(t.charCodeAt(e)) && hv(t.charCodeAt(e - 1)) && e--;
  let n = Mt(t, e);
  for (e += qr(n); e < t.length; ) {
    let i = Mt(t, e);
    if (n == T0 || i == T0 || r && T_(i))
      e += qr(i), n = i;
    else if (x0(i)) {
      let s = 0, o = e - 2;
      for (; o >= 0 && x0(Mt(t, o)); )
        s++, o -= 2;
      if (s % 2 == 0)
        break;
      e += 2;
    } else
      break;
  }
  return e;
}
function C_(t, e, r) {
  for (; e > 0; ) {
    let n = dv(t, e - 2, r);
    if (n < e)
      return n;
    e--;
  }
  return 0;
}
function fv(t) {
  return t >= 56320 && t < 57344;
}
function hv(t) {
  return t >= 55296 && t < 56320;
}
function Mt(t, e) {
  let r = t.charCodeAt(e);
  if (!hv(r) || e + 1 == t.length)
    return r;
  let n = t.charCodeAt(e + 1);
  return fv(n) ? (r - 55296 << 10) + (n - 56320) + 65536 : r;
}
function pv(t) {
  return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
}
function qr(t) {
  return t < 65536 ? 1 : 2;
}
const Jf = /\r\n?|\n/;
var qt = /* @__PURE__ */ function(t) {
  return t[t.Simple = 0] = "Simple", t[t.TrackDel = 1] = "TrackDel", t[t.TrackBefore = 2] = "TrackBefore", t[t.TrackAfter = 3] = "TrackAfter", t;
}(qt || (qt = {}));
class Rn {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let r = 0; r < this.sections.length; r += 2)
      e += this.sections[r];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let r = 0; r < this.sections.length; r += 2) {
      let n = this.sections[r + 1];
      e += n < 0 ? this.sections[r] : n;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let r = 0, n = 0, i = 0; r < this.sections.length; ) {
      let s = this.sections[r++], o = this.sections[r++];
      o < 0 ? (e(n, i, s), i += s) : i += o, n += s;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, r = !1) {
    eh(this, e, r);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let r = 0; r < this.sections.length; ) {
      let n = this.sections[r++], i = this.sections[r++];
      i < 0 ? e.push(n, i) : e.push(i, n);
    }
    return new Rn(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : mv(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `other` happened before the ones in `this`.
  */
  mapDesc(e, r = !1) {
    return e.empty ? this : th(this, e, r);
  }
  mapPos(e, r = -1, n = qt.Simple) {
    let i = 0, s = 0;
    for (let o = 0; o < this.sections.length; ) {
      let a = this.sections[o++], l = this.sections[o++], c = i + a;
      if (l < 0) {
        if (c > e)
          return s + (e - i);
        s += a;
      } else {
        if (n != qt.Simple && c >= e && (n == qt.TrackDel && i < e && c > e || n == qt.TrackBefore && i < e || n == qt.TrackAfter && c > e))
          return null;
        if (c > e || c == e && r < 0 && !a)
          return e == i || r < 0 ? s : s + l;
        s += l;
      }
      i = c;
    }
    if (e > i)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${i}`);
    return s;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, r = e) {
    for (let n = 0, i = 0; n < this.sections.length && i <= r; ) {
      let s = this.sections[n++], o = this.sections[n++], a = i + s;
      if (o >= 0 && i <= r && a >= e)
        return i < e && a > r ? "cover" : !0;
      i = a;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let r = 0; r < this.sections.length; ) {
      let n = this.sections[r++], i = this.sections[r++];
      e += (e ? " " : "") + n + (i >= 0 ? ":" + i : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((r) => typeof r != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new Rn(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new Rn(e);
  }
}
class wt extends Rn {
  constructor(e, r) {
    super(e), this.inserted = r;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return eh(this, (r, n, i, s, o) => e = e.replace(i, i + (n - r), o), !1), e;
  }
  mapDesc(e, r = !1) {
    return th(this, e, r, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let r = this.sections.slice(), n = [];
    for (let i = 0, s = 0; i < r.length; i += 2) {
      let o = r[i], a = r[i + 1];
      if (a >= 0) {
        r[i] = a, r[i + 1] = o;
        let l = i >> 1;
        for (; n.length < l; )
          n.push(Xe.empty);
        n.push(o ? e.slice(s, s + o) : Xe.empty);
      }
      s += o;
    }
    return new wt(r, n);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` â†’ `docB` and `other` represents `docB` â†’ `docC`, the
  returned value will represent the change `docA` â†’ `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : mv(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, r = !1) {
    return e.empty ? this : th(this, e, r, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, r = !1) {
    eh(this, e, r);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return Rn.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let r = [], n = [], i = [], s = new La(this);
    e:
      for (let o = 0, a = 0; ; ) {
        let l = o == e.length ? 1e9 : e[o++];
        for (; a < l || a == l && s.len == 0; ) {
          if (s.done)
            break e;
          let u = Math.min(s.len, l - a);
          Zt(i, u, -1);
          let d = s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0;
          Zt(r, u, d), d > 0 && oi(n, r, s.text), s.forward(u), a += u;
        }
        let c = e[o++];
        for (; a < c; ) {
          if (s.done)
            break e;
          let u = Math.min(s.len, c - a);
          Zt(r, u, -1), Zt(i, u, s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0), s.forward(u), a += u;
        }
      }
    return {
      changes: new wt(r, n),
      filtered: Rn.create(i)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let r = 0; r < this.sections.length; r += 2) {
      let n = this.sections[r], i = this.sections[r + 1];
      i < 0 ? e.push(n) : i == 0 ? e.push([n]) : e.push([n].concat(this.inserted[r >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, r, n) {
    let i = [], s = [], o = 0, a = null;
    function l(u = !1) {
      if (!u && !i.length)
        return;
      o < r && Zt(i, r - o, -1);
      let d = new wt(i, s);
      a = a ? a.compose(d.map(a)) : d, i = [], s = [], o = 0;
    }
    function c(u) {
      if (Array.isArray(u))
        for (let d of u)
          c(d);
      else if (u instanceof wt) {
        if (u.length != r)
          throw new RangeError(`Mismatched change set length (got ${u.length}, expected ${r})`);
        l(), a = a ? a.compose(u.map(a)) : u;
      } else {
        let { from: d, to: f = d, insert: h } = u;
        if (d > f || d < 0 || f > r)
          throw new RangeError(`Invalid change range ${d} to ${f} (in doc of length ${r})`);
        let p = h ? typeof h == "string" ? Xe.of(h.split(n || Jf)) : h : Xe.empty, g = p.length;
        if (d == f && g == 0)
          return;
        d < o && l(), d > o && Zt(i, d - o, -1), Zt(i, f - d, g), oi(s, i, p), o = f;
      }
    }
    return c(e), l(!a), a;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new wt(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let r = [], n = [];
    for (let i = 0; i < e.length; i++) {
      let s = e[i];
      if (typeof s == "number")
        r.push(s, -1);
      else {
        if (!Array.isArray(s) || typeof s[0] != "number" || s.some((o, a) => a && typeof o != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (s.length == 1)
          r.push(s[0], 0);
        else {
          for (; n.length < i; )
            n.push(Xe.empty);
          n[i] = Xe.of(s.slice(1)), r.push(s[0], n[i].length);
        }
      }
    }
    return new wt(r, n);
  }
  /**
  @internal
  */
  static createSet(e, r) {
    return new wt(e, r);
  }
}
function Zt(t, e, r, n = !1) {
  if (e == 0 && r <= 0)
    return;
  let i = t.length - 2;
  i >= 0 && r <= 0 && r == t[i + 1] ? t[i] += e : e == 0 && t[i] == 0 ? t[i + 1] += r : n ? (t[i] += e, t[i + 1] += r) : t.push(e, r);
}
function oi(t, e, r) {
  if (r.length == 0)
    return;
  let n = e.length - 2 >> 1;
  if (n < t.length)
    t[t.length - 1] = t[t.length - 1].append(r);
  else {
    for (; t.length < n; )
      t.push(Xe.empty);
    t.push(r);
  }
}
function eh(t, e, r) {
  let n = t.inserted;
  for (let i = 0, s = 0, o = 0; o < t.sections.length; ) {
    let a = t.sections[o++], l = t.sections[o++];
    if (l < 0)
      i += a, s += a;
    else {
      let c = i, u = s, d = Xe.empty;
      for (; c += a, u += l, l && n && (d = d.append(n[o - 2 >> 1])), !(r || o == t.sections.length || t.sections[o + 1] < 0); )
        a = t.sections[o++], l = t.sections[o++];
      e(i, c, s, u, d), i = c, s = u;
    }
  }
}
function th(t, e, r, n = !1) {
  let i = [], s = n ? [] : null, o = new La(t), a = new La(e);
  for (let l = -1; ; )
    if (o.ins == -1 && a.ins == -1) {
      let c = Math.min(o.len, a.len);
      Zt(i, c, -1), o.forward(c), a.forward(c);
    } else if (a.ins >= 0 && (o.ins < 0 || l == o.i || o.off == 0 && (a.len < o.len || a.len == o.len && !r))) {
      let c = a.len;
      for (Zt(i, a.ins, -1); c; ) {
        let u = Math.min(o.len, c);
        o.ins >= 0 && l < o.i && o.len <= u && (Zt(i, 0, o.ins), s && oi(s, i, o.text), l = o.i), o.forward(u), c -= u;
      }
      a.next();
    } else if (o.ins >= 0) {
      let c = 0, u = o.len;
      for (; u; )
        if (a.ins == -1) {
          let d = Math.min(u, a.len);
          c += d, u -= d, a.forward(d);
        } else if (a.ins == 0 && a.len < u)
          u -= a.len, a.next();
        else
          break;
      Zt(i, c, l < o.i ? o.ins : 0), s && l < o.i && oi(s, i, o.text), l = o.i, o.forward(o.len - u);
    } else {
      if (o.done && a.done)
        return s ? wt.createSet(i, s) : Rn.create(i);
      throw new Error("Mismatched change set lengths");
    }
}
function mv(t, e, r = !1) {
  let n = [], i = r ? [] : null, s = new La(t), o = new La(e);
  for (let a = !1; ; ) {
    if (s.done && o.done)
      return i ? wt.createSet(n, i) : Rn.create(n);
    if (s.ins == 0)
      Zt(n, s.len, 0, a), s.next();
    else if (o.len == 0 && !o.done)
      Zt(n, 0, o.ins, a), i && oi(i, n, o.text), o.next();
    else {
      if (s.done || o.done)
        throw new Error("Mismatched change set lengths");
      {
        let l = Math.min(s.len2, o.len), c = n.length;
        if (s.ins == -1) {
          let u = o.ins == -1 ? -1 : o.off ? 0 : o.ins;
          Zt(n, l, u, a), i && u && oi(i, n, o.text);
        } else
          o.ins == -1 ? (Zt(n, s.off ? 0 : s.len, l, a), i && oi(i, n, s.textBit(l))) : (Zt(n, s.off ? 0 : s.len, o.off ? 0 : o.ins, a), i && !o.off && oi(i, n, o.text));
        a = (s.ins > l || o.ins >= 0 && o.len > l) && (a || n.length > c), s.forward2(l), o.forward(l);
      }
    }
  }
}
class La {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, r = this.i - 2 >> 1;
    return r >= e.length ? Xe.empty : e[r];
  }
  textBit(e) {
    let { inserted: r } = this.set, n = this.i - 2 >> 1;
    return n >= r.length && !e ? Xe.empty : r[n].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class Fi {
  constructor(e, r, n) {
    this.from = e, this.to = r, this.flags = n;
  }
  /**
  The anchor of the rangeâ€”the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 7;
    return e == 7 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 6;
    return e == 16777215 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, r = -1) {
    let n, i;
    return this.empty ? n = i = e.mapPos(this.from, r) : (n = e.mapPos(this.from, 1), i = e.mapPos(this.to, -1)), n == this.from && i == this.to ? this : new Fi(n, i, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, r = e) {
    if (e <= this.anchor && r >= this.anchor)
      return ce.range(e, r);
    let n = Math.abs(e - this.anchor) > Math.abs(r - this.anchor) ? e : r;
    return ce.range(this.anchor, n);
  }
  /**
  Compare this range to another range.
  */
  eq(e, r = !1) {
    return this.anchor == e.anchor && this.head == e.head && (!r || !this.empty || this.assoc == e.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return ce.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, r, n) {
    return new Fi(e, r, n);
  }
}
class ce {
  constructor(e, r) {
    this.ranges = e, this.mainIndex = r;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, r = -1) {
    return e.empty ? this : ce.create(this.ranges.map((n) => n.map(e, r)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(e, r = !1) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let n = 0; n < this.ranges.length; n++)
      if (!this.ranges[n].eq(e.ranges[n], r))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new ce([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, r = !0) {
    return ce.create([e].concat(this.ranges), r ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, r = this.mainIndex) {
    let n = this.ranges.slice();
    return n[r] = e, ce.create(n, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new ce(e.ranges.map((r) => Fi.fromJSON(r)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, r = e) {
    return new ce([ce.range(e, r)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, r = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let n = 0, i = 0; i < e.length; i++) {
      let s = e[i];
      if (s.empty ? s.from <= n : s.from < n)
        return ce.normalized(e.slice(), r);
      n = s.to;
    }
    return new ce(e, r);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, r = 0, n, i) {
    return Fi.create(e, e, (r == 0 ? 0 : r < 0 ? 8 : 16) | (n == null ? 7 : Math.min(6, n)) | (i ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(e, r, n, i) {
    let s = (n ?? 16777215) << 6 | (i == null ? 7 : Math.min(6, i));
    return r < e ? Fi.create(r, e, 48 | s) : Fi.create(e, r, (r > e ? 8 : 0) | s);
  }
  /**
  @internal
  */
  static normalized(e, r = 0) {
    let n = e[r];
    e.sort((i, s) => i.from - s.from), r = e.indexOf(n);
    for (let i = 1; i < e.length; i++) {
      let s = e[i], o = e[i - 1];
      if (s.empty ? s.from <= o.to : s.from < o.to) {
        let a = o.from, l = Math.max(s.to, o.to);
        i <= r && r--, e.splice(--i, 2, s.anchor > s.head ? ce.range(l, a) : ce.range(a, l));
      }
    }
    return new ce(e, r);
  }
}
function gv(t, e) {
  for (let r of t.ranges)
    if (r.to > e)
      throw new RangeError("Selection points outside of document");
}
let Jp = 0;
class be {
  constructor(e, r, n, i, s) {
    this.combine = e, this.compareInput = r, this.compare = n, this.isStatic = i, this.id = Jp++, this.default = e([]), this.extensions = typeof s == "function" ? s(this) : s;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new be(e.combine || ((r) => r), e.compareInput || ((r, n) => r === n), e.compare || (e.combine ? (r, n) => r === n : em), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new xc([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, r) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new xc(e, this, 1, r);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, r) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new xc(e, this, 2, r);
  }
  from(e, r) {
    return r || (r = (n) => n), this.compute([e], (n) => r(n.field(e)));
  }
}
function em(t, e) {
  return t == e || t.length == e.length && t.every((r, n) => r === e[n]);
}
class xc {
  constructor(e, r, n, i) {
    this.dependencies = e, this.facet = r, this.type = n, this.value = i, this.id = Jp++;
  }
  dynamicSlot(e) {
    var r;
    let n = this.value, i = this.facet.compareInput, s = this.id, o = e[s] >> 1, a = this.type == 2, l = !1, c = !1, u = [];
    for (let d of this.dependencies)
      d == "doc" ? l = !0 : d == "selection" ? c = !0 : ((r = e[d.id]) !== null && r !== void 0 ? r : 1) & 1 || u.push(e[d.id]);
    return {
      create(d) {
        return d.values[o] = n(d), 1;
      },
      update(d, f) {
        if (l && f.docChanged || c && (f.docChanged || f.selection) || rh(d, u)) {
          let h = n(d);
          if (a ? !C0(h, d.values[o], i) : !i(h, d.values[o]))
            return d.values[o] = h, 1;
        }
        return 0;
      },
      reconfigure: (d, f) => {
        let h, p = f.config.address[s];
        if (p != null) {
          let g = Kc(f, p);
          if (this.dependencies.every((m) => m instanceof be ? f.facet(m) === d.facet(m) : m instanceof Br ? f.field(m, !1) == d.field(m, !1) : !0) || (a ? C0(h = n(d), g, i) : i(h = n(d), g)))
            return d.values[o] = g, 0;
        } else
          h = n(d);
        return d.values[o] = h, 1;
      }
    };
  }
}
function C0(t, e, r) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (!r(t[n], e[n]))
      return !1;
  return !0;
}
function rh(t, e) {
  let r = !1;
  for (let n of e)
    Aa(t, n) & 1 && (r = !0);
  return r;
}
function Q_(t, e, r) {
  let n = r.map((l) => t[l.id]), i = r.map((l) => l.type), s = n.filter((l) => !(l & 1)), o = t[e.id] >> 1;
  function a(l) {
    let c = [];
    for (let u = 0; u < n.length; u++) {
      let d = Kc(l, n[u]);
      if (i[u] == 2)
        for (let f of d)
          c.push(f);
      else
        c.push(d);
    }
    return e.combine(c);
  }
  return {
    create(l) {
      for (let c of n)
        Aa(l, c);
      return l.values[o] = a(l), 1;
    },
    update(l, c) {
      if (!rh(l, s))
        return 0;
      let u = a(l);
      return e.compare(u, l.values[o]) ? 0 : (l.values[o] = u, 1);
    },
    reconfigure(l, c) {
      let u = rh(l, n), d = c.config.facets[e.id], f = c.facet(e);
      if (d && !u && em(r, d))
        return l.values[o] = f, 0;
      let h = a(l);
      return e.compare(h, f) ? (l.values[o] = f, 0) : (l.values[o] = h, 1);
    }
  };
}
const Q0 = /* @__PURE__ */ be.define({ static: !0 });
class Br {
  constructor(e, r, n, i, s) {
    this.id = e, this.createF = r, this.updateF = n, this.compareF = i, this.spec = s, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let r = new Br(Jp++, e.create, e.update, e.compare || ((n, i) => n === i), e);
    return e.provide && (r.provides = e.provide(r)), r;
  }
  create(e) {
    let r = e.facet(Q0).find((n) => n.field == this);
    return ((r == null ? void 0 : r.create) || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let r = e[this.id] >> 1;
    return {
      create: (n) => (n.values[r] = this.create(n), 1),
      update: (n, i) => {
        let s = n.values[r], o = this.updateF(s, i);
        return this.compareF(s, o) ? 0 : (n.values[r] = o, 1);
      },
      reconfigure: (n, i) => i.config.address[this.id] != null ? (n.values[r] = i.field(this), 0) : (n.values[r] = this.create(n), 1)
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, Q0.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const Xi = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function sa(t) {
  return (e) => new Ov(e, t);
}
const pl = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ sa(Xi.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ sa(Xi.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ sa(Xi.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ sa(Xi.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ sa(Xi.lowest)
};
class Ov {
  constructor(e, r) {
    this.inner = e, this.prec = r;
  }
}
class Yu {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new nh(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return Yu.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class nh {
  constructor(e, r) {
    this.compartment = e, this.inner = r;
  }
}
class Gc {
  constructor(e, r, n, i, s, o) {
    for (this.base = e, this.compartments = r, this.dynamicSlots = n, this.address = i, this.staticValues = s, this.facets = o, this.statusTemplate = []; this.statusTemplate.length < n.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let r = this.address[e.id];
    return r == null ? e.default : this.staticValues[r >> 1];
  }
  static resolve(e, r, n) {
    let i = [], s = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Map();
    for (let f of A_(e, r, o))
      f instanceof Br ? i.push(f) : (s[f.facet.id] || (s[f.facet.id] = [])).push(f);
    let a = /* @__PURE__ */ Object.create(null), l = [], c = [];
    for (let f of i)
      a[f.id] = c.length << 1, c.push((h) => f.slot(h));
    let u = n == null ? void 0 : n.config.facets;
    for (let f in s) {
      let h = s[f], p = h[0].facet, g = u && u[f] || [];
      if (h.every(
        (m) => m.type == 0
        /* Provider.Static */
      ))
        if (a[p.id] = l.length << 1 | 1, em(g, h))
          l.push(n.facet(p));
        else {
          let m = p.combine(h.map((y) => y.value));
          l.push(n && p.compare(m, n.facet(p)) ? n.facet(p) : m);
        }
      else {
        for (let m of h)
          m.type == 0 ? (a[m.id] = l.length << 1 | 1, l.push(m.value)) : (a[m.id] = c.length << 1, c.push((y) => m.dynamicSlot(y)));
        a[p.id] = c.length << 1, c.push((m) => Q_(m, p, h));
      }
    }
    let d = c.map((f) => f(a));
    return new Gc(e, o, d, a, l, s);
  }
}
function A_(t, e, r) {
  let n = [[], [], [], [], []], i = /* @__PURE__ */ new Map();
  function s(o, a) {
    let l = i.get(o);
    if (l != null) {
      if (l <= a)
        return;
      let c = n[l].indexOf(o);
      c > -1 && n[l].splice(c, 1), o instanceof nh && r.delete(o.compartment);
    }
    if (i.set(o, a), Array.isArray(o))
      for (let c of o)
        s(c, a);
    else if (o instanceof nh) {
      if (r.has(o.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let c = e.get(o.compartment) || o.inner;
      r.set(o.compartment, c), s(c, a);
    } else if (o instanceof Ov)
      s(o.inner, o.prec);
    else if (o instanceof Br)
      n[a].push(o), o.provides && s(o.provides, a);
    else if (o instanceof xc)
      n[a].push(o), o.facet.extensions && s(o.facet.extensions, Xi.default);
    else {
      let c = o.extension;
      if (!c)
        throw new Error(`Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      s(c, a);
    }
  }
  return s(t, Xi.default), n.reduce((o, a) => o.concat(a));
}
function Aa(t, e) {
  if (e & 1)
    return 2;
  let r = e >> 1, n = t.status[r];
  if (n == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (n & 2)
    return n;
  t.status[r] = 4;
  let i = t.computeSlot(t, t.config.dynamicSlots[r]);
  return t.status[r] = 2 | i;
}
function Kc(t, e) {
  return e & 1 ? t.config.staticValues[e >> 1] : t.values[e >> 1];
}
const yv = /* @__PURE__ */ be.define(), ih = /* @__PURE__ */ be.define({
  combine: (t) => t.some((e) => e),
  static: !0
}), bv = /* @__PURE__ */ be.define({
  combine: (t) => t.length ? t[0] : void 0,
  static: !0
}), vv = /* @__PURE__ */ be.define(), wv = /* @__PURE__ */ be.define(), $v = /* @__PURE__ */ be.define(), Sv = /* @__PURE__ */ be.define({
  combine: (t) => t.length ? t[0] : !1
});
class Os {
  /**
  @internal
  */
  constructor(e, r) {
    this.type = e, this.value = r;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new E_();
  }
}
class E_ {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new Os(this, e);
  }
}
class R_ {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new Le(this, e);
  }
}
class Le {
  /**
  @internal
  */
  constructor(e, r) {
    this.type = e, this.value = r;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let r = this.type.map(this.value, e);
    return r === void 0 ? void 0 : r == this.value ? this : new Le(this.type, r);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new R_(e.map || ((r) => r));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, r) {
    if (!e.length)
      return e;
    let n = [];
    for (let i of e) {
      let s = i.map(r);
      s && n.push(s);
    }
    return n;
  }
}
Le.reconfigure = /* @__PURE__ */ Le.define();
Le.appendConfig = /* @__PURE__ */ Le.define();
class Rt {
  constructor(e, r, n, i, s, o) {
    this.startState = e, this.changes = r, this.selection = n, this.effects = i, this.annotations = s, this.scrollIntoView = o, this._doc = null, this._state = null, n && gv(n, r.newLength), s.some((a) => a.type == Rt.time) || (this.annotations = s.concat(Rt.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, r, n, i, s, o) {
    return new Rt(e, r, n, i, s, o);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let r of this.annotations)
      if (r.type == e)
        return r.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let r = this.annotation(Rt.userEvent);
    return !!(r && (r == e || r.length > e.length && r.slice(0, e.length) == e && r[e.length] == "."));
  }
}
Rt.time = /* @__PURE__ */ Os.define();
Rt.userEvent = /* @__PURE__ */ Os.define();
Rt.addToHistory = /* @__PURE__ */ Os.define();
Rt.remote = /* @__PURE__ */ Os.define();
function I_(t, e) {
  let r = [];
  for (let n = 0, i = 0; ; ) {
    let s, o;
    if (n < t.length && (i == e.length || e[i] >= t[n]))
      s = t[n++], o = t[n++];
    else if (i < e.length)
      s = e[i++], o = e[i++];
    else
      return r;
    !r.length || r[r.length - 1] < s ? r.push(s, o) : r[r.length - 1] < o && (r[r.length - 1] = o);
  }
}
function kv(t, e, r) {
  var n;
  let i, s, o;
  return r ? (i = e.changes, s = wt.empty(e.changes.length), o = t.changes.compose(e.changes)) : (i = e.changes.map(t.changes), s = t.changes.mapDesc(e.changes, !0), o = t.changes.compose(i)), {
    changes: o,
    selection: e.selection ? e.selection.map(s) : (n = t.selection) === null || n === void 0 ? void 0 : n.map(i),
    effects: Le.mapEffects(t.effects, i).concat(Le.mapEffects(e.effects, s)),
    annotations: t.annotations.length ? t.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: t.scrollIntoView || e.scrollIntoView
  };
}
function sh(t, e, r) {
  let n = e.selection, i = Ks(e.annotations);
  return e.userEvent && (i = i.concat(Rt.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof wt ? e.changes : wt.of(e.changes || [], r, t.facet(bv)),
    selection: n && (n instanceof ce ? n : ce.single(n.anchor, n.head)),
    effects: Ks(e.effects),
    annotations: i,
    scrollIntoView: !!e.scrollIntoView
  };
}
function _v(t, e, r) {
  let n = sh(t, e.length ? e[0] : {}, t.doc.length);
  e.length && e[0].filter === !1 && (r = !1);
  for (let s = 1; s < e.length; s++) {
    e[s].filter === !1 && (r = !1);
    let o = !!e[s].sequential;
    n = kv(n, sh(t, e[s], o ? n.changes.newLength : t.doc.length), o);
  }
  let i = Rt.create(t, n.changes, n.selection, n.effects, n.annotations, n.scrollIntoView);
  return Z_(r ? j_(i) : i);
}
function j_(t) {
  let e = t.startState, r = !0;
  for (let i of e.facet(vv)) {
    let s = i(t);
    if (s === !1) {
      r = !1;
      break;
    }
    Array.isArray(s) && (r = r === !0 ? s : I_(r, s));
  }
  if (r !== !0) {
    let i, s;
    if (r === !1)
      s = t.changes.invertedDesc, i = wt.empty(e.doc.length);
    else {
      let o = t.changes.filter(r);
      i = o.changes, s = o.filtered.mapDesc(o.changes).invertedDesc;
    }
    t = Rt.create(e, i, t.selection && t.selection.map(s), Le.mapEffects(t.effects, s), t.annotations, t.scrollIntoView);
  }
  let n = e.facet(wv);
  for (let i = n.length - 1; i >= 0; i--) {
    let s = n[i](t);
    s instanceof Rt ? t = s : Array.isArray(s) && s.length == 1 && s[0] instanceof Rt ? t = s[0] : t = _v(e, Ks(s), !1);
  }
  return t;
}
function Z_(t) {
  let e = t.startState, r = e.facet($v), n = t;
  for (let i = r.length - 1; i >= 0; i--) {
    let s = r[i](t);
    s && Object.keys(s).length && (n = kv(n, sh(e, s, t.changes.newLength), !0));
  }
  return n == t ? t : Rt.create(e, t.changes, t.selection, n.effects, n.annotations, n.scrollIntoView);
}
const M_ = [];
function Ks(t) {
  return t == null ? M_ : Array.isArray(t) ? t : [t];
}
var wr = /* @__PURE__ */ function(t) {
  return t[t.Word = 0] = "Word", t[t.Space = 1] = "Space", t[t.Other = 2] = "Other", t;
}(wr || (wr = {}));
const q_ = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let oh;
try {
  oh = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function N_(t) {
  if (oh)
    return oh.test(t);
  for (let e = 0; e < t.length; e++) {
    let r = t[e];
    if (/\w/.test(r) || r > "Â€" && (r.toUpperCase() != r.toLowerCase() || q_.test(r)))
      return !0;
  }
  return !1;
}
function D_(t) {
  return (e) => {
    if (!/\S/.test(e))
      return wr.Space;
    if (N_(e))
      return wr.Word;
    for (let r = 0; r < t.length; r++)
      if (e.indexOf(t[r]) > -1)
        return wr.Word;
    return wr.Other;
  };
}
class De {
  constructor(e, r, n, i, s, o) {
    this.config = e, this.doc = r, this.selection = n, this.values = i, this.status = e.statusTemplate.slice(), this.computeSlot = s, o && (o._state = this);
    for (let a = 0; a < this.config.dynamicSlots.length; a++)
      Aa(this, a << 1);
    this.computeSlot = null;
  }
  field(e, r = !0) {
    let n = this.config.address[e.id];
    if (n == null) {
      if (r)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return Aa(this, n), Kc(this, n);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return _v(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let r = this.config, { base: n, compartments: i } = r;
    for (let a of e.effects)
      a.is(Yu.reconfigure) ? (r && (i = /* @__PURE__ */ new Map(), r.compartments.forEach((l, c) => i.set(c, l)), r = null), i.set(a.value.compartment, a.value.extension)) : a.is(Le.reconfigure) ? (r = null, n = a.value) : a.is(Le.appendConfig) && (r = null, n = Ks(n).concat(a.value));
    let s;
    r ? s = e.startState.values.slice() : (r = Gc.resolve(n, i, this), s = new De(r, this.doc, this.selection, r.dynamicSlots.map(() => null), (l, c) => c.reconfigure(l, this), null).values);
    let o = e.startState.facet(ih) ? e.newSelection : e.newSelection.asSingle();
    new De(r, e.newDoc, o, s, (a, l) => l.update(a, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((r) => ({
      changes: { from: r.from, to: r.to, insert: e },
      range: ce.cursor(r.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let r = this.selection, n = e(r.ranges[0]), i = this.changes(n.changes), s = [n.range], o = Ks(n.effects);
    for (let a = 1; a < r.ranges.length; a++) {
      let l = e(r.ranges[a]), c = this.changes(l.changes), u = c.map(i);
      for (let f = 0; f < a; f++)
        s[f] = s[f].map(u);
      let d = i.mapDesc(c, !0);
      s.push(l.range.map(d)), i = i.compose(u), o = Le.mapEffects(o, u).concat(Le.mapEffects(Ks(l.effects), d));
    }
    return {
      changes: i,
      selection: ce.create(s, r.mainIndex),
      effects: o
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof wt ? e : wt.of(e, this.doc.length, this.facet(De.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return Xe.of(e.split(this.facet(De.lineSeparator) || Jf));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, r = this.doc.length) {
    return this.doc.sliceString(e, r, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let r = this.config.address[e.id];
    return r == null ? e.default : (Aa(this, r), Kc(this, r));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let r = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let n in e) {
        let i = e[n];
        i instanceof Br && this.config.address[i.id] != null && (r[n] = i.spec.toJSON(this.field(e[n]), this));
      }
    return r;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, r = {}, n) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let i = [];
    if (n) {
      for (let s in n)
        if (Object.prototype.hasOwnProperty.call(e, s)) {
          let o = n[s], a = e[s];
          i.push(o.init((l) => o.spec.fromJSON(a, l)));
        }
    }
    return De.create({
      doc: e.doc,
      selection: ce.fromJSON(e.selection),
      extensions: r.extensions ? i.concat([r.extensions]) : i
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editorâ€”updated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let r = Gc.resolve(e.extensions || [], /* @__PURE__ */ new Map()), n = e.doc instanceof Xe ? e.doc : Xe.of((e.doc || "").split(r.staticFacet(De.lineSeparator) || Jf)), i = e.selection ? e.selection instanceof ce ? e.selection : ce.single(e.selection.anchor, e.selection.head) : ce.single(0);
    return gv(i, n.length), r.staticFacet(ih) || (i = i.asSingle()), new De(r, n, i, r.dynamicSlots.map(() => null), (s, o) => o.create(s), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(De.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(De.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(Sv);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...r) {
    for (let n of this.facet(De.phrases))
      if (Object.prototype.hasOwnProperty.call(n, e)) {
        e = n[e];
        break;
      }
    return r.length && (e = e.replace(/\$(\$|\d*)/g, (n, i) => {
      if (i == "$")
        return "$";
      let s = +(i || 1);
      return !s || s > r.length ? n : r[s - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, r, n = -1) {
    let i = [];
    for (let s of this.facet(yv))
      for (let o of s(this, r, n))
        Object.prototype.hasOwnProperty.call(o, e) && i.push(o[e]);
    return i;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return D_(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: r, from: n, length: i } = this.doc.lineAt(e), s = this.charCategorizer(e), o = e - n, a = e - n;
    for (; o > 0; ) {
      let l = fn(r, o, !1);
      if (s(r.slice(l, o)) != wr.Word)
        break;
      o = l;
    }
    for (; a < i; ) {
      let l = fn(r, a);
      if (s(r.slice(a, l)) != wr.Word)
        break;
      a = l;
    }
    return o == a ? null : ce.range(o + n, a + n);
  }
}
De.allowMultipleSelections = ih;
De.tabSize = /* @__PURE__ */ be.define({
  combine: (t) => t.length ? t[0] : 4
});
De.lineSeparator = bv;
De.readOnly = Sv;
De.phrases = /* @__PURE__ */ be.define({
  compare(t, e) {
    let r = Object.keys(t), n = Object.keys(e);
    return r.length == n.length && r.every((i) => t[i] == e[i]);
  }
});
De.languageData = yv;
De.changeFilter = vv;
De.transactionFilter = wv;
De.transactionExtender = $v;
Yu.reconfigure = /* @__PURE__ */ Le.define();
function Bu(t, e, r = {}) {
  let n = {};
  for (let i of t)
    for (let s of Object.keys(i)) {
      let o = i[s], a = n[s];
      if (a === void 0)
        n[s] = o;
      else if (!(a === o || o === void 0))
        if (Object.hasOwnProperty.call(r, s))
          n[s] = r[s](a, o);
        else
          throw new Error("Config merge conflict for field " + s);
    }
  for (let i in e)
    n[i] === void 0 && (n[i] = e[i]);
  return n;
}
class as {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, r = e) {
    return ah.create(e, r, this);
  }
}
as.prototype.startSide = as.prototype.endSide = 0;
as.prototype.point = !1;
as.prototype.mapMode = qt.TrackDel;
let ah = class Pv {
  constructor(e, r, n) {
    this.from = e, this.to = r, this.value = n;
  }
  /**
  @internal
  */
  static create(e, r, n) {
    return new Pv(e, r, n);
  }
};
function lh(t, e) {
  return t.from - e.from || t.value.startSide - e.value.startSide;
}
class tm {
  constructor(e, r, n, i) {
    this.from = e, this.to = r, this.value = n, this.maxPoint = i;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, r, n, i = 0) {
    let s = n ? this.to : this.from;
    for (let o = i, a = s.length; ; ) {
      if (o == a)
        return o;
      let l = o + a >> 1, c = s[l] - e || (n ? this.value[l].endSide : this.value[l].startSide) - r;
      if (l == o)
        return c >= 0 ? o : a;
      c >= 0 ? a = l : o = l + 1;
    }
  }
  between(e, r, n, i) {
    for (let s = this.findIndex(r, -1e9, !0), o = this.findIndex(n, 1e9, !1, s); s < o; s++)
      if (i(this.from[s] + e, this.to[s] + e, this.value[s]) === !1)
        return !1;
  }
  map(e, r) {
    let n = [], i = [], s = [], o = -1, a = -1;
    for (let l = 0; l < this.value.length; l++) {
      let c = this.value[l], u = this.from[l] + e, d = this.to[l] + e, f, h;
      if (u == d) {
        let p = r.mapPos(u, c.startSide, c.mapMode);
        if (p == null || (f = h = p, c.startSide != c.endSide && (h = r.mapPos(u, c.endSide), h < f)))
          continue;
      } else if (f = r.mapPos(u, c.startSide), h = r.mapPos(d, c.endSide), f > h || f == h && c.startSide > 0 && c.endSide <= 0)
        continue;
      (h - f || c.endSide - c.startSide) < 0 || (o < 0 && (o = f), c.point && (a = Math.max(a, h - f)), n.push(c), i.push(f - o), s.push(h - o));
    }
    return { mapped: n.length ? new tm(i, s, n, a) : null, pos: o };
  }
}
class ze {
  constructor(e, r, n, i) {
    this.chunkPos = e, this.chunk = r, this.nextLayer = n, this.maxPoint = i;
  }
  /**
  @internal
  */
  static create(e, r, n, i) {
    return new ze(e, r, n, i);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let r of this.chunk)
      e += r.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: r = [], sort: n = !1, filterFrom: i = 0, filterTo: s = this.length } = e, o = e.filter;
    if (r.length == 0 && !o)
      return this;
    if (n && (r = r.slice().sort(lh)), this.isEmpty)
      return r.length ? ze.of(r) : this;
    let a = new xv(this, null, -1).goto(0), l = 0, c = [], u = new po();
    for (; a.value || l < r.length; )
      if (l < r.length && (a.from - r[l].from || a.startSide - r[l].value.startSide) >= 0) {
        let d = r[l++];
        u.addInner(d.from, d.to, d.value) || c.push(d);
      } else
        a.rangeIndex == 1 && a.chunkIndex < this.chunk.length && (l == r.length || this.chunkEnd(a.chunkIndex) < r[l].from) && (!o || i > this.chunkEnd(a.chunkIndex) || s < this.chunkPos[a.chunkIndex]) && u.addChunk(this.chunkPos[a.chunkIndex], this.chunk[a.chunkIndex]) ? a.nextChunk() : ((!o || i > a.to || s < a.from || o(a.from, a.to, a.value)) && (u.addInner(a.from, a.to, a.value) || c.push(ah.create(a.from, a.to, a.value))), a.next());
    return u.finishInner(this.nextLayer.isEmpty && !c.length ? ze.empty : this.nextLayer.update({ add: c, filter: o, filterFrom: i, filterTo: s }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let r = [], n = [], i = -1;
    for (let o = 0; o < this.chunk.length; o++) {
      let a = this.chunkPos[o], l = this.chunk[o], c = e.touchesRange(a, a + l.length);
      if (c === !1)
        i = Math.max(i, l.maxPoint), r.push(l), n.push(e.mapPos(a));
      else if (c === !0) {
        let { mapped: u, pos: d } = l.map(a, e);
        u && (i = Math.max(i, u.maxPoint), r.push(u), n.push(d));
      }
    }
    let s = this.nextLayer.map(e);
    return r.length == 0 ? s : new ze(n, r, s || ze.empty, i);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, r, n) {
    if (!this.isEmpty) {
      for (let i = 0; i < this.chunk.length; i++) {
        let s = this.chunkPos[i], o = this.chunk[i];
        if (r >= s && e <= s + o.length && o.between(s, e - s, r - s, n) === !1)
          return;
      }
      this.nextLayer.between(e, r, n);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return Ya.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, r = 0) {
    return Ya.from(e).goto(r);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, r, n, i, s = -1) {
    let o = e.filter((d) => d.maxPoint > 0 || !d.isEmpty && d.maxPoint >= s), a = r.filter((d) => d.maxPoint > 0 || !d.isEmpty && d.maxPoint >= s), l = A0(o, a, n), c = new oa(o, l, s), u = new oa(a, l, s);
    n.iterGaps((d, f, h) => E0(c, d, u, f, h, i)), n.empty && n.length == 0 && E0(c, 0, u, 0, 0, i);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, r, n = 0, i) {
    i == null && (i = 999999999);
    let s = e.filter((u) => !u.isEmpty && r.indexOf(u) < 0), o = r.filter((u) => !u.isEmpty && e.indexOf(u) < 0);
    if (s.length != o.length)
      return !1;
    if (!s.length)
      return !0;
    let a = A0(s, o), l = new oa(s, a, 0).goto(n), c = new oa(o, a, 0).goto(n);
    for (; ; ) {
      if (l.to != c.to || !ch(l.active, c.active) || l.point && (!c.point || !l.point.eq(c.point)))
        return !1;
      if (l.to > i)
        return !0;
      l.next(), c.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, r, n, i, s = -1) {
    let o = new oa(e, null, s).goto(r), a = r, l = o.openStart;
    for (; ; ) {
      let c = Math.min(o.to, n);
      if (o.point) {
        let u = o.activeForPoint(o.to), d = o.pointFrom < r ? u.length + 1 : o.point.startSide < 0 ? u.length : Math.min(u.length, l);
        i.point(a, c, o.point, u, d, o.pointRank), l = Math.min(o.openEnd(c), u.length);
      } else
        c > a && (i.span(a, c, o.active, l), l = o.openEnd(c));
      if (o.to > n)
        return l + (o.point && o.to > n ? 1 : 0);
      a = o.to, o.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, r = !1) {
    let n = new po();
    for (let i of e instanceof ah ? [e] : r ? z_(e) : e)
      n.add(i.from, i.to, i.value);
    return n.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(e) {
    if (!e.length)
      return ze.empty;
    let r = e[e.length - 1];
    for (let n = e.length - 2; n >= 0; n--)
      for (let i = e[n]; i != ze.empty; i = i.nextLayer)
        r = new ze(i.chunkPos, i.chunk, r, Math.max(i.maxPoint, r.maxPoint));
    return r;
  }
}
ze.empty = /* @__PURE__ */ new ze([], [], null, -1);
function z_(t) {
  if (t.length > 1)
    for (let e = t[0], r = 1; r < t.length; r++) {
      let n = t[r];
      if (lh(e, n) > 0)
        return t.slice().sort(lh);
      e = n;
    }
  return t;
}
ze.empty.nextLayer = ze.empty;
class po {
  finishChunk(e) {
    this.chunks.push(new tm(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, r, n) {
    this.addInner(e, r, n) || (this.nextLayer || (this.nextLayer = new po())).add(e, r, n);
  }
  /**
  @internal
  */
  addInner(e, r, n) {
    let i = e - this.lastTo || n.startSide - this.last.endSide;
    if (i <= 0 && (e - this.lastFrom || n.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return i < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(r - this.chunkStart), this.last = n, this.lastFrom = e, this.lastTo = r, this.value.push(n), n.point && (this.maxPoint = Math.max(this.maxPoint, r - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, r) {
    if ((e - this.lastTo || r.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, r.maxPoint), this.chunks.push(r), this.chunkPos.push(e);
    let n = r.value.length - 1;
    return this.last = r.value[n], this.lastFrom = r.from[n] + e, this.lastTo = r.to[n] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(ze.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let r = ze.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, r;
  }
}
function A0(t, e, r) {
  let n = /* @__PURE__ */ new Map();
  for (let s of t)
    for (let o = 0; o < s.chunk.length; o++)
      s.chunk[o].maxPoint <= 0 && n.set(s.chunk[o], s.chunkPos[o]);
  let i = /* @__PURE__ */ new Set();
  for (let s of e)
    for (let o = 0; o < s.chunk.length; o++) {
      let a = n.get(s.chunk[o]);
      a != null && (r ? r.mapPos(a) : a) == s.chunkPos[o] && !(r != null && r.touchesRange(a, a + s.chunk[o].length)) && i.add(s.chunk[o]);
    }
  return i;
}
class xv {
  constructor(e, r, n, i = 0) {
    this.layer = e, this.skip = r, this.minPoint = n, this.rank = i;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, r = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, r, !1), this;
  }
  gotoInner(e, r, n) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let i = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(i) || this.layer.chunkEnd(this.chunkIndex) < e || i.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, n = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let i = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], r, !0);
      (!n || this.rangeIndex < i) && this.setRangeIndex(i);
    }
    this.next();
  }
  forward(e, r) {
    (this.to - e || this.endSide - r) < 0 && this.gotoInner(e, r, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], r = this.layer.chunk[this.chunkIndex], n = e + r.from[this.rangeIndex];
        if (this.from = n, this.to = e + r.to[this.rangeIndex], this.value = r.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class Ya {
  constructor(e) {
    this.heap = e;
  }
  static from(e, r = null, n = -1) {
    let i = [];
    for (let s = 0; s < e.length; s++)
      for (let o = e[s]; !o.isEmpty; o = o.nextLayer)
        o.maxPoint >= n && i.push(new xv(o, r, n, s));
    return i.length == 1 ? i[0] : new Ya(i);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, r = -1e9) {
    for (let n of this.heap)
      n.goto(e, r);
    for (let n = this.heap.length >> 1; n >= 0; n--)
      Md(this.heap, n);
    return this.next(), this;
  }
  forward(e, r) {
    for (let n of this.heap)
      n.forward(e, r);
    for (let n = this.heap.length >> 1; n >= 0; n--)
      Md(this.heap, n);
    (this.to - e || this.value.endSide - r) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), Md(this.heap, 0);
    }
  }
}
function Md(t, e) {
  for (let r = t[e]; ; ) {
    let n = (e << 1) + 1;
    if (n >= t.length)
      break;
    let i = t[n];
    if (n + 1 < t.length && i.compare(t[n + 1]) >= 0 && (i = t[n + 1], n++), r.compare(i) < 0)
      break;
    t[n] = r, t[e] = i, e = n;
  }
}
class oa {
  constructor(e, r, n) {
    this.minPoint = n, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = Ya.from(e, r, n);
  }
  goto(e, r = -1e9) {
    return this.cursor.goto(e, r), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = r, this.openStart = -1, this.next(), this;
  }
  forward(e, r) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - r) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, r);
  }
  removeActive(e) {
    Bl(this.active, e), Bl(this.activeTo, e), Bl(this.activeRank, e), this.minActive = R0(this.active, this.activeTo);
  }
  addActive(e) {
    let r = 0, { value: n, to: i, rank: s } = this.cursor;
    for (; r < this.activeRank.length && (s - this.activeRank[r] || i - this.activeTo[r]) > 0; )
      r++;
    Fl(this.active, r, n), Fl(this.activeTo, r, i), Fl(this.activeRank, r, s), e && Fl(e, r, this.cursor.from), this.minActive = R0(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, r = this.point;
    this.point = null;
    let n = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let i = this.minActive;
      if (i > -1 && (this.activeTo[i] - this.cursor.from || this.active[i].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[i] > e) {
          this.to = this.activeTo[i], this.endSide = this.active[i].endSide;
          break;
        }
        this.removeActive(i), n && Bl(n, i);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let s = this.cursor.value;
          if (!s.point)
            this.addActive(n), this.cursor.next();
          else if (r && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = s, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = s.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (n) {
      this.openStart = 0;
      for (let i = n.length - 1; i >= 0 && n[i] < e; i--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let r = [];
    for (let n = this.active.length - 1; n >= 0 && !(this.activeRank[n] < this.pointRank); n--)
      (this.activeTo[n] > e || this.activeTo[n] == e && this.active[n].endSide >= this.point.endSide) && r.push(this.active[n]);
    return r.reverse();
  }
  openEnd(e) {
    let r = 0;
    for (let n = this.activeTo.length - 1; n >= 0 && this.activeTo[n] > e; n--)
      r++;
    return r;
  }
}
function E0(t, e, r, n, i, s) {
  t.goto(e), r.goto(n);
  let o = n + i, a = n, l = n - e;
  for (; ; ) {
    let c = t.to + l - r.to || t.endSide - r.endSide, u = c < 0 ? t.to + l : r.to, d = Math.min(u, o);
    if (t.point || r.point ? t.point && r.point && (t.point == r.point || t.point.eq(r.point)) && ch(t.activeForPoint(t.to), r.activeForPoint(r.to)) || s.comparePoint(a, d, t.point, r.point) : d > a && !ch(t.active, r.active) && s.compareRange(a, d, t.active, r.active), u > o)
      break;
    a = u, c <= 0 && t.next(), c >= 0 && r.next();
  }
}
function ch(t, e) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (t[r] != e[r] && !t[r].eq(e[r]))
      return !1;
  return !0;
}
function Bl(t, e) {
  for (let r = e, n = t.length - 1; r < n; r++)
    t[r] = t[r + 1];
  t.pop();
}
function Fl(t, e, r) {
  for (let n = t.length - 1; n >= e; n--)
    t[n + 1] = t[n];
  t[e] = r;
}
function R0(t, e) {
  let r = -1, n = 1e9;
  for (let i = 0; i < e.length; i++)
    (e[i] - n || t[i].endSide - t[r].endSide) < 0 && (r = i, n = e[i]);
  return r;
}
function Tv(t, e, r = t.length) {
  let n = 0;
  for (let i = 0; i < r; )
    t.charCodeAt(i) == 9 ? (n += e - n % e, i++) : (n++, i = fn(t, i));
  return n;
}
function X_(t, e, r, n) {
  for (let i = 0, s = 0; ; ) {
    if (s >= e)
      return i;
    if (i == t.length)
      break;
    s += t.charCodeAt(i) == 9 ? r - s % r : 1, i = fn(t, i);
  }
  return n === !0 ? -1 : t.length;
}
const uh = "Í¼", I0 = typeof Symbol > "u" ? "__" + uh : Symbol.for(uh), dh = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), j0 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class yi {
  // :: (Object<Style>, ?{finish: ?(string) â†’ string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, r) {
    this.rules = [];
    let { finish: n } = r || {};
    function i(o) {
      return /^@/.test(o) ? [o] : o.split(/,\s*/);
    }
    function s(o, a, l, c) {
      let u = [], d = /^@(\w+)\b/.exec(o[0]), f = d && d[1] == "keyframes";
      if (d && a == null)
        return l.push(o[0] + ";");
      for (let h in a) {
        let p = a[h];
        if (/&/.test(h))
          s(
            h.split(/,\s*/).map((g) => o.map((m) => g.replace(/&/, m))).reduce((g, m) => g.concat(m)),
            p,
            l
          );
        else if (p && typeof p == "object") {
          if (!d)
            throw new RangeError("The value of a property (" + h + ") should be a primitive value.");
          s(i(h), p, u, f);
        } else
          p != null && u.push(h.replace(/_.*/, "").replace(/[A-Z]/g, (g) => "-" + g.toLowerCase()) + ": " + p + ";");
      }
      (u.length || f) && l.push((n && !d && !c ? o.map(n) : o).join(", ") + " {" + u.join(" ") + "}");
    }
    for (let o in e)
      s(i(o), e[o], this.rules);
  }
  // :: () â†’ string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () â†’ string
  // Generate a new unique CSS class name.
  static newName() {
    let e = j0[I0] || 1;
    return j0[I0] = e + 1, uh + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(e, r, n) {
    let i = e[dh], s = n && n.nonce;
    i ? s && i.setNonce(s) : i = new W_(e, s), i.mount(Array.isArray(r) ? r : [r]);
  }
}
let Z0 = /* @__PURE__ */ new Map();
class W_ {
  constructor(e, r) {
    this.root = e;
    let n = e.ownerDocument || e, i = n.defaultView;
    if (!e.head && e.adoptedStyleSheets && i.CSSStyleSheet) {
      let s = Z0.get(n);
      if (s)
        return e[dh] = s;
      this.sheet = new i.CSSStyleSheet(), Z0.set(n, this);
    } else
      this.styleTag = n.createElement("style"), r && this.styleTag.setAttribute("nonce", r);
    this.modules = [], e[dh] = this;
  }
  mount(e) {
    let r = this.sheet, n = 0, i = 0;
    for (let s = 0; s < e.length; s++) {
      let o = e[s], a = this.modules.indexOf(o);
      if (a < i && a > -1 && (this.modules.splice(a, 1), i--, a = -1), a == -1) {
        if (this.modules.splice(i++, 0, o), r)
          for (let l = 0; l < o.rules.length; l++)
            r.insertRule(o.rules[l], n++);
      } else {
        for (; i < a; )
          n += this.modules[i++].rules.length;
        n += o.rules.length, i++;
      }
    }
    if (r)
      this.root.adoptedStyleSheets.indexOf(this.sheet) < 0 && (this.root.adoptedStyleSheets = [this.sheet, ...this.root.adoptedStyleSheets]);
    else {
      let s = "";
      for (let a = 0; a < this.modules.length; a++)
        s += this.modules[a].getRules() + `
`;
      this.styleTag.textContent = s;
      let o = this.root.head || this.root;
      this.styleTag.parentNode != o && o.insertBefore(this.styleTag, o.firstChild);
    }
  }
  setNonce(e) {
    this.styleTag && this.styleTag.getAttribute("nonce") != e && this.styleTag.setAttribute("nonce", e);
  }
}
var bi = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, Ba = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, U_ = typeof navigator < "u" && /Mac/.test(navigator.platform), V_ = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var Qt = 0; Qt < 10; Qt++)
  bi[48 + Qt] = bi[96 + Qt] = String(Qt);
for (var Qt = 1; Qt <= 24; Qt++)
  bi[Qt + 111] = "F" + Qt;
for (var Qt = 65; Qt <= 90; Qt++)
  bi[Qt] = String.fromCharCode(Qt + 32), Ba[Qt] = String.fromCharCode(Qt);
for (var qd in bi)
  Ba.hasOwnProperty(qd) || (Ba[qd] = bi[qd]);
function L_(t) {
  var e = U_ && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || V_ && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", r = !e && t.key || (t.shiftKey ? Ba : bi)[t.keyCode] || t.key || "Unidentified";
  return r == "Esc" && (r = "Escape"), r == "Del" && (r = "Delete"), r == "Left" && (r = "ArrowLeft"), r == "Up" && (r = "ArrowUp"), r == "Right" && (r = "ArrowRight"), r == "Down" && (r = "ArrowDown"), r;
}
function Jc(t) {
  let e;
  return t.nodeType == 11 ? e = t.getSelection ? t : t.ownerDocument : e = t, e.getSelection();
}
function fh(t, e) {
  return e ? t == e || t.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function Y_(t) {
  let e = t.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function Tc(t, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return fh(t, e.anchorNode);
  } catch {
    return !1;
  }
}
function Fa(t) {
  return t.nodeType == 3 ? ls(t, 0, t.nodeValue.length).getClientRects() : t.nodeType == 1 ? t.getClientRects() : [];
}
function Ea(t, e, r, n) {
  return r ? M0(t, e, r, n, -1) || M0(t, e, r, n, 1) : !1;
}
function Ha(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}
function M0(t, e, r, n, i) {
  for (; ; ) {
    if (t == r && e == n)
      return !0;
    if (e == (i < 0 ? 0 : Mn(t))) {
      if (t.nodeName == "DIV")
        return !1;
      let s = t.parentNode;
      if (!s || s.nodeType != 1)
        return !1;
      e = Ha(t) + (i < 0 ? 0 : 1), t = s;
    } else if (t.nodeType == 1) {
      if (t = t.childNodes[e + (i < 0 ? -1 : 0)], t.nodeType == 1 && t.contentEditable == "false")
        return !1;
      e = i < 0 ? Mn(t) : 0;
    } else
      return !1;
  }
}
function Mn(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function rm(t, e) {
  let r = e ? t.left : t.right;
  return { left: r, right: r, top: t.top, bottom: t.bottom };
}
function B_(t) {
  return {
    left: 0,
    right: t.innerWidth,
    top: 0,
    bottom: t.innerHeight
  };
}
function Cv(t, e) {
  let r = e.width / t.offsetWidth, n = e.height / t.offsetHeight;
  return (r > 0.995 && r < 1.005 || !isFinite(r) || Math.abs(e.width - t.offsetWidth) < 1) && (r = 1), (n > 0.995 && n < 1.005 || !isFinite(n) || Math.abs(e.height - t.offsetHeight) < 1) && (n = 1), { scaleX: r, scaleY: n };
}
function F_(t, e, r, n, i, s, o, a) {
  let l = t.ownerDocument, c = l.defaultView || window;
  for (let u = t, d = !1; u && !d; )
    if (u.nodeType == 1) {
      let f, h = u == l.body, p = 1, g = 1;
      if (h)
        f = B_(c);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(u).position) && (d = !0), u.scrollHeight <= u.clientHeight && u.scrollWidth <= u.clientWidth) {
          u = u.assignedSlot || u.parentNode;
          continue;
        }
        let O = u.getBoundingClientRect();
        ({ scaleX: p, scaleY: g } = Cv(u, O)), f = {
          left: O.left,
          right: O.left + u.clientWidth * p,
          top: O.top,
          bottom: O.top + u.clientHeight * g
        };
      }
      let m = 0, y = 0;
      if (i == "nearest")
        e.top < f.top ? (y = -(f.top - e.top + o), r > 0 && e.bottom > f.bottom + y && (y = e.bottom - f.bottom + y + o)) : e.bottom > f.bottom && (y = e.bottom - f.bottom + o, r < 0 && e.top - y < f.top && (y = -(f.top + y - e.top + o)));
      else {
        let O = e.bottom - e.top, b = f.bottom - f.top;
        y = (i == "center" && O <= b ? e.top + O / 2 - b / 2 : i == "start" || i == "center" && r < 0 ? e.top - o : e.bottom - b + o) - f.top;
      }
      if (n == "nearest" ? e.left < f.left ? (m = -(f.left - e.left + s), r > 0 && e.right > f.right + m && (m = e.right - f.right + m + s)) : e.right > f.right && (m = e.right - f.right + s, r < 0 && e.left < f.left + m && (m = -(f.left + m - e.left + s))) : m = (n == "center" ? e.left + (e.right - e.left) / 2 - (f.right - f.left) / 2 : n == "start" == a ? e.left - s : e.right - (f.right - f.left) + s) - f.left, m || y)
        if (h)
          c.scrollBy(m, y);
        else {
          let O = 0, b = 0;
          if (y) {
            let w = u.scrollTop;
            u.scrollTop += y / g, b = (u.scrollTop - w) * g;
          }
          if (m) {
            let w = u.scrollLeft;
            u.scrollLeft += m / p, O = (u.scrollLeft - w) * p;
          }
          e = {
            left: e.left - O,
            top: e.top - b,
            right: e.right - O,
            bottom: e.bottom - b
          }, O && Math.abs(O - m) < 1 && (n = "nearest"), b && Math.abs(b - y) < 1 && (i = "nearest");
        }
      if (h)
        break;
      u = u.assignedSlot || u.parentNode;
    } else if (u.nodeType == 11)
      u = u.host;
    else
      break;
}
function H_(t) {
  let e = t.ownerDocument;
  for (let r = t.parentNode; r && r != e.body; )
    if (r.nodeType == 1) {
      if (r.scrollHeight > r.clientHeight || r.scrollWidth > r.clientWidth)
        return r;
      r = r.assignedSlot || r.parentNode;
    } else if (r.nodeType == 11)
      r = r.host;
    else
      break;
  return null;
}
class G_ {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: r, focusNode: n } = e;
    this.set(r, Math.min(e.anchorOffset, r ? Mn(r) : 0), n, Math.min(e.focusOffset, n ? Mn(n) : 0));
  }
  set(e, r, n, i) {
    this.anchorNode = e, this.anchorOffset = r, this.focusNode = n, this.focusOffset = i;
  }
}
let Ts = null;
function Qv(t) {
  if (t.setActive)
    return t.setActive();
  if (Ts)
    return t.focus(Ts);
  let e = [];
  for (let r = t; r && (e.push(r, r.scrollTop, r.scrollLeft), r != r.ownerDocument); r = r.parentNode)
    ;
  if (t.focus(Ts == null ? {
    get preventScroll() {
      return Ts = { preventScroll: !0 }, !0;
    }
  } : void 0), !Ts) {
    Ts = !1;
    for (let r = 0; r < e.length; ) {
      let n = e[r++], i = e[r++], s = e[r++];
      n.scrollTop != i && (n.scrollTop = i), n.scrollLeft != s && (n.scrollLeft = s);
    }
  }
}
let q0;
function ls(t, e, r = e) {
  let n = q0 || (q0 = document.createRange());
  return n.setEnd(t, r), n.setStart(t, e), n;
}
function Js(t, e, r) {
  let n = { key: e, code: e, keyCode: r, which: r, cancelable: !0 }, i = new KeyboardEvent("keydown", n);
  i.synthetic = !0, t.dispatchEvent(i);
  let s = new KeyboardEvent("keyup", n);
  return s.synthetic = !0, t.dispatchEvent(s), i.defaultPrevented || s.defaultPrevented;
}
function K_(t) {
  for (; t; ) {
    if (t && (t.nodeType == 9 || t.nodeType == 11 && t.host))
      return t;
    t = t.assignedSlot || t.parentNode;
  }
  return null;
}
function Av(t) {
  for (; t.attributes.length; )
    t.removeAttributeNode(t.attributes[0]);
}
function J_(t, e) {
  let r = e.focusNode, n = e.focusOffset;
  if (!r || e.anchorNode != r || e.anchorOffset != n)
    return !1;
  for (n = Math.min(n, Mn(r)); ; )
    if (n) {
      if (r.nodeType != 1)
        return !1;
      let i = r.childNodes[n - 1];
      i.contentEditable == "false" ? n-- : (r = i, n = Mn(r));
    } else {
      if (r == t)
        return !0;
      n = Ha(r), r = r.parentNode;
    }
}
function Ev(t) {
  return t.scrollTop > Math.max(1, t.scrollHeight - t.clientHeight - 4);
}
class Nt {
  constructor(e, r, n = !0) {
    this.node = e, this.offset = r, this.precise = n;
  }
  static before(e, r) {
    return new Nt(e.parentNode, Ha(e), r);
  }
  static after(e, r) {
    return new Nt(e.parentNode, Ha(e) + 1, r);
  }
}
const nm = [];
class et {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let r = this.posAtStart;
    for (let n of this.children) {
      if (n == e)
        return r;
      r += n.length + n.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, r) {
    if (this.flags & 2) {
      let n = this.dom, i = null, s;
      for (let o of this.children) {
        if (o.flags & 7) {
          if (!o.dom && (s = i ? i.nextSibling : n.firstChild)) {
            let a = et.get(s);
            (!a || !a.parent && a.canReuseDOM(o)) && o.reuseDOM(s);
          }
          o.sync(e, r), o.flags &= -8;
        }
        if (s = i ? i.nextSibling : n.firstChild, r && !r.written && r.node == n && s != o.dom && (r.written = !0), o.dom.parentNode == n)
          for (; s && s != o.dom; )
            s = N0(s);
        else
          n.insertBefore(o.dom, s);
        i = o.dom;
      }
      for (s = i ? i.nextSibling : n.firstChild, s && r && r.node == n && (r.written = !0); s; )
        s = N0(s);
    } else if (this.flags & 1)
      for (let n of this.children)
        n.flags & 7 && (n.sync(e, r), n.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, r) {
    let n;
    if (e == this.dom)
      n = this.dom.childNodes[r];
    else {
      let i = Mn(e) == 0 ? 0 : r == 0 ? -1 : 1;
      for (; ; ) {
        let s = e.parentNode;
        if (s == this.dom)
          break;
        i == 0 && s.firstChild != s.lastChild && (e == s.firstChild ? i = -1 : i = 1), e = s;
      }
      i < 0 ? n = e : n = e.nextSibling;
    }
    if (n == this.dom.firstChild)
      return 0;
    for (; n && !et.get(n); )
      n = n.nextSibling;
    if (!n)
      return this.length;
    for (let i = 0, s = 0; ; i++) {
      let o = this.children[i];
      if (o.dom == n)
        return s;
      s += o.length + o.breakAfter;
    }
  }
  domBoundsAround(e, r, n = 0) {
    let i = -1, s = -1, o = -1, a = -1;
    for (let l = 0, c = n, u = n; l < this.children.length; l++) {
      let d = this.children[l], f = c + d.length;
      if (c < e && f > r)
        return d.domBoundsAround(e, r, c);
      if (f >= e && i == -1 && (i = l, s = c), c > r && d.dom.parentNode == this.dom) {
        o = l, a = u;
        break;
      }
      u = f, c = f + d.breakAfter;
    }
    return {
      from: s,
      to: a < 0 ? n + this.length : a,
      startDOM: (i ? this.children[i - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let r = this.parent; r; r = r.parent) {
      if (e && (r.flags |= 2), r.flags & 1)
        return;
      r.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);
  }
  get rootView() {
    for (let e = this; ; ) {
      let r = e.parent;
      if (!r)
        return e;
      e = r;
    }
  }
  replaceChildren(e, r, n = nm) {
    this.markDirty();
    for (let i = e; i < r; i++) {
      let s = this.children[i];
      s.parent == this && n.indexOf(s) < 0 && s.destroy();
    }
    this.children.splice(e, r - e, ...n);
    for (let i = 0; i < n.length; i++)
      n[i].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new Rv(this.children, e, this.children.length);
  }
  childPos(e, r = 1) {
    return this.childCursor().findPos(e, r);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, r, n, i, s, o) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let e of this.children)
      e.parent == this && e.destroy();
    this.parent = null;
  }
}
et.prototype.breakAfter = 0;
function N0(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class Rv {
  constructor(e, r, n) {
    this.children = e, this.pos = r, this.i = n, this.off = 0;
  }
  findPos(e, r = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (r > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let n = this.children[--this.i];
      this.pos -= n.length + n.breakAfter;
    }
  }
}
function Iv(t, e, r, n, i, s, o, a, l) {
  let { children: c } = t, u = c.length ? c[e] : null, d = s.length ? s[s.length - 1] : null, f = d ? d.breakAfter : o;
  if (!(e == n && u && !o && !f && s.length < 2 && u.merge(r, i, s.length ? d : null, r == 0, a, l))) {
    if (n < c.length) {
      let h = c[n];
      h && (i < h.length || h.breakAfter && (d != null && d.breakAfter)) ? (e == n && (h = h.split(i), i = 0), !f && d && h.merge(0, i, d, !0, 0, l) ? s[s.length - 1] = h : ((i || h.children.length && !h.children[0].length) && h.merge(0, i, null, !1, 0, l), s.push(h))) : h != null && h.breakAfter && (d ? d.breakAfter = 1 : o = 1), n++;
    }
    for (u && (u.breakAfter = o, r > 0 && (!o && s.length && u.merge(r, u.length, s[0], !1, a, 0) ? u.breakAfter = s.shift().breakAfter : (r < u.length || u.children.length && u.children[u.children.length - 1].length == 0) && u.merge(r, u.length, null, !1, a, 0), e++)); e < n && s.length; )
      if (c[n - 1].become(s[s.length - 1]))
        n--, s.pop(), l = s.length ? 0 : a;
      else if (c[e].become(s[0]))
        e++, s.shift(), a = s.length ? 0 : l;
      else
        break;
    !s.length && e && n < c.length && !c[e - 1].breakAfter && c[n].merge(0, 0, c[e - 1], !1, a, l) && e--, (e < n || s.length) && t.replaceChildren(e, n, s);
  }
}
function jv(t, e, r, n, i, s) {
  let o = t.childCursor(), { i: a, off: l } = o.findPos(r, 1), { i: c, off: u } = o.findPos(e, -1), d = e - r;
  for (let f of n)
    d += f.length;
  t.length += d, Iv(t, c, u, a, l, n, 0, i, s);
}
let dr = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, hh = typeof document < "u" ? document : { documentElement: { style: {} } };
const ph = /* @__PURE__ */ /Edge\/(\d+)/.exec(dr.userAgent), Zv = /* @__PURE__ */ /MSIE \d/.test(dr.userAgent), mh = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(dr.userAgent), Fu = !!(Zv || mh || ph), D0 = !Fu && /* @__PURE__ */ /gecko\/(\d+)/i.test(dr.userAgent), Nd = !Fu && /* @__PURE__ */ /Chrome\/(\d+)/.exec(dr.userAgent), z0 = "webkitFontSmoothing" in hh.documentElement.style, Mv = !Fu && /* @__PURE__ */ /Apple Computer/.test(dr.vendor), X0 = Mv && (/* @__PURE__ */ /Mobile\/\w+/.test(dr.userAgent) || dr.maxTouchPoints > 2);
var de = {
  mac: X0 || /* @__PURE__ */ /Mac/.test(dr.platform),
  windows: /* @__PURE__ */ /Win/.test(dr.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(dr.platform),
  ie: Fu,
  ie_version: Zv ? hh.documentMode || 6 : mh ? +mh[1] : ph ? +ph[1] : 0,
  gecko: D0,
  gecko_version: D0 ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(dr.userAgent) || [0, 0])[1] : 0,
  chrome: !!Nd,
  chrome_version: Nd ? +Nd[1] : 0,
  ios: X0,
  android: /* @__PURE__ */ /Android\b/.test(dr.userAgent),
  webkit: z0,
  safari: Mv,
  webkit_version: z0 ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: hh.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const eP = 256;
class qn extends et {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, r) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (r && r.node == this.dom && (r.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, r, n) {
    return this.flags & 8 || n && (!(n instanceof qn) || this.length - (r - e) + n.length > eP || n.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (n ? n.text : "") + this.text.slice(r), this.markDirty(), !0);
  }
  split(e) {
    let r = new qn(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), r.flags |= this.flags & 8, r;
  }
  localPosFromDOM(e, r) {
    return e == this.dom ? r : r ? this.text.length : 0;
  }
  domAtPos(e) {
    return new Nt(this.dom, e);
  }
  domBoundsAround(e, r, n) {
    return { from: n, to: n + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, r) {
    return tP(this.dom, e, r);
  }
}
class Nn extends et {
  constructor(e, r = [], n = 0) {
    super(), this.mark = e, this.children = r, this.length = n;
    for (let i of r)
      i.setParent(this);
  }
  setAttrs(e) {
    if (Av(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let r in this.mark.attrs)
        e.setAttribute(r, this.mark.attrs[r]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, r) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, r);
  }
  merge(e, r, n, i, s, o) {
    return n && (!(n instanceof Nn && n.mark.eq(this.mark)) || e && s <= 0 || r < this.length && o <= 0) ? !1 : (jv(this, e, r, n ? n.children.slice() : [], s - 1, o - 1), this.markDirty(), !0);
  }
  split(e) {
    let r = [], n = 0, i = -1, s = 0;
    for (let a of this.children) {
      let l = n + a.length;
      l > e && r.push(n < e ? a.split(e - n) : a), i < 0 && n >= e && (i = s), n = l, s++;
    }
    let o = this.length - e;
    return this.length = e, i > -1 && (this.children.length = i, this.markDirty()), new Nn(this.mark, r, o);
  }
  domAtPos(e) {
    return qv(this, e);
  }
  coordsAt(e, r) {
    return Dv(this, e, r);
  }
}
function tP(t, e, r) {
  let n = t.nodeValue.length;
  e > n && (e = n);
  let i = e, s = e, o = 0;
  e == 0 && r < 0 || e == n && r >= 0 ? de.chrome || de.gecko || (e ? (i--, o = 1) : s < n && (s++, o = -1)) : r < 0 ? i-- : s < n && s++;
  let a = ls(t, i, s).getClientRects();
  if (!a.length)
    return null;
  let l = a[(o ? o < 0 : r >= 0) ? 0 : a.length - 1];
  return de.safari && !o && l.width == 0 && (l = Array.prototype.find.call(a, (c) => c.width) || l), o ? rm(l, o < 0) : l || null;
}
class Hi extends et {
  static create(e, r, n) {
    return new Hi(e, r, n);
  }
  constructor(e, r, n) {
    super(), this.widget = e, this.length = r, this.side = n, this.prevWidget = null;
  }
  split(e) {
    let r = Hi.create(this.widget, this.length - e, this.side);
    return this.length -= e, r;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(e, r, n, i, s, o) {
    return n && (!(n instanceof Hi) || !this.widget.compare(n.widget) || e > 0 && s <= 0 || r < this.length && o <= 0) ? !1 : (this.length = e + (n ? n.length : 0) + (this.length - r), !0);
  }
  become(e) {
    return e instanceof Hi && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Xe.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: r } = e, n = r && r.state.doc, i = this.posAtStart;
    return n ? n.slice(i, i + this.length) : Xe.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? Nt.before(this.dom) : Nt.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, r) {
    let n = this.widget.coordsAt(this.dom, e, r);
    if (n)
      return n;
    let i = this.dom.getClientRects(), s = null;
    if (!i.length)
      return null;
    let o = this.side ? this.side < 0 : e > 0;
    for (let a = o ? i.length - 1 : 0; s = i[a], !(e > 0 ? a == 0 : a == i.length - 1 || s.top < s.bottom); a += o ? -1 : 1)
      ;
    return rm(s, !o);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class mo extends et {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof mo && e.side == this.side;
  }
  split() {
    return new mo(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? Nt.before(this.dom) : Nt.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Xe.empty;
  }
  get isHidden() {
    return !0;
  }
}
qn.prototype.children = Hi.prototype.children = mo.prototype.children = nm;
function qv(t, e) {
  let r = t.dom, { children: n } = t, i = 0;
  for (let s = 0; i < n.length; i++) {
    let o = n[i], a = s + o.length;
    if (!(a == s && o.getSide() <= 0)) {
      if (e > s && e < a && o.dom.parentNode == r)
        return o.domAtPos(e - s);
      if (e <= s)
        break;
      s = a;
    }
  }
  for (let s = i; s > 0; s--) {
    let o = n[s - 1];
    if (o.dom.parentNode == r)
      return o.domAtPos(o.length);
  }
  for (let s = i; s < n.length; s++) {
    let o = n[s];
    if (o.dom.parentNode == r)
      return o.domAtPos(0);
  }
  return new Nt(r, 0);
}
function Nv(t, e, r) {
  let n, { children: i } = t;
  r > 0 && e instanceof Nn && i.length && (n = i[i.length - 1]) instanceof Nn && n.mark.eq(e.mark) ? Nv(n, e.children[0], r - 1) : (i.push(e), e.setParent(t)), t.length += e.length;
}
function Dv(t, e, r) {
  let n = null, i = -1, s = null, o = -1;
  function a(c, u) {
    for (let d = 0, f = 0; d < c.children.length && f <= u; d++) {
      let h = c.children[d], p = f + h.length;
      p >= u && (h.children.length ? a(h, u - f) : (!s || s.isHidden && r > 0) && (p > u || f == p && h.getSide() > 0) ? (s = h, o = u - f) : (f < u || f == p && h.getSide() < 0 && !h.isHidden) && (n = h, i = u - f)), f = p;
    }
  }
  a(t, e);
  let l = (r < 0 ? n : s) || n || s;
  return l ? l.coordsAt(Math.max(0, l == n ? i : o), r) : rP(t);
}
function rP(t) {
  let e = t.dom.lastChild;
  if (!e)
    return t.dom.getBoundingClientRect();
  let r = Fa(e);
  return r[r.length - 1] || null;
}
function gh(t, e) {
  for (let r in t)
    r == "class" && e.class ? e.class += " " + t.class : r == "style" && e.style ? e.style += ";" + t.style : e[r] = t[r];
  return e;
}
const W0 = /* @__PURE__ */ Object.create(null);
function im(t, e, r) {
  if (t == e)
    return !0;
  t || (t = W0), e || (e = W0);
  let n = Object.keys(t), i = Object.keys(e);
  if (n.length - (r && n.indexOf(r) > -1 ? 1 : 0) != i.length - (r && i.indexOf(r) > -1 ? 1 : 0))
    return !1;
  for (let s of n)
    if (s != r && (i.indexOf(s) == -1 || t[s] !== e[s]))
      return !1;
  return !0;
}
function Oh(t, e, r) {
  let n = !1;
  if (e)
    for (let i in e)
      r && i in r || (n = !0, i == "style" ? t.style.cssText = "" : t.removeAttribute(i));
  if (r)
    for (let i in r)
      e && e[i] == r[i] || (n = !0, i == "style" ? t.style.cssText = r[i] : t.setAttribute(i, r[i]));
  return n;
}
function nP(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let r = 0; r < t.attributes.length; r++) {
    let n = t.attributes[r];
    e[n.name] = n.value;
  }
  return e;
}
class Ot extends et {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, r, n, i, s, o) {
    if (n) {
      if (!(n instanceof Ot))
        return !1;
      this.dom || n.transferDOM(this);
    }
    return i && this.setDeco(n ? n.attrs : null), jv(this, e, r, n ? n.children.slice() : [], s, o), !0;
  }
  split(e) {
    let r = new Ot();
    if (r.breakAfter = this.breakAfter, this.length == 0)
      return r;
    let { i: n, off: i } = this.childPos(e);
    i && (r.append(this.children[n].split(i), 0), this.children[n].merge(i, this.children[n].length, null, !1, 0, 0), n++);
    for (let s = n; s < this.children.length; s++)
      r.append(this.children[s], 0);
    for (; n > 0 && this.children[n - 1].length == 0; )
      this.children[--n].destroy();
    return this.children.length = n, this.markDirty(), this.length = e, r;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    im(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, r) {
    Nv(this, e, r);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let r = e.spec.attributes, n = e.spec.class;
    r && (this.attrs = gh(r, this.attrs || {})), n && (this.attrs = gh({ class: n }, this.attrs || {}));
  }
  domAtPos(e) {
    return qv(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, r) {
    var n;
    this.dom ? this.flags & 4 && (Av(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (Oh(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, r);
    let i = this.dom.lastChild;
    for (; i && et.get(i) instanceof Nn; )
      i = i.lastChild;
    if (!i || !this.length || i.nodeName != "BR" && ((n = et.get(i)) === null || n === void 0 ? void 0 : n.isEditable) == !1 && (!de.ios || !this.children.some((s) => s instanceof qn))) {
      let s = document.createElement("BR");
      s.cmIgnore = !0, this.dom.appendChild(s);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, r;
    for (let n of this.children) {
      if (!(n instanceof qn) || /[^ -~]/.test(n.text))
        return null;
      let i = Fa(n.dom);
      if (i.length != 1)
        return null;
      e += i[0].width, r = i[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: r
    } : null;
  }
  coordsAt(e, r) {
    let n = Dv(this, e, r);
    if (!this.children.length && n && this.parent) {
      let { heightOracle: i } = this.parent.view.viewState, s = n.bottom - n.top;
      if (Math.abs(s - i.lineHeight) < 2 && i.textHeight < s) {
        let o = (s - i.textHeight) / 2;
        return { top: n.top + o, bottom: n.bottom - o, left: n.left, right: n.left };
      }
    }
    return n;
  }
  become(e) {
    return !1;
  }
  covers() {
    return !0;
  }
  static find(e, r) {
    for (let n = 0, i = 0; n < e.children.length; n++) {
      let s = e.children[n], o = i + s.length;
      if (o >= r) {
        if (s instanceof Ot)
          return s;
        if (o > r)
          break;
      }
      i = o + s.breakAfter;
    }
    return null;
  }
}
class di extends et {
  constructor(e, r, n) {
    super(), this.widget = e, this.length = r, this.deco = n, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, r, n, i, s, o) {
    return n && (!(n instanceof di) || !this.widget.compare(n.widget) || e > 0 && s <= 0 || r < this.length && o <= 0) ? !1 : (this.length = e + (n ? n.length : 0) + (this.length - r), !0);
  }
  domAtPos(e) {
    return e == 0 ? Nt.before(this.dom) : Nt.after(this.dom, e == this.length);
  }
  split(e) {
    let r = this.length - e;
    this.length = e;
    let n = new di(this.widget, r, this.deco);
    return n.breakAfter = this.breakAfter, n;
  }
  get children() {
    return nm;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Xe.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof di && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, r) {
    return this.widget.coordsAt(this.dom, e, r);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(e) {
    let { startSide: r, endSide: n } = this.deco;
    return r == n ? !1 : e < 0 ? r < 0 : n > 0;
  }
}
class Ro {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, r) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queriedâ€”less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, r, n) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var Xr = /* @__PURE__ */ function(t) {
  return t[t.Text = 0] = "Text", t[t.WidgetBefore = 1] = "WidgetBefore", t[t.WidgetAfter = 2] = "WidgetAfter", t[t.WidgetRange = 3] = "WidgetRange", t;
}(Xr || (Xr = {}));
class We extends as {
  constructor(e, r, n, i) {
    super(), this.startSide = e, this.endSide = r, this.widget = n, this.spec = i;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new ml(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let r = Math.max(-1e4, Math.min(1e4, e.side || 0)), n = !!e.block;
    return r += n && !e.inlineOrder ? r > 0 ? 3e8 : -4e8 : r > 0 ? 1e8 : -1e8, new vi(e, r, r, n, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let r = !!e.block, n, i;
    if (e.isBlockGap)
      n = -5e8, i = 4e8;
    else {
      let { start: s, end: o } = zv(e, r);
      n = (s ? r ? -3e8 : -1 : 5e8) - 1, i = (o ? r ? 2e8 : 1 : -6e8) + 1;
    }
    return new vi(e, n, i, r, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new gl(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, r = !1) {
    return ze.of(e, r);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
We.none = ze.empty;
class ml extends We {
  constructor(e) {
    let { start: r, end: n } = zv(e);
    super(r ? -1 : 5e8, n ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var r, n;
    return this == e || e instanceof ml && this.tagName == e.tagName && (this.class || ((r = this.attrs) === null || r === void 0 ? void 0 : r.class)) == (e.class || ((n = e.attrs) === null || n === void 0 ? void 0 : n.class)) && im(this.attrs, e.attrs, "class");
  }
  range(e, r = e) {
    if (e >= r)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, r);
  }
}
ml.prototype.point = !1;
class gl extends We {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof gl && this.spec.class == e.spec.class && im(this.spec.attributes, e.spec.attributes);
  }
  range(e, r = e) {
    if (r != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, r);
  }
}
gl.prototype.mapMode = qt.TrackBefore;
gl.prototype.point = !0;
class vi extends We {
  constructor(e, r, n, i, s, o) {
    super(r, n, s, e), this.block = i, this.isReplace = o, this.mapMode = i ? r <= 0 ? qt.TrackBefore : qt.TrackAfter : qt.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? Xr.WidgetRange : this.startSide <= 0 ? Xr.WidgetBefore : Xr.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof vi && iP(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, r = e) {
    if (this.isReplace && (e > r || e == r && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && r != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, r);
  }
}
vi.prototype.point = !0;
function zv(t, e = !1) {
  let { inclusiveStart: r, inclusiveEnd: n } = t;
  return r == null && (r = t.inclusive), n == null && (n = t.inclusive), { start: r ?? e, end: n ?? e };
}
function iP(t, e) {
  return t == e || !!(t && e && t.compare(e));
}
function yh(t, e, r, n = 0) {
  let i = r.length - 1;
  i >= 0 && r[i] + n >= t ? r[i] = Math.max(r[i], e) : r.push(t, e);
}
class Ra {
  constructor(e, r, n, i) {
    this.doc = e, this.pos = r, this.end = n, this.disallowBlockEffectsFor = i, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = r;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !(e.breakAfter || e instanceof di && e.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new Ot()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(Hl(new mo(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof di) && this.getLine();
  }
  buildText(e, r, n) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: s, lineBreak: o, done: a } = this.cursor.next(this.skip);
        if (this.skip = 0, a)
          throw new Error("Ran out of text content when drawing inline views");
        if (o) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = s, this.textOff = 0;
      }
      let i = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* T.Chunk */
      );
      this.flushBuffer(r.slice(r.length - n)), this.getLine().append(Hl(new qn(this.text.slice(this.textOff, this.textOff + i)), r), n), this.atCursorPos = !0, this.textOff += i, e -= i, n = 0;
    }
  }
  span(e, r, n, i) {
    this.buildText(r - e, n, i), this.pos = r, this.openStart < 0 && (this.openStart = i);
  }
  point(e, r, n, i, s, o) {
    if (this.disallowBlockEffectsFor[o] && n instanceof vi) {
      if (n.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (r > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let a = r - e;
    if (n instanceof vi)
      if (n.block)
        n.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new di(n.widget || new U0("div"), a, n));
      else {
        let l = Hi.create(n.widget || new U0("span"), a, a ? 0 : n.startSide), c = this.atCursorPos && !l.isEditable && s <= i.length && (e < r || n.startSide > 0), u = !l.isEditable && (e < r || s > i.length || n.startSide <= 0), d = this.getLine();
        this.pendingBuffer == 2 && !c && !l.isEditable && (this.pendingBuffer = 0), this.flushBuffer(i), c && (d.append(Hl(new mo(1), i), s), s = i.length + Math.max(0, s - i.length)), d.append(Hl(l, i), s), this.atCursorPos = u, this.pendingBuffer = u ? e < r || s > i.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = i.slice());
      }
    else
      this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(n);
    a && (this.textOff + a <= this.text.length ? this.textOff += a : (this.skip += a - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = r), this.openStart < 0 && (this.openStart = s);
  }
  static build(e, r, n, i, s) {
    let o = new Ra(e, r, n, s);
    return o.openEnd = ze.spans(i, r, n, o), o.openStart < 0 && (o.openStart = o.openEnd), o.finish(o.openEnd), o;
  }
}
function Hl(t, e) {
  for (let r of e)
    t = new Nn(r, [t], t.length);
  return t;
}
class U0 extends Ro {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
var mt = /* @__PURE__ */ function(t) {
  return t[t.LTR = 0] = "LTR", t[t.RTL = 1] = "RTL", t;
}(mt || (mt = {}));
const cs = mt.LTR, sm = mt.RTL;
function Xv(t) {
  let e = [];
  for (let r = 0; r < t.length; r++)
    e.push(1 << +t[r]);
  return e;
}
const sP = /* @__PURE__ */ Xv("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), oP = /* @__PURE__ */ Xv("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), bh = /* @__PURE__ */ Object.create(null), tn = [];
for (let t of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ t.charCodeAt(0), r = /* @__PURE__ */ t.charCodeAt(1);
  bh[e] = r, bh[r] = -e;
}
function Wv(t) {
  return t <= 247 ? sP[t] : 1424 <= t && t <= 1524 ? 2 : 1536 <= t && t <= 1785 ? oP[t - 1536] : 1774 <= t && t <= 2220 ? 4 : 8192 <= t && t <= 8204 ? 256 : 64336 <= t && t <= 65023 ? 4 : 1;
}
const aP = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class ai {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? sm : cs;
  }
  /**
  @internal
  */
  constructor(e, r, n) {
    this.from = e, this.to = r, this.level = n;
  }
  /**
  @internal
  */
  side(e, r) {
    return this.dir == r == e ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(e, r) {
    return e == (this.dir == r);
  }
  /**
  @internal
  */
  static find(e, r, n, i) {
    let s = -1;
    for (let o = 0; o < e.length; o++) {
      let a = e[o];
      if (a.from <= r && a.to >= r) {
        if (a.level == n)
          return o;
        (s < 0 || (i != 0 ? i < 0 ? a.from < r : a.to > r : e[s].level > a.level)) && (s = o);
      }
    }
    if (s < 0)
      throw new RangeError("Index out of range");
    return s;
  }
}
function Uv(t, e) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++) {
    let n = t[r], i = e[r];
    if (n.from != i.from || n.to != i.to || n.direction != i.direction || !Uv(n.inner, i.inner))
      return !1;
  }
  return !0;
}
const Ue = [];
function lP(t, e, r, n, i) {
  for (let s = 0; s <= n.length; s++) {
    let o = s ? n[s - 1].to : e, a = s < n.length ? n[s].from : r, l = s ? 256 : i;
    for (let c = o, u = l, d = l; c < a; c++) {
      let f = Wv(t.charCodeAt(c));
      f == 512 ? f = u : f == 8 && d == 4 && (f = 16), Ue[c] = f == 4 ? 2 : f, f & 7 && (d = f), u = f;
    }
    for (let c = o, u = l, d = l; c < a; c++) {
      let f = Ue[c];
      if (f == 128)
        c < a - 1 && u == Ue[c + 1] && u & 24 ? f = Ue[c] = u : Ue[c] = 256;
      else if (f == 64) {
        let h = c + 1;
        for (; h < a && Ue[h] == 64; )
          h++;
        let p = c && u == 8 || h < r && Ue[h] == 8 ? d == 1 ? 1 : 8 : 256;
        for (let g = c; g < h; g++)
          Ue[g] = p;
        c = h - 1;
      } else
        f == 8 && d == 1 && (Ue[c] = 1);
      u = f, f & 7 && (d = f);
    }
  }
}
function cP(t, e, r, n, i) {
  let s = i == 1 ? 2 : 1;
  for (let o = 0, a = 0, l = 0; o <= n.length; o++) {
    let c = o ? n[o - 1].to : e, u = o < n.length ? n[o].from : r;
    for (let d = c, f, h, p; d < u; d++)
      if (h = bh[f = t.charCodeAt(d)])
        if (h < 0) {
          for (let g = a - 3; g >= 0; g -= 3)
            if (tn[g + 1] == -h) {
              let m = tn[g + 2], y = m & 2 ? i : m & 4 ? m & 1 ? s : i : 0;
              y && (Ue[d] = Ue[tn[g]] = y), a = g;
              break;
            }
        } else {
          if (tn.length == 189)
            break;
          tn[a++] = d, tn[a++] = f, tn[a++] = l;
        }
      else if ((p = Ue[d]) == 2 || p == 1) {
        let g = p == i;
        l = g ? 0 : 1;
        for (let m = a - 3; m >= 0; m -= 3) {
          let y = tn[m + 2];
          if (y & 2)
            break;
          if (g)
            tn[m + 2] |= 2;
          else {
            if (y & 4)
              break;
            tn[m + 2] |= 4;
          }
        }
      }
  }
}
function uP(t, e, r, n) {
  for (let i = 0, s = n; i <= r.length; i++) {
    let o = i ? r[i - 1].to : t, a = i < r.length ? r[i].from : e;
    for (let l = o; l < a; ) {
      let c = Ue[l];
      if (c == 256) {
        let u = l + 1;
        for (; ; )
          if (u == a) {
            if (i == r.length)
              break;
            u = r[i++].to, a = i < r.length ? r[i].from : e;
          } else if (Ue[u] == 256)
            u++;
          else
            break;
        let d = s == 1, f = (u < e ? Ue[u] : n) == 1, h = d == f ? d ? 1 : 2 : n;
        for (let p = u, g = i, m = g ? r[g - 1].to : t; p > l; )
          p == m && (p = r[--g].from, m = g ? r[g - 1].to : t), Ue[--p] = h;
        l = u;
      } else
        s = c, l++;
    }
  }
}
function vh(t, e, r, n, i, s, o) {
  let a = n % 2 ? 2 : 1;
  if (n % 2 == i % 2)
    for (let l = e, c = 0; l < r; ) {
      let u = !0, d = !1;
      if (c == s.length || l < s[c].from) {
        let g = Ue[l];
        g != a && (u = !1, d = g == 16);
      }
      let f = !u && a == 1 ? [] : null, h = u ? n : n + 1, p = l;
      e:
        for (; ; )
          if (c < s.length && p == s[c].from) {
            if (d)
              break e;
            let g = s[c];
            if (!u)
              for (let m = g.to, y = c + 1; ; ) {
                if (m == r)
                  break e;
                if (y < s.length && s[y].from == m)
                  m = s[y++].to;
                else {
                  if (Ue[m] == a)
                    break e;
                  break;
                }
              }
            if (c++, f)
              f.push(g);
            else {
              g.from > l && o.push(new ai(l, g.from, h));
              let m = g.direction == cs != !(h % 2);
              wh(t, m ? n + 1 : n, i, g.inner, g.from, g.to, o), l = g.to;
            }
            p = g.to;
          } else {
            if (p == r || (u ? Ue[p] != a : Ue[p] == a))
              break;
            p++;
          }
      f ? vh(t, l, p, n + 1, i, f, o) : l < p && o.push(new ai(l, p, h)), l = p;
    }
  else
    for (let l = r, c = s.length; l > e; ) {
      let u = !0, d = !1;
      if (!c || l > s[c - 1].to) {
        let g = Ue[l - 1];
        g != a && (u = !1, d = g == 16);
      }
      let f = !u && a == 1 ? [] : null, h = u ? n : n + 1, p = l;
      e:
        for (; ; )
          if (c && p == s[c - 1].to) {
            if (d)
              break e;
            let g = s[--c];
            if (!u)
              for (let m = g.from, y = c; ; ) {
                if (m == e)
                  break e;
                if (y && s[y - 1].to == m)
                  m = s[--y].from;
                else {
                  if (Ue[m - 1] == a)
                    break e;
                  break;
                }
              }
            if (f)
              f.push(g);
            else {
              g.to < l && o.push(new ai(g.to, l, h));
              let m = g.direction == cs != !(h % 2);
              wh(t, m ? n + 1 : n, i, g.inner, g.from, g.to, o), l = g.from;
            }
            p = g.from;
          } else {
            if (p == e || (u ? Ue[p - 1] != a : Ue[p - 1] == a))
              break;
            p--;
          }
      f ? vh(t, p, l, n + 1, i, f, o) : p < l && o.push(new ai(p, l, h)), l = p;
    }
}
function wh(t, e, r, n, i, s, o) {
  let a = e % 2 ? 2 : 1;
  lP(t, i, s, n, a), cP(t, i, s, n, a), uP(i, s, n, a), vh(t, i, s, e, r, n, o);
}
function dP(t, e, r) {
  if (!t)
    return [new ai(0, 0, e == sm ? 1 : 0)];
  if (e == cs && !r.length && !aP.test(t))
    return Vv(t.length);
  if (r.length)
    for (; t.length > Ue.length; )
      Ue[Ue.length] = 256;
  let n = [], i = e == cs ? 0 : 1;
  return wh(t, i, i, r, 0, t.length, n), n;
}
function Vv(t) {
  return [new ai(0, t, 0)];
}
let Lv = "";
function fP(t, e, r, n, i) {
  var s;
  let o = n.head - t.from, a = ai.find(e, o, (s = n.bidiLevel) !== null && s !== void 0 ? s : -1, n.assoc), l = e[a], c = l.side(i, r);
  if (o == c) {
    let f = a += i ? 1 : -1;
    if (f < 0 || f >= e.length)
      return null;
    l = e[a = f], o = l.side(!i, r), c = l.side(i, r);
  }
  let u = fn(t.text, o, l.forward(i, r));
  (u < l.from || u > l.to) && (u = c), Lv = t.text.slice(Math.min(o, u), Math.max(o, u));
  let d = a == (i ? e.length - 1 : 0) ? null : e[a + (i ? 1 : -1)];
  return d && u == c && d.level + (i ? 0 : 1) < l.level ? ce.cursor(d.side(!i, r) + t.from, d.forward(i, r) ? 1 : -1, d.level) : ce.cursor(u + t.from, l.forward(i, r) ? -1 : 1, l.level);
}
function hP(t, e, r) {
  for (let n = e; n < r; n++) {
    let i = Wv(t.charCodeAt(n));
    if (i == 1)
      return cs;
    if (i == 2 || i == 4)
      return sm;
  }
  return cs;
}
const Yv = /* @__PURE__ */ be.define(), Bv = /* @__PURE__ */ be.define(), Fv = /* @__PURE__ */ be.define(), Hv = /* @__PURE__ */ be.define(), $h = /* @__PURE__ */ be.define(), Gv = /* @__PURE__ */ be.define(), Kv = /* @__PURE__ */ be.define(), Jv = /* @__PURE__ */ be.define({
  combine: (t) => t.some((e) => e)
}), pP = /* @__PURE__ */ be.define({
  combine: (t) => t.some((e) => e)
});
class eo {
  constructor(e, r = "nearest", n = "nearest", i = 5, s = 5, o = !1) {
    this.range = e, this.y = r, this.x = n, this.yMargin = i, this.xMargin = s, this.isSnapshot = o;
  }
  map(e) {
    return e.empty ? this : new eo(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(e) {
    return this.range.to <= e.doc.length ? this : new eo(ce.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const Gl = /* @__PURE__ */ Le.define({ map: (t, e) => t.map(e) });
function Wr(t, e, r) {
  let n = t.facet(Hv);
  n.length ? n[0](e) : window.onerror ? window.onerror(String(e), r, void 0, void 0, e) : r ? console.error(r + ":", e) : console.error(e);
}
const Hu = /* @__PURE__ */ be.define({ combine: (t) => t.length ? t[0] : !0 });
let mP = 0;
const va = /* @__PURE__ */ be.define();
class Pr {
  constructor(e, r, n, i, s) {
    this.id = e, this.create = r, this.domEventHandlers = n, this.domEventObservers = i, this.extension = s(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, r) {
    const { eventHandlers: n, eventObservers: i, provide: s, decorations: o } = r || {};
    return new Pr(mP++, e, n, i, (a) => {
      let l = [va.of(a)];
      return o && l.push(Ga.of((c) => {
        let u = c.plugin(a);
        return u ? o(u) : We.none;
      })), s && l.push(s(a)), l;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, r) {
    return Pr.define((n) => new e(n), r);
  }
}
class Dd {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let r = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(r);
          } catch (n) {
            if (Wr(r.state, n, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (r) {
        Wr(e.state, r, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var r;
    if (!((r = this.value) === null || r === void 0) && r.destroy)
      try {
        this.value.destroy();
      } catch (n) {
        Wr(e.state, n, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const ew = /* @__PURE__ */ be.define(), om = /* @__PURE__ */ be.define(), Ga = /* @__PURE__ */ be.define(), tw = /* @__PURE__ */ be.define(), am = /* @__PURE__ */ be.define(), rw = /* @__PURE__ */ be.define();
function V0(t, e) {
  let r = t.state.facet(rw);
  if (!r.length)
    return r;
  let n = r.map((s) => s instanceof Function ? s(t) : s), i = [];
  return ze.spans(n, e.from, e.to, {
    point() {
    },
    span(s, o, a, l) {
      let c = s - e.from, u = o - e.from, d = i;
      for (let f = a.length - 1; f >= 0; f--, l--) {
        let h = a[f].spec.bidiIsolate, p;
        if (h == null && (h = hP(e.text, c, u)), l > 0 && d.length && (p = d[d.length - 1]).to == c && p.direction == h)
          p.to = u, d = p.inner;
        else {
          let g = { from: c, to: u, direction: h, inner: [] };
          d.push(g), d = g.inner;
        }
      }
    }
  }), i;
}
const nw = /* @__PURE__ */ be.define();
function iw(t) {
  let e = 0, r = 0, n = 0, i = 0;
  for (let s of t.state.facet(nw)) {
    let o = s(t);
    o && (o.left != null && (e = Math.max(e, o.left)), o.right != null && (r = Math.max(r, o.right)), o.top != null && (n = Math.max(n, o.top)), o.bottom != null && (i = Math.max(i, o.bottom)));
  }
  return { left: e, right: r, top: n, bottom: i };
}
const wa = /* @__PURE__ */ be.define();
class Sr {
  constructor(e, r, n, i) {
    this.fromA = e, this.toA = r, this.fromB = n, this.toB = i;
  }
  join(e) {
    return new Sr(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let r = e.length, n = this;
    for (; r > 0; r--) {
      let i = e[r - 1];
      if (!(i.fromA > n.toA)) {
        if (i.toA < n.fromA)
          break;
        n = n.join(i), e.splice(r - 1, 1);
      }
    }
    return e.splice(r, 0, n), e;
  }
  static extendWithRanges(e, r) {
    if (r.length == 0)
      return e;
    let n = [];
    for (let i = 0, s = 0, o = 0, a = 0; ; i++) {
      let l = i == e.length ? null : e[i], c = o - a, u = l ? l.fromB : 1e9;
      for (; s < r.length && r[s] < u; ) {
        let d = r[s], f = r[s + 1], h = Math.max(a, d), p = Math.min(u, f);
        if (h <= p && new Sr(h + c, p + c, h, p).addToSet(n), f > u)
          break;
        s += 2;
      }
      if (!l)
        return n;
      new Sr(l.fromA, l.toA, l.fromB, l.toB).addToSet(n), o = l.toA, a = l.toB;
    }
  }
}
class eu {
  constructor(e, r, n) {
    this.view = e, this.state = r, this.transactions = n, this.flags = 0, this.startState = e.state, this.changes = wt.empty(this.startState.doc.length);
    for (let s of n)
      this.changes = this.changes.compose(s.changes);
    let i = [];
    this.changes.iterChangedRanges((s, o, a, l) => i.push(new Sr(s, o, a, l))), this.changedRanges = i;
  }
  /**
  @internal
  */
  static create(e, r, n) {
    return new eu(e, r, n);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class L0 extends et {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new Ot()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new Sr(0, 0, 0, e.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(e) {
    var r;
    let n = e.changedRanges;
    this.minWidth > 0 && n.length && (n.every(({ fromA: c, toA: u }) => u < this.minWidthFrom || c > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0);
    let i = -1;
    this.view.inputState.composing >= 0 && (!((r = this.domChanged) === null || r === void 0) && r.newSel ? i = this.domChanged.newSel.head : !$P(e.changes, this.hasComposition) && !e.selectionSet && (i = e.state.selection.main.head));
    let s = i > -1 ? OP(this.view, e.changes, i) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: c, to: u } = this.hasComposition;
      n = new Sr(c, u, e.changes.mapPos(c, -1), e.changes.mapPos(u, 1)).addToSet(n.slice());
    }
    this.hasComposition = s ? { from: s.range.fromB, to: s.range.toB } : null, (de.ie || de.chrome) && !s && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let o = this.decorations, a = this.updateDeco(), l = vP(o, a, e.changes);
    return n = Sr.extendWithRanges(n, l), !(this.flags & 7) && n.length == 0 ? !1 : (this.updateInner(n, e.startState.doc.length, s), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, r, n) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, r, n);
    let { observer: i } = this.view;
    i.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let o = de.chrome || de.ios ? { node: i.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, o), this.flags &= -8, o && (o.written || i.selectionRange.focusNode != o.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (o) => o.flags &= -9
      /* ViewFlag.Composition */
    );
    let s = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let o of this.children)
        o instanceof di && o.widget instanceof Y0 && s.push(o.dom);
    i.updateGaps(s);
  }
  updateChildren(e, r, n) {
    let i = n ? n.range.addToSet(e.slice()) : e, s = this.childCursor(r);
    for (let o = i.length - 1; ; o--) {
      let a = o >= 0 ? i[o] : null;
      if (!a)
        break;
      let { fromA: l, toA: c, fromB: u, toB: d } = a, f, h, p, g;
      if (n && n.range.fromB < d && n.range.toB > u) {
        let w = Ra.build(this.view.state.doc, u, n.range.fromB, this.decorations, this.dynamicDecorationMap), S = Ra.build(this.view.state.doc, n.range.toB, d, this.decorations, this.dynamicDecorationMap);
        h = w.breakAtStart, p = w.openStart, g = S.openEnd;
        let $ = this.compositionView(n);
        S.breakAtStart ? $.breakAfter = 1 : S.content.length && $.merge($.length, $.length, S.content[0], !1, S.openStart, 0) && ($.breakAfter = S.content[0].breakAfter, S.content.shift()), w.content.length && $.merge(0, 0, w.content[w.content.length - 1], !0, 0, w.openEnd) && w.content.pop(), f = w.content.concat($).concat(S.content);
      } else
        ({ content: f, breakAtStart: h, openStart: p, openEnd: g } = Ra.build(this.view.state.doc, u, d, this.decorations, this.dynamicDecorationMap));
      let { i: m, off: y } = s.findPos(c, 1), { i: O, off: b } = s.findPos(l, -1);
      Iv(this, O, b, m, y, f, h, p, g);
    }
    n && this.fixCompositionDOM(n);
  }
  compositionView(e) {
    let r = new qn(e.text.nodeValue);
    r.flags |= 8;
    for (let { deco: i } of e.marks)
      r = new Nn(i, [r], r.length);
    let n = new Ot();
    return n.append(r, 0), n;
  }
  fixCompositionDOM(e) {
    let r = (s, o) => {
      o.flags |= 8 | (o.children.some(
        (l) => l.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(o);
      let a = et.get(s);
      a && a != o && (a.dom = null), o.setDOM(s);
    }, n = this.childPos(e.range.fromB, 1), i = this.children[n.i];
    r(e.line, i);
    for (let s = e.marks.length - 1; s >= -1; s--)
      n = i.childPos(n.off, 1), i = i.children[n.i], r(s >= 0 ? e.marks[s].node : e.text, i);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, r = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let n = this.view.root.activeElement, i = n == this.dom, s = !i && Tc(this.dom, this.view.observer.selectionRange) && !(n && this.dom.contains(n));
    if (!(i || r || s))
      return;
    let o = this.forceSelection;
    this.forceSelection = !1;
    let a = this.view.state.selection.main, l = this.moveToLine(this.domAtPos(a.anchor)), c = a.empty ? l : this.moveToLine(this.domAtPos(a.head));
    if (de.gecko && a.empty && !this.hasComposition && gP(l)) {
      let d = document.createTextNode("");
      this.view.observer.ignore(() => l.node.insertBefore(d, l.node.childNodes[l.offset] || null)), l = c = new Nt(d, 0), o = !0;
    }
    let u = this.view.observer.selectionRange;
    (o || !u.focusNode || (!Ea(l.node, l.offset, u.anchorNode, u.anchorOffset) || !Ea(c.node, c.offset, u.focusNode, u.focusOffset)) && !this.suppressWidgetCursorChange(u, a)) && (this.view.observer.ignore(() => {
      de.android && de.chrome && this.dom.contains(u.focusNode) && wP(u.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let d = Jc(this.view.root);
      if (d)
        if (a.empty) {
          if (de.gecko) {
            let f = yP(l.node, l.offset);
            if (f && f != 3) {
              let h = ow(l.node, l.offset, f == 1 ? 1 : -1);
              h && (l = new Nt(h.node, h.offset));
            }
          }
          d.collapse(l.node, l.offset), a.bidiLevel != null && d.caretBidiLevel !== void 0 && (d.caretBidiLevel = a.bidiLevel);
        } else if (d.extend) {
          d.collapse(l.node, l.offset);
          try {
            d.extend(c.node, c.offset);
          } catch {
          }
        } else {
          let f = document.createRange();
          a.anchor > a.head && ([l, c] = [c, l]), f.setEnd(c.node, c.offset), f.setStart(l.node, l.offset), d.removeAllRanges(), d.addRange(f);
        }
      s && this.view.root.activeElement == this.dom && (this.dom.blur(), n && n.focus());
    }), this.view.observer.setSelectionRange(l, c)), this.impreciseAnchor = l.precise ? null : new Nt(u.anchorNode, u.anchorOffset), this.impreciseHead = c.precise ? null : new Nt(u.focusNode, u.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(e, r) {
    return this.hasComposition && r.empty && Ea(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == r.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, r = e.state.selection.main, n = Jc(e.root), { anchorNode: i, anchorOffset: s } = e.observer.selectionRange;
    if (!n || !r.empty || !r.assoc || !n.modify)
      return;
    let o = Ot.find(this, r.head);
    if (!o)
      return;
    let a = o.posAtStart;
    if (r.head == a || r.head == a + o.length)
      return;
    let l = this.coordsAt(r.head, -1), c = this.coordsAt(r.head, 1);
    if (!l || !c || l.bottom > c.top)
      return;
    let u = this.domAtPos(r.head + r.assoc);
    n.collapse(u.node, u.offset), n.modify("move", r.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let d = e.observer.selectionRange;
    e.docView.posFromDOM(d.anchorNode, d.anchorOffset) != r.from && n.collapse(i, s);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(e) {
    let r = this.dom, n;
    if (e.node != r)
      return e;
    for (let i = e.offset; !n && i < r.childNodes.length; i++) {
      let s = et.get(r.childNodes[i]);
      s instanceof Ot && (n = s.domAtPos(0));
    }
    for (let i = e.offset - 1; !n && i >= 0; i--) {
      let s = et.get(r.childNodes[i]);
      s instanceof Ot && (n = s.domAtPos(s.length));
    }
    return n ? new Nt(n.node, n.offset, !0) : e;
  }
  nearest(e) {
    for (let r = e; r; ) {
      let n = et.get(r);
      if (n && n.rootView == this)
        return n;
      r = r.parentNode;
    }
    return null;
  }
  posFromDOM(e, r) {
    let n = this.nearest(e);
    if (!n)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return n.localPosFromDOM(e, r) + n.posAtStart;
  }
  domAtPos(e) {
    let { i: r, off: n } = this.childCursor().findPos(e, -1);
    for (; r < this.children.length - 1; ) {
      let i = this.children[r];
      if (n < i.length || i instanceof Ot)
        break;
      r++, n = 0;
    }
    return this.children[r].domAtPos(n);
  }
  coordsAt(e, r) {
    let n = null, i = 0;
    for (let s = this.length, o = this.children.length - 1; o >= 0; o--) {
      let a = this.children[o], l = s - a.breakAfter, c = l - a.length;
      if (l < e)
        break;
      c <= e && (c < e || a.covers(-1)) && (l > e || a.covers(1)) && (!n || a instanceof Ot && !(n instanceof Ot && r >= 0)) && (n = a, i = c), s = c;
    }
    return n ? n.coordsAt(e - i, r) : null;
  }
  coordsForChar(e) {
    let { i: r, off: n } = this.childPos(e, 1), i = this.children[r];
    if (!(i instanceof Ot))
      return null;
    for (; i.children.length; ) {
      let { i: a, off: l } = i.childPos(n, 1);
      for (; ; a++) {
        if (a == i.children.length)
          return null;
        if ((i = i.children[a]).length)
          break;
      }
      n = l;
    }
    if (!(i instanceof qn))
      return null;
    let s = fn(i.text, n);
    if (s == n)
      return null;
    let o = ls(i.dom, n, s).getClientRects();
    for (let a = 0; a < o.length; a++) {
      let l = o[a];
      if (a == o.length - 1 || l.top < l.bottom && l.left < l.right)
        return l;
    }
    return null;
  }
  measureVisibleLineHeights(e) {
    let r = [], { from: n, to: i } = e, s = this.view.contentDOM.clientWidth, o = s > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, a = -1, l = this.view.textDirection == mt.LTR;
    for (let c = 0, u = 0; u < this.children.length; u++) {
      let d = this.children[u], f = c + d.length;
      if (f > i)
        break;
      if (c >= n) {
        let h = d.dom.getBoundingClientRect();
        if (r.push(h.height), o) {
          let p = d.dom.lastChild, g = p ? Fa(p) : [];
          if (g.length) {
            let m = g[g.length - 1], y = l ? m.right - h.left : h.right - m.left;
            y > a && (a = y, this.minWidth = s, this.minWidthFrom = c, this.minWidthTo = f);
          }
        }
      }
      c = f + d.breakAfter;
    }
    return r;
  }
  textDirectionAt(e) {
    let { i: r } = this.childPos(e, 1);
    return getComputedStyle(this.children[r].dom).direction == "rtl" ? mt.RTL : mt.LTR;
  }
  measureTextSize() {
    for (let s of this.children)
      if (s instanceof Ot) {
        let o = s.measureTextSize();
        if (o)
          return o;
      }
    let e = document.createElement("div"), r, n, i;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let s = Fa(e.firstChild)[0];
      r = e.getBoundingClientRect().height, n = s ? s.width / 27 : 7, i = s ? s.height : r, e.remove();
    }), { lineHeight: r, charWidth: n, textHeight: i };
  }
  childCursor(e = this.length) {
    let r = this.children.length;
    return r && (e -= this.children[--r].length), new Rv(this.children, e, r);
  }
  computeBlockGapDeco() {
    let e = [], r = this.view.viewState;
    for (let n = 0, i = 0; ; i++) {
      let s = i == r.viewports.length ? null : r.viewports[i], o = s ? s.from - 1 : this.length;
      if (o > n) {
        let a = (r.lineBlockAt(o).bottom - r.lineBlockAt(n).top) / this.view.scaleY;
        e.push(We.replace({
          widget: new Y0(a),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(n, o));
      }
      if (!s)
        break;
      n = s.to + 1;
    }
    return We.set(e);
  }
  updateDeco() {
    let e = this.view.state.facet(Ga).map((i, s) => (this.dynamicDecorationMap[s] = typeof i == "function") ? i(this.view) : i), r = !1, n = this.view.state.facet(tw).map((i, s) => {
      let o = typeof i == "function";
      return o && (r = !0), o ? i(this.view) : i;
    });
    n.length && (this.dynamicDecorationMap[e.length] = r, e.push(ze.join(n)));
    for (let i = e.length; i < e.length + 3; i++)
      this.dynamicDecorationMap[i] = !1;
    return this.decorations = [
      ...e,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
  }
  scrollIntoView(e) {
    if (e.isSnapshot) {
      let c = this.view.viewState.lineBlockAt(e.range.head);
      this.view.scrollDOM.scrollTop = c.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;
      return;
    }
    let { range: r } = e, n = this.coordsAt(r.head, r.empty ? r.assoc : r.head > r.anchor ? -1 : 1), i;
    if (!n)
      return;
    !r.empty && (i = this.coordsAt(r.anchor, r.anchor > r.head ? -1 : 1)) && (n = {
      left: Math.min(n.left, i.left),
      top: Math.min(n.top, i.top),
      right: Math.max(n.right, i.right),
      bottom: Math.max(n.bottom, i.bottom)
    });
    let s = iw(this.view), o = {
      left: n.left - s.left,
      top: n.top - s.top,
      right: n.right + s.right,
      bottom: n.bottom + s.bottom
    }, { offsetWidth: a, offsetHeight: l } = this.view.scrollDOM;
    F_(this.view.scrollDOM, o, r.head < r.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, a), -a), Math.max(Math.min(e.yMargin, l), -l), this.view.textDirection == mt.LTR);
  }
}
function gP(t) {
  return t.node.nodeType == 1 && t.node.firstChild && (t.offset == 0 || t.node.childNodes[t.offset - 1].contentEditable == "false") && (t.offset == t.node.childNodes.length || t.node.childNodes[t.offset].contentEditable == "false");
}
class Y0 extends Ro {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return e.className = "cm-gap", this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
function sw(t, e) {
  let r = t.observer.selectionRange, n = r.focusNode && ow(r.focusNode, r.focusOffset, 0);
  if (!n)
    return null;
  let i = e - n.offset;
  return { from: i, to: i + n.node.nodeValue.length, node: n.node };
}
function OP(t, e, r) {
  let n = sw(t, r);
  if (!n)
    return null;
  let { node: i, from: s, to: o } = n, a = i.nodeValue;
  if (/[\n\r]/.test(a) || t.state.doc.sliceString(n.from, n.to) != a)
    return null;
  let l = e.invertedDesc, c = new Sr(l.mapPos(s), l.mapPos(o), s, o), u = [];
  for (let d = i.parentNode; ; d = d.parentNode) {
    let f = et.get(d);
    if (f instanceof Nn)
      u.push({ node: d, deco: f.mark });
    else {
      if (f instanceof Ot || d.nodeName == "DIV" && d.parentNode == t.contentDOM)
        return { range: c, text: i, marks: u, line: d };
      if (d != t.contentDOM)
        u.push({ node: d, deco: new ml({
          inclusive: !0,
          attributes: nP(d),
          tagName: d.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function ow(t, e, r) {
  if (r <= 0)
    for (let n = t, i = e; ; ) {
      if (n.nodeType == 3)
        return { node: n, offset: i };
      if (n.nodeType == 1 && i > 0)
        n = n.childNodes[i - 1], i = Mn(n);
      else
        break;
    }
  if (r >= 0)
    for (let n = t, i = e; ; ) {
      if (n.nodeType == 3)
        return { node: n, offset: i };
      if (n.nodeType == 1 && i < n.childNodes.length && r >= 0)
        n = n.childNodes[i], i = 0;
      else
        break;
    }
  return null;
}
function yP(t, e) {
  return t.nodeType != 1 ? 0 : (e && t.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < t.childNodes.length && t.childNodes[e].contentEditable == "false" ? 2 : 0);
}
let bP = class {
  constructor() {
    this.changes = [];
  }
  compareRange(e, r) {
    yh(e, r, this.changes);
  }
  comparePoint(e, r) {
    yh(e, r, this.changes);
  }
};
function vP(t, e, r) {
  let n = new bP();
  return ze.compare(t, e, r, n), n.changes;
}
function wP(t, e) {
  for (let r = t; r && r != e; r = r.assignedSlot || r.parentNode)
    if (r.nodeType == 1 && r.contentEditable == "false")
      return !0;
  return !1;
}
function $P(t, e) {
  let r = !1;
  return e && t.iterChangedRanges((n, i) => {
    n < e.to && i > e.from && (r = !0);
  }), r;
}
function SP(t, e, r = 1) {
  let n = t.charCategorizer(e), i = t.doc.lineAt(e), s = e - i.from;
  if (i.length == 0)
    return ce.cursor(e);
  s == 0 ? r = 1 : s == i.length && (r = -1);
  let o = s, a = s;
  r < 0 ? o = fn(i.text, s, !1) : a = fn(i.text, s);
  let l = n(i.text.slice(o, a));
  for (; o > 0; ) {
    let c = fn(i.text, o, !1);
    if (n(i.text.slice(c, o)) != l)
      break;
    o = c;
  }
  for (; a < i.length; ) {
    let c = fn(i.text, a);
    if (n(i.text.slice(a, c)) != l)
      break;
    a = c;
  }
  return ce.range(o + i.from, a + i.from);
}
function kP(t, e) {
  return e.left > t ? e.left - t : Math.max(0, t - e.right);
}
function _P(t, e) {
  return e.top > t ? e.top - t : Math.max(0, t - e.bottom);
}
function zd(t, e) {
  return t.top < e.bottom - 1 && t.bottom > e.top + 1;
}
function B0(t, e) {
  return e < t.top ? { top: e, left: t.left, right: t.right, bottom: t.bottom } : t;
}
function F0(t, e) {
  return e > t.bottom ? { top: t.top, left: t.left, right: t.right, bottom: e } : t;
}
function Sh(t, e, r) {
  let n, i, s, o, a = !1, l, c, u, d;
  for (let p = t.firstChild; p; p = p.nextSibling) {
    let g = Fa(p);
    for (let m = 0; m < g.length; m++) {
      let y = g[m];
      i && zd(i, y) && (y = B0(F0(y, i.bottom), i.top));
      let O = kP(e, y), b = _P(r, y);
      if (O == 0 && b == 0)
        return p.nodeType == 3 ? H0(p, e, r) : Sh(p, e, r);
      if (!n || o > b || o == b && s > O) {
        n = p, i = y, s = O, o = b;
        let w = b ? r < y.top ? -1 : 1 : O ? e < y.left ? -1 : 1 : 0;
        a = !w || (w > 0 ? m < g.length - 1 : m > 0);
      }
      O == 0 ? r > y.bottom && (!u || u.bottom < y.bottom) ? (l = p, u = y) : r < y.top && (!d || d.top > y.top) && (c = p, d = y) : u && zd(u, y) ? u = F0(u, y.bottom) : d && zd(d, y) && (d = B0(d, y.top));
    }
  }
  if (u && u.bottom >= r ? (n = l, i = u) : d && d.top <= r && (n = c, i = d), !n)
    return { node: t, offset: 0 };
  let f = Math.max(i.left, Math.min(i.right, e));
  if (n.nodeType == 3)
    return H0(n, f, r);
  if (a && n.contentEditable != "false")
    return Sh(n, f, r);
  let h = Array.prototype.indexOf.call(t.childNodes, n) + (e >= (i.left + i.right) / 2 ? 1 : 0);
  return { node: t, offset: h };
}
function H0(t, e, r) {
  let n = t.nodeValue.length, i = -1, s = 1e9, o = 0;
  for (let a = 0; a < n; a++) {
    let l = ls(t, a, a + 1).getClientRects();
    for (let c = 0; c < l.length; c++) {
      let u = l[c];
      if (u.top == u.bottom)
        continue;
      o || (o = e - u.left);
      let d = (u.top > r ? u.top - r : r - u.bottom) - 1;
      if (u.left - 1 <= e && u.right + 1 >= e && d < s) {
        let f = e >= (u.left + u.right) / 2, h = f;
        if ((de.chrome || de.gecko) && ls(t, a).getBoundingClientRect().left == u.right && (h = !f), d <= 0)
          return { node: t, offset: a + (h ? 1 : 0) };
        i = a + (h ? 1 : 0), s = d;
      }
    }
  }
  return { node: t, offset: i > -1 ? i : o > 0 ? t.nodeValue.length : 0 };
}
function aw(t, e, r, n = -1) {
  var i, s;
  let o = t.contentDOM.getBoundingClientRect(), a = o.top + t.viewState.paddingTop, l, { docHeight: c } = t.viewState, { x: u, y: d } = e, f = d - a;
  if (f < 0)
    return 0;
  if (f > c)
    return t.state.doc.length;
  for (let w = t.viewState.heightOracle.textHeight / 2, S = !1; l = t.elementAtHeight(f), l.type != Xr.Text; )
    for (; f = n > 0 ? l.bottom + w : l.top - w, !(f >= 0 && f <= c); ) {
      if (S)
        return r ? null : 0;
      S = !0, n = -n;
    }
  d = a + f;
  let h = l.from;
  if (h < t.viewport.from)
    return t.viewport.from == 0 ? 0 : r ? null : G0(t, o, l, u, d);
  if (h > t.viewport.to)
    return t.viewport.to == t.state.doc.length ? t.state.doc.length : r ? null : G0(t, o, l, u, d);
  let p = t.dom.ownerDocument, g = t.root.elementFromPoint ? t.root : p, m = g.elementFromPoint(u, d);
  m && !t.contentDOM.contains(m) && (m = null), m || (u = Math.max(o.left + 1, Math.min(o.right - 1, u)), m = g.elementFromPoint(u, d), m && !t.contentDOM.contains(m) && (m = null));
  let y, O = -1;
  if (m && ((i = t.docView.nearest(m)) === null || i === void 0 ? void 0 : i.isEditable) != !1) {
    if (p.caretPositionFromPoint) {
      let w = p.caretPositionFromPoint(u, d);
      w && ({ offsetNode: y, offset: O } = w);
    } else if (p.caretRangeFromPoint) {
      let w = p.caretRangeFromPoint(u, d);
      w && ({ startContainer: y, startOffset: O } = w, (!t.contentDOM.contains(y) || de.safari && PP(y, O, u) || de.chrome && xP(y, O, u)) && (y = void 0));
    }
  }
  if (!y || !t.docView.dom.contains(y)) {
    let w = Ot.find(t.docView, h);
    if (!w)
      return f > l.top + l.height / 2 ? l.to : l.from;
    ({ node: y, offset: O } = Sh(w.dom, u, d));
  }
  let b = t.docView.nearest(y);
  if (!b)
    return null;
  if (b.isWidget && ((s = b.dom) === null || s === void 0 ? void 0 : s.nodeType) == 1) {
    let w = b.dom.getBoundingClientRect();
    return e.y < w.top || e.y <= w.bottom && e.x <= (w.left + w.right) / 2 ? b.posAtStart : b.posAtEnd;
  } else
    return b.localPosFromDOM(y, O) + b.posAtStart;
}
function G0(t, e, r, n, i) {
  let s = Math.round((n - e.left) * t.defaultCharacterWidth);
  if (t.lineWrapping && r.height > t.defaultLineHeight * 1.5) {
    let a = t.viewState.heightOracle.textHeight, l = Math.floor((i - r.top - (t.defaultLineHeight - a) * 0.5) / a);
    s += l * t.viewState.heightOracle.lineLength;
  }
  let o = t.state.sliceDoc(r.from, r.to);
  return r.from + X_(o, s, t.state.tabSize);
}
function PP(t, e, r) {
  let n;
  if (t.nodeType != 3 || e != (n = t.nodeValue.length))
    return !1;
  for (let i = t.nextSibling; i; i = i.nextSibling)
    if (i.nodeType != 1 || i.nodeName != "BR")
      return !1;
  return ls(t, n - 1, n).getBoundingClientRect().left > r;
}
function xP(t, e, r) {
  if (e != 0)
    return !1;
  for (let i = t; ; ) {
    let s = i.parentNode;
    if (!s || s.nodeType != 1 || s.firstChild != i)
      return !1;
    if (s.classList.contains("cm-line"))
      break;
    i = s;
  }
  let n = t.nodeType == 1 ? t.getBoundingClientRect() : ls(t, 0, Math.max(t.nodeValue.length, 1)).getBoundingClientRect();
  return r - n.left > 5;
}
function TP(t, e) {
  let r = t.lineBlockAt(e);
  if (Array.isArray(r.type)) {
    for (let n of r.type)
      if (n.to > e || n.to == e && (n.to == r.to || n.type == Xr.Text))
        return n;
  }
  return r;
}
function CP(t, e, r, n) {
  let i = TP(t, e.head), s = !n || i.type != Xr.Text || !(t.lineWrapping || i.widgetLineBreaks) ? null : t.coordsAtPos(e.assoc < 0 && e.head > i.from ? e.head - 1 : e.head);
  if (s) {
    let o = t.dom.getBoundingClientRect(), a = t.textDirectionAt(i.from), l = t.posAtCoords({
      x: r == (a == mt.LTR) ? o.right - 1 : o.left + 1,
      y: (s.top + s.bottom) / 2
    });
    if (l != null)
      return ce.cursor(l, r ? -1 : 1);
  }
  return ce.cursor(r ? i.to : i.from, r ? -1 : 1);
}
function K0(t, e, r, n) {
  let i = t.state.doc.lineAt(e.head), s = t.bidiSpans(i), o = t.textDirectionAt(i.from);
  for (let a = e, l = null; ; ) {
    let c = fP(i, s, o, a, r), u = Lv;
    if (!c) {
      if (i.number == (r ? t.state.doc.lines : 1))
        return a;
      u = `
`, i = t.state.doc.line(i.number + (r ? 1 : -1)), s = t.bidiSpans(i), c = t.visualLineSide(i, !r);
    }
    if (l) {
      if (!l(u))
        return a;
    } else {
      if (!n)
        return c;
      l = n(u);
    }
    a = c;
  }
}
function QP(t, e, r) {
  let n = t.state.charCategorizer(e), i = n(r);
  return (s) => {
    let o = n(s);
    return i == wr.Space && (i = o), i == o;
  };
}
function AP(t, e, r, n) {
  let i = e.head, s = r ? 1 : -1;
  if (i == (r ? t.state.doc.length : 0))
    return ce.cursor(i, e.assoc);
  let o = e.goalColumn, a, l = t.contentDOM.getBoundingClientRect(), c = t.coordsAtPos(i, e.assoc || -1), u = t.documentTop;
  if (c)
    o == null && (o = c.left - l.left), a = s < 0 ? c.top : c.bottom;
  else {
    let h = t.viewState.lineBlockAt(i);
    o == null && (o = Math.min(l.right - l.left, t.defaultCharacterWidth * (i - h.from))), a = (s < 0 ? h.top : h.bottom) + u;
  }
  let d = l.left + o, f = n ?? t.viewState.heightOracle.textHeight >> 1;
  for (let h = 0; ; h += 10) {
    let p = a + (f + h) * s, g = aw(t, { x: d, y: p }, !1, s);
    if (p < l.top || p > l.bottom || (s < 0 ? g < i : g > i)) {
      let m = t.docView.coordsForChar(g), y = !m || p < m.top ? -1 : 1;
      return ce.cursor(g, y, void 0, o);
    }
  }
}
function Cc(t, e, r) {
  for (; ; ) {
    let n = 0;
    for (let i of t)
      i.between(e - 1, e + 1, (s, o, a) => {
        if (e > s && e < o) {
          let l = n || r || (e - s < o - e ? -1 : 1);
          e = l < 0 ? s : o, n = l;
        }
      });
    if (!n)
      return e;
  }
}
function Xd(t, e, r) {
  let n = Cc(t.state.facet(am).map((i) => i(t)), r.from, e.head > r.from ? -1 : 1);
  return n == r.from ? r : ce.cursor(n, n < r.from ? 1 : -1);
}
class EP {
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  constructor(e) {
    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastEscPress = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, de.safari && e.contentDOM.addEventListener("input", () => null), de.gecko && BP(e.contentDOM.ownerDocument);
  }
  handleEvent(e) {
    !DP(this.view, e) || this.ignoreDuringComposition(e) || e.type == "keydown" && this.keydown(e) || this.runHandlers(e.type, e);
  }
  runHandlers(e, r) {
    let n = this.handlers[e];
    if (n) {
      for (let i of n.observers)
        i(this.view, r);
      for (let i of n.handlers) {
        if (r.defaultPrevented)
          break;
        if (i(this.view, r)) {
          r.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(e) {
    let r = RP(e), n = this.handlers, i = this.view.contentDOM;
    for (let s in r)
      if (s != "scroll") {
        let o = !r[s].handlers.length, a = n[s];
        a && o != !a.handlers.length && (i.removeEventListener(s, this.handleEvent), a = null), a || i.addEventListener(s, this.handleEvent, { passive: o });
      }
    for (let s in n)
      s != "scroll" && !r[s] && i.removeEventListener(s, this.handleEvent);
    this.handlers = r;
  }
  keydown(e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
      return !0;
    if (e.keyCode != 27 && cw.indexOf(e.keyCode) < 0 && (this.view.inputState.lastEscPress = 0), de.android && de.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let r;
    return de.ios && !e.synthetic && !e.altKey && !e.metaKey && ((r = lw.find((n) => n.keyCode == e.keyCode)) && !e.ctrlKey || IP.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = r || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey() {
    let e = this.pendingIOSKey;
    return e ? (this.pendingIOSKey = void 0, Js(this.view.contentDOM, e.key, e.keyCode)) : !1;
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : de.safari && !de.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function J0(t, e) {
  return (r, n) => {
    try {
      return e.call(t, n, r);
    } catch (i) {
      Wr(r.state, i);
    }
  };
}
function RP(t) {
  let e = /* @__PURE__ */ Object.create(null);
  function r(n) {
    return e[n] || (e[n] = { observers: [], handlers: [] });
  }
  for (let n of t) {
    let i = n.spec;
    if (i && i.domEventHandlers)
      for (let s in i.domEventHandlers) {
        let o = i.domEventHandlers[s];
        o && r(s).handlers.push(J0(n.value, o));
      }
    if (i && i.domEventObservers)
      for (let s in i.domEventObservers) {
        let o = i.domEventObservers[s];
        o && r(s).observers.push(J0(n.value, o));
      }
  }
  for (let n in Vr)
    r(n).handlers.push(Vr[n]);
  for (let n in Lr)
    r(n).observers.push(Lr[n]);
  return e;
}
const lw = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], IP = "dthko", cw = [16, 17, 18, 20, 91, 92, 224, 225], Kl = 6;
function Jl(t) {
  return Math.max(0, t) * 0.7 + 8;
}
function jP(t, e) {
  return Math.max(Math.abs(t.clientX - e.clientX), Math.abs(t.clientY - e.clientY));
}
class ZP {
  constructor(e, r, n, i) {
    this.view = e, this.startEvent = r, this.style = n, this.mustSelect = i, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = r, this.scrollParent = H_(e.contentDOM), this.atoms = e.state.facet(am).map((o) => o(e));
    let s = e.contentDOM.ownerDocument;
    s.addEventListener("mousemove", this.move = this.move.bind(this)), s.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = r.shiftKey, this.multiple = e.state.facet(De.allowMultipleSelections) && MP(e, r), this.dragging = NP(e, r) && hw(r) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && this.select(e);
  }
  move(e) {
    var r;
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && jP(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let n = 0, i = 0, s = ((r = this.scrollParent) === null || r === void 0 ? void 0 : r.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight }, o = iw(this.view);
    e.clientX - o.left <= s.left + Kl ? n = -Jl(s.left - e.clientX) : e.clientX + o.right >= s.right - Kl && (n = Jl(e.clientX - s.right)), e.clientY - o.top <= s.top + Kl ? i = -Jl(s.top - e.clientY) : e.clientY + o.bottom >= s.bottom - Kl && (i = Jl(e.clientY - s.bottom)), this.setScrollSpeed(n, i);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(e, r) {
    this.scrollSpeed = { x: e, y: r }, e || r ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x, this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let r = null;
    for (let n = 0; n < e.ranges.length; n++) {
      let i = e.ranges[n], s = null;
      if (i.empty) {
        let o = Cc(this.atoms, i.from, 0);
        o != i.from && (s = ce.cursor(o, -1));
      } else {
        let o = Cc(this.atoms, i.from, -1), a = Cc(this.atoms, i.to, 1);
        (o != i.from || a != i.to) && (s = ce.range(i.from == i.anchor ? o : a, i.from == i.head ? o : a));
      }
      s && (r || (r = e.ranges.slice()), r[n] = s);
    }
    return r ? ce.create(r, e.mainIndex) : e;
  }
  select(e) {
    let { view: r } = this, n = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !n.eq(r.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: n,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function MP(t, e) {
  let r = t.state.facet(Yv);
  return r.length ? r[0](e) : de.mac ? e.metaKey : e.ctrlKey;
}
function qP(t, e) {
  let r = t.state.facet(Bv);
  return r.length ? r[0](e) : de.mac ? !e.altKey : !e.ctrlKey;
}
function NP(t, e) {
  let { main: r } = t.state.selection;
  if (r.empty)
    return !1;
  let n = Jc(t.root);
  if (!n || n.rangeCount == 0)
    return !0;
  let i = n.getRangeAt(0).getClientRects();
  for (let s = 0; s < i.length; s++) {
    let o = i[s];
    if (o.left <= e.clientX && o.right >= e.clientX && o.top <= e.clientY && o.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function DP(t, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let r = e.target, n; r != t.contentDOM; r = r.parentNode)
    if (!r || r.nodeType == 11 || (n = et.get(r)) && n.ignoreEvent(e))
      return !1;
  return !0;
}
const Vr = /* @__PURE__ */ Object.create(null), Lr = /* @__PURE__ */ Object.create(null), uw = de.ie && de.ie_version < 15 || de.ios && de.webkit_version < 604;
function zP(t) {
  let e = t.dom.parentNode;
  if (!e)
    return;
  let r = e.appendChild(document.createElement("textarea"));
  r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus(), setTimeout(() => {
    t.focus(), r.remove(), dw(t, r.value);
  }, 50);
}
function dw(t, e) {
  let { state: r } = t, n, i = 1, s = r.toText(e), o = s.lines == r.selection.ranges.length;
  if (kh != null && r.selection.ranges.every((l) => l.empty) && kh == s.toString()) {
    let l = -1;
    n = r.changeByRange((c) => {
      let u = r.doc.lineAt(c.from);
      if (u.from == l)
        return { range: c };
      l = u.from;
      let d = r.toText((o ? s.line(i++).text : e) + r.lineBreak);
      return {
        changes: { from: u.from, insert: d },
        range: ce.cursor(c.from + d.length)
      };
    });
  } else
    o ? n = r.changeByRange((l) => {
      let c = s.line(i++);
      return {
        changes: { from: l.from, to: l.to, insert: c.text },
        range: ce.cursor(l.from + c.length)
      };
    }) : n = r.replaceSelection(s);
  t.dispatch(n, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
Lr.scroll = (t) => {
  t.inputState.lastScrollTop = t.scrollDOM.scrollTop, t.inputState.lastScrollLeft = t.scrollDOM.scrollLeft;
};
Vr.keydown = (t, e) => (t.inputState.setSelectionOrigin("select"), e.keyCode == 27 && (t.inputState.lastEscPress = Date.now()), !1);
Lr.touchstart = (t, e) => {
  t.inputState.lastTouchTime = Date.now(), t.inputState.setSelectionOrigin("select.pointer");
};
Lr.touchmove = (t) => {
  t.inputState.setSelectionOrigin("select.pointer");
};
Vr.mousedown = (t, e) => {
  if (t.observer.flush(), t.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let r = null;
  for (let n of t.state.facet(Fv))
    if (r = n(t, e), r)
      break;
  if (!r && e.button == 0 && (r = UP(t, e)), r) {
    let n = !t.hasFocus;
    t.inputState.startMouseSelection(new ZP(t, e, r, n)), n && t.observer.ignore(() => Qv(t.contentDOM));
    let i = t.inputState.mouseSelection;
    if (i)
      return i.start(e), i.dragging === !1;
  }
  return !1;
};
function eO(t, e, r, n) {
  if (n == 1)
    return ce.cursor(e, r);
  if (n == 2)
    return SP(t.state, e, r);
  {
    let i = Ot.find(t.docView, e), s = t.state.doc.lineAt(i ? i.posAtEnd : e), o = i ? i.posAtStart : s.from, a = i ? i.posAtEnd : s.to;
    return a < t.state.doc.length && a == s.to && a++, ce.range(o, a);
  }
}
let fw = (t, e) => t >= e.top && t <= e.bottom, tO = (t, e, r) => fw(e, r) && t >= r.left && t <= r.right;
function XP(t, e, r, n) {
  let i = Ot.find(t.docView, e);
  if (!i)
    return 1;
  let s = e - i.posAtStart;
  if (s == 0)
    return 1;
  if (s == i.length)
    return -1;
  let o = i.coordsAt(s, -1);
  if (o && tO(r, n, o))
    return -1;
  let a = i.coordsAt(s, 1);
  return a && tO(r, n, a) ? 1 : o && fw(n, o) ? -1 : 1;
}
function rO(t, e) {
  let r = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: r, bias: XP(t, r, e.clientX, e.clientY) };
}
const WP = de.ie && de.ie_version <= 11;
let nO = null, iO = 0, sO = 0;
function hw(t) {
  if (!WP)
    return t.detail;
  let e = nO, r = sO;
  return nO = t, sO = Date.now(), iO = !e || r > Date.now() - 400 && Math.abs(e.clientX - t.clientX) < 2 && Math.abs(e.clientY - t.clientY) < 2 ? (iO + 1) % 3 : 1;
}
function UP(t, e) {
  let r = rO(t, e), n = hw(e), i = t.state.selection;
  return {
    update(s) {
      s.docChanged && (r.pos = s.changes.mapPos(r.pos), i = i.map(s.changes));
    },
    get(s, o, a) {
      let l = rO(t, s), c, u = eO(t, l.pos, l.bias, n);
      if (r.pos != l.pos && !o) {
        let d = eO(t, r.pos, r.bias, n), f = Math.min(d.from, u.from), h = Math.max(d.to, u.to);
        u = f < u.from ? ce.range(f, h) : ce.range(h, f);
      }
      return o ? i.replaceRange(i.main.extend(u.from, u.to)) : a && n == 1 && i.ranges.length > 1 && (c = VP(i, l.pos)) ? c : a ? i.addRange(u) : ce.create([u]);
    }
  };
}
function VP(t, e) {
  for (let r = 0; r < t.ranges.length; r++) {
    let { from: n, to: i } = t.ranges[r];
    if (n <= e && i >= e)
      return ce.create(t.ranges.slice(0, r).concat(t.ranges.slice(r + 1)), t.mainIndex == r ? 0 : t.mainIndex - (t.mainIndex > r ? 1 : 0));
  }
  return null;
}
Vr.dragstart = (t, e) => {
  let { selection: { main: r } } = t.state;
  if (e.target.draggable) {
    let i = t.docView.nearest(e.target);
    if (i && i.isWidget) {
      let s = i.posAtStart, o = s + i.length;
      (s >= r.to || o <= r.from) && (r = ce.range(s, o));
    }
  }
  let { inputState: n } = t;
  return n.mouseSelection && (n.mouseSelection.dragging = !0), n.draggedContent = r, e.dataTransfer && (e.dataTransfer.setData("Text", t.state.sliceDoc(r.from, r.to)), e.dataTransfer.effectAllowed = "copyMove"), !1;
};
Vr.dragend = (t) => (t.inputState.draggedContent = null, !1);
function oO(t, e, r, n) {
  if (!r)
    return;
  let i = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: s } = t.inputState, o = n && s && qP(t, e) ? { from: s.from, to: s.to } : null, a = { from: i, insert: r }, l = t.state.changes(o ? [o, a] : a);
  t.focus(), t.dispatch({
    changes: l,
    selection: { anchor: l.mapPos(i, -1), head: l.mapPos(i, 1) },
    userEvent: o ? "move.drop" : "input.drop"
  }), t.inputState.draggedContent = null;
}
Vr.drop = (t, e) => {
  if (!e.dataTransfer)
    return !1;
  if (t.state.readOnly)
    return !0;
  let r = e.dataTransfer.files;
  if (r && r.length) {
    let n = Array(r.length), i = 0, s = () => {
      ++i == r.length && oO(t, e, n.filter((o) => o != null).join(t.state.lineBreak), !1);
    };
    for (let o = 0; o < r.length; o++) {
      let a = new FileReader();
      a.onerror = s, a.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(a.result) || (n[o] = a.result), s();
      }, a.readAsText(r[o]);
    }
    return !0;
  } else {
    let n = e.dataTransfer.getData("Text");
    if (n)
      return oO(t, e, n, !0), !0;
  }
  return !1;
};
Vr.paste = (t, e) => {
  if (t.state.readOnly)
    return !0;
  t.observer.flush();
  let r = uw ? null : e.clipboardData;
  return r ? (dw(t, r.getData("text/plain") || r.getData("text/uri-text")), !0) : (zP(t), !1);
};
function LP(t, e) {
  let r = t.dom.parentNode;
  if (!r)
    return;
  let n = r.appendChild(document.createElement("textarea"));
  n.style.cssText = "position: fixed; left: -10000px; top: 10px", n.value = e, n.focus(), n.selectionEnd = e.length, n.selectionStart = 0, setTimeout(() => {
    n.remove(), t.focus();
  }, 50);
}
function YP(t) {
  let e = [], r = [], n = !1;
  for (let i of t.selection.ranges)
    i.empty || (e.push(t.sliceDoc(i.from, i.to)), r.push(i));
  if (!e.length) {
    let i = -1;
    for (let { from: s } of t.selection.ranges) {
      let o = t.doc.lineAt(s);
      o.number > i && (e.push(o.text), r.push({ from: o.from, to: Math.min(t.doc.length, o.to + 1) })), i = o.number;
    }
    n = !0;
  }
  return { text: e.join(t.lineBreak), ranges: r, linewise: n };
}
let kh = null;
Vr.copy = Vr.cut = (t, e) => {
  let { text: r, ranges: n, linewise: i } = YP(t.state);
  if (!r && !i)
    return !1;
  kh = i ? r : null, e.type == "cut" && !t.state.readOnly && t.dispatch({
    changes: n,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let s = uw ? null : e.clipboardData;
  return s ? (s.clearData(), s.setData("text/plain", r), !0) : (LP(t, r), !1);
};
const pw = /* @__PURE__ */ Os.define();
function mw(t, e) {
  let r = [];
  for (let n of t.facet(Kv)) {
    let i = n(t, e);
    i && r.push(i);
  }
  return r ? t.update({ effects: r, annotations: pw.of(!0) }) : null;
}
function gw(t) {
  setTimeout(() => {
    let e = t.hasFocus;
    if (e != t.inputState.notifiedFocused) {
      let r = mw(t.state, e);
      r ? t.dispatch(r) : t.update([]);
    }
  }, 10);
}
Lr.focus = (t) => {
  t.inputState.lastFocusTime = Date.now(), !t.scrollDOM.scrollTop && (t.inputState.lastScrollTop || t.inputState.lastScrollLeft) && (t.scrollDOM.scrollTop = t.inputState.lastScrollTop, t.scrollDOM.scrollLeft = t.inputState.lastScrollLeft), gw(t);
};
Lr.blur = (t) => {
  t.observer.clearSelectionRange(), gw(t);
};
Lr.compositionstart = Lr.compositionupdate = (t) => {
  t.inputState.compositionFirstChange == null && (t.inputState.compositionFirstChange = !0), t.inputState.composing < 0 && (t.inputState.composing = 0);
};
Lr.compositionend = (t) => {
  t.inputState.composing = -1, t.inputState.compositionEndedAt = Date.now(), t.inputState.compositionPendingKey = !0, t.inputState.compositionPendingChange = t.observer.pendingRecords().length > 0, t.inputState.compositionFirstChange = null, de.chrome && de.android ? t.observer.flushSoon() : t.inputState.compositionPendingChange ? Promise.resolve().then(() => t.observer.flush()) : setTimeout(() => {
    t.inputState.composing < 0 && t.docView.hasComposition && t.update([]);
  }, 50);
};
Lr.contextmenu = (t) => {
  t.inputState.lastContextMenu = Date.now();
};
Vr.beforeinput = (t, e) => {
  var r;
  let n;
  if (de.chrome && de.android && (n = lw.find((i) => i.inputType == e.inputType)) && (t.observer.delayAndroidKey(n.key, n.keyCode), n.key == "Backspace" || n.key == "Delete")) {
    let i = ((r = window.visualViewport) === null || r === void 0 ? void 0 : r.height) || 0;
    setTimeout(() => {
      var s;
      (((s = window.visualViewport) === null || s === void 0 ? void 0 : s.height) || 0) > i + 10 && t.hasFocus && (t.contentDOM.blur(), t.focus());
    }, 100);
  }
  return !1;
};
const aO = /* @__PURE__ */ new Set();
function BP(t) {
  aO.has(t) || (aO.add(t), t.addEventListener("copy", () => {
  }), t.addEventListener("cut", () => {
  }));
}
const lO = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class FP {
  constructor(e) {
    this.lineWrapping = e, this.doc = Xe.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30, this.heightChanged = !1;
  }
  heightForGap(e, r) {
    let n = this.doc.lineAt(r).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (n += Math.max(0, Math.ceil((r - e - n * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * n;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return lO.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let r = !1;
    for (let n = 0; n < e.length; n++) {
      let i = e[n];
      i < 0 ? n++ : this.heightSamples[Math.floor(i * 10)] || (r = !0, this.heightSamples[Math.floor(i * 10)] = !0);
    }
    return r;
  }
  refresh(e, r, n, i, s, o) {
    let a = lO.indexOf(e) > -1, l = Math.round(r) != Math.round(this.lineHeight) || this.lineWrapping != a;
    if (this.lineWrapping = a, this.lineHeight = r, this.charWidth = n, this.textHeight = i, this.lineLength = s, l) {
      this.heightSamples = {};
      for (let c = 0; c < o.length; c++) {
        let u = o[c];
        u < 0 ? c++ : this.heightSamples[Math.floor(u * 10)] = !0;
      }
    }
    return l;
  }
}
class HP {
  constructor(e, r) {
    this.from = e, this.heights = r, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class un {
  /**
  @internal
  */
  constructor(e, r, n, i, s) {
    this.from = e, this.length = r, this.top = n, this.height = i, this._content = s;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? Xr.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof vi ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let r = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new un(this.from, this.length + e.length, this.top, this.height + e.height, r);
  }
}
var Ke = /* @__PURE__ */ function(t) {
  return t[t.ByPos = 0] = "ByPos", t[t.ByHeight = 1] = "ByHeight", t[t.ByPosNoHeight = 2] = "ByPosNoHeight", t;
}(Ke || (Ke = {}));
const Qc = 1e-3;
class Ft {
  constructor(e, r, n = 2) {
    this.length = e, this.height = r, this.flags = n;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e, r) {
    this.height != r && (Math.abs(this.height - r) > Qc && (e.heightChanged = !0), this.height = r);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, r, n) {
    return Ft.of(n);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, r) {
    r.push(this);
  }
  decomposeRight(e, r) {
    r.push(this);
  }
  applyChanges(e, r, n, i) {
    let s = this, o = n.doc;
    for (let a = i.length - 1; a >= 0; a--) {
      let { fromA: l, toA: c, fromB: u, toB: d } = i[a], f = s.lineAt(l, Ke.ByPosNoHeight, n.setDoc(r), 0, 0), h = f.to >= c ? f : s.lineAt(c, Ke.ByPosNoHeight, n, 0, 0);
      for (d += h.to - c, c = h.to; a > 0 && f.from <= i[a - 1].toA; )
        l = i[a - 1].fromA, u = i[a - 1].fromB, a--, l < f.from && (f = s.lineAt(l, Ke.ByPosNoHeight, n, 0, 0));
      u += f.from - l, l = f.from;
      let p = lm.build(n.setDoc(o), e, u, d);
      s = s.replace(l, c, p);
    }
    return s.updateHeight(n, 0);
  }
  static empty() {
    return new cr(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let r = 0, n = e.length, i = 0, s = 0;
    for (; ; )
      if (r == n)
        if (i > s * 2) {
          let a = e[r - 1];
          a.break ? e.splice(--r, 1, a.left, null, a.right) : e.splice(--r, 1, a.left, a.right), n += 1 + a.break, i -= a.size;
        } else if (s > i * 2) {
          let a = e[n];
          a.break ? e.splice(n, 1, a.left, null, a.right) : e.splice(n, 1, a.left, a.right), n += 2 + a.break, s -= a.size;
        } else
          break;
      else if (i < s) {
        let a = e[r++];
        a && (i += a.size);
      } else {
        let a = e[--n];
        a && (s += a.size);
      }
    let o = 0;
    return e[r - 1] == null ? (o = 1, r--) : e[r] == null && (o = 1, n++), new GP(Ft.of(e.slice(0, r)), o, Ft.of(e.slice(n)));
  }
}
Ft.prototype.size = 1;
class Ow extends Ft {
  constructor(e, r, n) {
    super(e, r), this.deco = n;
  }
  blockAt(e, r, n, i) {
    return new un(i, this.length, n, this.height, this.deco || 0);
  }
  lineAt(e, r, n, i, s) {
    return this.blockAt(0, n, i, s);
  }
  forEachLine(e, r, n, i, s, o) {
    e <= s + this.length && r >= s && o(this.blockAt(0, n, i, s));
  }
  updateHeight(e, r = 0, n = !1, i) {
    return i && i.from <= r && i.more && this.setHeight(e, i.heights[i.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class cr extends Ow {
  constructor(e, r) {
    super(e, r, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, r, n, i) {
    return new un(i, this.length, n, this.height, this.breaks);
  }
  replace(e, r, n) {
    let i = n[0];
    return n.length == 1 && (i instanceof cr || i instanceof Ct && i.flags & 4) && Math.abs(this.length - i.length) < 10 ? (i instanceof Ct ? i = new cr(i.length, this.height) : i.height = this.height, this.outdated || (i.outdated = !1), i) : Ft.of(n);
  }
  updateHeight(e, r = 0, n = !1, i) {
    return i && i.from <= r && i.more ? this.setHeight(e, i.heights[i.index++]) : (n || this.outdated) && this.setHeight(e, Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class Ct extends Ft {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, r) {
    let n = e.doc.lineAt(r).number, i = e.doc.lineAt(r + this.length).number, s = i - n + 1, o, a = 0;
    if (e.lineWrapping) {
      let l = Math.min(this.height, e.lineHeight * s);
      o = l / s, this.length > s + 1 && (a = (this.height - l) / (this.length - s - 1));
    } else
      o = this.height / s;
    return { firstLine: n, lastLine: i, perLine: o, perChar: a };
  }
  blockAt(e, r, n, i) {
    let { firstLine: s, lastLine: o, perLine: a, perChar: l } = this.heightMetrics(r, i);
    if (r.lineWrapping) {
      let c = i + Math.round(Math.max(0, Math.min(1, (e - n) / this.height)) * this.length), u = r.doc.lineAt(c), d = a + u.length * l, f = Math.max(n, e - d / 2);
      return new un(u.from, u.length, f, d, 0);
    } else {
      let c = Math.max(0, Math.min(o - s, Math.floor((e - n) / a))), { from: u, length: d } = r.doc.line(s + c);
      return new un(u, d, n + a * c, a, 0);
    }
  }
  lineAt(e, r, n, i, s) {
    if (r == Ke.ByHeight)
      return this.blockAt(e, n, i, s);
    if (r == Ke.ByPosNoHeight) {
      let { from: h, to: p } = n.doc.lineAt(e);
      return new un(h, p - h, 0, 0, 0);
    }
    let { firstLine: o, perLine: a, perChar: l } = this.heightMetrics(n, s), c = n.doc.lineAt(e), u = a + c.length * l, d = c.number - o, f = i + a * d + l * (c.from - s - d);
    return new un(c.from, c.length, Math.max(i, Math.min(f, i + this.height - u)), u, 0);
  }
  forEachLine(e, r, n, i, s, o) {
    e = Math.max(e, s), r = Math.min(r, s + this.length);
    let { firstLine: a, perLine: l, perChar: c } = this.heightMetrics(n, s);
    for (let u = e, d = i; u <= r; ) {
      let f = n.doc.lineAt(u);
      if (u == e) {
        let p = f.number - a;
        d += l * p + c * (e - s - p);
      }
      let h = l + c * f.length;
      o(new un(f.from, f.length, d, h, 0)), d += h, u = f.to + 1;
    }
  }
  replace(e, r, n) {
    let i = this.length - r;
    if (i > 0) {
      let s = n[n.length - 1];
      s instanceof Ct ? n[n.length - 1] = new Ct(s.length + i) : n.push(null, new Ct(i - 1));
    }
    if (e > 0) {
      let s = n[0];
      s instanceof Ct ? n[0] = new Ct(e + s.length) : n.unshift(new Ct(e - 1), null);
    }
    return Ft.of(n);
  }
  decomposeLeft(e, r) {
    r.push(new Ct(e - 1), null);
  }
  decomposeRight(e, r) {
    r.push(null, new Ct(this.length - e - 1));
  }
  updateHeight(e, r = 0, n = !1, i) {
    let s = r + this.length;
    if (i && i.from <= r + this.length && i.more) {
      let o = [], a = Math.max(r, i.from), l = -1;
      for (i.from > r && o.push(new Ct(i.from - r - 1).updateHeight(e, r)); a <= s && i.more; ) {
        let u = e.doc.lineAt(a).length;
        o.length && o.push(null);
        let d = i.heights[i.index++];
        l == -1 ? l = d : Math.abs(d - l) >= Qc && (l = -2);
        let f = new cr(u, d);
        f.outdated = !1, o.push(f), a += u + 1;
      }
      a <= s && o.push(null, new Ct(s - a).updateHeight(e, a));
      let c = Ft.of(o);
      return (l < 0 || Math.abs(c.height - this.height) >= Qc || Math.abs(l - this.heightMetrics(e, r).perLine) >= Qc) && (e.heightChanged = !0), c;
    } else
      (n || this.outdated) && (this.setHeight(e, e.heightForGap(r, r + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class GP extends Ft {
  constructor(e, r, n) {
    super(e.length + r + n.length, e.height + n.height, r | (e.outdated || n.outdated ? 2 : 0)), this.left = e, this.right = n, this.size = e.size + n.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, r, n, i) {
    let s = n + this.left.height;
    return e < s ? this.left.blockAt(e, r, n, i) : this.right.blockAt(e, r, s, i + this.left.length + this.break);
  }
  lineAt(e, r, n, i, s) {
    let o = i + this.left.height, a = s + this.left.length + this.break, l = r == Ke.ByHeight ? e < o : e < a, c = l ? this.left.lineAt(e, r, n, i, s) : this.right.lineAt(e, r, n, o, a);
    if (this.break || (l ? c.to < a : c.from > a))
      return c;
    let u = r == Ke.ByPosNoHeight ? Ke.ByPosNoHeight : Ke.ByPos;
    return l ? c.join(this.right.lineAt(a, u, n, o, a)) : this.left.lineAt(a, u, n, i, s).join(c);
  }
  forEachLine(e, r, n, i, s, o) {
    let a = i + this.left.height, l = s + this.left.length + this.break;
    if (this.break)
      e < l && this.left.forEachLine(e, r, n, i, s, o), r >= l && this.right.forEachLine(e, r, n, a, l, o);
    else {
      let c = this.lineAt(l, Ke.ByPos, n, i, s);
      e < c.from && this.left.forEachLine(e, c.from - 1, n, i, s, o), c.to >= e && c.from <= r && o(c), r > c.to && this.right.forEachLine(c.to + 1, r, n, a, l, o);
    }
  }
  replace(e, r, n) {
    let i = this.left.length + this.break;
    if (r < i)
      return this.balanced(this.left.replace(e, r, n), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - i, r - i, n));
    let s = [];
    e > 0 && this.decomposeLeft(e, s);
    let o = s.length;
    for (let a of n)
      s.push(a);
    if (e > 0 && cO(s, o - 1), r < this.length) {
      let a = s.length;
      this.decomposeRight(r, s), cO(s, a);
    }
    return Ft.of(s);
  }
  decomposeLeft(e, r) {
    let n = this.left.length;
    if (e <= n)
      return this.left.decomposeLeft(e, r);
    r.push(this.left), this.break && (n++, e >= n && r.push(null)), e > n && this.right.decomposeLeft(e - n, r);
  }
  decomposeRight(e, r) {
    let n = this.left.length, i = n + this.break;
    if (e >= i)
      return this.right.decomposeRight(e - i, r);
    e < n && this.left.decomposeRight(e, r), this.break && e < i && r.push(null), r.push(this.right);
  }
  balanced(e, r) {
    return e.size > 2 * r.size || r.size > 2 * e.size ? Ft.of(this.break ? [e, null, r] : [e, r]) : (this.left = e, this.right = r, this.height = e.height + r.height, this.outdated = e.outdated || r.outdated, this.size = e.size + r.size, this.length = e.length + this.break + r.length, this);
  }
  updateHeight(e, r = 0, n = !1, i) {
    let { left: s, right: o } = this, a = r + s.length + this.break, l = null;
    return i && i.from <= r + s.length && i.more ? l = s = s.updateHeight(e, r, n, i) : s.updateHeight(e, r, n), i && i.from <= a + o.length && i.more ? l = o = o.updateHeight(e, a, n, i) : o.updateHeight(e, a, n), l ? this.balanced(s, o) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function cO(t, e) {
  let r, n;
  t[e] == null && (r = t[e - 1]) instanceof Ct && (n = t[e + 1]) instanceof Ct && t.splice(e - 1, 3, new Ct(r.length + 1 + n.length));
}
const KP = 5;
class lm {
  constructor(e, r) {
    this.pos = e, this.oracle = r, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, r) {
    if (this.lineStart > -1) {
      let n = Math.min(r, this.lineEnd), i = this.nodes[this.nodes.length - 1];
      i instanceof cr ? i.length += n - this.pos : (n > this.pos || !this.isCovered) && this.nodes.push(new cr(n - this.pos, -1)), this.writtenTo = n, r > n && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = r;
  }
  point(e, r, n) {
    if (e < r || n.heightRelevant) {
      let i = n.widget ? n.widget.estimatedHeight : 0, s = n.widget ? n.widget.lineBreaks : 0;
      i < 0 && (i = this.oracle.lineHeight);
      let o = r - e;
      n.block ? this.addBlock(new Ow(o, i, n)) : (o || s || i >= KP) && this.addLineDeco(i, s, o);
    } else
      r > e && this.span(e, r);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: r } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = r, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new cr(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, r) {
    let n = new Ct(r - e);
    return this.oracle.doc.lineAt(e).to == r && (n.flags |= 4), n;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof cr)
      return e;
    let r = new cr(0, -1);
    return this.nodes.push(r), r;
  }
  addBlock(e) {
    this.enterLine();
    let r = e.deco;
    r && r.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, r && r.endSide > 0 && (this.covering = e);
  }
  addLineDeco(e, r, n) {
    let i = this.ensureLine();
    i.length += n, i.collapsed += n, i.widgetHeight = Math.max(i.widgetHeight, e), i.breaks += r, this.writtenTo = this.pos = this.pos + n;
  }
  finish(e) {
    let r = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(r instanceof cr) && !this.isCovered ? this.nodes.push(new cr(0, -1)) : (this.writtenTo < this.pos || r == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let n = e;
    for (let i of this.nodes)
      i instanceof cr && i.updateHeight(this.oracle, n), n += i ? i.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, r, n, i) {
    let s = new lm(n, e);
    return ze.spans(r, n, i, s, 0), s.finish(n);
  }
}
function JP(t, e, r) {
  let n = new ex();
  return ze.compare(t, e, r, n, 0), n.changes;
}
class ex {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, r, n, i) {
    (e < r || n && n.heightRelevant || i && i.heightRelevant) && yh(e, r, this.changes, 5);
  }
}
function tx(t, e) {
  let r = t.getBoundingClientRect(), n = t.ownerDocument, i = n.defaultView || window, s = Math.max(0, r.left), o = Math.min(i.innerWidth, r.right), a = Math.max(0, r.top), l = Math.min(i.innerHeight, r.bottom);
  for (let c = t.parentNode; c && c != n.body; )
    if (c.nodeType == 1) {
      let u = c, d = window.getComputedStyle(u);
      if ((u.scrollHeight > u.clientHeight || u.scrollWidth > u.clientWidth) && d.overflow != "visible") {
        let f = u.getBoundingClientRect();
        s = Math.max(s, f.left), o = Math.min(o, f.right), a = Math.max(a, f.top), l = c == t.parentNode ? f.bottom : Math.min(l, f.bottom);
      }
      c = d.position == "absolute" || d.position == "fixed" ? u.offsetParent : u.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
  return {
    left: s - r.left,
    right: Math.max(s, o) - r.left,
    top: a - (r.top + e),
    bottom: Math.max(a, l) - (r.top + e)
  };
}
function rx(t, e) {
  let r = t.getBoundingClientRect();
  return {
    left: 0,
    right: r.right - r.left,
    top: e,
    bottom: r.bottom - (r.top + e)
  };
}
class Wd {
  constructor(e, r, n) {
    this.from = e, this.to = r, this.size = n;
  }
  static same(e, r) {
    if (e.length != r.length)
      return !1;
    for (let n = 0; n < e.length; n++) {
      let i = e[n], s = r[n];
      if (i.from != s.from || i.to != s.to || i.size != s.size)
        return !1;
    }
    return !0;
  }
  draw(e, r) {
    return We.replace({
      widget: new nx(this.size * (r ? e.scaleY : e.scaleX), r)
    }).range(this.from, this.to);
  }
}
class nx extends Ro {
  constructor(e, r) {
    super(), this.size = e, this.vertical = r;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class uO {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !0, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = dO, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = mt.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let r = e.facet(om).some((n) => typeof n != "function" && n.class == "cm-lineWrapping");
    this.heightOracle = new FP(r), this.stateDeco = e.facet(Ga).filter((n) => typeof n != "function"), this.heightMap = Ft.empty().applyChanges(this.stateDeco, Xe.empty, this.heightOracle.setDoc(e.doc), [new Sr(0, 0, 0, e.doc.length)]), this.viewport = this.getViewport(0, null), this.updateViewportLines(), this.updateForViewport(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = We.set(this.lineGaps.map((n) => n.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: r } = this.state.selection;
    for (let n = 0; n <= 1; n++) {
      let i = n ? r.head : r.anchor;
      if (!e.some(({ from: s, to: o }) => i >= s && i <= o)) {
        let { from: s, to: o } = this.lineBlockAt(i);
        e.push(new ec(s, o));
      }
    }
    this.viewports = e.sort((n, i) => n.from - i.from), this.scaler = this.heightMap.height <= 7e6 ? dO : new ox(this.heightOracle, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(this.scaler.scale == 1 ? e : $a(e, this.scaler));
    });
  }
  update(e, r = null) {
    this.state = e.state;
    let n = this.stateDeco;
    this.stateDeco = this.state.facet(Ga).filter((u) => typeof u != "function");
    let i = e.changedRanges, s = Sr.extendWithRanges(i, JP(n, this.stateDeco, e ? e.changes : wt.empty(this.state.doc.length))), o = this.heightMap.height, a = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), s), this.heightMap.height != o && (e.flags |= 2), a ? (this.scrollAnchorPos = e.changes.mapPos(a.from, -1), this.scrollAnchorHeight = a.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let l = s.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (r && (r.range.head < l.from || r.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, r));
    let c = !e.changes.empty || e.flags & 2 || l.from != this.viewport.from || l.to != this.viewport.to;
    this.viewport = l, this.updateForViewport(), c && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(), r && (this.scrollTarget = r), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(pP) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let r = e.contentDOM, n = window.getComputedStyle(r), i = this.heightOracle, s = n.whiteSpace;
    this.defaultTextDirection = n.direction == "rtl" ? mt.RTL : mt.LTR;
    let o = this.heightOracle.mustRefreshForWrapping(s), a = r.getBoundingClientRect(), l = o || this.mustMeasureContent || this.contentDOMHeight != a.height;
    this.contentDOMHeight = a.height, this.mustMeasureContent = !1;
    let c = 0, u = 0;
    if (a.width && a.height) {
      let { scaleX: w, scaleY: S } = Cv(r, a);
      (this.scaleX != w || this.scaleY != S) && (this.scaleX = w, this.scaleY = S, c |= 8, o = l = !0);
    }
    let d = (parseInt(n.paddingTop) || 0) * this.scaleY, f = (parseInt(n.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != d || this.paddingBottom != f) && (this.paddingTop = d, this.paddingBottom = f, c |= 10), this.editorWidth != e.scrollDOM.clientWidth && (i.lineWrapping && (l = !0), this.editorWidth = e.scrollDOM.clientWidth, c |= 8);
    let h = e.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != h && (this.scrollAnchorHeight = -1, this.scrollTop = h), this.scrolledToBottom = Ev(e.scrollDOM);
    let p = (this.printing ? rx : tx)(r, this.paddingTop), g = p.top - this.pixelViewport.top, m = p.bottom - this.pixelViewport.bottom;
    this.pixelViewport = p;
    let y = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (y != this.inView && (this.inView = y, y && (l = !0)), !this.inView && !this.scrollTarget)
      return 0;
    let O = a.width;
    if ((this.contentDOMWidth != O || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = a.width, this.editorHeight = e.scrollDOM.clientHeight, c |= 8), l) {
      let w = e.docView.measureVisibleLineHeights(this.viewport);
      if (i.mustRefreshForHeights(w) && (o = !0), o || i.lineWrapping && Math.abs(O - this.contentDOMWidth) > i.charWidth) {
        let { lineHeight: S, charWidth: $, textHeight: _ } = e.docView.measureTextSize();
        o = S > 0 && i.refresh(s, S, $, _, O / $, w), o && (e.docView.minWidth = 0, c |= 8);
      }
      g > 0 && m > 0 ? u = Math.max(g, m) : g < 0 && m < 0 && (u = Math.min(g, m)), i.heightChanged = !1;
      for (let S of this.viewports) {
        let $ = S.from == this.viewport.from ? w : e.docView.measureVisibleLineHeights(S);
        this.heightMap = (o ? Ft.empty().applyChanges(this.stateDeco, Xe.empty, this.heightOracle, [new Sr(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(i, 0, o, new HP(S.from, $));
      }
      i.heightChanged && (c |= 2);
    }
    let b = !this.viewportIsAppropriate(this.viewport, u) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return b && (this.viewport = this.getViewport(u, this.scrollTarget)), this.updateForViewport(), (c & 2 || b) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(o ? [] : this.lineGaps, e)), c |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), c;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, r) {
    let n = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), i = this.heightMap, s = this.heightOracle, { visibleTop: o, visibleBottom: a } = this, l = new ec(i.lineAt(o - n * 1e3, Ke.ByHeight, s, 0, 0).from, i.lineAt(a + (1 - n) * 1e3, Ke.ByHeight, s, 0, 0).to);
    if (r) {
      let { head: c } = r.range;
      if (c < l.from || c > l.to) {
        let u = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), d = i.lineAt(c, Ke.ByPos, s, 0, 0), f;
        r.y == "center" ? f = (d.top + d.bottom) / 2 - u / 2 : r.y == "start" || r.y == "nearest" && c < l.from ? f = d.top : f = d.bottom - u, l = new ec(i.lineAt(f - 1e3 / 2, Ke.ByHeight, s, 0, 0).from, i.lineAt(f + u + 1e3 / 2, Ke.ByHeight, s, 0, 0).to);
      }
    }
    return l;
  }
  mapViewport(e, r) {
    let n = r.mapPos(e.from, -1), i = r.mapPos(e.to, 1);
    return new ec(this.heightMap.lineAt(n, Ke.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(i, Ke.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: r }, n = 0) {
    if (!this.inView)
      return !0;
    let { top: i } = this.heightMap.lineAt(e, Ke.ByPos, this.heightOracle, 0, 0), { bottom: s } = this.heightMap.lineAt(r, Ke.ByPos, this.heightOracle, 0, 0), { visibleTop: o, visibleBottom: a } = this;
    return (e == 0 || i <= o - Math.max(10, Math.min(
      -n,
      250
      /* VP.MaxCoverMargin */
    ))) && (r == this.state.doc.length || s >= a + Math.max(10, Math.min(
      n,
      250
      /* VP.MaxCoverMargin */
    ))) && i > o - 2 * 1e3 && s < a + 2 * 1e3;
  }
  mapLineGaps(e, r) {
    if (!e.length || r.empty)
      return e;
    let n = [];
    for (let i of e)
      r.touchesRange(i.from, i.to) || n.push(new Wd(r.mapPos(i.from), r.mapPos(i.to), i.size));
    return n;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, r) {
    let n = this.heightOracle.lineWrapping, i = n ? 1e4 : 2e3, s = i >> 1, o = i << 1;
    if (this.defaultTextDirection != mt.LTR && !n)
      return [];
    let a = [], l = (c, u, d, f) => {
      if (u - c < s)
        return;
      let h = this.state.selection.main, p = [h.from];
      h.empty || p.push(h.to);
      for (let m of p)
        if (m > c && m < u) {
          l(c, m - 10, d, f), l(m + 10, u, d, f);
          return;
        }
      let g = sx(e, (m) => m.from >= d.from && m.to <= d.to && Math.abs(m.from - c) < s && Math.abs(m.to - u) < s && !p.some((y) => m.from < y && m.to > y));
      if (!g) {
        if (u < d.to && r && n && r.visibleRanges.some((m) => m.from <= u && m.to >= u)) {
          let m = r.moveToLineBoundary(ce.cursor(u), !1, !0).head;
          m > c && (u = m);
        }
        g = new Wd(c, u, this.gapSize(d, c, u, f));
      }
      a.push(g);
    };
    for (let c of this.viewportLines) {
      if (c.length < o)
        continue;
      let u = ix(c.from, c.to, this.stateDeco);
      if (u.total < o)
        continue;
      let d = this.scrollTarget ? this.scrollTarget.range.head : null, f, h;
      if (n) {
        let p = i / this.heightOracle.lineLength * this.heightOracle.lineHeight, g, m;
        if (d != null) {
          let y = rc(u, d), O = ((this.visibleBottom - this.visibleTop) / 2 + p) / c.height;
          g = y - O, m = y + O;
        } else
          g = (this.visibleTop - c.top - p) / c.height, m = (this.visibleBottom - c.top + p) / c.height;
        f = tc(u, g), h = tc(u, m);
      } else {
        let p = u.total * this.heightOracle.charWidth, g = i * this.heightOracle.charWidth, m, y;
        if (d != null) {
          let O = rc(u, d), b = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + g) / p;
          m = O - b, y = O + b;
        } else
          m = (this.pixelViewport.left - g) / p, y = (this.pixelViewport.right + g) / p;
        f = tc(u, m), h = tc(u, y);
      }
      f > c.from && l(c.from, f, c, u), h < c.to && l(h, c.to, c, u);
    }
    return a;
  }
  gapSize(e, r, n, i) {
    let s = rc(i, n) - rc(i, r);
    return this.heightOracle.lineWrapping ? e.height * s : i.total * this.heightOracle.charWidth * s;
  }
  updateLineGaps(e) {
    Wd.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = We.set(e.map((r) => r.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let r = [];
    ze.spans(e, this.viewport.from, this.viewport.to, {
      span(i, s) {
        r.push({ from: i, to: s });
      },
      point() {
      }
    }, 20);
    let n = r.length != this.visibleRanges.length || this.visibleRanges.some((i, s) => i.from != r[s].from || i.to != r[s].to);
    return this.visibleRanges = r, n ? 4 : 0;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((r) => r.from <= e && r.to >= e) || $a(this.heightMap.lineAt(e, Ke.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return $a(this.heightMap.lineAt(this.scaler.fromDOM(e), Ke.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let r = this.lineBlockAtHeight(e + 8);
    return r.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? r : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return $a(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class ec {
  constructor(e, r) {
    this.from = e, this.to = r;
  }
}
function ix(t, e, r) {
  let n = [], i = t, s = 0;
  return ze.spans(r, t, e, {
    span() {
    },
    point(o, a) {
      o > i && (n.push({ from: i, to: o }), s += o - i), i = a;
    }
  }, 20), i < e && (n.push({ from: i, to: e }), s += e - i), { total: s, ranges: n };
}
function tc({ total: t, ranges: e }, r) {
  if (r <= 0)
    return e[0].from;
  if (r >= 1)
    return e[e.length - 1].to;
  let n = Math.floor(t * r);
  for (let i = 0; ; i++) {
    let { from: s, to: o } = e[i], a = o - s;
    if (n <= a)
      return s + n;
    n -= a;
  }
}
function rc(t, e) {
  let r = 0;
  for (let { from: n, to: i } of t.ranges) {
    if (e <= i) {
      r += e - n;
      break;
    }
    r += i - n;
  }
  return r / t.total;
}
function sx(t, e) {
  for (let r of t)
    if (e(r))
      return r;
}
const dO = {
  toDOM(t) {
    return t;
  },
  fromDOM(t) {
    return t;
  },
  scale: 1
};
class ox {
  constructor(e, r, n) {
    let i = 0, s = 0, o = 0;
    this.viewports = n.map(({ from: a, to: l }) => {
      let c = r.lineAt(a, Ke.ByPos, e, 0, 0).top, u = r.lineAt(l, Ke.ByPos, e, 0, 0).bottom;
      return i += u - c, { from: a, to: l, top: c, bottom: u, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - i) / (r.height - i);
    for (let a of this.viewports)
      a.domTop = o + (a.top - s) * this.scale, o = a.domBottom = a.domTop + (a.bottom - a.top), s = a.bottom;
  }
  toDOM(e) {
    for (let r = 0, n = 0, i = 0; ; r++) {
      let s = r < this.viewports.length ? this.viewports[r] : null;
      if (!s || e < s.top)
        return i + (e - n) * this.scale;
      if (e <= s.bottom)
        return s.domTop + (e - s.top);
      n = s.bottom, i = s.domBottom;
    }
  }
  fromDOM(e) {
    for (let r = 0, n = 0, i = 0; ; r++) {
      let s = r < this.viewports.length ? this.viewports[r] : null;
      if (!s || e < s.domTop)
        return n + (e - i) / this.scale;
      if (e <= s.domBottom)
        return s.top + (e - s.domTop);
      n = s.bottom, i = s.domBottom;
    }
  }
}
function $a(t, e) {
  if (e.scale == 1)
    return t;
  let r = e.toDOM(t.top), n = e.toDOM(t.bottom);
  return new un(t.from, t.length, r, n - r, Array.isArray(t._content) ? t._content.map((i) => $a(i, e)) : t._content);
}
const nc = /* @__PURE__ */ be.define({ combine: (t) => t.join(" ") }), _h = /* @__PURE__ */ be.define({ combine: (t) => t.indexOf(!0) > -1 }), Ph = /* @__PURE__ */ yi.newName(), yw = /* @__PURE__ */ yi.newName(), bw = /* @__PURE__ */ yi.newName(), vw = { "&light": "." + yw, "&dark": "." + bw };
function xh(t, e, r) {
  return new yi(e, {
    finish(n) {
      return /&/.test(n) ? n.replace(/&\w*/, (i) => {
        if (i == "&")
          return t;
        if (!r || !r[i])
          throw new RangeError(`Unsupported selector: ${i}`);
        return r[i];
      }) : t + " " + n;
    }
  });
}
const ax = /* @__PURE__ */ xh("." + Ph, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace:before": {
    content: "attr(data-display)",
    position: "absolute",
    pointerEvents: "none",
    color: "#888"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, vw), Sa = "ï¿¿";
class lx {
  constructor(e, r) {
    this.points = e, this.text = "", this.lineSeparator = r.facet(De.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += Sa;
  }
  readRange(e, r) {
    if (!e)
      return this;
    let n = e.parentNode;
    for (let i = e; ; ) {
      this.findPointBefore(n, i);
      let s = this.text.length;
      this.readNode(i);
      let o = i.nextSibling;
      if (o == r)
        break;
      let a = et.get(i), l = et.get(o);
      (a && l ? a.breakAfter : (a ? a.breakAfter : fO(i)) || fO(o) && (i.nodeName != "BR" || i.cmIgnore) && this.text.length > s) && this.lineBreak(), i = o;
    }
    return this.findPointBefore(n, r), this;
  }
  readTextNode(e) {
    let r = e.nodeValue;
    for (let n of this.points)
      n.node == e && (n.pos = this.text.length + Math.min(n.offset, r.length));
    for (let n = 0, i = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let s = -1, o = 1, a;
      if (this.lineSeparator ? (s = r.indexOf(this.lineSeparator, n), o = this.lineSeparator.length) : (a = i.exec(r)) && (s = a.index, o = a[0].length), this.append(r.slice(n, s < 0 ? r.length : s)), s < 0)
        break;
      if (this.lineBreak(), o > 1)
        for (let l of this.points)
          l.node == e && l.pos > this.text.length && (l.pos -= o - 1);
      n = s + o;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let r = et.get(e), n = r && r.overrideDOMText;
    if (n != null) {
      this.findPointInside(e, n.length);
      for (let i = n.iter(); !i.next().done; )
        i.lineBreak ? this.lineBreak() : this.append(i.value);
    } else
      e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, r) {
    for (let n of this.points)
      n.node == e && e.childNodes[n.offset] == r && (n.pos = this.text.length);
  }
  findPointInside(e, r) {
    for (let n of this.points)
      (e.nodeType == 3 ? n.node == e : e.contains(n.node)) && (n.pos = this.text.length + (cx(e, n.node, n.offset) ? r : 0));
  }
}
function cx(t, e, r) {
  for (; ; ) {
    if (!e || r < Mn(e))
      return !1;
    if (e == t)
      return !0;
    r = Ha(e) + 1, e = e.parentNode;
  }
}
function fO(t) {
  return t.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(t.nodeName);
}
class hO {
  constructor(e, r) {
    this.node = e, this.offset = r, this.pos = -1;
  }
}
class ux {
  constructor(e, r, n, i) {
    this.typeOver = i, this.bounds = null, this.text = "";
    let { impreciseHead: s, impreciseAnchor: o } = e.docView;
    if (e.state.readOnly && r > -1)
      this.newSel = null;
    else if (r > -1 && (this.bounds = e.docView.domBoundsAround(r, n, 0))) {
      let a = s || o ? [] : hx(e), l = new lx(a, e.state);
      l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = px(a, this.bounds.from);
    } else {
      let a = e.observer.selectionRange, l = s && s.node == a.focusNode && s.offset == a.focusOffset || !fh(e.contentDOM, a.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(a.focusNode, a.focusOffset), c = o && o.node == a.anchorNode && o.offset == a.anchorOffset || !fh(e.contentDOM, a.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(a.anchorNode, a.anchorOffset), u = e.viewport;
      if ((de.ios || de.chrome) && e.state.selection.main.empty && l != c && (u.from > 0 || u.to < e.state.doc.length)) {
        let d = Math.min(l, c), f = Math.max(l, c), h = u.from - d, p = u.to - f;
        (h == 0 || h == 1 || d == 0) && (p == 0 || p == -1 || f == e.state.doc.length) && (l = 0, c = e.state.doc.length);
      }
      this.newSel = ce.single(c, l);
    }
  }
}
function ww(t, e) {
  let r, { newSel: n } = e, i = t.state.selection.main, s = t.inputState.lastKeyTime > Date.now() - 100 ? t.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: o, to: a } = e.bounds, l = i.from, c = null;
    (s === 8 || de.android && e.text.length < a - o) && (l = i.to, c = "end");
    let u = fx(t.state.doc.sliceString(o, a, Sa), e.text, l - o, c);
    u && (de.chrome && s == 13 && u.toB == u.from + 2 && e.text.slice(u.from, u.toB) == Sa + Sa && u.toB--, r = {
      from: o + u.from,
      to: o + u.toA,
      insert: Xe.of(e.text.slice(u.from, u.toB).split(Sa))
    });
  } else
    n && (!t.hasFocus && t.state.facet(Hu) || n.main.eq(i)) && (n = null);
  if (!r && !n)
    return !1;
  if (!r && e.typeOver && !i.empty && n && n.main.empty ? r = { from: i.from, to: i.to, insert: t.state.doc.slice(i.from, i.to) } : r && r.from >= i.from && r.to <= i.to && (r.from != i.from || r.to != i.to) && i.to - i.from - (r.to - r.from) <= 4 ? r = {
    from: i.from,
    to: i.to,
    insert: t.state.doc.slice(i.from, r.from).append(r.insert).append(t.state.doc.slice(r.to, i.to))
  } : (de.mac || de.android) && r && r.from == r.to && r.from == i.head - 1 && /^\. ?$/.test(r.insert.toString()) && t.contentDOM.getAttribute("autocorrect") == "off" ? (n && r.insert.length == 2 && (n = ce.single(n.main.anchor - 1, n.main.head - 1)), r = { from: i.from, to: i.to, insert: Xe.of([" "]) }) : de.chrome && r && r.from == r.to && r.from == i.head && r.insert.toString() == `
 ` && t.lineWrapping && (n && (n = ce.single(n.main.anchor - 1, n.main.head - 1)), r = { from: i.from, to: i.to, insert: Xe.of([" "]) }), r) {
    if (de.ios && t.inputState.flushIOSKey() || de.android && (r.from == i.from && r.to == i.to && r.insert.length == 1 && r.insert.lines == 2 && Js(t.contentDOM, "Enter", 13) || (r.from == i.from - 1 && r.to == i.to && r.insert.length == 0 || s == 8 && r.insert.length < r.to - r.from && r.to > i.head) && Js(t.contentDOM, "Backspace", 8) || r.from == i.from && r.to == i.to + 1 && r.insert.length == 0 && Js(t.contentDOM, "Delete", 46)))
      return !0;
    let o = r.insert.toString();
    t.inputState.composing >= 0 && t.inputState.composing++;
    let a, l = () => a || (a = dx(t, r, n));
    return t.state.facet(Gv).some((c) => c(t, r.from, r.to, o, l)) || t.dispatch(l()), !0;
  } else if (n && !n.main.eq(i)) {
    let o = !1, a = "select";
    return t.inputState.lastSelectionTime > Date.now() - 50 && (t.inputState.lastSelectionOrigin == "select" && (o = !0), a = t.inputState.lastSelectionOrigin), t.dispatch({ selection: n, scrollIntoView: o, userEvent: a }), !0;
  } else
    return !1;
}
function dx(t, e, r) {
  let n, i = t.state, s = i.selection.main;
  if (e.from >= s.from && e.to <= s.to && e.to - e.from >= (s.to - s.from) / 3 && (!r || r.main.empty && r.main.from == e.from + e.insert.length) && t.inputState.composing < 0) {
    let a = s.from < e.from ? i.sliceDoc(s.from, e.from) : "", l = s.to > e.to ? i.sliceDoc(e.to, s.to) : "";
    n = i.replaceSelection(t.state.toText(a + e.insert.sliceString(0, void 0, t.state.lineBreak) + l));
  } else {
    let a = i.changes(e), l = r && r.main.to <= a.newLength ? r.main : void 0;
    if (i.selection.ranges.length > 1 && t.inputState.composing >= 0 && e.to <= s.to && e.to >= s.to - 10) {
      let c = t.state.sliceDoc(e.from, e.to), u, d = r && sw(t, r.main.head);
      if (d) {
        let p = e.insert.length - (e.to - e.from);
        u = { from: d.from, to: d.to - p };
      } else
        u = t.state.doc.lineAt(s.head);
      let f = s.to - e.to, h = s.to - s.from;
      n = i.changeByRange((p) => {
        if (p.from == s.from && p.to == s.to)
          return { changes: a, range: l || p.map(a) };
        let g = p.to - f, m = g - c.length;
        if (p.to - p.from != h || t.state.sliceDoc(m, g) != c || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        p.to >= u.from && p.from <= u.to)
          return { range: p };
        let y = i.changes({ from: m, to: g, insert: e.insert }), O = p.to - s.to;
        return {
          changes: y,
          range: l ? ce.range(Math.max(0, l.anchor + O), Math.max(0, l.head + O)) : p.map(y)
        };
      });
    } else
      n = {
        changes: a,
        selection: l && i.selection.replaceRange(l)
      };
  }
  let o = "input.type";
  return (t.composing || t.inputState.compositionPendingChange && t.inputState.compositionEndedAt > Date.now() - 50) && (t.inputState.compositionPendingChange = !1, o += ".compose", t.inputState.compositionFirstChange && (o += ".start", t.inputState.compositionFirstChange = !1)), i.update(n, { userEvent: o, scrollIntoView: !0 });
}
function fx(t, e, r, n) {
  let i = Math.min(t.length, e.length), s = 0;
  for (; s < i && t.charCodeAt(s) == e.charCodeAt(s); )
    s++;
  if (s == i && t.length == e.length)
    return null;
  let o = t.length, a = e.length;
  for (; o > 0 && a > 0 && t.charCodeAt(o - 1) == e.charCodeAt(a - 1); )
    o--, a--;
  if (n == "end") {
    let l = Math.max(0, s - Math.min(o, a));
    r -= o + l - s;
  }
  if (o < s && t.length < e.length) {
    let l = r <= s && r >= o ? s - r : 0;
    s -= l, a = s + (a - o), o = s;
  } else if (a < s) {
    let l = r <= s && r >= a ? s - r : 0;
    s -= l, o = s + (o - a), a = s;
  }
  return { from: s, toA: o, toB: a };
}
function hx(t) {
  let e = [];
  if (t.root.activeElement != t.contentDOM)
    return e;
  let { anchorNode: r, anchorOffset: n, focusNode: i, focusOffset: s } = t.observer.selectionRange;
  return r && (e.push(new hO(r, n)), (i != r || s != n) && e.push(new hO(i, s))), e;
}
function px(t, e) {
  if (t.length == 0)
    return null;
  let r = t[0].pos, n = t.length == 2 ? t[1].pos : r;
  return r > -1 && n > -1 ? ce.single(r + e, n + e) : null;
}
const mx = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, Ud = de.ie && de.ie_version <= 11;
class gx {
  constructor(e) {
    this.view = e, this.active = !1, this.selectionRange = new G_(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((r) => {
      for (let n of r)
        this.queue.push(n);
      (de.ie && de.ie_version <= 11 || de.ios && e.composing) && r.some((n) => n.type == "childList" && n.removedNodes.length || n.type == "characterData" && n.oldValue.length > n.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), Ud && (this.onCharData = (r) => {
      this.queue.push({
        target: r.target,
        type: "characterData",
        oldValue: r.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var r;
      ((r = this.view.docView) === null || r === void 0 ? void 0 : r.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((r) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), r.length > 0 && r[r.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((r) => {
      r.length > 0 && r[r.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint() {
    this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500);
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((r, n) => r != e[n]))) {
      this.gapIntersection.disconnect();
      for (let r of e)
        this.gapIntersection.observe(r);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let r = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: n } = this, i = this.selectionRange;
    if (n.state.facet(Hu) ? n.root.activeElement != this.dom : !Tc(n.dom, i))
      return;
    let s = i.anchorNode && n.docView.nearest(i.anchorNode);
    if (s && s.ignoreEvent(e)) {
      r || (this.selectionChanged = !1);
      return;
    }
    (de.ie && de.ie_version <= 11 || de.android && de.chrome) && !n.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    i.focusNode && Ea(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, r = de.safari && e.root.nodeType == 11 && Y_(this.dom.ownerDocument) == this.dom && Ox(this.view) || Jc(e.root);
    if (!r || this.selectionRange.eq(r))
      return !1;
    let n = Tc(this.dom, r);
    return n && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && J_(this.dom, r) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(r), n && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, r) {
    this.selectionRange.set(e.node, e.offset, r.node, r.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, r = null;
    for (let n = this.dom; n; )
      if (n.nodeType == 1)
        !r && e < this.scrollTargets.length && this.scrollTargets[e] == n ? e++ : r || (r = this.scrollTargets.slice(0, e)), r && r.push(n), n = n.assignedSlot || n.parentNode;
      else if (n.nodeType == 11)
        n = n.host;
      else
        break;
    if (e < this.scrollTargets.length && !r && (r = this.scrollTargets.slice(0, e)), r) {
      for (let n of this.scrollTargets)
        n.removeEventListener("scroll", this.onScroll);
      for (let n of this.scrollTargets = r)
        n.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, mx), Ud && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), Ud && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, r) {
    var n;
    if (!this.delayedAndroidKey) {
      let i = () => {
        let s = this.delayedAndroidKey;
        s && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = s.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && s.force && Js(this.dom, s.key, s.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(i);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: r,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((n = this.delayedAndroidKey) === null || n === void 0) && n.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let r = -1, n = -1, i = !1;
    for (let s of e) {
      let o = this.readMutation(s);
      o && (o.typeOver && (i = !0), r == -1 ? { from: r, to: n } = o : (r = Math.min(o.from, r), n = Math.max(o.to, n)));
    }
    return { from: r, to: n, typeOver: i };
  }
  readChange() {
    let { from: e, to: r, typeOver: n } = this.processRecords(), i = this.selectionChanged && Tc(this.dom, this.selectionRange);
    if (e < 0 && !i)
      return null;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let s = new ux(this.view, e, r, n);
    return this.view.docView.domChanged = { newSel: s.newSel ? s.newSel.main : null }, s;
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let r = this.readChange();
    if (!r)
      return this.view.requestMeasure(), !1;
    let n = this.view.state, i = ww(this.view, r);
    return this.view.state == n && this.view.update([]), i;
  }
  readMutation(e) {
    let r = this.view.docView.nearest(e.target);
    if (!r || r.ignoreMutation(e))
      return null;
    if (r.markDirty(e.type == "attributes"), e.type == "attributes" && (r.flags |= 4), e.type == "childList") {
      let n = pO(r, e.previousSibling || e.target.previousSibling, -1), i = pO(r, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: n ? r.posAfter(n) : r.posAtStart,
        to: i ? r.posBefore(i) : r.posAtEnd,
        typeOver: !1
      };
    } else
      return e.type == "characterData" ? { from: r.posAtStart, to: r.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var e, r, n;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (r = this.gapIntersection) === null || r === void 0 || r.disconnect(), (n = this.resizeScroll) === null || n === void 0 || n.disconnect();
    for (let i of this.scrollTargets)
      i.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
}
function pO(t, e, r) {
  for (; e; ) {
    let n = et.get(e);
    if (n && n.parent == t)
      return n;
    let i = e.parentNode;
    e = i != t.dom ? i : r > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function Ox(t) {
  let e = null;
  function r(l) {
    l.preventDefault(), l.stopImmediatePropagation(), e = l.getTargetRanges()[0];
  }
  if (t.contentDOM.addEventListener("beforeinput", r, !0), t.dom.ownerDocument.execCommand("indent"), t.contentDOM.removeEventListener("beforeinput", r, !0), !e)
    return null;
  let n = e.startContainer, i = e.startOffset, s = e.endContainer, o = e.endOffset, a = t.docView.domAtPos(t.state.selection.main.anchor);
  return Ea(a.node, a.offset, s, o) && ([n, i, s, o] = [s, o, n, i]), { anchorNode: n, anchorOffset: i, focusNode: s, focusOffset: o };
}
class Se {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);
    let { dispatch: r } = e;
    this.dispatchTransactions = e.dispatchTransactions || r && ((n) => n.forEach((i) => r(i, this))) || ((n) => this.update(n)), this.dispatch = this.dispatch.bind(this), this._root = e.root || K_(e.parent) || document, this.viewState = new uO(e.state || De.create(e)), e.scrollTo && e.scrollTo.is(Gl) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(va).map((n) => new Dd(n));
    for (let n of this.plugins)
      n.update(this);
    this.observer = new gx(this), this.inputState = new EP(this), this.inputState.ensureHandlers(this.plugins), this.docView = new L0(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure();
  }
  dispatch(...e) {
    let r = e.length == 1 && e[0] instanceof Rt ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];
    this.dispatchTransactions(r, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let r = !1, n = !1, i, s = this.state;
    for (let f of e) {
      if (f.startState != s)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      s = f.state;
    }
    if (this.destroyed) {
      this.viewState.state = s;
      return;
    }
    let o = this.hasFocus, a = 0, l = null;
    e.some((f) => f.annotation(pw)) ? (this.inputState.notifiedFocused = o, a = 1) : o != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = o, l = mw(s, o), l || (a = 1));
    let c = this.observer.delayedAndroidKey, u = null;
    if (c ? (this.observer.clearDelayedAndroidKey(), u = this.observer.readChange(), (u && !this.state.doc.eq(s.doc) || !this.state.selection.eq(s.selection)) && (u = null)) : this.observer.clear(), s.facet(De.phrases) != this.state.facet(De.phrases))
      return this.setState(s);
    i = eu.create(this, s, e), i.flags |= a;
    let d = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let f of e) {
        if (d && (d = d.map(f.changes)), f.scrollIntoView) {
          let { main: h } = f.state.selection;
          d = new eo(h.empty ? h : ce.cursor(h.head, h.head > h.anchor ? -1 : 1));
        }
        for (let h of f.effects)
          h.is(Gl) && (d = h.value.clip(this.state));
      }
      this.viewState.update(i, d), this.bidiCache = tu.update(this.bidiCache, i.changes), i.empty || (this.updatePlugins(i), this.inputState.update(i)), r = this.docView.update(i), this.state.facet(wa) != this.styleModules && this.mountStyles(), n = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(r, e.some((f) => f.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (i.startState.facet(nc) != i.state.facet(nc) && (this.viewState.mustMeasureContent = !0), (r || n || d || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), !i.empty)
      for (let f of this.state.facet($h))
        try {
          f(i);
        } catch (h) {
          Wr(this.state, h, "update listener");
        }
    (l || u) && Promise.resolve().then(() => {
      l && this.state == l.startState && this.dispatch(l), u && !ww(this, u) && c.force && Js(this.contentDOM, c.key, c.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let r = this.hasFocus;
    try {
      for (let n of this.plugins)
        n.destroy(this);
      this.viewState = new uO(e), this.plugins = e.facet(va).map((n) => new Dd(n)), this.pluginMap.clear();
      for (let n of this.plugins)
        n.update(this);
      this.docView.destroy(), this.docView = new L0(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    r && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let r = e.startState.facet(va), n = e.state.facet(va);
    if (r != n) {
      let i = [];
      for (let s of n) {
        let o = r.indexOf(s);
        if (o < 0)
          i.push(new Dd(s));
        else {
          let a = this.plugins[o];
          a.mustUpdate = e, i.push(a);
        }
      }
      for (let s of this.plugins)
        s.mustUpdate != e && s.destroy(this);
      this.plugins = i, this.pluginMap.clear();
    } else
      for (let i of this.plugins)
        i.mustUpdate = e;
    for (let i = 0; i < this.plugins.length; i++)
      this.plugins[i].update(this);
    r != n && this.inputState.ensureHandlers(this.plugins);
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, e && this.observer.forceFlush();
    let r = null, n = this.scrollDOM, i = n.scrollTop * this.scaleY, { scrollAnchorPos: s, scrollAnchorHeight: o } = this.viewState;
    Math.abs(i - this.viewState.scrollTop) > 1 && (o = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let a = 0; ; a++) {
        if (o < 0)
          if (Ev(n))
            s = -1, o = this.viewState.heightMap.height;
          else {
            let h = this.viewState.scrollAnchorAt(i);
            s = h.from, o = h.top;
          }
        this.updateState = 1;
        let l = this.viewState.measure(this);
        if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (a > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let c = [];
        l & 4 || ([this.measureRequests, c] = [c, this.measureRequests]);
        let u = c.map((h) => {
          try {
            return h.read(this);
          } catch (p) {
            return Wr(this.state, p), mO;
          }
        }), d = eu.create(this, this.state, []), f = !1;
        d.flags |= l, r ? r.flags |= l : r = d, this.updateState = 2, d.empty || (this.updatePlugins(d), this.inputState.update(d), this.updateAttrs(), f = this.docView.update(d));
        for (let h = 0; h < c.length; h++)
          if (u[h] != mO)
            try {
              let p = c[h];
              p.write && p.write(u[h], this);
            } catch (p) {
              Wr(this.state, p);
            }
        if (f && this.docView.updateSelection(!0), !d.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, o = -1;
              continue;
            } else {
              let p = (s < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(s).top) - o;
              if (p > 1 || p < -1) {
                i = i + p, n.scrollTop = i / this.scaleY, o = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (r && !r.empty)
      for (let a of this.state.facet($h))
        a(r);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return Ph + " " + (this.state.facet(_h) ? bw : yw) + " " + this.state.facet(nc);
  }
  updateAttrs() {
    let e = gO(this, ew, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), r = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: this.state.facet(Hu) ? "true" : "false",
      class: "cm-content",
      style: `${de.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (r["aria-readonly"] = "true"), gO(this, om, r);
    let n = this.observer.ignore(() => {
      let i = Oh(this.contentDOM, this.contentAttrs, r), s = Oh(this.dom, this.editorAttrs, e);
      return i || s;
    });
    return this.editorAttrs = e, this.contentAttrs = r, n;
  }
  showAnnouncements(e) {
    let r = !0;
    for (let n of e)
      for (let i of n.effects)
        if (i.is(Se.announce)) {
          r && (this.announceDOM.textContent = ""), r = !1;
          let s = this.announceDOM.appendChild(document.createElement("div"));
          s.textContent = i.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(wa);
    let e = this.state.facet(Se.cspNonce);
    yi.mount(this.root, this.styleModules.concat(ax).reverse(), e ? { nonce: e } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let r = 0; r < this.measureRequests.length; r++)
          if (this.measureRequests[r].key === e.key) {
            this.measureRequests[r] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let r = this.pluginMap.get(e);
    return (r === void 0 || r && r.spec != e) && this.pluginMap.set(e, r = this.plugins.find((n) => n.spec == e) || null), r && r.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, r, n) {
    return Xd(this, e, K0(this, e, r, n));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, r) {
    return Xd(this, e, K0(this, e, r, (n) => QP(this, e.head, n)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(e, r) {
    let n = this.bidiSpans(e), i = this.textDirectionAt(e.from), s = n[r ? n.length - 1 : 0];
    return ce.cursor(s.side(r, i) + e.from, s.forward(!r, i) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, r, n = !0) {
    return CP(this, e, r, n);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, r, n) {
    return Xd(this, e, AP(this, e, r, n));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, r = 0) {
    return this.docView.posFromDOM(e, r);
  }
  posAtCoords(e, r = !0) {
    return this.readMeasured(), aw(this, e, r);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, r = 1) {
    this.readMeasured();
    let n = this.docView.coordsAt(e, r);
    if (!n || n.left == n.right)
      return n;
    let i = this.state.doc.lineAt(e), s = this.bidiSpans(i), o = s[ai.find(s, e - i.from, -1, r)];
    return rm(n, o.dir == mt.LTR == r > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(Jv) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)â€”if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > yx)
      return Vv(e.length);
    let r = this.textDirectionAt(e.from), n;
    for (let s of this.bidiCache)
      if (s.from == e.from && s.dir == r && (s.fresh || Uv(s.isolates, n = V0(this, e))))
        return s.order;
    n || (n = V0(this, e));
    let i = dP(e.text, r, n);
    return this.bidiCache.push(new tu(e.from, e.to, r, n, !0, i)), i;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || de.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      Qv(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, r = {}) {
    return Gl.of(new eo(typeof e == "number" ? ce.cursor(e) : e, r.y, r.x, r.yMargin, r.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: e, scrollLeft: r } = this.scrollDOM, n = this.viewState.scrollAnchorAt(e);
    return Gl.of(new eo(ce.cursor(n.from), "start", "start", n.top - e, r, !0));
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return Pr.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(e) {
    return Pr.define(() => ({}), { eventObservers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)â€”to which the scope class will be
  addedâ€”need to be explicitly differentiated by adding an `&` to
  the selector for that elementâ€”for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, r) {
    let n = yi.newName(), i = [nc.of(n), wa.of(xh(`.${n}`, e))];
    return r && r.dark && i.push(_h.of(!0)), i;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return pl.lowest(wa.of(xh("." + Ph, e, vw)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var r;
    let n = e.querySelector(".cm-content"), i = n && et.get(n) || et.get(e);
    return ((r = i == null ? void 0 : i.rootView) === null || r === void 0 ? void 0 : r.view) || null;
  }
}
Se.styleModule = wa;
Se.inputHandler = Gv;
Se.focusChangeEffect = Kv;
Se.perLineTextDirection = Jv;
Se.exceptionSink = Hv;
Se.updateListener = $h;
Se.editable = Hu;
Se.mouseSelectionStyle = Fv;
Se.dragMovesSelection = Bv;
Se.clickAddsSelectionRange = Yv;
Se.decorations = Ga;
Se.outerDecorations = tw;
Se.atomicRanges = am;
Se.bidiIsolatedRanges = rw;
Se.scrollMargins = nw;
Se.darkTheme = _h;
Se.cspNonce = /* @__PURE__ */ be.define({ combine: (t) => t.length ? t[0] : "" });
Se.contentAttributes = om;
Se.editorAttributes = ew;
Se.lineWrapping = /* @__PURE__ */ Se.contentAttributes.of({ class: "cm-lineWrapping" });
Se.announce = /* @__PURE__ */ Le.define();
const yx = 4096, mO = {};
class tu {
  constructor(e, r, n, i, s, o) {
    this.from = e, this.to = r, this.dir = n, this.isolates = i, this.fresh = s, this.order = o;
  }
  static update(e, r) {
    if (r.empty && !e.some((s) => s.fresh))
      return e;
    let n = [], i = e.length ? e[e.length - 1].dir : mt.LTR;
    for (let s = Math.max(0, e.length - 10); s < e.length; s++) {
      let o = e[s];
      o.dir == i && !r.touchesRange(o.from, o.to) && n.push(new tu(r.mapPos(o.from, 1), r.mapPos(o.to, -1), o.dir, o.isolates, !1, o.order));
    }
    return n;
  }
}
function gO(t, e, r) {
  for (let n = t.state.facet(e), i = n.length - 1; i >= 0; i--) {
    let s = n[i], o = typeof s == "function" ? s(t) : s;
    o && gh(o, r);
  }
  return r;
}
const bx = de.mac ? "mac" : de.windows ? "win" : de.linux ? "linux" : "key";
function vx(t, e) {
  const r = t.split(/-(?!$)/);
  let n = r[r.length - 1];
  n == "Space" && (n = " ");
  let i, s, o, a;
  for (let l = 0; l < r.length - 1; ++l) {
    const c = r[l];
    if (/^(cmd|meta|m)$/i.test(c))
      a = !0;
    else if (/^a(lt)?$/i.test(c))
      i = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      s = !0;
    else if (/^s(hift)?$/i.test(c))
      o = !0;
    else if (/^mod$/i.test(c))
      e == "mac" ? a = !0 : s = !0;
    else
      throw new Error("Unrecognized modifier name: " + c);
  }
  return i && (n = "Alt-" + n), s && (n = "Ctrl-" + n), a && (n = "Meta-" + n), o && (n = "Shift-" + n), n;
}
function ic(t, e, r) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), r !== !1 && e.shiftKey && (t = "Shift-" + t), t;
}
const wx = /* @__PURE__ */ pl.default(/* @__PURE__ */ Se.domEventHandlers({
  keydown(t, e) {
    return _x($x(e.state), t, e, "editor");
  }
})), Ka = /* @__PURE__ */ be.define({ enables: wx }), OO = /* @__PURE__ */ new WeakMap();
function $x(t) {
  let e = t.facet(Ka), r = OO.get(e);
  return r || OO.set(e, r = kx(e.reduce((n, i) => n.concat(i), []))), r;
}
let ii = null;
const Sx = 4e3;
function kx(t, e = bx) {
  let r = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null), i = (o, a) => {
    let l = n[o];
    if (l == null)
      n[o] = a;
    else if (l != a)
      throw new Error("Key binding " + o + " is used both as a regular binding and as a multi-stroke prefix");
  }, s = (o, a, l, c, u) => {
    var d, f;
    let h = r[o] || (r[o] = /* @__PURE__ */ Object.create(null)), p = a.split(/ (?!$)/).map((y) => vx(y, e));
    for (let y = 1; y < p.length; y++) {
      let O = p.slice(0, y).join(" ");
      i(O, !0), h[O] || (h[O] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(b) => {
          let w = ii = { view: b, prefix: O, scope: o };
          return setTimeout(() => {
            ii == w && (ii = null);
          }, Sx), !0;
        }]
      });
    }
    let g = p.join(" ");
    i(g, !1);
    let m = h[g] || (h[g] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((f = (d = h._any) === null || d === void 0 ? void 0 : d.run) === null || f === void 0 ? void 0 : f.slice()) || []
    });
    l && m.run.push(l), c && (m.preventDefault = !0), u && (m.stopPropagation = !0);
  };
  for (let o of t) {
    let a = o.scope ? o.scope.split(" ") : ["editor"];
    if (o.any)
      for (let c of a) {
        let u = r[c] || (r[c] = /* @__PURE__ */ Object.create(null));
        u._any || (u._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        for (let d in u)
          u[d].run.push(o.any);
      }
    let l = o[e] || o.key;
    if (l)
      for (let c of a)
        s(c, l, o.run, o.preventDefault, o.stopPropagation), o.shift && s(c, "Shift-" + l, o.shift, o.preventDefault, o.stopPropagation);
  }
  return r;
}
function _x(t, e, r, n) {
  let i = L_(e), s = Mt(i, 0), o = qr(s) == i.length && i != " ", a = "", l = !1, c = !1, u = !1;
  ii && ii.view == r && ii.scope == n && (a = ii.prefix + " ", cw.indexOf(e.keyCode) < 0 && (c = !0, ii = null));
  let d = /* @__PURE__ */ new Set(), f = (m) => {
    if (m) {
      for (let y of m.run)
        if (!d.has(y) && (d.add(y), y(r, e)))
          return m.stopPropagation && (u = !0), !0;
      m.preventDefault && (m.stopPropagation && (u = !0), c = !0);
    }
    return !1;
  }, h = t[n], p, g;
  return h && (f(h[a + ic(i, e, !o)]) ? l = !0 : o && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(de.windows && e.ctrlKey && e.altKey) && (p = bi[e.keyCode]) && p != i ? (f(h[a + ic(p, e, !0)]) || e.shiftKey && (g = Ba[e.keyCode]) != i && g != p && f(h[a + ic(g, e, !1)])) && (l = !0) : o && e.shiftKey && f(h[a + ic(i, e, !0)]) && (l = !0), !l && f(h._any) && (l = !0)), c && (l = !0), l && u && e.stopPropagation(), l;
}
const Px = !de.ios, yO = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
Px && (yO[".cm-line"].caretColor = "transparent !important", yO[".cm-content"] = { caretColor: "transparent !important" });
function bO(t, e, r, n, i) {
  e.lastIndex = 0;
  for (let s = t.iterRange(r, n), o = r, a; !s.next().done; o += s.value.length)
    if (!s.lineBreak)
      for (; a = e.exec(s.value); )
        i(o + a.index, a);
}
function xx(t, e) {
  let r = t.visibleRanges;
  if (r.length == 1 && r[0].from == t.viewport.from && r[0].to == t.viewport.to)
    return r;
  let n = [];
  for (let { from: i, to: s } of r)
    i = Math.max(t.state.doc.lineAt(i).from, i - e), s = Math.min(t.state.doc.lineAt(s).to, s + e), n.length && n[n.length - 1].to >= i ? n[n.length - 1].to = s : n.push({ from: i, to: s });
  return n;
}
class $w {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: r, decoration: n, decorate: i, boundary: s, maxLength: o = 1e3 } = e;
    if (!r.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = r, i)
      this.addMatch = (a, l, c, u) => i(u, c, c + a[0].length, a, l);
    else if (typeof n == "function")
      this.addMatch = (a, l, c, u) => {
        let d = n(a, l, c);
        d && u(c, c + a[0].length, d);
      };
    else if (n)
      this.addMatch = (a, l, c, u) => u(c, c + a[0].length, n);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = s, this.maxLength = o;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let r = new po(), n = r.add.bind(r);
    for (let { from: i, to: s } of xx(e, this.maxLength))
      bO(e.state.doc, this.regexp, i, s, (o, a) => this.addMatch(a, e, o, n));
    return r.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, r) {
    let n = 1e9, i = -1;
    return e.docChanged && e.changes.iterChanges((s, o, a, l) => {
      l > e.view.viewport.from && a < e.view.viewport.to && (n = Math.min(a, n), i = Math.max(l, i));
    }), e.viewportChanged || i - n > 1e3 ? this.createDeco(e.view) : i > -1 ? this.updateRange(e.view, r.map(e.changes), n, i) : r;
  }
  updateRange(e, r, n, i) {
    for (let s of e.visibleRanges) {
      let o = Math.max(s.from, n), a = Math.min(s.to, i);
      if (a > o) {
        let l = e.state.doc.lineAt(o), c = l.to < a ? e.state.doc.lineAt(a) : l, u = Math.max(s.from, l.from), d = Math.min(s.to, c.to);
        if (this.boundary) {
          for (; o > l.from; o--)
            if (this.boundary.test(l.text[o - 1 - l.from])) {
              u = o;
              break;
            }
          for (; a < c.to; a++)
            if (this.boundary.test(c.text[a - c.from])) {
              d = a;
              break;
            }
        }
        let f = [], h, p = (g, m, y) => f.push(y.range(g, m));
        if (l == c)
          for (this.regexp.lastIndex = u - l.from; (h = this.regexp.exec(l.text)) && h.index < d - l.from; )
            this.addMatch(h, e, h.index + l.from, p);
        else
          bO(e.state.doc, this.regexp, u, d, (g, m) => this.addMatch(m, e, g, p));
        r = r.update({ filterFrom: u, filterTo: d, filter: (g, m) => g < u || m > d, add: f });
      }
    }
    return r;
  }
}
const Th = /x/.unicode != null ? "gu" : "g", Tx = /* @__PURE__ */ new RegExp(`[\0-\b
--ÂŸÂ­Øœâ€‹â€Žâ€\u2028\u2029â€­â€®â¦â§â©\uFEFFï¿¹-ï¿¼]`, Th), Cx = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let Vd = null;
function Qx() {
  var t;
  if (Vd == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    Vd = ((t = e.tabSize) !== null && t !== void 0 ? t : e.MozTabSize) != null;
  }
  return Vd || !1;
}
const Ac = /* @__PURE__ */ be.define({
  combine(t) {
    let e = Bu(t, {
      render: null,
      specialChars: Tx,
      addSpecialChars: null
    });
    return (e.replaceTabs = !Qx()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, Th)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, Th)), e;
  }
});
function Ax(t = {}) {
  return [Ac.of(t), Ex()];
}
let vO = null;
function Ex() {
  return vO || (vO = Pr.fromClass(class {
    constructor(t) {
      this.view = t, this.decorations = We.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(t.state.facet(Ac)), this.decorations = this.decorator.createDeco(t);
    }
    makeDecorator(t) {
      return new $w({
        regexp: t.specialChars,
        decoration: (e, r, n) => {
          let { doc: i } = r.state, s = Mt(e[0], 0);
          if (s == 9) {
            let o = i.lineAt(n), a = r.state.tabSize, l = Tv(o.text, a, n - o.from);
            return We.replace({
              widget: new Zx((a - l % a) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[s] || (this.decorationCache[s] = We.replace({ widget: new jx(t, s) }));
        },
        boundary: t.replaceTabs ? void 0 : /[^]/
      });
    }
    update(t) {
      let e = t.state.facet(Ac);
      t.startState.facet(Ac) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(t.view)) : this.decorations = this.decorator.updateDeco(t, this.decorations);
    }
  }, {
    decorations: (t) => t.decorations
  }));
}
const Rx = "â€¢";
function Ix(t) {
  return t >= 32 ? Rx : t == 10 ? "â¤" : String.fromCharCode(9216 + t);
}
class jx extends Ro {
  constructor(e, r) {
    super(), this.options = e, this.code = r;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let r = Ix(this.code), n = e.state.phrase("Control character") + " " + (Cx[this.code] || "0x" + this.code.toString(16)), i = this.options.render && this.options.render(this.code, n, r);
    if (i)
      return i;
    let s = document.createElement("span");
    return s.textContent = r, s.title = n, s.setAttribute("aria-label", n), s.className = "cm-specialChar", s;
  }
  ignoreEvent() {
    return !1;
  }
}
class Zx extends Ro {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
const aa = "-10000px";
class Mx {
  constructor(e, r, n, i) {
    this.facet = r, this.createTooltipView = n, this.removeTooltipView = i, this.input = e.state.facet(r), this.tooltips = this.input.filter((o) => o);
    let s = null;
    this.tooltipViews = this.tooltips.map((o) => s = n(o, s));
  }
  update(e, r) {
    var n;
    let i = e.state.facet(this.facet), s = i.filter((l) => l);
    if (i === this.input) {
      for (let l of this.tooltipViews)
        l.update && l.update(e);
      return !1;
    }
    let o = [], a = r ? [] : null;
    for (let l = 0; l < s.length; l++) {
      let c = s[l], u = -1;
      if (c) {
        for (let d = 0; d < this.tooltips.length; d++) {
          let f = this.tooltips[d];
          f && f.create == c.create && (u = d);
        }
        if (u < 0)
          o[l] = this.createTooltipView(c, l ? o[l - 1] : null), a && (a[l] = !!c.above);
        else {
          let d = o[l] = this.tooltipViews[u];
          a && (a[l] = r[u]), d.update && d.update(e);
        }
      }
    }
    for (let l of this.tooltipViews)
      o.indexOf(l) < 0 && (this.removeTooltipView(l), (n = l.destroy) === null || n === void 0 || n.call(l));
    return r && (a.forEach((l, c) => r[c] = l), r.length = a.length), this.input = i, this.tooltips = s, this.tooltipViews = o, !0;
  }
}
function qx(t) {
  let { win: e } = t;
  return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth };
}
const Ld = /* @__PURE__ */ be.define({
  combine: (t) => {
    var e, r, n;
    return {
      position: de.ios ? "absolute" : ((e = t.find((i) => i.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((r = t.find((i) => i.parent)) === null || r === void 0 ? void 0 : r.parent) || null,
      tooltipSpace: ((n = t.find((i) => i.tooltipSpace)) === null || n === void 0 ? void 0 : n.tooltipSpace) || qx
    };
  }
}), wO = /* @__PURE__ */ new WeakMap(), Sw = /* @__PURE__ */ Pr.fromClass(class {
  constructor(t) {
    this.view = t, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = t.state.facet(Ld);
    this.position = e.position, this.parent = e.parent, this.classes = t.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new Mx(t, kw, (r, n) => this.createTooltip(r, n), (r) => {
      this.resizeObserver && this.resizeObserver.unobserve(r.dom), r.dom.remove();
    }), this.above = this.manager.tooltips.map((r) => !!r.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((r) => {
      Date.now() > this.lastTransaction - 50 && r.length > 0 && r[r.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), t.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let t of this.manager.tooltipViews)
        this.intersectionObserver.observe(t.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(t) {
    t.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(t, this.above);
    e && this.observeIntersection();
    let r = e || t.geometryChanged, n = t.state.facet(Ld);
    if (n.position != this.position && !this.madeAbsolute) {
      this.position = n.position;
      for (let i of this.manager.tooltipViews)
        i.dom.style.position = this.position;
      r = !0;
    }
    if (n.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = n.parent, this.createContainer();
      for (let i of this.manager.tooltipViews)
        this.container.appendChild(i.dom);
      r = !0;
    } else
      this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    r && this.maybeMeasure();
  }
  createTooltip(t, e) {
    let r = t.create(this.view), n = e ? e.dom : null;
    if (r.dom.classList.add("cm-tooltip"), t.arrow && !r.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let i = document.createElement("div");
      i.className = "cm-tooltip-arrow", r.dom.insertBefore(i, n);
    }
    return r.dom.style.position = this.position, r.dom.style.top = aa, r.dom.style.left = "0px", this.container.insertBefore(r.dom, n), r.mount && r.mount(this.view), this.resizeObserver && this.resizeObserver.observe(r.dom), r;
  }
  destroy() {
    var t, e, r;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let n of this.manager.tooltipViews)
      n.dom.remove(), (t = n.destroy) === null || t === void 0 || t.call(n);
    this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (r = this.intersectionObserver) === null || r === void 0 || r.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let t = this.view.dom.getBoundingClientRect(), e = 1, r = 1, n = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: i } = this.manager.tooltipViews[0];
      if (de.gecko)
        n = i.offsetParent != this.container.ownerDocument.body;
      else if (i.style.top == aa && i.style.left == "0px") {
        let s = i.getBoundingClientRect();
        n = Math.abs(s.top + 1e4) > 1 || Math.abs(s.left) > 1;
      }
    }
    if (n || this.position == "absolute")
      if (this.parent) {
        let i = this.parent.getBoundingClientRect();
        i.width && i.height && (e = i.width / this.parent.offsetWidth, r = i.height / this.parent.offsetHeight);
      } else
        ({ scaleX: e, scaleY: r } = this.view.viewState);
    return {
      editor: t,
      parent: this.parent ? this.container.getBoundingClientRect() : t,
      pos: this.manager.tooltips.map((i, s) => {
        let o = this.manager.tooltipViews[s];
        return o.getCoords ? o.getCoords(i.pos) : this.view.coordsAtPos(i.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: i }) => i.getBoundingClientRect()),
      space: this.view.state.facet(Ld).tooltipSpace(this.view),
      scaleX: e,
      scaleY: r,
      makeAbsolute: n
    };
  }
  writeMeasure(t) {
    var e;
    if (t.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let a of this.manager.tooltipViews)
        a.dom.style.position = "absolute";
    }
    let { editor: r, space: n, scaleX: i, scaleY: s } = t, o = [];
    for (let a = 0; a < this.manager.tooltips.length; a++) {
      let l = this.manager.tooltips[a], c = this.manager.tooltipViews[a], { dom: u } = c, d = t.pos[a], f = t.size[a];
      if (!d || d.bottom <= Math.max(r.top, n.top) || d.top >= Math.min(r.bottom, n.bottom) || d.right < Math.max(r.left, n.left) - 0.1 || d.left > Math.min(r.right, n.right) + 0.1) {
        u.style.top = aa;
        continue;
      }
      let h = l.arrow ? c.dom.querySelector(".cm-tooltip-arrow") : null, p = h ? 7 : 0, g = f.right - f.left, m = (e = wO.get(c)) !== null && e !== void 0 ? e : f.bottom - f.top, y = c.offset || Dx, O = this.view.textDirection == mt.LTR, b = f.width > n.right - n.left ? O ? n.left : n.right - f.width : O ? Math.min(d.left - (h ? 14 : 0) + y.x, n.right - g) : Math.max(n.left, d.left - g + (h ? 14 : 0) - y.x), w = this.above[a];
      !l.strictSide && (w ? d.top - (f.bottom - f.top) - y.y < n.top : d.bottom + (f.bottom - f.top) + y.y > n.bottom) && w == n.bottom - d.bottom > d.top - n.top && (w = this.above[a] = !w);
      let S = (w ? d.top - n.top : n.bottom - d.bottom) - p;
      if (S < m && c.resize !== !1) {
        if (S < this.view.defaultLineHeight) {
          u.style.top = aa;
          continue;
        }
        wO.set(c, m), u.style.height = (m = S) / s + "px";
      } else
        u.style.height && (u.style.height = "");
      let $ = w ? d.top - m - p - y.y : d.bottom + p + y.y, _ = b + g;
      if (c.overlap !== !0)
        for (let Q of o)
          Q.left < _ && Q.right > b && Q.top < $ + m && Q.bottom > $ && ($ = w ? Q.top - m - 2 - p : Q.bottom + p + 2);
      if (this.position == "absolute" ? (u.style.top = ($ - t.parent.top) / s + "px", u.style.left = (b - t.parent.left) / i + "px") : (u.style.top = $ / s + "px", u.style.left = b / i + "px"), h) {
        let Q = d.left + (O ? y.x : -y.x) - (b + 14 - 7);
        h.style.left = Q / i + "px";
      }
      c.overlap !== !0 && o.push({ left: b, top: $, right: _, bottom: $ + m }), u.classList.toggle("cm-tooltip-above", w), u.classList.toggle("cm-tooltip-below", !w), c.positioned && c.positioned(t.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let t of this.manager.tooltipViews)
        t.dom.style.top = aa;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
}), Nx = /* @__PURE__ */ Se.baseTheme({
  ".cm-tooltip": {
    zIndex: 100,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), Dx = { x: 0, y: 0 }, kw = /* @__PURE__ */ be.define({
  enables: [Sw, Nx]
});
function _w(t, e) {
  let r = t.plugin(Sw);
  if (!r)
    return null;
  let n = r.manager.tooltips.indexOf(e);
  return n < 0 ? null : r.manager.tooltipViews[n];
}
class us extends as {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
us.prototype.elementClass = "";
us.prototype.toDOM = void 0;
us.prototype.mapMode = qt.TrackBefore;
us.prototype.startSide = us.prototype.endSide = -1;
us.prototype.point = !0;
const Yd = /* @__PURE__ */ be.define(), Ec = /* @__PURE__ */ be.define(), Ch = /* @__PURE__ */ be.define({
  combine: (t) => t.some((e) => e)
});
function zx(t) {
  let e = [
    Xx
  ];
  return t && t.fixed === !1 && e.push(Ch.of(!0)), e;
}
const Xx = /* @__PURE__ */ Pr.fromClass(class {
  constructor(t) {
    this.view = t, this.prevViewport = t.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px", this.gutters = t.state.facet(Ec).map((e) => new SO(t, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !t.state.facet(Ch), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), t.scrollDOM.insertBefore(this.dom, t.contentDOM);
  }
  update(t) {
    if (this.updateGutters(t)) {
      let e = this.prevViewport, r = t.view.viewport, n = Math.min(e.to, r.to) - Math.max(e.from, r.from);
      this.syncGutters(n < (r.to - r.from) * 0.8);
    }
    t.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight + "px"), this.view.state.facet(Ch) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = t.view.viewport;
  }
  syncGutters(t) {
    let e = this.dom.nextSibling;
    t && this.dom.remove();
    let r = ze.iter(this.view.state.facet(Yd), this.view.viewport.from), n = [], i = this.gutters.map((s) => new Wx(s, this.view.viewport, -this.view.documentPadding.top));
    for (let s of this.view.viewportLineBlocks)
      if (n.length && (n = []), Array.isArray(s.type)) {
        let o = !0;
        for (let a of s.type)
          if (a.type == Xr.Text && o) {
            Qh(r, n, a.from);
            for (let l of i)
              l.line(this.view, a, n);
            o = !1;
          } else if (a.widget)
            for (let l of i)
              l.widget(this.view, a);
      } else if (s.type == Xr.Text) {
        Qh(r, n, s.from);
        for (let o of i)
          o.line(this.view, s, n);
      } else if (s.widget)
        for (let o of i)
          o.widget(this.view, s);
    for (let s of i)
      s.finish();
    t && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(t) {
    let e = t.startState.facet(Ec), r = t.state.facet(Ec), n = t.docChanged || t.heightChanged || t.viewportChanged || !ze.eq(t.startState.facet(Yd), t.state.facet(Yd), t.view.viewport.from, t.view.viewport.to);
    if (e == r)
      for (let i of this.gutters)
        i.update(t) && (n = !0);
    else {
      n = !0;
      let i = [];
      for (let s of r) {
        let o = e.indexOf(s);
        o < 0 ? i.push(new SO(this.view, s)) : (this.gutters[o].update(t), i.push(this.gutters[o]));
      }
      for (let s of this.gutters)
        s.dom.remove(), i.indexOf(s) < 0 && s.destroy();
      for (let s of i)
        this.dom.appendChild(s.dom);
      this.gutters = i;
    }
    return n;
  }
  destroy() {
    for (let t of this.gutters)
      t.destroy();
    this.dom.remove();
  }
}, {
  provide: (t) => Se.scrollMargins.of((e) => {
    let r = e.plugin(t);
    return !r || r.gutters.length == 0 || !r.fixed ? null : e.textDirection == mt.LTR ? { left: r.dom.offsetWidth * e.scaleX } : { right: r.dom.offsetWidth * e.scaleX };
  })
});
function $O(t) {
  return Array.isArray(t) ? t : [t];
}
function Qh(t, e, r) {
  for (; t.value && t.from <= r; )
    t.from == r && e.push(t.value), t.next();
}
class Wx {
  constructor(e, r, n) {
    this.gutter = e, this.height = n, this.i = 0, this.cursor = ze.iter(e.markers, r.from);
  }
  addElement(e, r, n) {
    let { gutter: i } = this, s = (r.top - this.height) / e.scaleY, o = r.height / e.scaleY;
    if (this.i == i.elements.length) {
      let a = new Pw(e, o, s, n);
      i.elements.push(a), i.dom.appendChild(a.dom);
    } else
      i.elements[this.i].update(e, o, s, n);
    this.height = r.bottom, this.i++;
  }
  line(e, r, n) {
    let i = [];
    Qh(this.cursor, i, r.from), n.length && (i = i.concat(n));
    let s = this.gutter.config.lineMarker(e, r, i);
    s && i.unshift(s);
    let o = this.gutter;
    i.length == 0 && !o.config.renderEmptyElements || this.addElement(e, r, i);
  }
  widget(e, r) {
    let n = this.gutter.config.widgetMarker(e, r.widget, r);
    n && this.addElement(e, r, [n]);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let r = e.elements.pop();
      e.dom.removeChild(r.dom), r.destroy();
    }
  }
}
class SO {
  constructor(e, r) {
    this.view = e, this.config = r, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let n in r.domEventHandlers)
      this.dom.addEventListener(n, (i) => {
        let s = i.target, o;
        if (s != this.dom && this.dom.contains(s)) {
          for (; s.parentNode != this.dom; )
            s = s.parentNode;
          let l = s.getBoundingClientRect();
          o = (l.top + l.bottom) / 2;
        } else
          o = i.clientY;
        let a = e.lineBlockAtHeight(o - e.documentTop);
        r.domEventHandlers[n](e, a, i) && i.preventDefault();
      });
    this.markers = $O(r.markers(e)), r.initialSpacer && (this.spacer = new Pw(e, 0, 0, [r.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let r = this.markers;
    if (this.markers = $O(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let i = this.config.updateSpacer(this.spacer.markers[0], e);
      i != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [i]);
    }
    let n = e.view.viewport;
    return !ze.eq(this.markers, r, n.from, n.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class Pw {
  constructor(e, r, n, i) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, r, n, i);
  }
  update(e, r, n, i) {
    this.height != r && (this.height = r, this.dom.style.height = r + "px"), this.above != n && (this.dom.style.marginTop = (this.above = n) ? n + "px" : ""), Ux(this.markers, i) || this.setMarkers(e, i);
  }
  setMarkers(e, r) {
    let n = "cm-gutterElement", i = this.dom.firstChild;
    for (let s = 0, o = 0; ; ) {
      let a = o, l = s < r.length ? r[s++] : null, c = !1;
      if (l) {
        let u = l.elementClass;
        u && (n += " " + u);
        for (let d = o; d < this.markers.length; d++)
          if (this.markers[d].compare(l)) {
            a = d, c = !0;
            break;
          }
      } else
        a = this.markers.length;
      for (; o < a; ) {
        let u = this.markers[o++];
        if (u.toDOM) {
          u.destroy(i);
          let d = i.nextSibling;
          i.remove(), i = d;
        }
      }
      if (!l)
        break;
      l.toDOM && (c ? i = i.nextSibling : this.dom.insertBefore(l.toDOM(e), i)), c && o++;
    }
    this.dom.className = n, this.markers = r;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function Ux(t, e) {
  if (t.length != e.length)
    return !1;
  for (let r = 0; r < t.length; r++)
    if (!t[r].compare(e[r]))
      return !1;
  return !0;
}
const Vx = /* @__PURE__ */ be.define(), zs = /* @__PURE__ */ be.define({
  combine(t) {
    return Bu(t, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, r) {
        let n = Object.assign({}, e);
        for (let i in r) {
          let s = n[i], o = r[i];
          n[i] = s ? (a, l, c) => s(a, l, c) || o(a, l, c) : o;
        }
        return n;
      }
    });
  }
});
class Bd extends us {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function Fd(t, e) {
  return t.state.facet(zs).formatNumber(e, t.state);
}
const Lx = /* @__PURE__ */ Ec.compute([zs], (t) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(Vx);
  },
  lineMarker(e, r, n) {
    return n.some((i) => i.toDOM) ? null : new Bd(Fd(e, e.state.doc.lineAt(r.from).number));
  },
  widgetMarker: () => null,
  lineMarkerChange: (e) => e.startState.facet(zs) != e.state.facet(zs),
  initialSpacer(e) {
    return new Bd(Fd(e, kO(e.state.doc.lines)));
  },
  updateSpacer(e, r) {
    let n = Fd(r.view, kO(r.view.state.doc.lines));
    return n == e.number ? e : new Bd(n);
  },
  domEventHandlers: t.facet(zs).domEventHandlers
}));
function Yx(t = {}) {
  return [
    zs.of(t),
    zx(),
    Lx
  ];
}
function kO(t) {
  let e = 9;
  for (; e < t; )
    e = e * 10 + 9;
  return e;
}
const xw = 1024;
let Bx = 0;
class $r {
  constructor(e, r) {
    this.from = e, this.to = r;
  }
}
class Ie {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = Bx++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = Gt.match(e)), (r) => {
      let n = e(r);
      return n === void 0 ? null : [this, n];
    };
  }
}
Ie.closedBy = new Ie({ deserialize: (t) => t.split(" ") });
Ie.openedBy = new Ie({ deserialize: (t) => t.split(" ") });
Ie.group = new Ie({ deserialize: (t) => t.split(" ") });
Ie.isolate = new Ie({ deserialize: (t) => {
  if (t && t != "rtl" && t != "ltr" && t != "auto")
    throw new RangeError("Invalid value for isolate: " + t);
  return t || "auto";
} });
Ie.contextHash = new Ie({ perNode: !0 });
Ie.lookAhead = new Ie({ perNode: !0 });
Ie.mounted = new Ie({ perNode: !0 });
class Ja {
  constructor(e, r, n) {
    this.tree = e, this.overlay = r, this.parser = n;
  }
  /**
  @internal
  */
  static get(e) {
    return e && e.props && e.props[Ie.mounted.id];
  }
}
const Fx = /* @__PURE__ */ Object.create(null);
class Gt {
  /**
  @internal
  */
  constructor(e, r, n, i = 0) {
    this.name = e, this.props = r, this.id = n, this.flags = i;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let r = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : Fx, n = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), i = new Gt(e.name || "", r, e.id, n);
    if (e.props) {
      for (let s of e.props)
        if (Array.isArray(s) || (s = s(i)), s) {
          if (s[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          r[s[0].id] = s[1];
        }
    }
    return i;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let r = this.prop(Ie.group);
      return r ? r.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let r = /* @__PURE__ */ Object.create(null);
    for (let n in e)
      for (let i of n.split(" "))
        r[i] = e[n];
    return (n) => {
      for (let i = n.prop(Ie.group), s = -1; s < (i ? i.length : 0); s++) {
        let o = r[s < 0 ? n.name : i[s]];
        if (o)
          return o;
      }
    };
  }
}
Gt.none = new Gt(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class cm {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e) {
    this.types = e;
    for (let r = 0; r < e.length; r++)
      if (e[r].id != r)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e) {
    let r = [];
    for (let n of this.types) {
      let i = null;
      for (let s of e) {
        let o = s(n);
        o && (i || (i = Object.assign({}, n.props)), i[o[0].id] = o[1]);
      }
      r.push(i ? new Gt(n.name, i, n.id, n.flags) : n);
    }
    return new cm(r);
  }
}
const sc = /* @__PURE__ */ new WeakMap(), _O = /* @__PURE__ */ new WeakMap();
var Be;
(function(t) {
  t[t.ExcludeBuffers = 1] = "ExcludeBuffers", t[t.IncludeAnonymous = 2] = "IncludeAnonymous", t[t.IgnoreMounts = 4] = "IgnoreMounts", t[t.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Be || (Be = {}));
class it {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, r, n, i, s) {
    if (this.type = e, this.children = r, this.positions = n, this.length = i, this.props = null, s && s.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [o, a] of s)
        this.props[typeof o == "number" ? o : o.id] = a;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = Ja.get(this);
    if (e && !e.overlay)
      return e.tree.toString();
    let r = "";
    for (let n of this.children) {
      let i = n.toString();
      i && (r && (r += ","), r += i);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (r.length ? "(" + r + ")" : "") : r;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new ru(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, r = 0, n = 0) {
    let i = sc.get(this) || this.topNode, s = new ru(i);
    return s.moveTo(e, r), sc.set(this, s._tree), s;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new zt(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, r = 0) {
    let n = el(sc.get(this) || this.topNode, e, r, !1);
    return sc.set(this, n), n;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, r = 0) {
    let n = el(_O.get(this) || this.topNode, e, r, !0);
    return _O.set(this, n), n;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(e, r = 0) {
    return Kx(this, e, r);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: r, leave: n, from: i = 0, to: s = this.length } = e, o = e.mode || 0, a = (o & Be.IncludeAnonymous) > 0;
    for (let l = this.cursor(o | Be.IncludeAnonymous); ; ) {
      let c = !1;
      if (l.from <= s && l.to >= i && (!a && l.type.isAnonymous || r(l) !== !1)) {
        if (l.firstChild())
          continue;
        c = !0;
      }
      for (; c && n && (a || !l.type.isAnonymous) && n(l), !l.nextSibling(); ) {
        if (!l.parent())
          return;
        c = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let r in this.props)
        e.push([+r, this.props[r]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : fm(Gt.none, this.children, this.positions, 0, this.children.length, 0, this.length, (r, n, i) => new it(this.type, r, n, i, this.propValues), e.makeTree || ((r, n, i) => new it(Gt.none, r, n, i)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return Jx(e);
  }
}
it.empty = new it(Gt.none, [], [], 0);
class um {
  constructor(e, r) {
    this.buffer = e, this.index = r;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new um(this.buffer, this.index);
  }
}
class wi {
  /**
  Create a tree buffer.
  */
  constructor(e, r, n) {
    this.buffer = e, this.length = r, this.set = n;
  }
  /**
  @internal
  */
  get type() {
    return Gt.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let r = 0; r < this.buffer.length; )
      e.push(this.childString(r)), r = this.buffer[r + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let r = this.buffer[e], n = this.buffer[e + 3], i = this.set.types[r], s = i.name;
    if (/\W/.test(s) && !i.isError && (s = JSON.stringify(s)), e += 4, n == e)
      return s;
    let o = [];
    for (; e < n; )
      o.push(this.childString(e)), e = this.buffer[e + 3];
    return s + "(" + o.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, r, n, i, s) {
    let { buffer: o } = this, a = -1;
    for (let l = e; l != r && !(Tw(s, i, o[l + 1], o[l + 2]) && (a = l, n > 0)); l = o[l + 3])
      ;
    return a;
  }
  /**
  @internal
  */
  slice(e, r, n) {
    let i = this.buffer, s = new Uint16Array(r - e), o = 0;
    for (let a = e, l = 0; a < r; ) {
      s[l++] = i[a++], s[l++] = i[a++] - n;
      let c = s[l++] = i[a++] - n;
      s[l++] = i[a++] - e, o = Math.max(o, c);
    }
    return new wi(s, o, this.set);
  }
}
function Tw(t, e, r, n) {
  switch (t) {
    case -2:
      return r < e;
    case -1:
      return n >= e && r < e;
    case 0:
      return r < e && n > e;
    case 1:
      return r <= e && n > e;
    case 2:
      return n > e;
    case 4:
      return !0;
  }
}
function el(t, e, r, n) {
  for (var i; t.from == t.to || (r < 1 ? t.from >= e : t.from > e) || (r > -1 ? t.to <= e : t.to < e); ) {
    let o = !n && t instanceof zt && t.index < 0 ? null : t.parent;
    if (!o)
      return t;
    t = o;
  }
  let s = n ? 0 : Be.IgnoreOverlays;
  if (n)
    for (let o = t, a = o.parent; a; o = a, a = o.parent)
      o instanceof zt && o.index < 0 && ((i = a.enter(e, r, s)) === null || i === void 0 ? void 0 : i.from) != o.from && (t = a);
  for (; ; ) {
    let o = t.enter(e, r, s);
    if (!o)
      return t;
    t = o;
  }
}
class Cw {
  cursor(e = 0) {
    return new ru(this, e);
  }
  getChild(e, r = null, n = null) {
    let i = PO(this, e, r, n);
    return i.length ? i[0] : null;
  }
  getChildren(e, r = null, n = null) {
    return PO(this, e, r, n);
  }
  resolve(e, r = 0) {
    return el(this, e, r, !1);
  }
  resolveInner(e, r = 0) {
    return el(this, e, r, !0);
  }
  matchContext(e) {
    return Ah(this, e);
  }
  enterUnfinishedNodesBefore(e) {
    let r = this.childBefore(e), n = this;
    for (; r; ) {
      let i = r.lastChild;
      if (!i || i.to != r.to)
        break;
      i.type.isError && i.from == i.to ? (n = r, r = i.prevSibling) : r = i;
    }
    return n;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class zt extends Cw {
  constructor(e, r, n, i) {
    super(), this._tree = e, this.from = r, this.index = n, this._parent = i;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, r, n, i, s = 0) {
    for (let o = this; ; ) {
      for (let { children: a, positions: l } = o._tree, c = r > 0 ? a.length : -1; e != c; e += r) {
        let u = a[e], d = l[e] + o.from;
        if (Tw(i, n, d, d + u.length)) {
          if (u instanceof wi) {
            if (s & Be.ExcludeBuffers)
              continue;
            let f = u.findChild(0, u.buffer.length, r, n - d, i);
            if (f > -1)
              return new hn(new Hx(o, u, e, d), null, f);
          } else if (s & Be.IncludeAnonymous || !u.type.isAnonymous || dm(u)) {
            let f;
            if (!(s & Be.IgnoreMounts) && (f = Ja.get(u)) && !f.overlay)
              return new zt(f.tree, d, e, o);
            let h = new zt(u, d, e, o);
            return s & Be.IncludeAnonymous || !h.type.isAnonymous ? h : h.nextChild(r < 0 ? u.children.length - 1 : 0, r, n, i);
          }
        }
      }
      if (s & Be.IncludeAnonymous || !o.type.isAnonymous || (o.index >= 0 ? e = o.index + r : e = r < 0 ? -1 : o._parent._tree.children.length, o = o._parent, !o))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, r, n = 0) {
    let i;
    if (!(n & Be.IgnoreOverlays) && (i = Ja.get(this._tree)) && i.overlay) {
      let s = e - this.from;
      for (let { from: o, to: a } of i.overlay)
        if ((r > 0 ? o <= s : o < s) && (r < 0 ? a >= s : a > s))
          return new zt(i.tree, i.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, r, n);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function PO(t, e, r, n) {
  let i = t.cursor(), s = [];
  if (!i.firstChild())
    return s;
  if (r != null) {
    for (let o = !1; !o; )
      if (o = i.type.is(r), !i.nextSibling())
        return s;
  }
  for (; ; ) {
    if (n != null && i.type.is(n))
      return s;
    if (i.type.is(e) && s.push(i.node), !i.nextSibling())
      return n == null ? s : [];
  }
}
function Ah(t, e, r = e.length - 1) {
  for (let n = t.parent; r >= 0; n = n.parent) {
    if (!n)
      return !1;
    if (!n.type.isAnonymous) {
      if (e[r] && e[r] != n.name)
        return !1;
      r--;
    }
  }
  return !0;
}
class Hx {
  constructor(e, r, n, i) {
    this.parent = e, this.buffer = r, this.index = n, this.start = i;
  }
}
class hn extends Cw {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, r, n) {
    super(), this.context = e, this._parent = r, this.index = n, this.type = e.buffer.set.types[e.buffer.buffer[n]];
  }
  child(e, r, n) {
    let { buffer: i } = this.context, s = i.findChild(this.index + 4, i.buffer[this.index + 3], e, r - this.context.start, n);
    return s < 0 ? null : new hn(this.context, this, s);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, r, n = 0) {
    if (n & Be.ExcludeBuffers)
      return null;
    let { buffer: i } = this.context, s = i.findChild(this.index + 4, i.buffer[this.index + 3], r > 0 ? 1 : -1, e - this.context.start, r);
    return s < 0 ? null : new hn(this.context, this, s);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, r = e.buffer[this.index + 3];
    return r < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new hn(this.context, this._parent, r) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, r = this._parent ? this._parent.index + 4 : 0;
    return this.index == r ? this.externalSibling(-1) : new hn(this.context, this._parent, e.findChild(
      r,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], r = [], { buffer: n } = this.context, i = this.index + 4, s = n.buffer[this.index + 3];
    if (s > i) {
      let o = n.buffer[this.index + 1];
      e.push(n.slice(i, s, o)), r.push(0);
    }
    return new it(this.type, e, r, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function Qw(t) {
  if (!t.length)
    return null;
  let e = 0, r = t[0];
  for (let s = 1; s < t.length; s++) {
    let o = t[s];
    (o.from > r.from || o.to < r.to) && (r = o, e = s);
  }
  let n = r instanceof zt && r.index < 0 ? null : r.parent, i = t.slice();
  return n ? i[e] = n : i.splice(e, 1), new Gx(i, r);
}
class Gx {
  constructor(e, r) {
    this.heads = e, this.node = r;
  }
  get next() {
    return Qw(this.heads);
  }
}
function Kx(t, e, r) {
  let n = t.resolveInner(e, r), i = null;
  for (let s = n instanceof zt ? n : n.context.parent; s; s = s.parent)
    if (s.index < 0) {
      let o = s.parent;
      (i || (i = [n])).push(o.resolve(e, r)), s = o;
    } else {
      let o = Ja.get(s.tree);
      if (o && o.overlay && o.overlay[0].from <= e && o.overlay[o.overlay.length - 1].to >= e) {
        let a = new zt(o.tree, o.overlay[0].from + s.from, -1, s);
        (i || (i = [n])).push(el(a, e, r, !1));
      }
    }
  return i ? Qw(i) : n;
}
class ru {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, r = 0) {
    if (this.mode = r, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof zt)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let n = e._parent; n; n = n._parent)
        this.stack.unshift(n.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, r) {
    this.index = e;
    let { start: n, buffer: i } = this.buffer;
    return this.type = r || i.set.types[i.buffer[e]], this.from = n + i.buffer[e + 1], this.to = n + i.buffer[e + 2], !0;
  }
  /**
  @internal
  */
  yield(e) {
    return e ? e instanceof zt ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, r, n) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, r, n, this.mode));
    let { buffer: i } = this.buffer, s = i.findChild(this.index + 4, i.buffer[this.index + 3], e, r - this.buffer.start, n);
    return s < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(s));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, r, n = this.mode) {
    return this.buffer ? n & Be.ExcludeBuffers ? !1 : this.enterChild(1, e, r) : this.yield(this._tree.enter(e, r, n));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Be.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & Be.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: r } = this.buffer, n = this.stack.length - 1;
    if (e < 0) {
      let i = n < 0 ? 0 : this.stack[n] + 4;
      if (this.index != i)
        return this.yieldBuf(r.findChild(
          i,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let i = r.buffer[this.index + 3];
      if (i < (n < 0 ? r.buffer.length : r.buffer[this.stack[n] + 3]))
        return this.yieldBuf(i);
    }
    return n < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let r, n, { buffer: i } = this;
    if (i) {
      if (e > 0) {
        if (this.index < i.buffer.buffer.length)
          return !1;
      } else
        for (let s = 0; s < this.index; s++)
          if (i.buffer.buffer[s + 3] < this.index)
            return !1;
      ({ index: r, parent: n } = i);
    } else
      ({ index: r, _parent: n } = this._tree);
    for (; n; { index: r, _parent: n } = n)
      if (r > -1)
        for (let s = r + e, o = e < 0 ? -1 : n._tree.children.length; s != o; s += e) {
          let a = n._tree.children[s];
          if (this.mode & Be.IncludeAnonymous || a instanceof wi || !a.type.isAnonymous || dm(a))
            return !1;
        }
    return !0;
  }
  move(e, r) {
    if (r && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traveral. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, r = 0) {
    for (; (this.from == this.to || (r < 1 ? this.from >= e : this.from > e) || (r > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, r); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, r = null, n = 0;
    if (e && e.context == this.buffer)
      e:
        for (let i = this.index, s = this.stack.length; s >= 0; ) {
          for (let o = e; o; o = o._parent)
            if (o.index == i) {
              if (i == this.index)
                return o;
              r = o, n = s + 1;
              break e;
            }
          i = this.stack[--s];
        }
    for (let i = n; i < this.stack.length; i++)
      r = new hn(this.buffer, r, this.stack[i]);
    return this.bufferNode = new hn(this.buffer, r, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, r) {
    for (let n = 0; ; ) {
      let i = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          n++;
          continue;
        }
        this.type.isAnonymous || (i = !0);
      }
      for (; i && r && r(this), i = this.type.isAnonymous, !this.nextSibling(); ) {
        if (!n)
          return;
        this.parent(), n--, i = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given contextâ€”a sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return Ah(this.node, e);
    let { buffer: r } = this.buffer, { types: n } = r.set;
    for (let i = e.length - 1, s = this.stack.length - 1; i >= 0; s--) {
      if (s < 0)
        return Ah(this.node, e, i);
      let o = n[r.buffer[this.stack[s]]];
      if (!o.isAnonymous) {
        if (e[i] && e[i] != o.name)
          return !1;
        i--;
      }
    }
    return !0;
  }
}
function dm(t) {
  return t.children.some((e) => e instanceof wi || !e.type.isAnonymous || dm(e));
}
function Jx(t) {
  var e;
  let { buffer: r, nodeSet: n, maxBufferLength: i = xw, reused: s = [], minRepeatType: o = n.types.length } = t, a = Array.isArray(r) ? new um(r, r.length) : r, l = n.types, c = 0, u = 0;
  function d(S, $, _, Q, N, B) {
    let { id: J, start: U, end: ue, size: le } = a, Pe = u;
    for (; le < 0; )
      if (a.next(), le == -1) {
        let z = s[J];
        _.push(z), Q.push(U - S);
        return;
      } else if (le == -3) {
        c = J;
        return;
      } else if (le == -4) {
        u = J;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${le}`);
    let Ce = l[J], X, F, K = U - S;
    if (ue - U <= i && (F = m(a.pos - $, N))) {
      let z = new Uint16Array(F.size - F.skip), R = a.pos - F.size, D = z.length;
      for (; a.pos > R; )
        D = y(F.start, z, D);
      X = new wi(z, ue - F.start, n), K = F.start - S;
    } else {
      let z = a.pos - le;
      a.next();
      let R = [], D = [], M = J >= o ? J : -1, P = 0, A = ue;
      for (; a.pos > z; )
        M >= 0 && a.id == M && a.size >= 0 ? (a.end <= A - i && (p(R, D, U, P, a.end, A, M, Pe), P = R.length, A = a.end), a.next()) : B > 2500 ? f(U, z, R, D) : d(U, z, R, D, M, B + 1);
      if (M >= 0 && P > 0 && P < R.length && p(R, D, U, P, U, A, M, Pe), R.reverse(), D.reverse(), M > -1 && P > 0) {
        let W = h(Ce);
        X = fm(Ce, R, D, 0, R.length, 0, ue - U, W, W);
      } else
        X = g(Ce, R, D, ue - U, Pe - ue);
    }
    _.push(X), Q.push(K);
  }
  function f(S, $, _, Q) {
    let N = [], B = 0, J = -1;
    for (; a.pos > $; ) {
      let { id: U, start: ue, end: le, size: Pe } = a;
      if (Pe > 4)
        a.next();
      else {
        if (J > -1 && ue < J)
          break;
        J < 0 && (J = le - i), N.push(U, ue, le), B++, a.next();
      }
    }
    if (B) {
      let U = new Uint16Array(B * 4), ue = N[N.length - 2];
      for (let le = N.length - 3, Pe = 0; le >= 0; le -= 3)
        U[Pe++] = N[le], U[Pe++] = N[le + 1] - ue, U[Pe++] = N[le + 2] - ue, U[Pe++] = Pe;
      _.push(new wi(U, N[2] - ue, n)), Q.push(ue - S);
    }
  }
  function h(S) {
    return ($, _, Q) => {
      let N = 0, B = $.length - 1, J, U;
      if (B >= 0 && (J = $[B]) instanceof it) {
        if (!B && J.type == S && J.length == Q)
          return J;
        (U = J.prop(Ie.lookAhead)) && (N = _[B] + J.length + U);
      }
      return g(S, $, _, Q, N);
    };
  }
  function p(S, $, _, Q, N, B, J, U) {
    let ue = [], le = [];
    for (; S.length > Q; )
      ue.push(S.pop()), le.push($.pop() + _ - N);
    S.push(g(n.types[J], ue, le, B - N, U - B)), $.push(N - _);
  }
  function g(S, $, _, Q, N = 0, B) {
    if (c) {
      let J = [Ie.contextHash, c];
      B = B ? [J].concat(B) : [J];
    }
    if (N > 25) {
      let J = [Ie.lookAhead, N];
      B = B ? [J].concat(B) : [J];
    }
    return new it(S, $, _, Q, B);
  }
  function m(S, $) {
    let _ = a.fork(), Q = 0, N = 0, B = 0, J = _.end - i, U = { size: 0, start: 0, skip: 0 };
    e:
      for (let ue = _.pos - S; _.pos > ue; ) {
        let le = _.size;
        if (_.id == $ && le >= 0) {
          U.size = Q, U.start = N, U.skip = B, B += 4, Q += 4, _.next();
          continue;
        }
        let Pe = _.pos - le;
        if (le < 0 || Pe < ue || _.start < J)
          break;
        let Ce = _.id >= o ? 4 : 0, X = _.start;
        for (_.next(); _.pos > Pe; ) {
          if (_.size < 0)
            if (_.size == -3)
              Ce += 4;
            else
              break e;
          else
            _.id >= o && (Ce += 4);
          _.next();
        }
        N = X, Q += le, B += Ce;
      }
    return ($ < 0 || Q == S) && (U.size = Q, U.start = N, U.skip = B), U.size > 4 ? U : void 0;
  }
  function y(S, $, _) {
    let { id: Q, start: N, end: B, size: J } = a;
    if (a.next(), J >= 0 && Q < o) {
      let U = _;
      if (J > 4) {
        let ue = a.pos - (J - 4);
        for (; a.pos > ue; )
          _ = y(S, $, _);
      }
      $[--_] = U, $[--_] = B - S, $[--_] = N - S, $[--_] = Q;
    } else
      J == -3 ? c = Q : J == -4 && (u = Q);
    return _;
  }
  let O = [], b = [];
  for (; a.pos > 0; )
    d(t.start || 0, t.bufferStart || 0, O, b, -1, 0);
  let w = (e = t.length) !== null && e !== void 0 ? e : O.length ? b[0] + O[0].length : 0;
  return new it(l[t.topID], O.reverse(), b.reverse(), w);
}
const xO = /* @__PURE__ */ new WeakMap();
function Rc(t, e) {
  if (!t.isAnonymous || e instanceof wi || e.type != t)
    return 1;
  let r = xO.get(e);
  if (r == null) {
    r = 1;
    for (let n of e.children) {
      if (n.type != t || !(n instanceof it)) {
        r = 1;
        break;
      }
      r += Rc(t, n);
    }
    xO.set(e, r);
  }
  return r;
}
function fm(t, e, r, n, i, s, o, a, l) {
  let c = 0;
  for (let p = n; p < i; p++)
    c += Rc(t, e[p]);
  let u = Math.ceil(
    c * 1.5 / 8
    /* Balance.BranchFactor */
  ), d = [], f = [];
  function h(p, g, m, y, O) {
    for (let b = m; b < y; ) {
      let w = b, S = g[b], $ = Rc(t, p[b]);
      for (b++; b < y; b++) {
        let _ = Rc(t, p[b]);
        if ($ + _ >= u)
          break;
        $ += _;
      }
      if (b == w + 1) {
        if ($ > u) {
          let _ = p[w];
          h(_.children, _.positions, 0, _.children.length, g[w] + O);
          continue;
        }
        d.push(p[w]);
      } else {
        let _ = g[b - 1] + p[b - 1].length - S;
        d.push(fm(t, p, g, w, b, S, _, null, l));
      }
      f.push(S + O - s);
    }
  }
  return h(e, r, n, i, 0), (a || l)(d, f, o);
}
class Aw {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, r, n) {
    let i = this.map.get(e);
    i || this.map.set(e, i = /* @__PURE__ */ new Map()), i.set(r, n);
  }
  getBuffer(e, r) {
    let n = this.map.get(e);
    return n && n.get(r);
  }
  /**
  Set the value for this syntax node.
  */
  set(e, r) {
    e instanceof hn ? this.setBuffer(e.context.buffer, e.index, r) : e instanceof zt && this.map.set(e.tree, r);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(e) {
    return e instanceof hn ? this.getBuffer(e.context.buffer, e.index) : e instanceof zt ? this.map.get(e.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(e, r) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, r) : this.map.set(e.tree, r);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class In {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, r, n, i, s = !1, o = !1) {
    this.from = e, this.to = r, this.tree = n, this.offset = i, this.open = (s ? 1 : 0) | (o ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, r = [], n = !1) {
    let i = [new In(0, e.length, e, 0, !1, n)];
    for (let s of r)
      s.to > e.length && i.push(s);
    return i;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, r, n = 128) {
    if (!r.length)
      return e;
    let i = [], s = 1, o = e.length ? e[0] : null;
    for (let a = 0, l = 0, c = 0; ; a++) {
      let u = a < r.length ? r[a] : null, d = u ? u.fromA : 1e9;
      if (d - l >= n)
        for (; o && o.from < d; ) {
          let f = o;
          if (l >= f.from || d <= f.to || c) {
            let h = Math.max(f.from, l) - c, p = Math.min(f.to, d) - c;
            f = h >= p ? null : new In(h, p, f.tree, f.offset + c, a > 0, !!u);
          }
          if (f && i.push(f), o.to > d)
            break;
          o = s < e.length ? e[s++] : null;
        }
      if (!u)
        break;
      l = u.toA, c = u.toA - u.toB;
    }
    return i;
  }
}
let Ew = class {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e, r, n) {
    return typeof e == "string" && (e = new e4(e)), n = n ? n.length ? n.map((i) => new $r(i.from, i.to)) : [new $r(0, 0)] : [new $r(0, e.length)], this.createParse(e, r || [], n);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e, r, n) {
    let i = this.startParse(e, r, n);
    for (; ; ) {
      let s = i.advance();
      if (s)
        return s;
    }
  }
};
class e4 {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, r) {
    return this.string.slice(e, r);
  }
}
function t4(t) {
  return (e, r, n, i) => new n4(e, t, r, n, i);
}
class TO {
  constructor(e, r, n, i, s) {
    this.parser = e, this.parse = r, this.overlay = n, this.target = i, this.from = s;
  }
}
function CO(t) {
  if (!t.length || t.some((e) => e.from >= e.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(t));
}
class r4 {
  constructor(e, r, n, i, s, o, a) {
    this.parser = e, this.predicate = r, this.mounts = n, this.index = i, this.start = s, this.target = o, this.prev = a, this.depth = 0, this.ranges = [];
  }
}
const Eh = new Ie({ perNode: !0 });
class n4 {
  constructor(e, r, n, i, s) {
    this.nest = r, this.input = n, this.fragments = i, this.ranges = s, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e;
  }
  advance() {
    if (this.baseParse) {
      let n = this.baseParse.advance();
      if (!n)
        return null;
      if (this.baseParse = null, this.baseTree = n, this.startInner(), this.stoppedAt != null)
        for (let i of this.inner)
          i.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let n = this.baseTree;
      return this.stoppedAt != null && (n = new it(n.type, n.children, n.positions, n.length, n.propValues.concat([[Eh, this.stoppedAt]]))), n;
    }
    let e = this.inner[this.innerDone], r = e.parse.advance();
    if (r) {
      this.innerDone++;
      let n = Object.assign(/* @__PURE__ */ Object.create(null), e.target.props);
      n[Ie.mounted.id] = new Ja(r, e.overlay, e.parser), e.target.props = n;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let e = this.input.length;
    for (let r = this.innerDone; r < this.inner.length; r++)
      this.inner[r].from < e && (e = Math.min(e, this.inner[r].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (this.stoppedAt = e, this.baseParse)
      this.baseParse.stopAt(e);
    else
      for (let r = this.innerDone; r < this.inner.length; r++)
        this.inner[r].parse.stopAt(e);
  }
  startInner() {
    let e = new o4(this.fragments), r = null, n = null, i = new ru(new zt(this.baseTree, this.ranges[0].from, 0, null), Be.IncludeAnonymous | Be.IgnoreMounts);
    e:
      for (let s, o; ; ) {
        let a = !0, l;
        if (this.stoppedAt != null && i.from >= this.stoppedAt)
          a = !1;
        else if (e.hasNode(i)) {
          if (r) {
            let c = r.mounts.find((u) => u.frag.from <= i.from && u.frag.to >= i.to && u.mount.overlay);
            if (c)
              for (let u of c.mount.overlay) {
                let d = u.from + c.pos, f = u.to + c.pos;
                d >= i.from && f <= i.to && !r.ranges.some((h) => h.from < f && h.to > d) && r.ranges.push({ from: d, to: f });
              }
          }
          a = !1;
        } else if (n && (o = i4(n.ranges, i.from, i.to)))
          a = o != 2;
        else if (!i.type.isAnonymous && (s = this.nest(i, this.input)) && (i.from < i.to || !s.overlay)) {
          i.tree || s4(i);
          let c = e.findMounts(i.from, s.parser);
          if (typeof s.overlay == "function")
            r = new r4(s.parser, s.overlay, c, this.inner.length, i.from, i.tree, r);
          else {
            let u = EO(this.ranges, s.overlay || (i.from < i.to ? [new $r(i.from, i.to)] : []));
            u.length && CO(u), (u.length || !s.overlay) && this.inner.push(new TO(s.parser, u.length ? s.parser.startParse(this.input, RO(c, u), u) : s.parser.startParse(""), s.overlay ? s.overlay.map((d) => new $r(d.from - i.from, d.to - i.from)) : null, i.tree, u.length ? u[0].from : i.from)), s.overlay ? u.length && (n = { ranges: u, depth: 0, prev: n }) : a = !1;
          }
        } else
          r && (l = r.predicate(i)) && (l === !0 && (l = new $r(i.from, i.to)), l.from < l.to && r.ranges.push(l));
        if (a && i.firstChild())
          r && r.depth++, n && n.depth++;
        else
          for (; !i.nextSibling(); ) {
            if (!i.parent())
              break e;
            if (r && !--r.depth) {
              let c = EO(this.ranges, r.ranges);
              c.length && (CO(c), this.inner.splice(r.index, 0, new TO(r.parser, r.parser.startParse(this.input, RO(r.mounts, c), c), r.ranges.map((u) => new $r(u.from - r.start, u.to - r.start)), r.target, c[0].from))), r = r.prev;
            }
            n && !--n.depth && (n = n.prev);
          }
      }
  }
}
function i4(t, e, r) {
  for (let n of t) {
    if (n.from >= r)
      break;
    if (n.to > e)
      return n.from <= e && n.to >= r ? 2 : 1;
  }
  return 0;
}
function QO(t, e, r, n, i, s) {
  if (e < r) {
    let o = t.buffer[e + 1];
    n.push(t.slice(e, r, o)), i.push(o - s);
  }
}
function s4(t) {
  let { node: e } = t, r = [], n = e.context.buffer;
  do
    r.push(t.index), t.parent();
  while (!t.tree);
  let i = t.tree, s = i.children.indexOf(n), o = i.children[s], a = o.buffer, l = [s];
  function c(u, d, f, h, p, g) {
    let m = r[g], y = [], O = [];
    QO(o, u, m, y, O, h);
    let b = a[m + 1], w = a[m + 2];
    l.push(y.length);
    let S = g ? c(m + 4, a[m + 3], o.set.types[a[m]], b, w - b, g - 1) : e.toTree();
    return y.push(S), O.push(b - h), QO(o, a[m + 3], d, y, O, h), new it(f, y, O, p);
  }
  i.children[s] = c(0, a.length, Gt.none, 0, o.length, r.length - 1);
  for (let u of l) {
    let d = t.tree.children[u], f = t.tree.positions[u];
    t.yield(new zt(d, f + t.from, u, t._tree));
  }
}
class AO {
  constructor(e, r) {
    this.offset = r, this.done = !1, this.cursor = e.cursor(Be.IncludeAnonymous | Be.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(e) {
    let { cursor: r } = this, n = e - this.offset;
    for (; !this.done && r.from < n; )
      r.to >= e && r.enter(n, 1, Be.IgnoreOverlays | Be.ExcludeBuffers) || r.next(!1) || (this.done = !0);
  }
  hasNode(e) {
    if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
      for (let r = this.cursor.tree; ; ) {
        if (r == e.tree)
          return !0;
        if (r.children.length && r.positions[0] == 0 && r.children[0] instanceof it)
          r = r.children[0];
        else
          break;
      }
    return !1;
  }
}
let o4 = class {
  constructor(e) {
    var r;
    if (this.fragments = e, this.curTo = 0, this.fragI = 0, e.length) {
      let n = this.curFrag = e[0];
      this.curTo = (r = n.tree.prop(Eh)) !== null && r !== void 0 ? r : n.to, this.inner = new AO(n.tree, -n.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);
  }
  nextFrag() {
    var e;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let r = this.curFrag = this.fragments[this.fragI];
      this.curTo = (e = r.tree.prop(Eh)) !== null && e !== void 0 ? e : r.to, this.inner = new AO(r.tree, -r.offset);
    }
  }
  findMounts(e, r) {
    var n;
    let i = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1);
      for (let s = this.inner.cursor.node; s; s = s.parent) {
        let o = (n = s.tree) === null || n === void 0 ? void 0 : n.prop(Ie.mounted);
        if (o && o.parser == r)
          for (let a = this.fragI; a < this.fragments.length; a++) {
            let l = this.fragments[a];
            if (l.from >= s.to)
              break;
            l.tree == this.curFrag.tree && i.push({
              frag: l,
              pos: s.from - l.offset,
              mount: o
            });
          }
      }
    }
    return i;
  }
};
function EO(t, e) {
  let r = null, n = e;
  for (let i = 1, s = 0; i < t.length; i++) {
    let o = t[i - 1].to, a = t[i].from;
    for (; s < n.length; s++) {
      let l = n[s];
      if (l.from >= a)
        break;
      l.to <= o || (r || (n = r = e.slice()), l.from < o ? (r[s] = new $r(l.from, o), l.to > a && r.splice(s + 1, 0, new $r(a, l.to))) : l.to > a ? r[s--] = new $r(a, l.to) : r.splice(s--, 1));
    }
  }
  return n;
}
function a4(t, e, r, n) {
  let i = 0, s = 0, o = !1, a = !1, l = -1e9, c = [];
  for (; ; ) {
    let u = i == t.length ? 1e9 : o ? t[i].to : t[i].from, d = s == e.length ? 1e9 : a ? e[s].to : e[s].from;
    if (o != a) {
      let f = Math.max(l, r), h = Math.min(u, d, n);
      f < h && c.push(new $r(f, h));
    }
    if (l = Math.min(u, d), l == 1e9)
      break;
    u == l && (o ? (o = !1, i++) : o = !0), d == l && (a ? (a = !1, s++) : a = !0);
  }
  return c;
}
function RO(t, e) {
  let r = [];
  for (let { pos: n, mount: i, frag: s } of t) {
    let o = n + (i.overlay ? i.overlay[0].from : 0), a = o + i.tree.length, l = Math.max(s.from, o), c = Math.min(s.to, a);
    if (i.overlay) {
      let u = i.overlay.map((f) => new $r(f.from + n, f.to + n)), d = a4(e, u, l, c);
      for (let f = 0, h = l; ; f++) {
        let p = f == d.length, g = p ? c : d[f].from;
        if (g > h && r.push(new In(h, g, i.tree, -o, s.from >= h || s.openStart, s.to <= g || s.openEnd)), p)
          break;
        h = d[f].to;
      }
    } else
      r.push(new In(l, c, i.tree, -o, s.from >= o || s.openStart, s.to <= a || s.openEnd));
  }
  return r;
}
let l4 = 0, ei = class Rw {
  /**
  @internal
  */
  constructor(e, r, n) {
    this.set = e, this.base = r, this.modified = n, this.id = l4++;
  }
  /**
  Define a new tag. If `parent` is given, the tag is treated as a
  sub-tag of that parent, and
  [highlighters](#highlight.tagHighlighter) that don't mention
  this tag will try to fall back to the parent tag (or grandparent
  tag, etc).
  */
  static define(e) {
    if (e != null && e.base)
      throw new Error("Can not derive from a modified tag");
    let r = new Rw([], null, []);
    if (r.set.push(r), e)
      for (let n of e.set)
        r.set.push(n);
    return r;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier() {
    let e = new nu();
    return (r) => r.modified.indexOf(e) > -1 ? r : nu.get(r.base || r, r.modified.concat(e).sort((n, i) => n.id - i.id));
  }
}, c4 = 0;
class nu {
  constructor() {
    this.instances = [], this.id = c4++;
  }
  static get(e, r) {
    if (!r.length)
      return e;
    let n = r[0].instances.find((a) => a.base == e && u4(r, a.modified));
    if (n)
      return n;
    let i = [], s = new ei(i, e, r);
    for (let a of r)
      a.instances.push(s);
    let o = d4(r);
    for (let a of e.set)
      if (!a.modified.length)
        for (let l of o)
          i.push(nu.get(a, l));
    return s;
  }
}
function u4(t, e) {
  return t.length == e.length && t.every((r, n) => r == e[n]);
}
function d4(t) {
  let e = [[]];
  for (let r = 0; r < t.length; r++)
    for (let n = 0, i = e.length; n < i; n++)
      e.push(e[n].concat(t[r]));
  return e.sort((r, n) => n.length - r.length);
}
function Io(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let r in t) {
    let n = t[r];
    Array.isArray(n) || (n = [n]);
    for (let i of r.split(" "))
      if (i) {
        let s = [], o = 2, a = i;
        for (let d = 0; ; ) {
          if (a == "..." && d > 0 && d + 3 == i.length) {
            o = 1;
            break;
          }
          let f = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(a);
          if (!f)
            throw new RangeError("Invalid path: " + i);
          if (s.push(f[0] == "*" ? "" : f[0][0] == '"' ? JSON.parse(f[0]) : f[0]), d += f[0].length, d == i.length)
            break;
          let h = i[d++];
          if (d == i.length && h == "!") {
            o = 0;
            break;
          }
          if (h != "/")
            throw new RangeError("Invalid path: " + i);
          a = i.slice(d);
        }
        let l = s.length - 1, c = s[l];
        if (!c)
          throw new RangeError("Invalid path: " + i);
        let u = new iu(n, o, l > 0 ? s.slice(0, l) : null);
        e[c] = u.sort(e[c]);
      }
  }
  return Iw.add(e);
}
const Iw = new Ie();
class iu {
  constructor(e, r, n, i) {
    this.tags = e, this.mode = r, this.context = n, this.next = i;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
iu.empty = new iu([], 2, null);
function jw(t, e) {
  let r = /* @__PURE__ */ Object.create(null);
  for (let s of t)
    if (!Array.isArray(s.tag))
      r[s.tag.id] = s.class;
    else
      for (let o of s.tag)
        r[o.id] = s.class;
  let { scope: n, all: i = null } = e || {};
  return {
    style: (s) => {
      let o = i;
      for (let a of s)
        for (let l of a.set) {
          let c = r[l.id];
          if (c) {
            o = o ? o + " " + c : c;
            break;
          }
        }
      return o;
    },
    scope: n
  };
}
function f4(t, e) {
  let r = null;
  for (let n of t) {
    let i = n.style(e);
    i && (r = r ? r + " " + i : i);
  }
  return r;
}
function h4(t, e, r, n = 0, i = t.length) {
  let s = new p4(n, Array.isArray(e) ? e : [e], r);
  s.highlightRange(t.cursor(), n, i, "", s.highlighters), s.flush(i);
}
class p4 {
  constructor(e, r, n) {
    this.at = e, this.highlighters = r, this.span = n, this.class = "";
  }
  startSpan(e, r) {
    r != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = r);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, r, n, i, s) {
    let { type: o, from: a, to: l } = e;
    if (a >= n || l <= r)
      return;
    o.isTop && (s = this.highlighters.filter((h) => !h.scope || h.scope(o)));
    let c = i, u = m4(e) || iu.empty, d = f4(s, u.tags);
    if (d && (c && (c += " "), c += d, u.mode == 1 && (i += (i ? " " : "") + d)), this.startSpan(Math.max(r, a), c), u.opaque)
      return;
    let f = e.tree && e.tree.prop(Ie.mounted);
    if (f && f.overlay) {
      let h = e.node.enter(f.overlay[0].from + a, 1), p = this.highlighters.filter((m) => !m.scope || m.scope(f.tree.type)), g = e.firstChild();
      for (let m = 0, y = a; ; m++) {
        let O = m < f.overlay.length ? f.overlay[m] : null, b = O ? O.from + a : l, w = Math.max(r, y), S = Math.min(n, b);
        if (w < S && g)
          for (; e.from < S && (this.highlightRange(e, w, S, i, s), this.startSpan(Math.min(S, e.to), c), !(e.to >= b || !e.nextSibling())); )
            ;
        if (!O || b > n)
          break;
        y = O.to + a, y > r && (this.highlightRange(h.cursor(), Math.max(r, O.from + a), Math.min(n, y), "", p), this.startSpan(Math.min(n, y), c));
      }
      g && e.parent();
    } else if (e.firstChild()) {
      f && (i = "");
      do
        if (!(e.to <= r)) {
          if (e.from >= n)
            break;
          this.highlightRange(e, r, n, i, s), this.startSpan(Math.min(n, e.to), c);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function m4(t) {
  let e = t.type.prop(Iw);
  for (; e && e.context && !t.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const ae = ei.define, oc = ae(), ti = ae(), IO = ae(ti), jO = ae(ti), ri = ae(), ac = ae(ri), Hd = ae(ri), on = ae(), Ni = ae(on), rn = ae(), nn = ae(), Rh = ae(), la = ae(Rh), lc = ae(), E = {
  /**
  A comment.
  */
  comment: oc,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: ae(oc),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: ae(oc),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: ae(oc),
  /**
  Any kind of identifier.
  */
  name: ti,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: ae(ti),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: IO,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: ae(IO),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: jO,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: ae(jO),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: ae(ti),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: ae(ti),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: ae(ti),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: ae(ti),
  /**
  A literal value.
  */
  literal: ri,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: ac,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: ae(ac),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: ae(ac),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: ae(ac),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: Hd,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: ae(Hd),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: ae(Hd),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: ae(ri),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: ae(ri),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: ae(ri),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: ae(ri),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: ae(ri),
  /**
  A language keyword.
  */
  keyword: rn,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: ae(rn),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: ae(rn),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: ae(rn),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: ae(rn),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: ae(rn),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: ae(rn),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: ae(rn),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: ae(rn),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: ae(rn),
  /**
  An operator.
  */
  operator: nn,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: ae(nn),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: ae(nn),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: ae(nn),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: ae(nn),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: ae(nn),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: ae(nn),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: ae(nn),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: ae(nn),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: ae(nn),
  /**
  Program or markup punctuation.
  */
  punctuation: Rh,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: ae(Rh),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: la,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: ae(la),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: ae(la),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: ae(la),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: ae(la),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: on,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: Ni,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: ae(Ni),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: ae(Ni),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: ae(Ni),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: ae(Ni),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: ae(Ni),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: ae(Ni),
  /**
  A prose separator (such as a horizontal rule).
  */
  contentSeparator: ae(on),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: ae(on),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: ae(on),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: ae(on),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: ae(on),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: ae(on),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: ae(on),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: ae(on),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: ae(),
  /**
  Deleted text.
  */
  deleted: ae(),
  /**
  Changed text.
  */
  changed: ae(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: ae(),
  /**
  Metadata or meta-instruction.
  */
  meta: lc,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: ae(lc),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: ae(lc),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: ae(lc),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: ei.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: ei.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: ei.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: ei.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: ei.defineModifier(),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: ei.defineModifier()
};
jw([
  { tag: E.link, class: "tok-link" },
  { tag: E.heading, class: "tok-heading" },
  { tag: E.emphasis, class: "tok-emphasis" },
  { tag: E.strong, class: "tok-strong" },
  { tag: E.keyword, class: "tok-keyword" },
  { tag: E.atom, class: "tok-atom" },
  { tag: E.bool, class: "tok-bool" },
  { tag: E.url, class: "tok-url" },
  { tag: E.labelName, class: "tok-labelName" },
  { tag: E.inserted, class: "tok-inserted" },
  { tag: E.deleted, class: "tok-deleted" },
  { tag: E.literal, class: "tok-literal" },
  { tag: E.string, class: "tok-string" },
  { tag: E.number, class: "tok-number" },
  { tag: [E.regexp, E.escape, E.special(E.string)], class: "tok-string2" },
  { tag: E.variableName, class: "tok-variableName" },
  { tag: E.local(E.variableName), class: "tok-variableName tok-local" },
  { tag: E.definition(E.variableName), class: "tok-variableName tok-definition" },
  { tag: E.special(E.variableName), class: "tok-variableName2" },
  { tag: E.definition(E.propertyName), class: "tok-propertyName tok-definition" },
  { tag: E.typeName, class: "tok-typeName" },
  { tag: E.namespace, class: "tok-namespace" },
  { tag: E.className, class: "tok-className" },
  { tag: E.macroName, class: "tok-macroName" },
  { tag: E.propertyName, class: "tok-propertyName" },
  { tag: E.operator, class: "tok-operator" },
  { tag: E.comment, class: "tok-comment" },
  { tag: E.meta, class: "tok-meta" },
  { tag: E.invalid, class: "tok-invalid" },
  { tag: E.punctuation, class: "tok-punctuation" }
]);
var Gd;
const Xs = /* @__PURE__ */ new Ie();
function Zw(t) {
  return be.define({
    combine: t ? (e) => e.concat(t) : void 0
  });
}
const hm = /* @__PURE__ */ new Ie();
class zr {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, r, n = [], i = "") {
    this.data = e, this.name = i, De.prototype.hasOwnProperty("tree") || Object.defineProperty(De.prototype, "tree", { get() {
      return Xt(this);
    } }), this.parser = r, this.extension = [
      Oo.of(this),
      De.languageData.of((s, o, a) => {
        let l = ZO(s, o, a), c = l.type.prop(Xs);
        if (!c)
          return [];
        let u = s.facet(c), d = l.type.prop(hm);
        if (d) {
          let f = l.resolve(o - l.from, a);
          for (let h of d)
            if (h.test(f, s)) {
              let p = s.facet(h.facet);
              return h.type == "replace" ? p : p.concat(u);
            }
        }
        return u;
      })
    ].concat(n);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, r, n = -1) {
    return ZO(e, r, n).type.prop(Xs) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let r = e.facet(Oo);
    if ((r == null ? void 0 : r.data) == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!r || !r.allowsNesting)
      return [];
    let n = [], i = (s, o) => {
      if (s.prop(Xs) == this.data) {
        n.push({ from: o, to: o + s.length });
        return;
      }
      let a = s.prop(Ie.mounted);
      if (a) {
        if (a.tree.prop(Xs) == this.data) {
          if (a.overlay)
            for (let l of a.overlay)
              n.push({ from: l.from + o, to: l.to + o });
          else
            n.push({ from: o, to: o + s.length });
          return;
        } else if (a.overlay) {
          let l = n.length;
          if (i(a.tree, a.overlay[0].from + o), n.length > l)
            return;
        }
      }
      for (let l = 0; l < s.children.length; l++) {
        let c = s.children[l];
        c instanceof it && i(c, s.positions[l] + o);
      }
    };
    return i(Xt(e), 0), n;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
zr.setState = /* @__PURE__ */ Le.define();
function ZO(t, e, r) {
  let n = t.facet(Oo), i = Xt(t).topNode;
  if (!n || n.allowsNesting)
    for (let s = i; s; s = s.enter(e, r, Be.ExcludeBuffers))
      s.type.isTop && (i = s);
  return i;
}
class $i extends zr {
  constructor(e, r, n) {
    super(e, r, [], n), this.parser = r;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let r = Zw(e.languageData);
    return new $i(r, e.parser.configure({
      props: [Xs.add((n) => n.isTop ? r : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, r) {
    return new $i(this.data, this.parser.configure(e), r || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function Xt(t) {
  let e = t.field(zr.state, !1);
  return e ? e.tree : it.empty;
}
class g4 {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, r) {
    let n = this.cursorPos - this.string.length;
    return e < n || r >= this.cursorPos ? this.doc.sliceString(e, r) : this.string.slice(e - n, r - n);
  }
}
let ca = null;
class su {
  constructor(e, r, n = [], i, s, o, a, l) {
    this.parser = e, this.state = r, this.fragments = n, this.tree = i, this.treeLen = s, this.viewport = o, this.skipped = a, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, r, n) {
    return new su(e, r, [], it.empty, 0, n, [], null);
  }
  startParse() {
    return this.parser.startParse(new g4(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, r) {
    return r != null && r >= this.state.doc.length && (r = void 0), this.tree != it.empty && this.isDone(r ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var n;
      if (typeof e == "number") {
        let i = Date.now() + e;
        e = () => Date.now() > i;
      }
      for (this.parse || (this.parse = this.startParse()), r != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > r) && r < this.state.doc.length && this.parse.stopAt(r); ; ) {
        let i = this.parse.advance();
        if (i)
          if (this.fragments = this.withoutTempSkipped(In.addTree(i, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (n = this.parse.stoppedAt) !== null && n !== void 0 ? n : this.state.doc.length, this.tree = i, this.parse = null, this.treeLen < (r ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, r;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(r = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = r, this.fragments = this.withoutTempSkipped(In.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let r = ca;
    ca = this;
    try {
      return e();
    } finally {
      ca = r;
    }
  }
  withoutTempSkipped(e) {
    for (let r; r = this.tempSkipped.pop(); )
      e = MO(e, r.from, r.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, r) {
    let { fragments: n, tree: i, treeLen: s, viewport: o, skipped: a } = this;
    if (this.takeTree(), !e.empty) {
      let l = [];
      if (e.iterChangedRanges((c, u, d, f) => l.push({ fromA: c, toA: u, fromB: d, toB: f })), n = In.applyChanges(n, l), i = it.empty, s = 0, o = { from: e.mapPos(o.from, -1), to: e.mapPos(o.to, 1) }, this.skipped.length) {
        a = [];
        for (let c of this.skipped) {
          let u = e.mapPos(c.from, 1), d = e.mapPos(c.to, -1);
          u < d && a.push({ from: u, to: d });
        }
      }
    }
    return new su(this.parser, r, n, i, s, o, a, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let r = this.skipped.length;
    for (let n = 0; n < this.skipped.length; n++) {
      let { from: i, to: s } = this.skipped[n];
      i < e.to && s > e.from && (this.fragments = MO(this.fragments, i, s), this.skipped.splice(n--, 1));
    }
    return this.skipped.length >= r ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, r) {
    this.skipped.push({ from: e, to: r });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends Ew {
      createParse(r, n, i) {
        let s = i[0].from, o = i[i.length - 1].to;
        return {
          parsedPos: s,
          advance() {
            let l = ca;
            if (l) {
              for (let c of i)
                l.tempSkipped.push(c);
              e && (l.scheduleOn = l.scheduleOn ? Promise.all([l.scheduleOn, e]) : e);
            }
            return this.parsedPos = o, new it(Gt.none, [], [], o - s);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let r = this.fragments;
    return this.treeLen >= e && r.length && r[0].from == 0 && r[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return ca;
  }
}
function MO(t, e, r) {
  return In.applyChanges(t, [{ fromA: e, toA: r, fromB: e, toB: r }]);
}
class go {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let r = this.context.changes(e.changes, e.state), n = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), r.viewport.to);
    return r.work(20, n) || r.takeTree(), new go(r);
  }
  static init(e) {
    let r = Math.min(3e3, e.doc.length), n = su.create(e.facet(Oo).parser, e, { from: 0, to: r });
    return n.work(20, r) || n.takeTree(), new go(n);
  }
}
zr.state = /* @__PURE__ */ Br.define({
  create: go.init,
  update(t, e) {
    for (let r of e.effects)
      if (r.is(zr.setState))
        return r.value;
    return e.startState.facet(Oo) != e.state.facet(Oo) ? go.init(e.state) : t.apply(e);
  }
});
let Mw = (t) => {
  let e = setTimeout(
    () => t(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (Mw = (t) => {
  let e = -1, r = setTimeout(
    () => {
      e = requestIdleCallback(t, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(r) : cancelIdleCallback(e);
});
const Kd = typeof navigator < "u" && (!((Gd = navigator.scheduling) === null || Gd === void 0) && Gd.isInputPending) ? () => navigator.scheduling.isInputPending() : null, O4 = /* @__PURE__ */ Pr.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let r = this.view.state.field(zr.state).context;
    (r.updateViewport(e.view.viewport) || this.view.viewport.to > r.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(r);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, r = e.field(zr.state);
    (r.tree != r.context.tree || !r.context.isDone(e.doc.length)) && (this.working = Mw(this.work));
  }
  work(e) {
    this.working = null;
    let r = Date.now();
    if (this.chunkEnd < r && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = r + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: n, viewport: { to: i } } = this.view, s = n.field(zr.state);
    if (s.tree == s.context.tree && s.context.isDone(
      i + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let o = Date.now() + Math.min(this.chunkBudget, 100, e && !Kd ? Math.max(25, e.timeRemaining() - 5) : 1e9), a = s.context.treeLen < i && n.doc.length > i + 1e3, l = s.context.work(() => Kd && Kd() || Date.now() > o, i + (a ? 0 : 1e5));
    this.chunkBudget -= Date.now() - r, (l || this.chunkBudget <= 0) && (s.context.takeTree(), this.view.dispatch({ effects: zr.setState.of(new go(s.context)) })), this.chunkBudget > 0 && !(l && !a) && this.scheduleWork(), this.checkAsyncSchedule(s.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((r) => Wr(this.view.state, r)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), Oo = /* @__PURE__ */ be.define({
  combine(t) {
    return t.length ? t[0] : null;
  },
  enables: (t) => [
    zr.state,
    O4,
    Se.contentAttributes.compute([t], (e) => {
      let r = e.facet(t);
      return r && r.name ? { "data-language": r.name } : {};
    })
  ]
});
class Ol {
  /**
  Create a language support object.
  */
  constructor(e, r = []) {
    this.language = e, this.support = r, this.extension = [e, r];
  }
}
const y4 = /* @__PURE__ */ be.define(), pm = /* @__PURE__ */ be.define({
  combine: (t) => {
    if (!t.length)
      return "  ";
    let e = t[0];
    if (!e || /\S/.test(e) || Array.from(e).some((r) => r != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(t[0]));
    return e;
  }
});
function b4(t) {
  let e = t.facet(pm);
  return e.charCodeAt(0) == 9 ? t.tabSize * e.length : e.length;
}
function v4(t, e) {
  let r = "", n = t.tabSize, i = t.facet(pm)[0];
  if (i == "	") {
    for (; e >= n; )
      r += "	", e -= n;
    i = " ";
  }
  for (let s = 0; s < e; s++)
    r += i;
  return r;
}
function w4(t, e) {
  t instanceof De && (t = new qw(t));
  for (let n of t.state.facet(y4)) {
    let i = n(t, e);
    if (i !== void 0)
      return i;
  }
  let r = Xt(t.state);
  return r.length >= e ? $4(t, r, e) : null;
}
class qw {
  /**
  Create an indent context.
  */
  constructor(e, r = {}) {
    this.state = e, this.options = r, this.unit = b4(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, r = 1) {
    let n = this.state.doc.lineAt(e), { simulateBreak: i, simulateDoubleBreak: s } = this.options;
    return i != null && i >= n.from && i <= n.to ? s && i == e ? { text: "", from: e } : (r < 0 ? i < e : i <= e) ? { text: n.text.slice(i - n.from), from: i } : { text: n.text.slice(0, i - n.from), from: n.from } : n;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, r = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: n, from: i } = this.lineAt(e, r);
    return n.slice(e - i, Math.min(n.length, e + 100 - i));
  }
  /**
  Find the column for the given position.
  */
  column(e, r = 1) {
    let { text: n, from: i } = this.lineAt(e, r), s = this.countColumn(n, e - i), o = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1;
    return o > -1 && (s += o - this.countColumn(n, n.search(/\S|$/))), s;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, r = e.length) {
    return Tv(e, this.state.tabSize, r);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, r = 1) {
    let { text: n, from: i } = this.lineAt(e, r), s = this.options.overrideIndentation;
    if (s) {
      let o = s(i);
      if (o > -1)
        return o;
    }
    return this.countColumn(n, n.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const jo = /* @__PURE__ */ new Ie();
function $4(t, e, r) {
  let n = e.resolveStack(r), i = n.node.enterUnfinishedNodesBefore(r);
  if (i != n.node) {
    let s = [];
    for (let o = i; o != n.node; o = o.parent)
      s.push(o);
    for (let o = s.length - 1; o >= 0; o--)
      n = { node: s[o], next: n };
  }
  return Nw(n, t, r);
}
function Nw(t, e, r) {
  for (let n = t; n; n = n.next) {
    let i = k4(n.node);
    if (i)
      return i(mm.create(e, r, n));
  }
  return 0;
}
function S4(t) {
  return t.pos == t.options.simulateBreak && t.options.simulateDoubleBreak;
}
function k4(t) {
  let e = t.type.prop(jo);
  if (e)
    return e;
  let r = t.firstChild, n;
  if (r && (n = r.type.prop(Ie.closedBy))) {
    let i = t.lastChild, s = i && n.indexOf(i.name) > -1;
    return (o) => Dw(o, !0, 1, void 0, s && !S4(o) ? i.from : void 0);
  }
  return t.parent == null ? _4 : null;
}
function _4() {
  return 0;
}
class mm extends qw {
  constructor(e, r, n) {
    super(e.state, e.options), this.base = e, this.pos = r, this.context = n;
  }
  /**
  The syntax tree node to which the indentation strategy
  applies.
  */
  get node() {
    return this.context.node;
  }
  /**
  @internal
  */
  static create(e, r, n) {
    return new mm(e, r, n);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let r = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let n = e.resolve(r.from);
      for (; n.parent && n.parent.from == n.from; )
        n = n.parent;
      if (P4(n, e))
        break;
      r = this.state.doc.lineAt(n.from);
    }
    return this.lineIndent(r.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    return Nw(this.context.next, this.base, this.pos);
  }
}
function P4(t, e) {
  for (let r = e; r; r = r.parent)
    if (t == r)
      return !0;
  return !1;
}
function x4(t) {
  let e = t.node, r = e.childAfter(e.from), n = e.lastChild;
  if (!r)
    return null;
  let i = t.options.simulateBreak, s = t.state.doc.lineAt(r.from), o = i == null || i <= s.from ? s.to : Math.min(s.to, i);
  for (let a = r.to; ; ) {
    let l = e.childAfter(a);
    if (!l || l == n)
      return null;
    if (!l.type.isSkipped)
      return l.from < o ? r : null;
    a = l.to;
  }
}
function Ih({ closing: t, align: e = !0, units: r = 1 }) {
  return (n) => Dw(n, e, r, t);
}
function Dw(t, e, r, n, i) {
  let s = t.textAfter, o = s.match(/^\s*/)[0].length, a = n && s.slice(o, o + n.length) == n || i == t.pos + o, l = e ? x4(t) : null;
  return l ? a ? t.column(l.from) : t.column(l.to) : t.baseIndent + (a ? 0 : t.unit * r);
}
const T4 = (t) => t.baseIndent;
function to({ except: t, units: e = 1 } = {}) {
  return (r) => {
    let n = t && t.test(r.textAfter);
    return r.baseIndent + (n ? 0 : e * r.unit);
  };
}
const C4 = 200;
function Q4() {
  return De.transactionFilter.of((t) => {
    if (!t.docChanged || !t.isUserEvent("input.type") && !t.isUserEvent("input.complete"))
      return t;
    let e = t.startState.languageDataAt("indentOnInput", t.startState.selection.main.head);
    if (!e.length)
      return t;
    let r = t.newDoc, { head: n } = t.newSelection.main, i = r.lineAt(n);
    if (n > i.from + C4)
      return t;
    let s = r.sliceString(i.from, n);
    if (!e.some((c) => c.test(s)))
      return t;
    let { state: o } = t, a = -1, l = [];
    for (let { head: c } of o.selection.ranges) {
      let u = o.doc.lineAt(c);
      if (u.from == a)
        continue;
      a = u.from;
      let d = w4(o, u.from);
      if (d == null)
        continue;
      let f = /^\s*/.exec(u.text)[0], h = v4(o, d);
      f != h && l.push({ from: u.from, to: u.from + f.length, insert: h });
    }
    return l.length ? [t, { changes: l, sequential: !0 }] : t;
  });
}
const yl = /* @__PURE__ */ new Ie();
function Gu(t) {
  let e = t.firstChild, r = t.lastChild;
  return e && e.to < r.from ? { from: e.to, to: r.type.isError ? t.to : r.from } : null;
}
class bl {
  constructor(e, r) {
    this.specs = e;
    let n;
    function i(a) {
      let l = yi.newName();
      return (n || (n = /* @__PURE__ */ Object.create(null)))["." + l] = a, l;
    }
    const s = typeof r.all == "string" ? r.all : r.all ? i(r.all) : void 0, o = r.scope;
    this.scope = o instanceof zr ? (a) => a.prop(Xs) == o.data : o ? (a) => a == o : void 0, this.style = jw(e.map((a) => ({
      tag: a.tag,
      class: a.class || i(Object.assign({}, a, { tag: null }))
    })), {
      all: s
    }).style, this.module = n ? new yi(n) : null, this.themeType = r.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, r) {
    return new bl(e, r || {});
  }
}
const jh = /* @__PURE__ */ be.define(), zw = /* @__PURE__ */ be.define({
  combine(t) {
    return t.length ? [t[0]] : null;
  }
});
function Jd(t) {
  let e = t.facet(jh);
  return e.length ? e : t.facet(zw);
}
function Xw(t, e) {
  let r = [E4], n;
  return t instanceof bl && (t.module && r.push(Se.styleModule.of(t.module)), n = t.themeType), e != null && e.fallback ? r.push(zw.of(t)) : n ? r.push(jh.computeN([Se.darkTheme], (i) => i.facet(Se.darkTheme) == (n == "dark") ? [t] : [])) : r.push(jh.of(t)), r;
}
class A4 {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = Xt(e.state), this.decorations = this.buildDeco(e, Jd(e.state)), this.decoratedTo = e.viewport.to;
  }
  update(e) {
    let r = Xt(e.state), n = Jd(e.state), i = n != Jd(e.startState), { viewport: s } = e.view, o = e.changes.mapPos(this.decoratedTo, 1);
    r.length < s.to && !i && r.type == this.tree.type && o >= s.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = o) : (r != this.tree || e.viewportChanged || i) && (this.tree = r, this.decorations = this.buildDeco(e.view, n), this.decoratedTo = s.to);
  }
  buildDeco(e, r) {
    if (!r || !this.tree.length)
      return We.none;
    let n = new po();
    for (let { from: i, to: s } of e.visibleRanges)
      h4(this.tree, r, (o, a, l) => {
        n.add(o, a, this.markCache[l] || (this.markCache[l] = We.mark({ class: l })));
      }, i, s);
    return n.finish();
  }
}
const E4 = /* @__PURE__ */ pl.high(/* @__PURE__ */ Pr.fromClass(A4, {
  decorations: (t) => t.decorations
})), R4 = /* @__PURE__ */ bl.define([
  {
    tag: E.meta,
    color: "#404740"
  },
  {
    tag: E.link,
    textDecoration: "underline"
  },
  {
    tag: E.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: E.emphasis,
    fontStyle: "italic"
  },
  {
    tag: E.strong,
    fontWeight: "bold"
  },
  {
    tag: E.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: E.keyword,
    color: "#708"
  },
  {
    tag: [E.atom, E.bool, E.url, E.contentSeparator, E.labelName],
    color: "#219"
  },
  {
    tag: [E.literal, E.inserted],
    color: "#164"
  },
  {
    tag: [E.string, E.deleted],
    color: "#a11"
  },
  {
    tag: [E.regexp, E.escape, /* @__PURE__ */ E.special(E.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ E.definition(E.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ E.local(E.variableName),
    color: "#30a"
  },
  {
    tag: [E.typeName, E.namespace],
    color: "#085"
  },
  {
    tag: E.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ E.special(E.variableName), E.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ E.definition(E.propertyName),
    color: "#00c"
  },
  {
    tag: E.comment,
    color: "#940"
  },
  {
    tag: E.invalid,
    color: "#f00"
  }
]), I4 = /* @__PURE__ */ Se.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), Ww = 1e4, Uw = "()[]{}", Vw = /* @__PURE__ */ be.define({
  combine(t) {
    return Bu(t, {
      afterCursor: !0,
      brackets: Uw,
      maxScanDistance: Ww,
      renderMatch: M4
    });
  }
}), j4 = /* @__PURE__ */ We.mark({ class: "cm-matchingBracket" }), Z4 = /* @__PURE__ */ We.mark({ class: "cm-nonmatchingBracket" });
function M4(t) {
  let e = [], r = t.matched ? j4 : Z4;
  return e.push(r.range(t.start.from, t.start.to)), t.end && e.push(r.range(t.end.from, t.end.to)), e;
}
const q4 = /* @__PURE__ */ Br.define({
  create() {
    return We.none;
  },
  update(t, e) {
    if (!e.docChanged && !e.selection)
      return t;
    let r = [], n = e.state.facet(Vw);
    for (let i of e.state.selection.ranges) {
      if (!i.empty)
        continue;
      let s = cc(e.state, i.head, -1, n) || i.head > 0 && cc(e.state, i.head - 1, 1, n) || n.afterCursor && (cc(e.state, i.head, 1, n) || i.head < e.state.doc.length && cc(e.state, i.head + 1, -1, n));
      s && (r = r.concat(n.renderMatch(s, e.state)));
    }
    return We.set(r, !0);
  },
  provide: (t) => Se.decorations.from(t)
}), N4 = [
  q4,
  I4
];
function D4(t = {}) {
  return [Vw.of(t), N4];
}
const Lw = /* @__PURE__ */ new Ie();
function Zh(t, e, r) {
  let n = t.prop(e < 0 ? Ie.openedBy : Ie.closedBy);
  if (n)
    return n;
  if (t.name.length == 1) {
    let i = r.indexOf(t.name);
    if (i > -1 && i % 2 == (e < 0 ? 1 : 0))
      return [r[i + e]];
  }
  return null;
}
function Mh(t) {
  let e = t.type.prop(Lw);
  return e ? e(t.node) : t;
}
function cc(t, e, r, n = {}) {
  let i = n.maxScanDistance || Ww, s = n.brackets || Uw, o = Xt(t), a = o.resolveInner(e, r);
  for (let l = a; l; l = l.parent) {
    let c = Zh(l.type, r, s);
    if (c && l.from < l.to) {
      let u = Mh(l);
      if (u && (r > 0 ? e >= u.from && e < u.to : e > u.from && e <= u.to))
        return z4(t, e, r, l, u, c, s);
    }
  }
  return X4(t, e, r, o, a.type, i, s);
}
function z4(t, e, r, n, i, s, o) {
  let a = n.parent, l = { from: i.from, to: i.to }, c = 0, u = a == null ? void 0 : a.cursor();
  if (u && (r < 0 ? u.childBefore(n.from) : u.childAfter(n.to)))
    do
      if (r < 0 ? u.to <= n.from : u.from >= n.to) {
        if (c == 0 && s.indexOf(u.type.name) > -1 && u.from < u.to) {
          let d = Mh(u);
          return { start: l, end: d ? { from: d.from, to: d.to } : void 0, matched: !0 };
        } else if (Zh(u.type, r, o))
          c++;
        else if (Zh(u.type, -r, o)) {
          if (c == 0) {
            let d = Mh(u);
            return {
              start: l,
              end: d && d.from < d.to ? { from: d.from, to: d.to } : void 0,
              matched: !1
            };
          }
          c--;
        }
      }
    while (r < 0 ? u.prevSibling() : u.nextSibling());
  return { start: l, matched: !1 };
}
function X4(t, e, r, n, i, s, o) {
  let a = r < 0 ? t.sliceDoc(e - 1, e) : t.sliceDoc(e, e + 1), l = o.indexOf(a);
  if (l < 0 || l % 2 == 0 != r > 0)
    return null;
  let c = { from: r < 0 ? e - 1 : e, to: r > 0 ? e + 1 : e }, u = t.doc.iterRange(e, r > 0 ? t.doc.length : 0), d = 0;
  for (let f = 0; !u.next().done && f <= s; ) {
    let h = u.value;
    r < 0 && (f += h.length);
    let p = e + f * r;
    for (let g = r > 0 ? 0 : h.length - 1, m = r > 0 ? h.length : -1; g != m; g += r) {
      let y = o.indexOf(h[g]);
      if (!(y < 0 || n.resolveInner(p + g, 1).type != i))
        if (y % 2 == 0 == r > 0)
          d++;
        else {
          if (d == 1)
            return { start: c, end: { from: p + g, to: p + g + 1 }, matched: y >> 1 == l >> 1 };
          d--;
        }
    }
    r > 0 && (f += h.length);
  }
  return u.done ? { start: c, matched: !1 } : null;
}
const W4 = /* @__PURE__ */ Object.create(null), qO = [Gt.none], NO = [], DO = /* @__PURE__ */ Object.create(null), U4 = /* @__PURE__ */ Object.create(null);
for (let [t, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  U4[t] = /* @__PURE__ */ V4(W4, e);
function ef(t, e) {
  NO.indexOf(t) > -1 || (NO.push(t), console.warn(e));
}
function V4(t, e) {
  let r = [];
  for (let a of e.split(" ")) {
    let l = [];
    for (let c of a.split(".")) {
      let u = t[c] || E[c];
      u ? typeof u == "function" ? l.length ? l = l.map(u) : ef(c, `Modifier ${c} used at start of tag`) : l.length ? ef(c, `Tag ${c} used as modifier`) : l = Array.isArray(u) ? u : [u] : ef(c, `Unknown highlighting tag ${c}`);
    }
    for (let c of l)
      r.push(c);
  }
  if (!r.length)
    return 0;
  let n = e.replace(/ /g, "_"), i = n + " " + r.map((a) => a.id), s = DO[i];
  if (s)
    return s.id;
  let o = DO[i] = Gt.define({
    id: qO.length,
    name: n,
    props: [Io({ [n]: r })]
  });
  return qO.push(o), o.id;
}
mt.RTL, mt.LTR;
class Yw {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sourcesâ€”in the editor, the extension will create
  these for you.)
  */
  constructor(e, r, n) {
    this.state = e, this.pos = r, this.explicit = n, this.abortListeners = [];
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let r = Xt(this.state).resolveInner(this.pos, -1);
    for (; r && e.indexOf(r.name) < 0; )
      r = r.parent;
    return r ? {
      from: r.from,
      to: this.pos,
      text: this.state.sliceDoc(r.from, this.pos),
      type: r.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let r = this.state.doc.lineAt(this.pos), n = Math.max(r.from, this.pos - 250), i = r.text.slice(n - r.from, this.pos - r.from), s = i.search(Fw(e, !1));
    return s < 0 ? null : { from: n + s, to: this.pos, text: i.slice(s) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  */
  addEventListener(e, r) {
    e == "abort" && this.abortListeners && this.abortListeners.push(r);
  }
}
function zO(t) {
  let e = Object.keys(t).join(""), r = /\w/.test(e);
  return r && (e = e.replace(/\w/g, "")), `[${r ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function L4(t) {
  let e = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null);
  for (let { label: i } of t) {
    e[i[0]] = !0;
    for (let s = 1; s < i.length; s++)
      r[i[s]] = !0;
  }
  let n = zO(e) + zO(r) + "*$";
  return [new RegExp("^" + n), new RegExp(n)];
}
function Bw(t) {
  let e = t.map((i) => typeof i == "string" ? { label: i } : i), [r, n] = e.every((i) => /^\w+$/.test(i.label)) ? [/\w*$/, /\w+$/] : L4(e);
  return (i) => {
    let s = i.matchBefore(n);
    return s || i.explicit ? { from: s ? s.from : i.pos, options: e, validFor: r } : null;
  };
}
function Y4(t, e) {
  return (r) => {
    for (let n = Xt(r.state).resolveInner(r.pos, -1); n; n = n.parent) {
      if (t.indexOf(n.name) > -1)
        return null;
      if (n.type.isTop)
        break;
    }
    return e(r);
  };
}
class XO {
  constructor(e, r, n, i) {
    this.completion = e, this.source = r, this.match = n, this.score = i;
  }
}
function fi(t) {
  return t.selection.main.from;
}
function Fw(t, e) {
  var r;
  let { source: n } = t, i = e && n[0] != "^", s = n[n.length - 1] != "$";
  return !i && !s ? t : new RegExp(`${i ? "^" : ""}(?:${n})${s ? "$" : ""}`, (r = t.flags) !== null && r !== void 0 ? r : t.ignoreCase ? "i" : "");
}
const Hw = /* @__PURE__ */ Os.define();
function B4(t, e, r, n) {
  let { main: i } = t.selection, s = r - i.from, o = n - i.from;
  return Object.assign(Object.assign({}, t.changeByRange((a) => a != i && r != n && t.sliceDoc(a.from + s, a.from + o) != t.sliceDoc(r, n) ? { range: a } : {
    changes: { from: a.from + s, to: n == i.from ? a.to : a.from + o, insert: e },
    range: ce.cursor(a.from + s + e.length)
  })), { scrollIntoView: !0, userEvent: "input.complete" });
}
const WO = /* @__PURE__ */ new WeakMap();
function F4(t) {
  if (!Array.isArray(t))
    return t;
  let e = WO.get(t);
  return e || WO.set(t, e = Bw(t)), e;
}
const ou = /* @__PURE__ */ Le.define(), tl = /* @__PURE__ */ Le.define();
class H4 {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let r = 0; r < e.length; ) {
      let n = Mt(e, r), i = qr(n);
      this.chars.push(n);
      let s = e.slice(r, r + i), o = s.toUpperCase();
      this.folded.push(Mt(o == s ? s.toLowerCase() : o, 0)), r += i;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, r) {
    return this.score = e, this.matched = r, !0;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return !1;
    let { chars: r, folded: n, any: i, precise: s, byWord: o } = this;
    if (r.length == 1) {
      let O = Mt(e, 0), b = qr(O), w = b == e.length ? 0 : -100;
      if (O != r[0])
        if (O == n[0])
          w += -200;
        else
          return !1;
      return this.ret(w, [0, b]);
    }
    let a = e.indexOf(this.pattern);
    if (a == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let l = r.length, c = 0;
    if (a < 0) {
      for (let O = 0, b = Math.min(e.length, 200); O < b && c < l; ) {
        let w = Mt(e, O);
        (w == r[c] || w == n[c]) && (i[c++] = O), O += qr(w);
      }
      if (c < l)
        return !1;
    }
    let u = 0, d = 0, f = !1, h = 0, p = -1, g = -1, m = /[a-z]/.test(e), y = !0;
    for (let O = 0, b = Math.min(e.length, 200), w = 0; O < b && d < l; ) {
      let S = Mt(e, O);
      a < 0 && (u < l && S == r[u] && (s[u++] = O), h < l && (S == r[h] || S == n[h] ? (h == 0 && (p = O), g = O + 1, h++) : h = 0));
      let $, _ = S < 255 ? S >= 48 && S <= 57 || S >= 97 && S <= 122 ? 2 : S >= 65 && S <= 90 ? 1 : 0 : ($ = pv(S)) != $.toLowerCase() ? 1 : $ != $.toUpperCase() ? 2 : 0;
      (!O || _ == 1 && m || w == 0 && _ != 0) && (r[d] == S || n[d] == S && (f = !0) ? o[d++] = O : o.length && (y = !1)), w = _, O += qr(S);
    }
    return d == l && o[0] == 0 && y ? this.result(-100 + (f ? -200 : 0), o, e) : h == l && p == 0 ? this.ret(-200 - e.length + (g == e.length ? 0 : -100), [0, g]) : a > -1 ? this.ret(-700 - e.length, [a, a + this.pattern.length]) : h == l ? this.ret(-900 - e.length, [p, g]) : d == l ? this.result(-100 + (f ? -200 : 0) + -700 + (y ? 0 : -1100), o, e) : r.length == 2 ? !1 : this.result((i[0] ? -700 : 0) + -200 + -1100, i, e);
  }
  result(e, r, n) {
    let i = [], s = 0;
    for (let o of r) {
      let a = o + (this.astral ? qr(Mt(n, o)) : 1);
      s && i[s - 1] == o ? i[s - 1] = a : (i[s++] = o, i[s++] = a);
    }
    return this.ret(e - n.length, i);
  }
}
const Et = /* @__PURE__ */ be.define({
  combine(t) {
    return Bu(t, {
      activateOnTyping: !0,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: G4,
      compareCompletions: (e, r) => e.label.localeCompare(r.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (e, r) => e && r,
      closeOnBlur: (e, r) => e && r,
      icons: (e, r) => e && r,
      tooltipClass: (e, r) => (n) => UO(e(n), r(n)),
      optionClass: (e, r) => (n) => UO(e(n), r(n)),
      addToOptions: (e, r) => e.concat(r)
    });
  }
});
function UO(t, e) {
  return t ? e ? t + " " + e : t : e;
}
function G4(t, e, r, n, i, s) {
  let o = t.textDirection == mt.RTL, a = o, l = !1, c = "top", u, d, f = e.left - i.left, h = i.right - e.right, p = n.right - n.left, g = n.bottom - n.top;
  if (a && f < Math.min(p, h) ? a = !1 : !a && h < Math.min(p, f) && (a = !0), p <= (a ? f : h))
    u = Math.max(i.top, Math.min(r.top, i.bottom - g)) - e.top, d = Math.min(400, a ? f : h);
  else {
    l = !0, d = Math.min(
      400,
      (o ? e.right : i.right - e.left) - 30
      /* Info.Margin */
    );
    let O = i.bottom - e.bottom;
    O >= g || O > e.top ? u = r.bottom - e.top : (c = "bottom", u = e.bottom - r.top);
  }
  let m = (e.bottom - e.top) / s.offsetHeight, y = (e.right - e.left) / s.offsetWidth;
  return {
    style: `${c}: ${u / m}px; max-width: ${d / y}px`,
    class: "cm-completionInfo-" + (l ? o ? "left-narrow" : "right-narrow" : a ? "left" : "right")
  };
}
function K4(t) {
  let e = t.addToOptions.slice();
  return t.icons && e.push({
    render(r) {
      let n = document.createElement("div");
      return n.classList.add("cm-completionIcon"), r.type && n.classList.add(...r.type.split(/\s+/g).map((i) => "cm-completionIcon-" + i)), n.setAttribute("aria-hidden", "true"), n;
    },
    position: 20
  }), e.push({
    render(r, n, i, s) {
      let o = document.createElement("span");
      o.className = "cm-completionLabel";
      let a = r.displayLabel || r.label, l = 0;
      for (let c = 0; c < s.length; ) {
        let u = s[c++], d = s[c++];
        u > l && o.appendChild(document.createTextNode(a.slice(l, u)));
        let f = o.appendChild(document.createElement("span"));
        f.appendChild(document.createTextNode(a.slice(u, d))), f.className = "cm-completionMatchedText", l = d;
      }
      return l < a.length && o.appendChild(document.createTextNode(a.slice(l))), o;
    },
    position: 50
  }, {
    render(r) {
      if (!r.detail)
        return null;
      let n = document.createElement("span");
      return n.className = "cm-completionDetail", n.textContent = r.detail, n;
    },
    position: 80
  }), e.sort((r, n) => r.position - n.position).map((r) => r.render);
}
function tf(t, e, r) {
  if (t <= r)
    return { from: 0, to: t };
  if (e < 0 && (e = 0), e <= t >> 1) {
    let i = Math.floor(e / r);
    return { from: i * r, to: (i + 1) * r };
  }
  let n = Math.floor((t - e) / r);
  return { from: t - (n + 1) * r, to: t - n * r };
}
class J4 {
  constructor(e, r, n) {
    this.view = e, this.stateField = r, this.applyCompletion = n, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (l) => this.placeInfo(l),
      key: this
    }, this.space = null, this.currentClass = "";
    let i = e.state.field(r), { options: s, selected: o } = i.open, a = e.state.facet(Et);
    this.optionContent = K4(a), this.optionClass = a.optionClass, this.tooltipClass = a.tooltipClass, this.range = tf(s.length, o, a.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (l) => {
      let { options: c } = e.state.field(r).open;
      for (let u = l.target, d; u && u != this.dom; u = u.parentNode)
        if (u.nodeName == "LI" && (d = /-(\d+)$/.exec(u.id)) && +d[1] < c.length) {
          this.applyCompletion(e, c[+d[1]]), l.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (l) => {
      let c = e.state.field(this.stateField, !1);
      c && c.tooltip && e.state.facet(Et).closeOnBlur && l.relatedTarget != e.contentDOM && e.dispatch({ effects: tl.of(null) });
    }), this.showOptions(s, i.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(e, r) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, r, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(e) {
    var r;
    let n = e.state.field(this.stateField), i = e.startState.field(this.stateField);
    if (this.updateTooltipClass(e.state), n != i) {
      let { options: s, selected: o, disabled: a } = n.open;
      (!i.open || i.open.options != s) && (this.range = tf(s.length, o, e.state.facet(Et).maxRenderedOptions), this.showOptions(s, n.id)), this.updateSel(), a != ((r = i.open) === null || r === void 0 ? void 0 : r.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!a);
    }
  }
  updateTooltipClass(e) {
    let r = this.tooltipClass(e);
    if (r != this.currentClass) {
      for (let n of this.currentClass.split(" "))
        n && this.dom.classList.remove(n);
      for (let n of r.split(" "))
        n && this.dom.classList.add(n);
      this.currentClass = r;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), r = e.open;
    if ((r.selected > -1 && r.selected < this.range.from || r.selected >= this.range.to) && (this.range = tf(r.options.length, r.selected, this.view.state.facet(Et).maxRenderedOptions), this.showOptions(r.options, e.id)), this.updateSelectedOption(r.selected)) {
      this.destroyInfo();
      let { completion: n } = r.options[r.selected], { info: i } = n;
      if (!i)
        return;
      let s = typeof i == "string" ? document.createTextNode(i) : i(n);
      if (!s)
        return;
      "then" in s ? s.then((o) => {
        o && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(o, n);
      }).catch((o) => Wr(this.view.state, o, "completion info")) : this.addInfoPane(s, n);
    }
  }
  addInfoPane(e, r) {
    this.destroyInfo();
    let n = this.info = document.createElement("div");
    if (n.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      n.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: i, destroy: s } = e;
      n.appendChild(i), this.infoDestroy = s || null;
    }
    this.dom.appendChild(n), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let r = null;
    for (let n = this.list.firstChild, i = this.range.from; n; n = n.nextSibling, i++)
      n.nodeName != "LI" || !n.id ? i-- : i == e ? n.hasAttribute("aria-selected") || (n.setAttribute("aria-selected", "true"), r = n) : n.hasAttribute("aria-selected") && n.removeAttribute("aria-selected");
    return r && t7(this.list, r), r;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let r = this.dom.getBoundingClientRect(), n = this.info.getBoundingClientRect(), i = e.getBoundingClientRect(), s = this.space;
    if (!s) {
      let o = this.dom.ownerDocument.defaultView || window;
      s = { left: 0, top: 0, right: o.innerWidth, bottom: o.innerHeight };
    }
    return i.top > Math.min(s.bottom, r.bottom) - 10 || i.bottom < Math.max(s.top, r.top) + 10 ? null : this.view.state.facet(Et).positionInfo(this.view, r, i, n, s, this.dom);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, r, n) {
    const i = document.createElement("ul");
    i.id = r, i.setAttribute("role", "listbox"), i.setAttribute("aria-expanded", "true"), i.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let s = null;
    for (let o = n.from; o < n.to; o++) {
      let { completion: a, match: l } = e[o], { section: c } = a;
      if (c) {
        let f = typeof c == "string" ? c : c.name;
        if (f != s && (o > n.from || n.from == 0))
          if (s = f, typeof c != "string" && c.header)
            i.appendChild(c.header(c));
          else {
            let h = i.appendChild(document.createElement("completion-section"));
            h.textContent = f;
          }
      }
      const u = i.appendChild(document.createElement("li"));
      u.id = r + "-" + o, u.setAttribute("role", "option");
      let d = this.optionClass(a);
      d && (u.className = d);
      for (let f of this.optionContent) {
        let h = f(a, this.view.state, this.view, l);
        h && u.appendChild(h);
      }
    }
    return n.from && i.classList.add("cm-completionListIncompleteTop"), n.to < e.length && i.classList.add("cm-completionListIncompleteBottom"), i;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function e7(t, e) {
  return (r) => new J4(r, t, e);
}
function t7(t, e) {
  let r = t.getBoundingClientRect(), n = e.getBoundingClientRect(), i = r.height / t.offsetHeight;
  n.top < r.top ? t.scrollTop -= (r.top - n.top) / i : n.bottom > r.bottom && (t.scrollTop += (n.bottom - r.bottom) / i);
}
function VO(t) {
  return (t.boost || 0) * 100 + (t.apply ? 10 : 0) + (t.info ? 5 : 0) + (t.type ? 1 : 0);
}
function r7(t, e) {
  let r = [], n = null, i = (l) => {
    r.push(l);
    let { section: c } = l.completion;
    if (c) {
      n || (n = []);
      let u = typeof c == "string" ? c : c.name;
      n.some((d) => d.name == u) || n.push(typeof c == "string" ? { name: u } : c);
    }
  };
  for (let l of t)
    if (l.hasResult()) {
      let c = l.result.getMatch;
      if (l.result.filter === !1)
        for (let u of l.result.options)
          i(new XO(u, l.source, c ? c(u) : [], 1e9 - r.length));
      else {
        let u = new H4(e.sliceDoc(l.from, l.to));
        for (let d of l.result.options)
          if (u.match(d.label)) {
            let f = d.displayLabel ? c ? c(d, u.matched) : [] : u.matched;
            i(new XO(d, l.source, f, u.score + (d.boost || 0)));
          }
      }
    }
  if (n) {
    let l = /* @__PURE__ */ Object.create(null), c = 0, u = (d, f) => {
      var h, p;
      return ((h = d.rank) !== null && h !== void 0 ? h : 1e9) - ((p = f.rank) !== null && p !== void 0 ? p : 1e9) || (d.name < f.name ? -1 : 1);
    };
    for (let d of n.sort(u))
      c -= 1e5, l[d.name] = c;
    for (let d of r) {
      let { section: f } = d.completion;
      f && (d.score += l[typeof f == "string" ? f : f.name]);
    }
  }
  let s = [], o = null, a = e.facet(Et).compareCompletions;
  for (let l of r.sort((c, u) => u.score - c.score || a(c.completion, u.completion))) {
    let c = l.completion;
    !o || o.label != c.label || o.detail != c.detail || o.type != null && c.type != null && o.type != c.type || o.apply != c.apply || o.boost != c.boost ? s.push(l) : VO(l.completion) > VO(o) && (s[s.length - 1] = l), o = l.completion;
  }
  return s;
}
class Ws {
  constructor(e, r, n, i, s, o) {
    this.options = e, this.attrs = r, this.tooltip = n, this.timestamp = i, this.selected = s, this.disabled = o;
  }
  setSelected(e, r) {
    return e == this.selected || e >= this.options.length ? this : new Ws(this.options, LO(r, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, r, n, i, s) {
    let o = r7(e, r);
    if (!o.length)
      return i && e.some(
        (l) => l.state == 1
        /* State.Pending */
      ) ? new Ws(i.options, i.attrs, i.tooltip, i.timestamp, i.selected, !0) : null;
    let a = r.facet(Et).selectOnOpen ? 0 : -1;
    if (i && i.selected != a && i.selected != -1) {
      let l = i.options[i.selected].completion;
      for (let c = 0; c < o.length; c++)
        if (o[c].completion == l) {
          a = c;
          break;
        }
    }
    return new Ws(o, LO(n, a), {
      pos: e.reduce((l, c) => c.hasResult() ? Math.min(l, c.from) : l, 1e8),
      create: a7,
      above: s.aboveCursor
    }, i ? i.timestamp : Date.now(), a, !1);
  }
  map(e) {
    return new Ws(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
}
class au {
  constructor(e, r, n) {
    this.active = e, this.id = r, this.open = n;
  }
  static start() {
    return new au(s7, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: r } = e, n = r.facet(Et), s = (n.override || r.languageDataAt("autocomplete", fi(r)).map(F4)).map((a) => (this.active.find((c) => c.source == a) || new ir(
      a,
      this.active.some(
        (c) => c.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, n));
    s.length == this.active.length && s.every((a, l) => a == this.active[l]) && (s = this.active);
    let o = this.open;
    o && e.docChanged && (o = o.map(e.changes)), e.selection || s.some((a) => a.hasResult() && e.changes.touchesRange(a.from, a.to)) || !n7(s, this.active) ? o = Ws.build(s, r, this.id, o, n) : o && o.disabled && !s.some(
      (a) => a.state == 1
      /* State.Pending */
    ) && (o = null), !o && s.every(
      (a) => a.state != 1
      /* State.Pending */
    ) && s.some((a) => a.hasResult()) && (s = s.map((a) => a.hasResult() ? new ir(
      a.source,
      0
      /* State.Inactive */
    ) : a));
    for (let a of e.effects)
      a.is(Kw) && (o = o && o.setSelected(a.value, this.id));
    return s == this.active && o == this.open ? this : new au(s, this.id, o);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : i7;
  }
}
function n7(t, e) {
  if (t == e)
    return !0;
  for (let r = 0, n = 0; ; ) {
    for (; r < t.length && !t[r].hasResult; )
      r++;
    for (; n < e.length && !e[n].hasResult; )
      n++;
    let i = r == t.length, s = n == e.length;
    if (i || s)
      return i == s;
    if (t[r++].result != e[n++].result)
      return !1;
  }
}
const i7 = {
  "aria-autocomplete": "list"
};
function LO(t, e) {
  let r = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": t
  };
  return e > -1 && (r["aria-activedescendant"] = t + "-" + e), r;
}
const s7 = [];
function qh(t) {
  return t.isUserEvent("input.type") ? "input" : t.isUserEvent("delete.backward") ? "delete" : null;
}
class ir {
  constructor(e, r, n = -1) {
    this.source = e, this.state = r, this.explicitPos = n;
  }
  hasResult() {
    return !1;
  }
  update(e, r) {
    let n = qh(e), i = this;
    n ? i = i.handleUserEvent(e, n, r) : e.docChanged ? i = i.handleChange(e) : e.selection && i.state != 0 && (i = new ir(
      i.source,
      0
      /* State.Inactive */
    ));
    for (let s of e.effects)
      if (s.is(ou))
        i = new ir(i.source, 1, s.value ? fi(e.state) : -1);
      else if (s.is(tl))
        i = new ir(
          i.source,
          0
          /* State.Inactive */
        );
      else if (s.is(Gw))
        for (let o of s.value)
          o.source == i.source && (i = o);
    return i;
  }
  handleUserEvent(e, r, n) {
    return r == "delete" || !n.activateOnTyping ? this.map(e.changes) : new ir(
      this.source,
      1
      /* State.Pending */
    );
  }
  handleChange(e) {
    return e.changes.touchesRange(fi(e.startState)) ? new ir(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty || this.explicitPos < 0 ? this : new ir(this.source, this.state, e.mapPos(this.explicitPos));
  }
}
class ro extends ir {
  constructor(e, r, n, i, s) {
    super(e, 2, r), this.result = n, this.from = i, this.to = s;
  }
  hasResult() {
    return !0;
  }
  handleUserEvent(e, r, n) {
    var i;
    let s = e.changes.mapPos(this.from), o = e.changes.mapPos(this.to, 1), a = fi(e.state);
    if ((this.explicitPos < 0 ? a <= s : a < this.from) || a > o || r == "delete" && fi(e.startState) == this.from)
      return new ir(
        this.source,
        r == "input" && n.activateOnTyping ? 1 : 0
        /* State.Inactive */
      );
    let l = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos), c;
    return o7(this.result.validFor, e.state, s, o) ? new ro(this.source, l, this.result, s, o) : this.result.update && (c = this.result.update(this.result, s, o, new Yw(e.state, a, l >= 0))) ? new ro(this.source, l, c, c.from, (i = c.to) !== null && i !== void 0 ? i : fi(e.state)) : new ir(this.source, 1, l);
  }
  handleChange(e) {
    return e.changes.touchesRange(this.from, this.to) ? new ir(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty ? this : new ro(this.source, this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos), this.result, e.mapPos(this.from), e.mapPos(this.to, 1));
  }
}
function o7(t, e, r, n) {
  if (!t)
    return !1;
  let i = e.sliceDoc(r, n);
  return typeof t == "function" ? t(i, r, n, e) : Fw(t, !0).test(i);
}
const Gw = /* @__PURE__ */ Le.define({
  map(t, e) {
    return t.map((r) => r.map(e));
  }
}), Kw = /* @__PURE__ */ Le.define(), ur = /* @__PURE__ */ Br.define({
  create() {
    return au.start();
  },
  update(t, e) {
    return t.update(e);
  },
  provide: (t) => [
    kw.from(t, (e) => e.tooltip),
    Se.contentAttributes.from(t, (e) => e.attrs)
  ]
});
function Jw(t, e) {
  const r = e.completion.apply || e.completion.label;
  let n = t.state.field(ur).active.find((i) => i.source == e.source);
  return n instanceof ro ? (typeof r == "string" ? t.dispatch(Object.assign(Object.assign({}, B4(t.state, r, n.from, n.to)), { annotations: Hw.of(e.completion) })) : r(t, e.completion, n.from, n.to), !0) : !1;
}
const a7 = /* @__PURE__ */ e7(ur, Jw);
function uc(t, e = "option") {
  return (r) => {
    let n = r.state.field(ur, !1);
    if (!n || !n.open || n.open.disabled || Date.now() - n.open.timestamp < r.state.facet(Et).interactionDelay)
      return !1;
    let i = 1, s;
    e == "page" && (s = _w(r, n.open.tooltip)) && (i = Math.max(2, Math.floor(s.dom.offsetHeight / s.dom.querySelector("li").offsetHeight) - 1));
    let { length: o } = n.open.options, a = n.open.selected > -1 ? n.open.selected + i * (t ? 1 : -1) : t ? 0 : o - 1;
    return a < 0 ? a = e == "page" ? 0 : o - 1 : a >= o && (a = e == "page" ? o - 1 : 0), r.dispatch({ effects: Kw.of(a) }), !0;
  };
}
const l7 = (t) => {
  let e = t.state.field(ur, !1);
  return t.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < t.state.facet(Et).interactionDelay ? !1 : Jw(t, e.open.options[e.open.selected]);
}, c7 = (t) => t.state.field(ur, !1) ? (t.dispatch({ effects: ou.of(!0) }), !0) : !1, u7 = (t) => {
  let e = t.state.field(ur, !1);
  return !e || !e.active.some(
    (r) => r.state != 0
    /* State.Inactive */
  ) ? !1 : (t.dispatch({ effects: tl.of(null) }), !0);
};
class d7 {
  constructor(e, r) {
    this.active = e, this.context = r, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const f7 = 50, h7 = 1e3, p7 = /* @__PURE__ */ Pr.fromClass(class {
  constructor(t) {
    this.view = t, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let e of t.state.field(ur).active)
      e.state == 1 && this.startQuery(e);
  }
  update(t) {
    let e = t.state.field(ur);
    if (!t.selectionSet && !t.docChanged && t.startState.field(ur) == e)
      return;
    let r = t.transactions.some((i) => (i.selection || i.docChanged) && !qh(i));
    for (let i = 0; i < this.running.length; i++) {
      let s = this.running[i];
      if (r || s.updates.length + t.transactions.length > f7 && Date.now() - s.time > h7) {
        for (let o of s.context.abortListeners)
          try {
            o();
          } catch (a) {
            Wr(this.view.state, a);
          }
        s.context.abortListeners = null, this.running.splice(i--, 1);
      } else
        s.updates.push(...t.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), t.transactions.some((i) => i.effects.some((s) => s.is(ou))) && (this.pendingStart = !0);
    let n = this.pendingStart ? 50 : t.state.facet(Et).activateOnTypingDelay;
    if (this.debounceUpdate = e.active.some((i) => i.state == 1 && !this.running.some((s) => s.active.source == i.source)) ? setTimeout(() => this.startUpdate(), n) : -1, this.composing != 0)
      for (let i of t.transactions)
        qh(i) == "input" ? this.composing = 2 : this.composing == 2 && i.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: t } = this.view, e = t.field(ur);
    for (let r of e.active)
      r.state == 1 && !this.running.some((n) => n.active.source == r.source) && this.startQuery(r);
  }
  startQuery(t) {
    let { state: e } = this.view, r = fi(e), n = new Yw(e, r, t.explicitPos == r), i = new d7(t, n);
    this.running.push(i), Promise.resolve(t.source(n)).then((s) => {
      i.context.aborted || (i.done = s || null, this.scheduleAccept());
    }, (s) => {
      this.view.dispatch({ effects: tl.of(null) }), Wr(this.view.state, s);
    });
  }
  scheduleAccept() {
    this.running.every((t) => t.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Et).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var t;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], r = this.view.state.facet(Et);
    for (let n = 0; n < this.running.length; n++) {
      let i = this.running[n];
      if (i.done === void 0)
        continue;
      if (this.running.splice(n--, 1), i.done) {
        let o = new ro(i.active.source, i.active.explicitPos, i.done, i.done.from, (t = i.done.to) !== null && t !== void 0 ? t : fi(i.updates.length ? i.updates[0].startState : this.view.state));
        for (let a of i.updates)
          o = o.update(a, r);
        if (o.hasResult()) {
          e.push(o);
          continue;
        }
      }
      let s = this.view.state.field(ur).active.find((o) => o.source == i.active.source);
      if (s && s.state == 1)
        if (i.done == null) {
          let o = new ir(
            i.active.source,
            0
            /* State.Inactive */
          );
          for (let a of i.updates)
            o = o.update(a, r);
          o.state != 1 && e.push(o);
        } else
          this.startQuery(s);
    }
    e.length && this.view.dispatch({ effects: Gw.of(e) });
  }
}, {
  eventHandlers: {
    blur(t) {
      let e = this.view.state.field(ur, !1);
      if (e && e.tooltip && this.view.state.facet(Et).closeOnBlur) {
        let r = e.open && _w(this.view, e.open.tooltip);
        (!r || !r.dom.contains(t.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: tl.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: ou.of(!1) }), 20), this.composing = 0;
    }
  }
}), e2 = /* @__PURE__ */ Se.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"Â·Â·Â·"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'Æ’'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'â—‹'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'â—Œ'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'ð‘¥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'ð¶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'ð‘¡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'âˆª'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'â–¡'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'ðŸ”‘ï¸Ž'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'â–¢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class m7 {
  constructor(e, r, n, i) {
    this.field = e, this.line = r, this.from = n, this.to = i;
  }
}
class gm {
  constructor(e, r, n) {
    this.field = e, this.from = r, this.to = n;
  }
  map(e) {
    let r = e.mapPos(this.from, -1, qt.TrackDel), n = e.mapPos(this.to, 1, qt.TrackDel);
    return r == null || n == null ? null : new gm(this.field, r, n);
  }
}
class Om {
  constructor(e, r) {
    this.lines = e, this.fieldPositions = r;
  }
  instantiate(e, r) {
    let n = [], i = [r], s = e.doc.lineAt(r), o = /^\s*/.exec(s.text)[0];
    for (let l of this.lines) {
      if (n.length) {
        let c = o, u = /^\t*/.exec(l)[0].length;
        for (let d = 0; d < u; d++)
          c += e.facet(pm);
        i.push(r + c.length - u), l = c + l.slice(u);
      }
      n.push(l), r += l.length + 1;
    }
    let a = this.fieldPositions.map((l) => new gm(l.field, i[l.line] + l.from, i[l.line] + l.to));
    return { text: n, ranges: a };
  }
  static parse(e) {
    let r = [], n = [], i = [], s;
    for (let o of e.split(/\r\n?|\n/)) {
      for (; s = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(o); ) {
        let a = s[1] ? +s[1] : null, l = s[2] || s[3] || "", c = -1;
        for (let u = 0; u < r.length; u++)
          (a != null ? r[u].seq == a : l && r[u].name == l) && (c = u);
        if (c < 0) {
          let u = 0;
          for (; u < r.length && (a == null || r[u].seq != null && r[u].seq < a); )
            u++;
          r.splice(u, 0, { seq: a, name: l }), c = u;
          for (let d of i)
            d.field >= c && d.field++;
        }
        i.push(new m7(c, n.length, s.index, s.index + l.length)), o = o.slice(0, s.index) + l + o.slice(s.index + s[0].length);
      }
      for (let a; a = /\\([{}])/.exec(o); ) {
        o = o.slice(0, a.index) + a[1] + o.slice(a.index + a[0].length);
        for (let l of i)
          l.line == n.length && l.from > a.index && (l.from--, l.to--);
      }
      n.push(o);
    }
    return new Om(n, i);
  }
}
let g7 = /* @__PURE__ */ We.widget({ widget: /* @__PURE__ */ new class extends Ro {
  toDOM() {
    let t = document.createElement("span");
    return t.className = "cm-snippetFieldPosition", t;
  }
  ignoreEvent() {
    return !1;
  }
}() }), O7 = /* @__PURE__ */ We.mark({ class: "cm-snippetField" });
class Zo {
  constructor(e, r) {
    this.ranges = e, this.active = r, this.deco = We.set(e.map((n) => (n.from == n.to ? g7 : O7).range(n.from, n.to)));
  }
  map(e) {
    let r = [];
    for (let n of this.ranges) {
      let i = n.map(e);
      if (!i)
        return null;
      r.push(i);
    }
    return new Zo(r, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((r) => this.ranges.some((n) => n.field == this.active && n.from <= r.from && n.to >= r.to));
  }
}
const vl = /* @__PURE__ */ Le.define({
  map(t, e) {
    return t && t.map(e);
  }
}), y7 = /* @__PURE__ */ Le.define(), rl = /* @__PURE__ */ Br.define({
  create() {
    return null;
  },
  update(t, e) {
    for (let r of e.effects) {
      if (r.is(vl))
        return r.value;
      if (r.is(y7) && t)
        return new Zo(t.ranges, r.value);
    }
    return t && e.docChanged && (t = t.map(e.changes)), t && e.selection && !t.selectionInsideField(e.selection) && (t = null), t;
  },
  provide: (t) => Se.decorations.from(t, (e) => e ? e.deco : We.none)
});
function ym(t, e) {
  return ce.create(t.filter((r) => r.field == e).map((r) => ce.range(r.from, r.to)));
}
function b7(t) {
  let e = Om.parse(t);
  return (r, n, i, s) => {
    let { text: o, ranges: a } = e.instantiate(r.state, i), l = {
      changes: { from: i, to: s, insert: Xe.of(o) },
      scrollIntoView: !0,
      annotations: n ? [Hw.of(n), Rt.userEvent.of("input.complete")] : void 0
    };
    if (a.length && (l.selection = ym(a, 0)), a.some((c) => c.field > 0)) {
      let c = new Zo(a, 0), u = l.effects = [vl.of(c)];
      r.state.field(rl, !1) === void 0 && u.push(Le.appendConfig.of([rl, k7, _7, e2]));
    }
    r.dispatch(r.state.update(l));
  };
}
function t2(t) {
  return ({ state: e, dispatch: r }) => {
    let n = e.field(rl, !1);
    if (!n || t < 0 && n.active == 0)
      return !1;
    let i = n.active + t, s = t > 0 && !n.ranges.some((o) => o.field == i + t);
    return r(e.update({
      selection: ym(n.ranges, i),
      effects: vl.of(s ? null : new Zo(n.ranges, i)),
      scrollIntoView: !0
    })), !0;
  };
}
const v7 = ({ state: t, dispatch: e }) => t.field(rl, !1) ? (e(t.update({ effects: vl.of(null) })), !0) : !1, w7 = /* @__PURE__ */ t2(1), $7 = /* @__PURE__ */ t2(-1), S7 = [
  { key: "Tab", run: w7, shift: $7 },
  { key: "Escape", run: v7 }
], YO = /* @__PURE__ */ be.define({
  combine(t) {
    return t.length ? t[0] : S7;
  }
}), k7 = /* @__PURE__ */ pl.highest(/* @__PURE__ */ Ka.compute([YO], (t) => t.facet(YO)));
function rr(t, e) {
  return Object.assign(Object.assign({}, e), { apply: b7(t) });
}
const _7 = /* @__PURE__ */ Se.domEventHandlers({
  mousedown(t, e) {
    let r = e.state.field(rl, !1), n;
    if (!r || (n = e.posAtCoords({ x: t.clientX, y: t.clientY })) == null)
      return !1;
    let i = r.ranges.find((s) => s.from <= n && s.to >= n);
    return !i || i.field == r.active ? !1 : (e.dispatch({
      selection: ym(r.ranges, i.field),
      effects: vl.of(r.ranges.some((s) => s.field > i.field) ? new Zo(r.ranges, i.field) : null),
      scrollIntoView: !0
    }), !0);
  }
}), nl = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, Gi = /* @__PURE__ */ Le.define({
  map(t, e) {
    let r = e.mapPos(t, -1, qt.TrackAfter);
    return r ?? void 0;
  }
}), bm = /* @__PURE__ */ new class extends as {
}();
bm.startSide = 1;
bm.endSide = -1;
const r2 = /* @__PURE__ */ Br.define({
  create() {
    return ze.empty;
  },
  update(t, e) {
    if (t = t.map(e.changes), e.selection) {
      let r = e.state.doc.lineAt(e.selection.main.head);
      t = t.update({ filter: (n) => n >= r.from && n <= r.to });
    }
    for (let r of e.effects)
      r.is(Gi) && (t = t.update({ add: [bm.range(r.value, r.value + 1)] }));
    return t;
  }
});
function P7() {
  return [T7, r2];
}
const rf = "()[]{}<>";
function n2(t) {
  for (let e = 0; e < rf.length; e += 2)
    if (rf.charCodeAt(e) == t)
      return rf.charAt(e + 1);
  return pv(t < 128 ? t : t + 1);
}
function i2(t, e) {
  return t.languageDataAt("closeBrackets", e)[0] || nl;
}
const x7 = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), T7 = /* @__PURE__ */ Se.inputHandler.of((t, e, r, n) => {
  if ((x7 ? t.composing : t.compositionStarted) || t.state.readOnly)
    return !1;
  let i = t.state.selection.main;
  if (n.length > 2 || n.length == 2 && qr(Mt(n, 0)) == 1 || e != i.from || r != i.to)
    return !1;
  let s = A7(t.state, n);
  return s ? (t.dispatch(s), !0) : !1;
}), C7 = ({ state: t, dispatch: e }) => {
  if (t.readOnly)
    return !1;
  let n = i2(t, t.selection.main.head).brackets || nl.brackets, i = null, s = t.changeByRange((o) => {
    if (o.empty) {
      let a = E7(t.doc, o.head);
      for (let l of n)
        if (l == a && Ku(t.doc, o.head) == n2(Mt(l, 0)))
          return {
            changes: { from: o.head - l.length, to: o.head + l.length },
            range: ce.cursor(o.head - l.length)
          };
    }
    return { range: i = o };
  });
  return i || e(t.update(s, { scrollIntoView: !0, userEvent: "delete.backward" })), !i;
}, Q7 = [
  { key: "Backspace", run: C7 }
];
function A7(t, e) {
  let r = i2(t, t.selection.main.head), n = r.brackets || nl.brackets;
  for (let i of n) {
    let s = n2(Mt(i, 0));
    if (e == i)
      return s == i ? j7(t, i, n.indexOf(i + i + i) > -1, r) : R7(t, i, s, r.before || nl.before);
    if (e == s && s2(t, t.selection.main.from))
      return I7(t, i, s);
  }
  return null;
}
function s2(t, e) {
  let r = !1;
  return t.field(r2).between(0, t.doc.length, (n) => {
    n == e && (r = !0);
  }), r;
}
function Ku(t, e) {
  let r = t.sliceString(e, e + 2);
  return r.slice(0, qr(Mt(r, 0)));
}
function E7(t, e) {
  let r = t.sliceString(e - 2, e);
  return qr(Mt(r, 0)) == r.length ? r : r.slice(1);
}
function R7(t, e, r, n) {
  let i = null, s = t.changeByRange((o) => {
    if (!o.empty)
      return {
        changes: [{ insert: e, from: o.from }, { insert: r, from: o.to }],
        effects: Gi.of(o.to + e.length),
        range: ce.range(o.anchor + e.length, o.head + e.length)
      };
    let a = Ku(t.doc, o.head);
    return !a || /\s/.test(a) || n.indexOf(a) > -1 ? {
      changes: { insert: e + r, from: o.head },
      effects: Gi.of(o.head + e.length),
      range: ce.cursor(o.head + e.length)
    } : { range: i = o };
  });
  return i ? null : t.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function I7(t, e, r) {
  let n = null, i = t.changeByRange((s) => s.empty && Ku(t.doc, s.head) == r ? {
    changes: { from: s.head, to: s.head + r.length, insert: r },
    range: ce.cursor(s.head + r.length)
  } : n = { range: s });
  return n ? null : t.update(i, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function j7(t, e, r, n) {
  let i = n.stringPrefixes || nl.stringPrefixes, s = null, o = t.changeByRange((a) => {
    if (!a.empty)
      return {
        changes: [{ insert: e, from: a.from }, { insert: e, from: a.to }],
        effects: Gi.of(a.to + e.length),
        range: ce.range(a.anchor + e.length, a.head + e.length)
      };
    let l = a.head, c = Ku(t.doc, l), u;
    if (c == e) {
      if (BO(t, l))
        return {
          changes: { insert: e + e, from: l },
          effects: Gi.of(l + e.length),
          range: ce.cursor(l + e.length)
        };
      if (s2(t, l)) {
        let f = r && t.sliceDoc(l, l + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: l, to: l + f.length, insert: f },
          range: ce.cursor(l + f.length)
        };
      }
    } else {
      if (r && t.sliceDoc(l - 2 * e.length, l) == e + e && (u = FO(t, l - 2 * e.length, i)) > -1 && BO(t, u))
        return {
          changes: { insert: e + e + e + e, from: l },
          effects: Gi.of(l + e.length),
          range: ce.cursor(l + e.length)
        };
      if (t.charCategorizer(l)(c) != wr.Word && FO(t, l, i) > -1 && !Z7(t, l, e, i))
        return {
          changes: { insert: e + e, from: l },
          effects: Gi.of(l + e.length),
          range: ce.cursor(l + e.length)
        };
    }
    return { range: s = a };
  });
  return s ? null : t.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function BO(t, e) {
  let r = Xt(t).resolveInner(e + 1);
  return r.parent && r.from == e;
}
function Z7(t, e, r, n) {
  let i = Xt(t).resolveInner(e, -1), s = n.reduce((o, a) => Math.max(o, a.length), 0);
  for (let o = 0; o < 5; o++) {
    let a = t.sliceDoc(i.from, Math.min(i.to, i.from + r.length + s)), l = a.indexOf(r);
    if (!l || l > -1 && n.indexOf(a.slice(0, l)) > -1) {
      let u = i.firstChild;
      for (; u && u.from == i.from && u.to - u.from > r.length + l; ) {
        if (t.sliceDoc(u.to - r.length, u.to) == r)
          return !1;
        u = u.firstChild;
      }
      return !0;
    }
    let c = i.to == e && i.parent;
    if (!c)
      break;
    i = c;
  }
  return !1;
}
function FO(t, e, r) {
  let n = t.charCategorizer(e);
  if (n(t.sliceDoc(e - 1, e)) != wr.Word)
    return e;
  for (let i of r) {
    let s = e - i.length;
    if (t.sliceDoc(s, e) == i && n(t.sliceDoc(s - 1, s)) != wr.Word)
      return s;
  }
  return -1;
}
function M7(t = {}) {
  return [
    ur,
    Et.of(t),
    p7,
    q7,
    e2
  ];
}
const o2 = [
  { key: "Ctrl-Space", run: c7 },
  { key: "Escape", run: u7 },
  { key: "ArrowDown", run: /* @__PURE__ */ uc(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ uc(!1) },
  { key: "PageDown", run: /* @__PURE__ */ uc(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ uc(!1, "page") },
  { key: "Enter", run: l7 }
], q7 = /* @__PURE__ */ pl.highest(/* @__PURE__ */ Ka.computeN([Et], (t) => t.facet(Et).defaultKeymap ? [o2] : []));
class lu {
  /**
  @internal
  */
  constructor(e, r, n, i, s, o, a, l, c, u = 0, d) {
    this.p = e, this.stack = r, this.state = n, this.reducePos = i, this.pos = s, this.score = o, this.buffer = a, this.bufferBase = l, this.curContext = c, this.lookAhead = u, this.parent = d;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((e, r) => r % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(e, r, n = 0) {
    let i = e.parser.context;
    return new lu(e, [], r, n, n, 0, [], 0, i ? new HO(i, i.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(e, r) {
    this.stack.push(this.state, r, this.bufferBase + this.buffer.length), this.state = e;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(e) {
    var r;
    let n = e >> 19, i = e & 65535, { parser: s } = this.p, o = s.dynamicPrecedence(i);
    if (o && (this.score += o), n == 0) {
      this.pushState(s.getGoto(this.state, i, !0), this.reducePos), i < s.minRepeatTerm && this.storeNode(i, this.reducePos, this.reducePos, 4, !0), this.reduceContext(i, this.reducePos);
      return;
    }
    let a = this.stack.length - (n - 1) * 3 - (e & 262144 ? 6 : 0), l = a ? this.stack[a - 2] : this.p.ranges[0].from, c = this.reducePos - l;
    c >= 2e3 && !(!((r = this.p.parser.nodeSet.types[i]) === null || r === void 0) && r.isAnonymous) && (l == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = c) : this.p.lastBigReductionSize < c && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = l, this.p.lastBigReductionSize = c));
    let u = a ? this.stack[a - 1] : 0, d = this.bufferBase + this.buffer.length - u;
    if (i < s.minRepeatTerm || e & 131072) {
      let f = s.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(i, l, f, d + 4, !0);
    }
    if (e & 262144)
      this.state = this.stack[a];
    else {
      let f = this.stack[a - 3];
      this.state = s.getGoto(f, i, !0);
    }
    for (; this.stack.length > a; )
      this.stack.pop();
    this.reduceContext(i, l);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(e, r, n, i = 4, s = !1) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let o = this, a = this.buffer.length;
      if (a == 0 && o.parent && (a = o.bufferBase - o.parent.bufferBase, o = o.parent), a > 0 && o.buffer[a - 4] == 0 && o.buffer[a - 1] > -1) {
        if (r == n)
          return;
        if (o.buffer[a - 2] >= r) {
          o.buffer[a - 2] = n;
          return;
        }
      }
    }
    if (!s || this.pos == n)
      this.buffer.push(e, r, n, i);
    else {
      let o = this.buffer.length;
      if (o > 0 && this.buffer[o - 4] != 0)
        for (; o > 0 && this.buffer[o - 2] > n; )
          this.buffer[o] = this.buffer[o - 4], this.buffer[o + 1] = this.buffer[o - 3], this.buffer[o + 2] = this.buffer[o - 2], this.buffer[o + 3] = this.buffer[o - 1], o -= 4, i > 4 && (i -= 4);
      this.buffer[o] = e, this.buffer[o + 1] = r, this.buffer[o + 2] = n, this.buffer[o + 3] = i;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(e, r, n, i) {
    if (e & 131072)
      this.pushState(e & 65535, this.pos);
    else if (e & 262144)
      this.pos = i, this.shiftContext(r, n), r <= this.p.parser.maxNode && this.buffer.push(r, n, i, 4);
    else {
      let s = e, { parser: o } = this.p;
      (i > this.pos || r <= o.maxNode) && (this.pos = i, o.stateFlag(
        s,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = i)), this.pushState(s, n), this.shiftContext(r, n), r <= o.maxNode && this.buffer.push(r, n, i, 4);
    }
  }
  // Apply an action
  /**
  @internal
  */
  apply(e, r, n, i) {
    e & 65536 ? this.reduce(e) : this.shift(e, r, n, i);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(e, r) {
    let n = this.p.reused.length - 1;
    (n < 0 || this.p.reused[n] != e) && (this.p.reused.push(e), n++);
    let i = this.pos;
    this.reducePos = this.pos = i + e.length, this.pushState(r, i), this.buffer.push(
      n,
      i,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let e = this, r = e.buffer.length;
    for (; r > 0 && e.buffer[r - 2] > e.reducePos; )
      r -= 4;
    let n = e.buffer.slice(r), i = e.bufferBase + r;
    for (; e && i == e.bufferBase; )
      e = e.parent;
    return new lu(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, n, i, this.curContext, this.lookAhead, e);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(e, r) {
    let n = e <= this.p.parser.maxNode;
    n && this.storeNode(e, this.pos, r, 4), this.storeNode(0, this.pos, r, n ? 8 : 4), this.pos = this.reducePos = r, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(e) {
    for (let r = new N7(this); ; ) {
      let n = this.p.parser.stateSlot(
        r.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(r.state, e);
      if (n == 0)
        return !1;
      if (!(n & 65536))
        return !0;
      r.reduce(n);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(e) {
    if (this.stack.length >= 300)
      return [];
    let r = this.p.parser.nextStates(this.state);
    if (r.length > 8 || this.stack.length >= 120) {
      let i = [];
      for (let s = 0, o; s < r.length; s += 2)
        (o = r[s + 1]) != this.state && this.p.parser.hasAction(o, e) && i.push(r[s], o);
      if (this.stack.length < 120)
        for (let s = 0; i.length < 8 && s < r.length; s += 2) {
          let o = r[s + 1];
          i.some((a, l) => l & 1 && a == o) || i.push(r[s], o);
        }
      r = i;
    }
    let n = [];
    for (let i = 0; i < r.length && n.length < 4; i += 2) {
      let s = r[i + 1];
      if (s == this.state)
        continue;
      let o = this.split();
      o.pushState(s, this.pos), o.storeNode(0, o.pos, o.pos, 4, !0), o.shiftContext(r[i], this.pos), o.reducePos = this.pos, o.score -= 200, n.push(o);
    }
    return n;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: e } = this.p, r = e.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if (!(r & 65536))
      return !1;
    if (!e.validAction(this.state, r)) {
      let n = r >> 19, i = r & 65535, s = this.stack.length - n * 3;
      if (s < 0 || e.getGoto(this.stack[s], i, !1) < 0) {
        let o = this.findForcedReduction();
        if (o == null)
          return !1;
        r = o;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(r), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: e } = this.p, r = [], n = (i, s) => {
      if (!r.includes(i))
        return r.push(i), e.allActions(i, (o) => {
          if (!(o & 393216))
            if (o & 65536) {
              let a = (o >> 19) - s;
              if (a > 1) {
                let l = o & 65535, c = this.stack.length - a * 3;
                if (c >= 0 && e.getGoto(this.stack[c], l, !1) >= 0)
                  return a << 19 | 65536 | l;
              }
            } else {
              let a = n(o, s + 1);
              if (a != null)
                return a;
            }
        });
    };
    return n(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !e.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length)
      return !1;
    for (let r = 0; r < this.stack.length; r += 3)
      if (this.stack[r] != e.stack[r])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, r) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(r)));
  }
  reduceContext(e, r) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(r)));
  }
  /**
  @internal
  */
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let r = new HO(this.curContext.tracker, e);
      r.hash != this.curContext.hash && this.emitContext(), this.curContext = r;
    }
  }
  /**
  @internal
  */
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class HO {
  constructor(e, r) {
    this.tracker = e, this.context = r, this.hash = e.strict ? e.hash(r) : 0;
  }
}
class N7 {
  constructor(e) {
    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;
  }
  reduce(e) {
    let r = e & 65535, n = e >> 19;
    n == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (n - 1) * 3;
    let i = this.start.p.parser.getGoto(this.stack[this.base - 3], r, !0);
    this.state = i;
  }
}
class cu {
  constructor(e, r, n) {
    this.stack = e, this.pos = r, this.index = n, this.buffer = e.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e, r = e.bufferBase + e.buffer.length) {
    return new cu(e, r, r - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new cu(this.stack, this.pos, this.index);
  }
}
function ka(t, e = Uint16Array) {
  if (typeof t != "string")
    return t;
  let r = null;
  for (let n = 0, i = 0; n < t.length; ) {
    let s = 0;
    for (; ; ) {
      let o = t.charCodeAt(n++), a = !1;
      if (o == 126) {
        s = 65535;
        break;
      }
      o >= 92 && o--, o >= 34 && o--;
      let l = o - 32;
      if (l >= 46 && (l -= 46, a = !0), s += l, a)
        break;
      s *= 46;
    }
    r ? r[i++] = s : r = new e(s);
  }
  return r;
}
class Ic {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const GO = new Ic();
class D7 {
  /**
  @internal
  */
  constructor(e, r) {
    this.input = e, this.ranges = r, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = GO, this.rangeIndex = 0, this.pos = this.chunkPos = r[0].from, this.range = r[0], this.end = r[r.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(e, r) {
    let n = this.range, i = this.rangeIndex, s = this.pos + e;
    for (; s < n.from; ) {
      if (!i)
        return null;
      let o = this.ranges[--i];
      s -= n.from - o.to, n = o;
    }
    for (; r < 0 ? s > n.to : s >= n.to; ) {
      if (i == this.ranges.length - 1)
        return null;
      let o = this.ranges[++i];
      s += o.from - n.to, n = o;
    }
    return s;
  }
  /**
  @internal
  */
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to)
      return e;
    for (let r of this.ranges)
      if (r.to > e)
        return Math.max(e, r.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsingâ€”when looking forwardâ€”or even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(e) {
    let r = this.chunkOff + e, n, i;
    if (r >= 0 && r < this.chunk.length)
      n = this.pos + e, i = this.chunk.charCodeAt(r);
    else {
      let s = this.resolveOffset(e, 1);
      if (s == null)
        return -1;
      if (n = s, n >= this.chunk2Pos && n < this.chunk2Pos + this.chunk2.length)
        i = this.chunk2.charCodeAt(n - this.chunk2Pos);
      else {
        let o = this.rangeIndex, a = this.range;
        for (; a.to <= n; )
          a = this.ranges[++o];
        this.chunk2 = this.input.chunk(this.chunk2Pos = n), n + this.chunk2.length > a.to && (this.chunk2 = this.chunk2.slice(0, a.to - n)), i = this.chunk2.charCodeAt(0);
      }
    }
    return n >= this.token.lookAhead && (this.token.lookAhead = n + 1), i;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(e, r = 0) {
    let n = r ? this.resolveOffset(r, -1) : this.pos;
    if (n == null || n < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e, this.token.end = n;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(e, r) {
    this.token.value = e, this.token.end = r;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: r } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = r, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e = this.input.chunk(this.pos), r = this.pos + e.length;
      this.chunk = r > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(e, r) {
    if (r ? (this.token = r, r.start = e, r.lookAhead = e + 1, r.value = r.extended = -1) : this.token = GO, this.pos != e) {
      if (this.pos = e, e == this.end)
        return this.setDone(), this;
      for (; e < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(e, r) {
    if (e >= this.chunkPos && r <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, r - this.chunkPos);
    if (e >= this.chunk2Pos && r <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, r - this.chunk2Pos);
    if (e >= this.range.from && r <= this.range.to)
      return this.input.read(e, r);
    let n = "";
    for (let i of this.ranges) {
      if (i.from >= r)
        break;
      i.to > e && (n += this.input.read(Math.max(i.from, e), Math.min(i.to, r)));
    }
    return n;
  }
}
class no {
  constructor(e, r) {
    this.data = e, this.id = r;
  }
  token(e, r) {
    let { parser: n } = r.p;
    a2(this.data, e, r, this.id, n.data, n.tokenPrecTable);
  }
}
no.prototype.contextual = no.prototype.fallback = no.prototype.extend = !1;
class uu {
  constructor(e, r, n) {
    this.precTable = r, this.elseToken = n, this.data = typeof e == "string" ? ka(e) : e;
  }
  token(e, r) {
    let n = e.pos, i = 0;
    for (; ; ) {
      let s = e.next < 0, o = e.resolveOffset(1, 1);
      if (a2(this.data, e, r, 0, this.data, this.precTable), e.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (s || i++, o == null)
        break;
      e.reset(o, e.token);
    }
    i && (e.reset(n, e.token), e.acceptToken(this.elseToken, i));
  }
}
uu.prototype.contextual = no.prototype.fallback = no.prototype.extend = !1;
class Kt {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(e, r = {}) {
    this.token = e, this.contextual = !!r.contextual, this.fallback = !!r.fallback, this.extend = !!r.extend;
  }
}
function a2(t, e, r, n, i, s) {
  let o = 0, a = 1 << n, { dialect: l } = r.p.parser;
  e:
    for (; a & t[o]; ) {
      let c = t[o + 1];
      for (let h = o + 3; h < c; h += 2)
        if ((t[h + 1] & a) > 0) {
          let p = t[h];
          if (l.allows(p) && (e.token.value == -1 || e.token.value == p || z7(p, e.token.value, i, s))) {
            e.acceptToken(p);
            break;
          }
        }
      let u = e.next, d = 0, f = t[o + 2];
      if (e.next < 0 && f > d && t[c + f * 3 - 3] == 65535) {
        o = t[c + f * 3 - 1];
        continue e;
      }
      for (; d < f; ) {
        let h = d + f >> 1, p = c + h + (h << 1), g = t[p], m = t[p + 1] || 65536;
        if (u < g)
          f = h;
        else if (u >= m)
          d = h + 1;
        else {
          o = t[p + 2], e.advance();
          continue e;
        }
      }
      break;
    }
}
function KO(t, e, r) {
  for (let n = e, i; (i = t[n]) != 65535; n++)
    if (i == r)
      return n - e;
  return -1;
}
function z7(t, e, r, n) {
  let i = KO(r, n, e);
  return i < 0 || KO(r, n, t) < i;
}
const ar = typeof process < "u" && process.env && /\bparse\b/.test(process.env.LOG);
let nf = null;
function JO(t, e, r) {
  let n = t.cursor(Be.IncludeAnonymous);
  for (n.moveTo(e); ; )
    if (!(r < 0 ? n.childBefore(e) : n.childAfter(e)))
      for (; ; ) {
        if ((r < 0 ? n.to < e : n.from > e) && !n.type.isError)
          return r < 0 ? Math.max(0, Math.min(
            n.to - 1,
            e - 25
            /* Safety.Margin */
          )) : Math.min(t.length, Math.max(
            n.from + 1,
            e + 25
            /* Safety.Margin */
          ));
        if (r < 0 ? n.prevSibling() : n.nextSibling())
          break;
        if (!n.parent())
          return r < 0 ? 0 : t.length;
      }
}
class X7 {
  constructor(e, r) {
    this.fragments = e, this.nodeSet = r, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e) {
      for (this.safeFrom = e.openStart ? JO(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? JO(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(e) {
    if (e < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let r = this.trees.length - 1;
      if (r < 0)
        return this.nextFragment(), null;
      let n = this.trees[r], i = this.index[r];
      if (i == n.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let s = n.children[i], o = this.start[r] + n.positions[i];
      if (o > e)
        return this.nextStart = o, null;
      if (s instanceof it) {
        if (o == e) {
          if (o < this.safeFrom)
            return null;
          let a = o + s.length;
          if (a <= this.safeTo) {
            let l = s.prop(Ie.lookAhead);
            if (!l || a + l < this.fragment.to)
              return s;
          }
        }
        this.index[r]++, o + s.length >= Math.max(this.safeFrom, e) && (this.trees.push(s), this.start.push(o), this.index.push(0));
      } else
        this.index[r]++, this.nextStart = o + s.length;
    }
  }
}
class W7 {
  constructor(e, r) {
    this.stream = r, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((n) => new Ic());
  }
  getActions(e) {
    let r = 0, n = null, { parser: i } = e.p, { tokenizers: s } = i, o = i.stateSlot(
      e.state,
      3
      /* ParseState.TokenizerMask */
    ), a = e.curContext ? e.curContext.hash : 0, l = 0;
    for (let c = 0; c < s.length; c++) {
      if (!(1 << c & o))
        continue;
      let u = s[c], d = this.tokens[c];
      if (!(n && !u.fallback) && ((u.contextual || d.start != e.pos || d.mask != o || d.context != a) && (this.updateCachedToken(d, u, e), d.mask = o, d.context = a), d.lookAhead > d.end + 25 && (l = Math.max(d.lookAhead, l)), d.value != 0)) {
        let f = r;
        if (d.extended > -1 && (r = this.addActions(e, d.extended, d.end, r)), r = this.addActions(e, d.value, d.end, r), !u.extend && (n = d, r > f))
          break;
      }
    }
    for (; this.actions.length > r; )
      this.actions.pop();
    return l && e.setLookAhead(l), !n && e.pos == this.stream.end && (n = new Ic(), n.value = e.p.parser.eofTerm, n.start = n.end = e.pos, r = this.addActions(e, n.value, n.end, r)), this.mainToken = n, this.actions;
  }
  getMainToken(e) {
    if (this.mainToken)
      return this.mainToken;
    let r = new Ic(), { pos: n, p: i } = e;
    return r.start = n, r.end = Math.min(n + 1, i.stream.end), r.value = n == i.stream.end ? i.parser.eofTerm : 0, r;
  }
  updateCachedToken(e, r, n) {
    let i = this.stream.clipPos(n.pos);
    if (r.token(this.stream.reset(i, e), n), e.value > -1) {
      let { parser: s } = n.p;
      for (let o = 0; o < s.specialized.length; o++)
        if (s.specialized[o] == e.value) {
          let a = s.specializers[o](this.stream.read(e.start, e.end), n);
          if (a >= 0 && n.p.parser.dialect.allows(a >> 1)) {
            a & 1 ? e.extended = a >> 1 : e.value = a >> 1;
            break;
          }
        }
    } else
      e.value = 0, e.end = this.stream.clipPos(i + 1);
  }
  putAction(e, r, n, i) {
    for (let s = 0; s < i; s += 3)
      if (this.actions[s] == e)
        return i;
    return this.actions[i++] = e, this.actions[i++] = r, this.actions[i++] = n, i;
  }
  addActions(e, r, n, i) {
    let { state: s } = e, { parser: o } = e.p, { data: a } = o;
    for (let l = 0; l < 2; l++)
      for (let c = o.stateSlot(
        s,
        l ? 2 : 1
        /* ParseState.Actions */
      ); ; c += 3) {
        if (a[c] == 65535)
          if (a[c + 1] == 1)
            c = Tn(a, c + 2);
          else {
            i == 0 && a[c + 1] == 2 && (i = this.putAction(Tn(a, c + 2), r, n, i));
            break;
          }
        a[c] == r && (i = this.putAction(Tn(a, c + 1), r, n, i));
      }
    return i;
  }
}
class U7 {
  constructor(e, r, n, i) {
    this.parser = e, this.input = r, this.ranges = i, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new D7(r, i), this.tokens = new W7(e, this.stream), this.topTerm = e.top[1];
    let { from: s } = i[0];
    this.stacks = [lu.start(this, e.top[0], s)], this.fragments = n.length && this.stream.end - s > e.bufferLength * 4 ? new X7(n, e.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let e = this.stacks, r = this.minStackPos, n = this.stacks = [], i, s;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [o] = e;
      for (; o.forceReduce() && o.stack.length && o.stack[o.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let o = 0; o < e.length; o++) {
      let a = e[o];
      for (; ; ) {
        if (this.tokens.mainToken = null, a.pos > r)
          n.push(a);
        else {
          if (this.advanceStack(a, n, e))
            continue;
          {
            i || (i = [], s = []), i.push(a);
            let l = this.tokens.getMainToken(a);
            s.push(l.value, l.end);
          }
        }
        break;
      }
    }
    if (!n.length) {
      let o = i && L7(i);
      if (o)
        return ar && console.log("Finish with " + this.stackID(o)), this.stackToTree(o);
      if (this.parser.strict)
        throw ar && i && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + r);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && i) {
      let o = this.stoppedAt != null && i[0].pos > this.stoppedAt ? i[0] : this.runRecovery(i, s, n);
      if (o)
        return ar && console.log("Force-finish " + this.stackID(o)), this.stackToTree(o.forceAll());
    }
    if (this.recovering) {
      let o = this.recovering == 1 ? 1 : this.recovering * 3;
      if (n.length > o)
        for (n.sort((a, l) => l.score - a.score); n.length > o; )
          n.pop();
      n.some((a) => a.reducePos > r) && this.recovering--;
    } else if (n.length > 1) {
      e:
        for (let o = 0; o < n.length - 1; o++) {
          let a = n[o];
          for (let l = o + 1; l < n.length; l++) {
            let c = n[l];
            if (a.sameState(c) || a.buffer.length > 500 && c.buffer.length > 500)
              if ((a.score - c.score || a.buffer.length - c.buffer.length) > 0)
                n.splice(l--, 1);
              else {
                n.splice(o--, 1);
                continue e;
              }
          }
        }
      n.length > 12 && n.splice(
        12,
        n.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = n[0].pos;
    for (let o = 1; o < n.length; o++)
      n[o].pos < this.minStackPos && (this.minStackPos = n[o].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(e, r, n) {
    let i = e.pos, { parser: s } = this, o = ar ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && i > this.stoppedAt)
      return e.forceReduce() ? e : null;
    if (this.fragments) {
      let c = e.curContext && e.curContext.tracker.strict, u = c ? e.curContext.hash : 0;
      for (let d = this.fragments.nodeAt(i); d; ) {
        let f = this.parser.nodeSet.types[d.type.id] == d.type ? s.getGoto(e.state, d.type.id) : -1;
        if (f > -1 && d.length && (!c || (d.prop(Ie.contextHash) || 0) == u))
          return e.useNode(d, f), ar && console.log(o + this.stackID(e) + ` (via reuse of ${s.getName(d.type.id)})`), !0;
        if (!(d instanceof it) || d.children.length == 0 || d.positions[0] > 0)
          break;
        let h = d.children[0];
        if (h instanceof it && d.positions[0] == 0)
          d = h;
        else
          break;
      }
    }
    let a = s.stateSlot(
      e.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (a > 0)
      return e.reduce(a), ar && console.log(o + this.stackID(e) + ` (via always-reduce ${s.getName(
        a & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (e.stack.length >= 8400)
      for (; e.stack.length > 6e3 && e.forceReduce(); )
        ;
    let l = this.tokens.getActions(e);
    for (let c = 0; c < l.length; ) {
      let u = l[c++], d = l[c++], f = l[c++], h = c == l.length || !n, p = h ? e : e.split(), g = this.tokens.mainToken;
      if (p.apply(u, d, g ? g.start : p.pos, f), ar && console.log(o + this.stackID(p) + ` (via ${u & 65536 ? `reduce of ${s.getName(
        u & 65535
        /* Action.ValueMask */
      )}` : "shift"} for ${s.getName(d)} @ ${i}${p == e ? "" : ", split"})`), h)
        return !0;
      p.pos > i ? r.push(p) : n.push(p);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(e, r) {
    let n = e.pos;
    for (; ; ) {
      if (!this.advanceStack(e, null, null))
        return !1;
      if (e.pos > n)
        return e1(e, r), !0;
    }
  }
  runRecovery(e, r, n) {
    let i = null, s = !1;
    for (let o = 0; o < e.length; o++) {
      let a = e[o], l = r[o << 1], c = r[(o << 1) + 1], u = ar ? this.stackID(a) + " -> " : "";
      if (a.deadEnd && (s || (s = !0, a.restart(), ar && console.log(u + this.stackID(a) + " (restarted)"), this.advanceFully(a, n))))
        continue;
      let d = a.split(), f = u;
      for (let h = 0; d.forceReduce() && h < 10 && (ar && console.log(f + this.stackID(d) + " (via force-reduce)"), !this.advanceFully(d, n)); h++)
        ar && (f = this.stackID(d) + " -> ");
      for (let h of a.recoverByInsert(l))
        ar && console.log(u + this.stackID(h) + " (via recover-insert)"), this.advanceFully(h, n);
      this.stream.end > a.pos ? (c == a.pos && (c++, l = 0), a.recoverByDelete(l, c), ar && console.log(u + this.stackID(a) + ` (via recover-delete ${this.parser.getName(l)})`), e1(a, n)) : (!i || i.score < a.score) && (i = a);
    }
    return i;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(e) {
    return e.close(), it.build({
      buffer: cu.create(e),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e) {
    let r = (nf || (nf = /* @__PURE__ */ new WeakMap())).get(e);
    return r || nf.set(e, r = String.fromCodePoint(this.nextStackID++)), r + e;
  }
}
function e1(t, e) {
  for (let r = 0; r < e.length; r++) {
    let n = e[r];
    if (n.pos == t.pos && n.sameState(t)) {
      e[r].score < t.score && (e[r] = t);
      return;
    }
  }
  e.push(t);
}
class V7 {
  constructor(e, r, n) {
    this.source = e, this.flags = r, this.disabled = n;
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
const sf = (t) => t;
class vm {
  /**
  Define a context tracker.
  */
  constructor(e) {
    this.start = e.start, this.shift = e.shift || sf, this.reduce = e.reduce || sf, this.reuse = e.reuse || sf, this.hash = e.hash || (() => 0), this.strict = e.strict !== !1;
  }
}
class Si extends Ew {
  /**
  @internal
  */
  constructor(e) {
    if (super(), this.wrappers = [], e.version != 14)
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
    let r = e.nodeNames.split(" ");
    this.minRepeatTerm = r.length;
    for (let a = 0; a < e.repeatNodeCount; a++)
      r.push("");
    let n = Object.keys(e.topRules).map((a) => e.topRules[a][1]), i = [];
    for (let a = 0; a < r.length; a++)
      i.push([]);
    function s(a, l, c) {
      i[a].push([l, l.deserialize(String(c))]);
    }
    if (e.nodeProps)
      for (let a of e.nodeProps) {
        let l = a[0];
        typeof l == "string" && (l = Ie[l]);
        for (let c = 1; c < a.length; ) {
          let u = a[c++];
          if (u >= 0)
            s(u, l, a[c++]);
          else {
            let d = a[c + -u];
            for (let f = -u; f > 0; f--)
              s(a[c++], l, d);
            c++;
          }
        }
      }
    this.nodeSet = new cm(r.map((a, l) => Gt.define({
      name: l >= this.minRepeatTerm ? void 0 : a,
      id: l,
      props: i[l],
      top: n.indexOf(l) > -1,
      error: l == 0,
      skipped: e.skippedNodes && e.skippedNodes.indexOf(l) > -1
    }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = !1, this.bufferLength = xw;
    let o = ka(e.tokenData);
    this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let a = 0; a < this.specializerSpecs.length; a++)
      this.specialized[a] = this.specializerSpecs[a].term;
    this.specializers = this.specializerSpecs.map(t1), this.states = ka(e.states, Uint32Array), this.data = ka(e.stateData), this.goto = ka(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((a) => typeof a == "number" ? new no(o, a) : a), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e, r, n) {
    let i = new U7(this, e, r, n);
    for (let s of this.wrappers)
      i = s(i, e, r, n);
    return i;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(e, r, n = !1) {
    let i = this.goto;
    if (r >= i[0])
      return -1;
    for (let s = i[r + 1]; ; ) {
      let o = i[s++], a = o & 1, l = i[s++];
      if (a && n)
        return l;
      for (let c = s + (o >> 1); s < c; s++)
        if (i[s] == e)
          return l;
      if (a)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(e, r) {
    let n = this.data;
    for (let i = 0; i < 2; i++)
      for (let s = this.stateSlot(
        e,
        i ? 2 : 1
        /* ParseState.Actions */
      ), o; ; s += 3) {
        if ((o = n[s]) == 65535)
          if (n[s + 1] == 1)
            o = n[s = Tn(n, s + 2)];
          else {
            if (n[s + 1] == 2)
              return Tn(n, s + 2);
            break;
          }
        if (o == r || o == 0)
          return Tn(n, s + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(e, r) {
    return this.states[e * 6 + r];
  }
  /**
  @internal
  */
  stateFlag(e, r) {
    return (this.stateSlot(
      e,
      0
      /* ParseState.Flags */
    ) & r) > 0;
  }
  /**
  @internal
  */
  validAction(e, r) {
    return !!this.allActions(e, (n) => n == r ? !0 : null);
  }
  /**
  @internal
  */
  allActions(e, r) {
    let n = this.stateSlot(
      e,
      4
      /* ParseState.DefaultReduce */
    ), i = n ? r(n) : void 0;
    for (let s = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); i == null; s += 3) {
      if (this.data[s] == 65535)
        if (this.data[s + 1] == 1)
          s = Tn(this.data, s + 2);
        else
          break;
      i = r(Tn(this.data, s + 1));
    }
    return i;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(e) {
    let r = [];
    for (let n = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; n += 3) {
      if (this.data[n] == 65535)
        if (this.data[n + 1] == 1)
          n = Tn(this.data, n + 2);
        else
          break;
      if (!(this.data[n + 2] & 1)) {
        let i = this.data[n + 1];
        r.some((s, o) => o & 1 && s == i) || r.push(this.data[n], i);
      }
    }
    return r;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(e) {
    let r = Object.assign(Object.create(Si.prototype), this);
    if (e.props && (r.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
      let n = this.topRules[e.top];
      if (!n)
        throw new RangeError(`Invalid top rule name ${e.top}`);
      r.top = n;
    }
    return e.tokenizers && (r.tokenizers = this.tokenizers.map((n) => {
      let i = e.tokenizers.find((s) => s.from == n);
      return i ? i.to : n;
    })), e.specializers && (r.specializers = this.specializers.slice(), r.specializerSpecs = this.specializerSpecs.map((n, i) => {
      let s = e.specializers.find((a) => a.from == n.external);
      if (!s)
        return n;
      let o = Object.assign(Object.assign({}, n), { external: s.to });
      return r.specializers[i] = t1(o), o;
    })), e.contextTracker && (r.context = e.contextTracker), e.dialect && (r.dialect = this.parseDialect(e.dialect)), e.strict != null && (r.strict = e.strict), e.wrap && (r.wrappers = r.wrappers.concat(e.wrap)), e.bufferLength != null && (r.bufferLength = e.bufferLength), r;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(e) {
    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(e) {
    let r = this.dynamicPrecedences;
    return r == null ? 0 : r[e] || 0;
  }
  /**
  @internal
  */
  parseDialect(e) {
    let r = Object.keys(this.dialects), n = r.map(() => !1);
    if (e)
      for (let s of e.split(" ")) {
        let o = r.indexOf(s);
        o >= 0 && (n[o] = !0);
      }
    let i = null;
    for (let s = 0; s < r.length; s++)
      if (!n[s])
        for (let o = this.dialects[r[s]], a; (a = this.data[o++]) != 65535; )
          (i || (i = new Uint8Array(this.maxTerm + 1)))[a] = 1;
    return new V7(e, n, i);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(e) {
    return new Si(e);
  }
}
function Tn(t, e) {
  return t[e] | t[e + 1] << 16;
}
function L7(t) {
  let e = null;
  for (let r of t) {
    let n = r.p.stoppedAt;
    (r.pos == r.p.stream.end || n != null && r.pos > n) && r.p.parser.stateFlag(
      r.state,
      2
      /* StateFlag.Accepting */
    ) && (!e || e.score < r.score) && (e = r);
  }
  return e;
}
function t1(t) {
  if (t.external) {
    let e = t.extend ? 1 : 0;
    return (r, n) => t.external(r, n) << 1 | e;
  }
  return t.get;
}
const Y7 = 99, r1 = 1, B7 = 100, F7 = 101, n1 = 2, l2 = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], H7 = 58, G7 = 40, c2 = 95, K7 = 91, jc = 45, J7 = 46, e8 = 35, t8 = 37, r8 = 38, n8 = 92, i8 = 10;
function il(t) {
  return t >= 65 && t <= 90 || t >= 97 && t <= 122 || t >= 161;
}
function u2(t) {
  return t >= 48 && t <= 57;
}
const s8 = new Kt((t, e) => {
  for (let r = !1, n = 0, i = 0; ; i++) {
    let { next: s } = t;
    if (il(s) || s == jc || s == c2 || r && u2(s))
      !r && (s != jc || i > 0) && (r = !0), n === i && s == jc && n++, t.advance();
    else if (s == n8 && t.peek(1) != i8)
      t.advance(), t.next > -1 && t.advance(), r = !0;
    else {
      r && t.acceptToken(s == G7 ? B7 : n == 2 && e.canShift(n1) ? n1 : F7);
      break;
    }
  }
}), o8 = new Kt((t) => {
  if (l2.includes(t.peek(-1))) {
    let { next: e } = t;
    (il(e) || e == c2 || e == e8 || e == J7 || e == K7 || e == H7 && il(t.peek(1)) || e == jc || e == r8) && t.acceptToken(Y7);
  }
}), a8 = new Kt((t) => {
  if (!l2.includes(t.peek(-1))) {
    let { next: e } = t;
    if (e == t8 && (t.advance(), t.acceptToken(r1)), il(e)) {
      do
        t.advance();
      while (il(t.next) || u2(t.next));
      t.acceptToken(r1);
    }
  }
}), l8 = Io({
  "AtKeyword import charset namespace keyframes media supports": E.definitionKeyword,
  "from to selector": E.keyword,
  NamespaceName: E.namespace,
  KeyframeName: E.labelName,
  KeyframeRangeName: E.operatorKeyword,
  TagName: E.tagName,
  ClassName: E.className,
  PseudoClassName: E.constant(E.className),
  IdName: E.labelName,
  "FeatureName PropertyName": E.propertyName,
  AttributeName: E.attributeName,
  NumberLiteral: E.number,
  KeywordQuery: E.keyword,
  UnaryQueryOp: E.operatorKeyword,
  "CallTag ValueName": E.atom,
  VariableName: E.variableName,
  Callee: E.operatorKeyword,
  Unit: E.unit,
  "UniversalSelector NestingSelector": E.definitionOperator,
  MatchOp: E.compareOperator,
  "ChildOp SiblingOp, LogicOp": E.logicOperator,
  BinOp: E.arithmeticOperator,
  Important: E.modifier,
  Comment: E.blockComment,
  ColorLiteral: E.color,
  "ParenthesizedContent StringLiteral": E.string,
  ":": E.punctuation,
  "PseudoOp #": E.derefOperator,
  "; ,": E.separator,
  "( )": E.paren,
  "[ ]": E.squareBracket,
  "{ }": E.brace
}), c8 = { __proto__: null, lang: 32, "nth-child": 32, "nth-last-child": 32, "nth-of-type": 32, "nth-last-of-type": 32, dir: 32, "host-context": 32, url: 60, "url-prefix": 60, domain: 60, regexp: 60, selector: 138 }, u8 = { __proto__: null, "@import": 118, "@media": 142, "@charset": 146, "@namespace": 150, "@keyframes": 156, "@supports": 168 }, d8 = { __proto__: null, not: 132, only: 132 }, f8 = Si.deserialize({
  version: 14,
  states: ":^QYQ[OOO#_Q[OOP#fOWOOOOQP'#Cd'#CdOOQP'#Cc'#CcO#kQ[O'#CfO$_QXO'#CaO$fQ[O'#ChO$qQ[O'#DTO$vQ[O'#DWOOQP'#Em'#EmO${QdO'#DgO%jQ[O'#DtO${QdO'#DvO%{Q[O'#DxO&WQ[O'#D{O&`Q[O'#ERO&nQ[O'#ETOOQS'#El'#ElOOQS'#EW'#EWQYQ[OOO&uQXO'#CdO'jQWO'#DcO'oQWO'#EsO'zQ[O'#EsQOQWOOP(UO#tO'#C_POOO)C@[)C@[OOQP'#Cg'#CgOOQP,59Q,59QO#kQ[O,59QO(aQ[O'#E[O({QWO,58{O)TQ[O,59SO$qQ[O,59oO$vQ[O,59rO(aQ[O,59uO(aQ[O,59wO(aQ[O,59xO)`Q[O'#DbOOQS,58{,58{OOQP'#Ck'#CkOOQO'#DR'#DROOQP,59S,59SO)gQWO,59SO)lQWO,59SOOQP'#DV'#DVOOQP,59o,59oOOQO'#DX'#DXO)qQ`O,59rOOQS'#Cp'#CpO${QdO'#CqO)yQvO'#CsO+ZQtO,5:ROOQO'#Cx'#CxO)lQWO'#CwO+oQWO'#CyO+tQ[O'#DOOOQS'#Ep'#EpOOQO'#Dj'#DjO+|Q[O'#DqO,[QWO'#EtO&`Q[O'#DoO,jQWO'#DrOOQO'#Eu'#EuO)OQWO,5:`O,oQpO,5:bOOQS'#Dz'#DzO,wQWO,5:dO,|Q[O,5:dOOQO'#D}'#D}O-UQWO,5:gO-ZQWO,5:mO-cQWO,5:oOOQS-E8U-E8UO${QdO,59}O-kQ[O'#E^O-xQWO,5;_O-xQWO,5;_POOO'#EV'#EVP.TO#tO,58yPOOO,58y,58yOOQP1G.l1G.lO.zQXO,5:vOOQO-E8Y-E8YOOQS1G.g1G.gOOQP1G.n1G.nO)gQWO1G.nO)lQWO1G.nOOQP1G/Z1G/ZO/XQ`O1G/^O/rQXO1G/aO0YQXO1G/cO0pQXO1G/dO1WQWO,59|O1]Q[O'#DSO1dQdO'#CoOOQP1G/^1G/^O${QdO1G/^O1kQpO,59]OOQS,59_,59_O${QdO,59aO1sQWO1G/mOOQS,59c,59cO1xQ!bO,59eOOQS'#DP'#DPOOQS'#EY'#EYO2QQ[O,59jOOQS,59j,59jO2YQWO'#DjO2eQWO,5:VO2jQWO,5:]O&`Q[O,5:XO&`Q[O'#E_O2rQWO,5;`O2}QWO,5:ZO(aQ[O,5:^OOQS1G/z1G/zOOQS1G/|1G/|OOQS1G0O1G0OO3`QWO1G0OO3eQdO'#EOOOQS1G0R1G0ROOQS1G0X1G0XOOQS1G0Z1G0ZO3pQtO1G/iOOQO,5:x,5:xO4WQ[O,5:xOOQO-E8[-E8[O4eQWO1G0yPOOO-E8T-E8TPOOO1G.e1G.eOOQP7+$Y7+$YOOQP7+$x7+$xO${QdO7+$xOOQS1G/h1G/hO4pQXO'#ErO4wQWO,59nO4|QtO'#EXO5tQdO'#EoO6OQWO,59ZO6TQpO7+$xOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%X7+%XO6]QWO1G/POOQS-E8W-E8WOOQS1G/U1G/UO${QdO1G/qOOQO1G/w1G/wOOQO1G/s1G/sO6bQWO,5:yOOQO-E8]-E8]O6pQXO1G/xOOQS7+%j7+%jO6wQYO'#CsOOQO'#EQ'#EQO7SQ`O'#EPOOQO'#EP'#EPO7_QWO'#E`O7gQdO,5:jOOQS,5:j,5:jO7rQtO'#E]O${QdO'#E]O8sQdO7+%TOOQO7+%T7+%TOOQO1G0d1G0dO9WQpO<<HdO9`QWO,5;^OOQP1G/Y1G/YOOQS-E8V-E8VO${QdO'#EZO9hQWO,5;ZOOQT1G.u1G.uOOQP<<Hd<<HdOOQS7+$k7+$kO9pQdO7+%]OOQO7+%d7+%dOOQO,5:k,5:kO3hQdO'#EaO7_QWO,5:zOOQS,5:z,5:zOOQS-E8^-E8^OOQS1G0U1G0UO9wQtO,5:wOOQS-E8Z-E8ZOOQO<<Ho<<HoOOQPAN>OAN>OO:xQdO,5:uOOQO-E8X-E8XOOQO<<Hw<<HwOOQO,5:{,5:{OOQO-E8_-E8_OOQS1G0f1G0f",
  stateData: ";[~O#ZOS#[QQ~OUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XRO#bTO~OQfOUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XeO#bTO~O#U#gP~P!ZO#[jO~O#XlO~O]qO^qOqsOtoOxrO!OtO!RvO#VuO#bnO~O!TwO~P#pO`}O#WzO#XyO~O#X!OO~O#X!QO~OQ![Ob!TOf![Oh![On!YOq!ZO#W!WO#X!SO#e!UO~Ob!^O!d!`O!g!aO#X!]O!T#hP~Oh!fOn!YO#X!eO~Oh!hO#X!hO~Ob!^O!d!`O!g!aO#X!]O~O!Y#hP~P%jO]WX]!WX^WXqWXtWXxWX!OWX!RWX!TWX#VWX#bWX~O]!mO~O!Y!nO#U#gX!S#gX~O#U#gX!S#gX~P!ZO#]!qO#^!qO#_!sO~OUYOXYO]VO^VOqXOxWO#XRO#bTO~OtoO!TwO~O`!zO#WzO#XyO~O!S#gP~P!ZOb#RO~Ob#SO~Op#TO|#UO~OP#WObgXjgX!YgX!dgX!ggX#XgXagXQgXfgXhgXngXqgXtgX!XgX#UgX#WgX#egXpgX!SgX~Ob!^Oj#XO!d!`O!g!aO#X!]O!Y#hP~Ob#[O~Op#`O#X#]O~Ob!^O!d!`O!g!aO#X#aO~Ot#eO!b#dO!T#hX!Y#hX~Ob#hO~Oj#XO!Y#jO~O!Y#kO~Oh#lOn!YO~O!T#mO~O!TwO!b#dO~O!TwO!Y#pO~O!Y#QX#U#QX!S#QX~P!ZO!Y!nO#U#ga!S#ga~O#]!qO#^!qO#_#wO~O]qO^qOqsOxrO!OtO!RvO#VuO#bnO~Ot#Oa!T#Oaa#Oa~P.`Op#yO|#zO~O]qO^qOqsOxrO#bnO~Ot}i!O}i!R}i!T}i#V}ia}i~P/aOt!Pi!O!Pi!R!Pi!T!Pi#V!Pia!Pi~P/aOt!Qi!O!Qi!R!Qi!T!Qi#V!Qia!Qi~P/aO!S#{O~Oa#fP~P(aOa#cP~P${Oa$SOj#XO~O!Y$UO~Oh$VOo$VO~Op$XO#X#]O~O]!`Xa!^X!b!^X~O]$YO~Oa$ZO!b#dO~Ot#eO!T#ha!Y#ha~O!b#dOt!ca!T!ca!Y!caa!ca~O!Y$`O~O!S$gO#X$bO#e$aO~Oj#XOt$iO!X$kO!Y!Vi#U!Vi!S!Vi~P${O!Y#Qa#U#Qa!S#Qa~P!ZO!Y!nO#U#gi!S#gi~Oa#fX~P#pOa$oO~Oj#XOQ!{Xa!{Xb!{Xf!{Xh!{Xn!{Xq!{Xt!{X#W!{X#X!{X#e!{X~Ot$qOa#cX~P${Oa$sO~Oj#XOp$tO~Oa$uO~O!b#dOt#Ra!T#Ra!Y#Ra~Oa$wO~P.`OP#WOtgX!TgX~O#e$aOt!sX!T!sX~Ot$yO!TwO~O!S$}O#X$bO#e$aO~Oj#XOQ#PXb#PXf#PXh#PXn#PXq#PXt#PX!X#PX!Y#PX#U#PX#W#PX#X#PX#e#PX!S#PX~Ot$iO!X%QO!Y!Vq#U!Vq!S!Vq~P${Oj#XOp%RO~OtoOa#fa~Ot$qOa#ca~Oa%UO~P${Oj#XOQ#Pab#Paf#Pah#Pan#Paq#Pat#Pa!X#Pa!Y#Pa#U#Pa#W#Pa#X#Pa#e#Pa!S#Pa~Oa!}at!}a~P${O#Zo#[#ej!R#e~",
  goto: "-g#jPPP#kP#nP#w$WP#w$g#wPP$mPPP$s$|$|P%`P$|P$|%z&^PPPP$|&vP&z'Q#wP'W#w'^P#wP#w#wPPP'd'y(WPP#nPP(_(_(i(_P(_P(_(_P#nP#nP#nP(l#nP(o(r(u(|#nP#nP)R)X)h)v)|*S*^*d*n*t*zPPPPPPPPPP+Q+ZP+v+yP,o,r,x-RRkQ_bOPdhw!n#skYOPdhotuvw!n#R#h#skSOPdhotuvw!n#R#h#sQmTR!tnQ{VR!xqQ!x}Q#Z!XR#x!zq![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%Sp![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%SU$d#m$f$yR$x$cq!XZ]!T!m#S#U#X#q#z$P$Y$i$j$q$v%Sp![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%SQ!f^R#l!gT#^!Z#_Q|VR!yqQ!x|R#x!yQ!PWR!{rQ!RXR!|sQxUQ!wpQ#i!cQ#o!jQ#p!kQ${$eR%X$zSgPwQ!phQ#r!nR$l#sZfPhw!n#sa!b[`a!V!^!`#d#eR#b!^R!g^R!i_R#n!iS$e#m$fR%V$yV$c#m$f$yQ!rjR#v!rQdOShPwU!ldh#sR#s!nQ$P#SU$p$P$v%SQ$v$YR%S$qQ#_!ZR$W#_Q$r$PR%T$rQpUS!vp$nR$n#|Q$j#qR%P$jQ!ogS#t!o#uR#u!pQ#f!_R$^#fQ$f#mR$|$fQ$z$eR%W$z_cOPdhw!n#s^UOPdhw!n#sQ!uoQ!}tQ#OuQ#PvQ#|#RR$_#hR$Q#SQ!VZQ!d]Q#V!TQ#q!m[$O#S$P$Y$q$v%SQ$R#UQ$T#XS$h#q$jQ$m#zR%O$iR#}#RQiPR#QwQ!c[Q!kaR#Y!VU!_[a!VQ!j`Q#c!^Q#g!`Q$[#dR$]#e",
  nodeNames: "âš  Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent ] [ LineNames LineName , PseudoClassName ArgList IdSelector # IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles",
  maxTerm: 117,
  nodeProps: [
    ["isolate", -2, 3, 24, ""],
    ["openedBy", 17, "(", 32, "[", 50, "{"],
    ["closedBy", 18, ")", 33, "]", 51, "}"]
  ],
  propSources: [l8],
  skippedNodes: [0, 3, 87],
  repeatNodeCount: 11,
  tokenData: "J^~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Ab![!]B]!]!^CX!^!_$}!_!`Cj!`!aC{!a!b$}!b!cDw!c!}$}!}#OFa#O#P$}#P#QFr#Q#R6d#R#T$}#T#UGT#U#c$}#c#dHf#d#o$}#o#pH{#p#q6d#q#rI^#r#sIo#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`JW<%lO$}`%QSOy%^z;'S%^;'S;=`%o<%lO%^`%cSo`Oy%^z;'S%^;'S;=`%o<%lO%^`%rP;=`<%l%^~%zh#Z~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#Z~o`OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^l)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^l)sUo`Oy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^l*[Uo`Oy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^l*sUo`Oy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^l+[Uo`Oy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^l+sUo`Oy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^l,[Uo`Oy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^l,sUo`Oy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^l-[Uo`Oy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^l-uS!X[o`Oy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.Rn/zYxQOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^l0oYo`Oy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^l1dYo`Oy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^l2ZYf[o`Oy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^l3QYf[o`Oy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^l3uYo`Oy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^l4lYf[o`Oy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^l5aYo`Oy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^l6WSf[o`Oy%^z;'S%^;'S;=`%o<%lO%^d6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^d7QS|So`Oy%^z;'S%^;'S;=`%o<%lO%^b7cSXQOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7on9cSb^Oy%^z;'S%^;'S;=`%o<%lO%^~9tOa~n9{UUQjWOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^n:fWjW!RQOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^l;TUo`Oy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^l;nYo`#e[Oy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^l<cYo`Oy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=WUo`Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=qUo`#e[Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l>[[o`#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^n?VSt^Oy%^z;'S%^;'S;=`%o<%lO%^l?hWjWOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^n@VU#bQOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjWOy%^z{@}{;'S%^;'S;=`%o<%lO%^~AUSo`#[~Oy%^z;'S%^;'S;=`%o<%lO%^lAg[#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^bBbU]QOy%^z![%^![!]Bt!];'S%^;'S;=`%o<%lO%^bB{S^Qo`Oy%^z;'S%^;'S;=`%o<%lO%^nC^S!Y^Oy%^z;'S%^;'S;=`%o<%lO%^dCoS|SOy%^z;'S%^;'S;=`%o<%lO%^bDQU!OQOy%^z!`%^!`!aDd!a;'S%^;'S;=`%o<%lO%^bDkS!OQo`Oy%^z;'S%^;'S;=`%o<%lO%^bDzWOy%^z!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bEk[![Qo`Oy%^z}%^}!OEd!O!Q%^!Q![Ed![!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^nFfSq^Oy%^z;'S%^;'S;=`%o<%lO%^nFwSp^Oy%^z;'S%^;'S;=`%o<%lO%^bGWUOy%^z#b%^#b#cGj#c;'S%^;'S;=`%o<%lO%^bGoUo`Oy%^z#W%^#W#XHR#X;'S%^;'S;=`%o<%lO%^bHYS!bQo`Oy%^z;'S%^;'S;=`%o<%lO%^bHiUOy%^z#f%^#f#gHR#g;'S%^;'S;=`%o<%lO%^fIQS!TUOy%^z;'S%^;'S;=`%o<%lO%^nIcS!S^Oy%^z;'S%^;'S;=`%o<%lO%^fItU!RQOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^`JZP;=`<%l$}",
  tokenizers: [o8, a8, s8, 1, 2, 3, 4, new uu("m~RRYZ[z{a~~g~aO#^~~dP!P!Qg~lO#_~~", 28, 105)],
  topRules: { StyleSheet: [0, 4], Styles: [1, 86] },
  specialized: [{ term: 100, get: (t) => c8[t] || -1 }, { term: 58, get: (t) => u8[t] || -1 }, { term: 101, get: (t) => d8[t] || -1 }],
  tokenPrec: 1200
});
let of = null;
function af() {
  if (!of && typeof document == "object" && document.body) {
    let { style: t } = document.body, e = [], r = /* @__PURE__ */ new Set();
    for (let n in t)
      n != "cssText" && n != "cssFloat" && typeof t[n] == "string" && (/[A-Z]/.test(n) && (n = n.replace(/[A-Z]/g, (i) => "-" + i.toLowerCase())), r.has(n) || (e.push(n), r.add(n)));
    of = e.sort().map((n) => ({ type: "property", label: n }));
  }
  return of || [];
}
const i1 = /* @__PURE__ */ [
  "active",
  "after",
  "any-link",
  "autofill",
  "backdrop",
  "before",
  "checked",
  "cue",
  "default",
  "defined",
  "disabled",
  "empty",
  "enabled",
  "file-selector-button",
  "first",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "focus-visible",
  "focus-within",
  "fullscreen",
  "has",
  "host",
  "host-context",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "marker",
  "modal",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "part",
  "placeholder",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "selection",
  "slotted",
  "target",
  "target-text",
  "valid",
  "visited",
  "where"
].map((t) => ({ type: "class", label: t })), s1 = /* @__PURE__ */ [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((t) => ({ type: "keyword", label: t })).concat(/* @__PURE__ */ [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((t) => ({ type: "constant", label: t }))), h8 = /* @__PURE__ */ [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((t) => ({ type: "type", label: t })), Ln = /^(\w[\w-]*|-\w[\w-]*|)$/, p8 = /^-(-[\w-]*)?$/;
function m8(t, e) {
  var r;
  if ((t.name == "(" || t.type.isError) && (t = t.parent || t), t.name != "ArgList")
    return !1;
  let n = (r = t.parent) === null || r === void 0 ? void 0 : r.firstChild;
  return (n == null ? void 0 : n.name) != "Callee" ? !1 : e.sliceString(n.from, n.to) == "var";
}
const o1 = /* @__PURE__ */ new Aw(), g8 = ["Declaration"];
function O8(t) {
  for (let e = t; ; ) {
    if (e.type.isTop)
      return e;
    if (!(e = e.parent))
      return t;
  }
}
function d2(t, e, r) {
  if (e.to - e.from > 4096) {
    let n = o1.get(e);
    if (n)
      return n;
    let i = [], s = /* @__PURE__ */ new Set(), o = e.cursor(Be.IncludeAnonymous);
    if (o.firstChild())
      do
        for (let a of d2(t, o.node, r))
          s.has(a.label) || (s.add(a.label), i.push(a));
      while (o.nextSibling());
    return o1.set(e, i), i;
  } else {
    let n = [], i = /* @__PURE__ */ new Set();
    return e.cursor().iterate((s) => {
      var o;
      if (r(s) && s.matchContext(g8) && ((o = s.node.nextSibling) === null || o === void 0 ? void 0 : o.name) == ":") {
        let a = t.sliceString(s.from, s.to);
        i.has(a) || (i.add(a), n.push({ label: a, type: "variable" }));
      }
    }), n;
  }
}
const y8 = (t) => (e) => {
  let { state: r, pos: n } = e, i = Xt(r).resolveInner(n, -1), s = i.type.isError && i.from == i.to - 1 && r.doc.sliceString(i.from, i.to) == "-";
  if (i.name == "PropertyName" || (s || i.name == "TagName") && /^(Block|Styles)$/.test(i.resolve(i.to).name))
    return { from: i.from, options: af(), validFor: Ln };
  if (i.name == "ValueName")
    return { from: i.from, options: s1, validFor: Ln };
  if (i.name == "PseudoClassName")
    return { from: i.from, options: i1, validFor: Ln };
  if (t(i) || (e.explicit || s) && m8(i, r.doc))
    return {
      from: t(i) || s ? i.from : n,
      options: d2(r.doc, O8(i), t),
      validFor: p8
    };
  if (i.name == "TagName") {
    for (let { parent: l } = i; l; l = l.parent)
      if (l.name == "Block")
        return { from: i.from, options: af(), validFor: Ln };
    return { from: i.from, options: h8, validFor: Ln };
  }
  if (!e.explicit)
    return null;
  let o = i.resolve(n), a = o.childBefore(n);
  return a && a.name == ":" && o.name == "PseudoClassSelector" ? { from: n, options: i1, validFor: Ln } : a && a.name == ":" && o.name == "Declaration" || o.name == "ArgList" ? { from: n, options: s1, validFor: Ln } : o.name == "Block" || o.name == "Styles" ? { from: n, options: af(), validFor: Ln } : null;
}, b8 = /* @__PURE__ */ y8((t) => t.name == "VariableName"), du = /* @__PURE__ */ $i.define({
  name: "css",
  parser: /* @__PURE__ */ f8.configure({
    props: [
      /* @__PURE__ */ jo.add({
        Declaration: /* @__PURE__ */ to()
      }),
      /* @__PURE__ */ yl.add({
        "Block KeyframeList": Gu
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function f2() {
  return new Ol(du, du.data.of({ autocomplete: b8 }));
}
const v8 = 54, w8 = 1, $8 = 55, S8 = 2, k8 = 56, _8 = 3, a1 = 4, P8 = 5, fu = 6, h2 = 7, p2 = 8, m2 = 9, g2 = 10, x8 = 11, T8 = 12, C8 = 13, lf = 57, Q8 = 14, l1 = 58, O2 = 20, A8 = 22, y2 = 23, E8 = 24, Nh = 26, b2 = 27, R8 = 28, I8 = 31, j8 = 34, Z8 = 36, M8 = 37, q8 = 0, N8 = 1, D8 = {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  command: !0,
  embed: !0,
  frame: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0,
  menuitem: !0
}, z8 = {
  dd: !0,
  li: !0,
  optgroup: !0,
  option: !0,
  p: !0,
  rp: !0,
  rt: !0,
  tbody: !0,
  td: !0,
  tfoot: !0,
  th: !0,
  tr: !0
}, c1 = {
  dd: { dd: !0, dt: !0 },
  dt: { dd: !0, dt: !0 },
  li: { li: !0 },
  option: { option: !0, optgroup: !0 },
  optgroup: { optgroup: !0 },
  p: {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    dir: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    menu: !0,
    nav: !0,
    ol: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    ul: !0
  },
  rp: { rp: !0, rt: !0 },
  rt: { rp: !0, rt: !0 },
  tbody: { tbody: !0, tfoot: !0 },
  td: { td: !0, th: !0 },
  tfoot: { tbody: !0 },
  th: { td: !0, th: !0 },
  thead: { tbody: !0, tfoot: !0 },
  tr: { tr: !0 }
};
function X8(t) {
  return t == 45 || t == 46 || t == 58 || t >= 65 && t <= 90 || t == 95 || t >= 97 && t <= 122 || t >= 161;
}
function v2(t) {
  return t == 9 || t == 10 || t == 13 || t == 32;
}
let u1 = null, d1 = null, f1 = 0;
function Dh(t, e) {
  let r = t.pos + e;
  if (f1 == r && d1 == t)
    return u1;
  let n = t.peek(e);
  for (; v2(n); )
    n = t.peek(++e);
  let i = "";
  for (; X8(n); )
    i += String.fromCharCode(n), n = t.peek(++e);
  return d1 = t, f1 = r, u1 = i ? i.toLowerCase() : n == W8 || n == U8 ? void 0 : null;
}
const w2 = 60, hu = 62, wm = 47, W8 = 63, U8 = 33, V8 = 45;
function h1(t, e) {
  this.name = t, this.parent = e, this.hash = e ? e.hash : 0;
  for (let r = 0; r < t.length; r++)
    this.hash += (this.hash << 4) + t.charCodeAt(r) + (t.charCodeAt(r) << 8);
}
const L8 = [fu, g2, h2, p2, m2], Y8 = new vm({
  start: null,
  shift(t, e, r, n) {
    return L8.indexOf(e) > -1 ? new h1(Dh(n, 1) || "", t) : t;
  },
  reduce(t, e) {
    return e == O2 && t ? t.parent : t;
  },
  reuse(t, e, r, n) {
    let i = e.type.id;
    return i == fu || i == Z8 ? new h1(Dh(n, 1) || "", t) : t;
  },
  hash(t) {
    return t ? t.hash : 0;
  },
  strict: !1
}), B8 = new Kt((t, e) => {
  if (t.next != w2) {
    t.next < 0 && e.context && t.acceptToken(lf);
    return;
  }
  t.advance();
  let r = t.next == wm;
  r && t.advance();
  let n = Dh(t, 0);
  if (n === void 0)
    return;
  if (!n)
    return t.acceptToken(r ? Q8 : fu);
  let i = e.context ? e.context.name : null;
  if (r) {
    if (n == i)
      return t.acceptToken(x8);
    if (i && z8[i])
      return t.acceptToken(lf, -2);
    if (e.dialectEnabled(q8))
      return t.acceptToken(T8);
    for (let s = e.context; s; s = s.parent)
      if (s.name == n)
        return;
    t.acceptToken(C8);
  } else {
    if (n == "script")
      return t.acceptToken(h2);
    if (n == "style")
      return t.acceptToken(p2);
    if (n == "textarea")
      return t.acceptToken(m2);
    if (D8.hasOwnProperty(n))
      return t.acceptToken(g2);
    i && c1[i] && c1[i][n] ? t.acceptToken(lf, -1) : t.acceptToken(fu);
  }
}, { contextual: !0 }), F8 = new Kt((t) => {
  for (let e = 0, r = 0; ; r++) {
    if (t.next < 0) {
      r && t.acceptToken(l1);
      break;
    }
    if (t.next == V8)
      e++;
    else if (t.next == hu && e >= 2) {
      r >= 3 && t.acceptToken(l1, -2);
      break;
    } else
      e = 0;
    t.advance();
  }
});
function H8(t) {
  for (; t; t = t.parent)
    if (t.name == "svg" || t.name == "math")
      return !0;
  return !1;
}
const G8 = new Kt((t, e) => {
  if (t.next == wm && t.peek(1) == hu) {
    let r = e.dialectEnabled(N8) || H8(e.context);
    t.acceptToken(r ? P8 : a1, 2);
  } else
    t.next == hu && t.acceptToken(a1, 1);
});
function $m(t, e, r) {
  let n = 2 + t.length;
  return new Kt((i) => {
    for (let s = 0, o = 0, a = 0; ; a++) {
      if (i.next < 0) {
        a && i.acceptToken(e);
        break;
      }
      if (s == 0 && i.next == w2 || s == 1 && i.next == wm || s >= 2 && s < n && i.next == t.charCodeAt(s - 2))
        s++, o++;
      else if ((s == 2 || s == n) && v2(i.next))
        o++;
      else if (s == n && i.next == hu) {
        a > o ? i.acceptToken(e, -o) : i.acceptToken(r, -(o - 2));
        break;
      } else if ((i.next == 10 || i.next == 13) && a) {
        i.acceptToken(e, 1);
        break;
      } else
        s = o = 0;
      i.advance();
    }
  });
}
const K8 = $m("script", v8, w8), J8 = $m("style", $8, S8), e6 = $m("textarea", k8, _8), t6 = Io({
  "Text RawText": E.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": E.angleBracket,
  TagName: E.tagName,
  "MismatchedCloseTag/TagName": [E.tagName, E.invalid],
  AttributeName: E.attributeName,
  "AttributeValue UnquotedAttributeValue": E.attributeValue,
  Is: E.definitionOperator,
  "EntityReference CharacterReference": E.character,
  Comment: E.blockComment,
  ProcessingInst: E.processingInstruction,
  DoctypeDecl: E.documentMeta
}), r6 = Si.deserialize({
  version: 14,
  states: ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%ZQ&rO,59fO%fQ&rO,59iO%qQ&rO,59lO%|Q&rO,59nOOOa'#D^'#D^O&XOaO'#CxO&dOaO,59[OOOb'#D_'#D_O&lObO'#C{O&wObO,59[OOOd'#D`'#D`O'POdO'#DOO'[OdO,59[OOO`'#Da'#DaO'dO!rO,59[O'kQ#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'pO$fO,59oOOO`,59o,59oO'xQ#|O,59qO'}Q#|O,59rOOO`-E7W-E7WO(SQ&rO'#CsOOQW'#DZ'#DZO(bQ&rO1G.wOOOa1G.w1G.wOOO`1G/Y1G/YO(mQ&rO1G/QOOOb1G/Q1G/QO(xQ&rO1G/TOOOd1G/T1G/TO)TQ&rO1G/WOOO`1G/W1G/WO)`Q&rO1G/YOOOa-E7[-E7[O)kQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)pQ#tO'#C|OOOd-E7^-E7^O)uQ#tO'#DPOOO`-E7_-E7_O)zQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O*PQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOO`7+$t7+$tOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rO*[Q#|O,59eO*aQ#|O,59hO*fQ#|O,59kOOO`1G/X1G/XO*kO7[O'#CvO*|OMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O+_O7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+pOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
  stateData: ",]~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OT}OhyO~OS!POT}OhyO~OS!ROT}OhyO~OS!TOT}OhyO~OS}OT}OhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXTgXhgX~OS!fOT!gOhyO~OS!hOT!gOhyO~OS!iOT!gOhyO~OS!jOT!gOhyO~OS!gOT!gOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
  goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{!O!Q!S!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ!ObQ!QcQ!SdQ!UeZ!e{!O!Q!S!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: "âš  StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 67,
  context: Y8,
  nodeProps: [
    ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 21, 30, 33, 36, "CloseTag"],
    ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 29, 32, 35, 37, "OpenTag"],
    ["group", -9, 14, 17, 18, 19, 20, 39, 40, 41, 42, "Entity", 16, "Entity TextContent", -3, 28, 31, 34, "TextContent Entity"],
    ["isolate", -11, 21, 29, 30, 32, 33, 35, 36, 37, 38, 41, 42, "ltr", -3, 26, 27, 39, ""]
  ],
  propSources: [t6],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [K8, J8, e6, G8, B8, F8, 0, 1, 2, 3, 4, 5],
  topRules: { Document: [0, 15] },
  dialects: { noMatch: 0, selfClosing: 509 },
  tokenPrec: 511
});
function $2(t, e) {
  let r = /* @__PURE__ */ Object.create(null);
  for (let n of t.getChildren(y2)) {
    let i = n.getChild(E8), s = n.getChild(Nh) || n.getChild(b2);
    i && (r[e.read(i.from, i.to)] = s ? s.type.id == Nh ? e.read(s.from + 1, s.to - 1) : e.read(s.from, s.to) : "");
  }
  return r;
}
function p1(t, e) {
  let r = t.getChild(A8);
  return r ? e.read(r.from, r.to) : " ";
}
function cf(t, e, r) {
  let n;
  for (let i of r)
    if (!i.attrs || i.attrs(n || (n = $2(t.node.parent.firstChild, e))))
      return { parser: i.parser };
  return null;
}
function S2(t = [], e = []) {
  let r = [], n = [], i = [], s = [];
  for (let a of t)
    (a.tag == "script" ? r : a.tag == "style" ? n : a.tag == "textarea" ? i : s).push(a);
  let o = e.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let a of e)
    (o[a.name] || (o[a.name] = [])).push(a);
  return t4((a, l) => {
    let c = a.type.id;
    if (c == R8)
      return cf(a, l, r);
    if (c == I8)
      return cf(a, l, n);
    if (c == j8)
      return cf(a, l, i);
    if (c == O2 && s.length) {
      let u = a.node, d = u.firstChild, f = d && p1(d, l), h;
      if (f) {
        for (let p of s)
          if (p.tag == f && (!p.attrs || p.attrs(h || (h = $2(u, l))))) {
            let g = u.lastChild, m = g.type.id == M8 ? g.from : u.to;
            if (m > d.to)
              return { parser: p.parser, overlay: [{ from: d.to, to: m }] };
          }
      }
    }
    if (o && c == y2) {
      let u = a.node, d;
      if (d = u.firstChild) {
        let f = o[l.read(d.from, d.to)];
        if (f)
          for (let h of f) {
            if (h.tagName && h.tagName != p1(u.parent, l))
              continue;
            let p = u.lastChild;
            if (p.type.id == Nh) {
              let g = p.from + 1, m = p.lastChild, y = p.to - (m && m.isError ? 0 : 1);
              if (y > g)
                return { parser: h.parser, overlay: [{ from: g, to: y }] };
            } else if (p.type.id == b2)
              return { parser: h.parser, overlay: [{ from: p.from, to: p.to }] };
          }
      }
    }
    return null;
  });
}
const n6 = 309, m1 = 1, i6 = 2, s6 = 3, o6 = 310, a6 = 312, l6 = 313, c6 = 4, u6 = 5, d6 = 0, zh = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], k2 = 125, f6 = 59, Xh = 47, h6 = 42, p6 = 43, m6 = 45, g6 = 60, O6 = 44, y6 = new vm({
  start: !1,
  shift(t, e) {
    return e == c6 || e == u6 || e == a6 ? t : e == l6;
  },
  strict: !1
}), b6 = new Kt((t, e) => {
  let { next: r } = t;
  (r == k2 || r == -1 || e.context) && t.acceptToken(o6);
}, { contextual: !0, fallback: !0 }), v6 = new Kt((t, e) => {
  let { next: r } = t, n;
  zh.indexOf(r) > -1 || r == Xh && ((n = t.peek(1)) == Xh || n == h6) || r != k2 && r != f6 && r != -1 && !e.context && t.acceptToken(n6);
}, { contextual: !0 }), w6 = new Kt((t, e) => {
  let { next: r } = t;
  if ((r == p6 || r == m6) && (t.advance(), r == t.next)) {
    t.advance();
    let n = !e.context && e.canShift(m1);
    t.acceptToken(n ? m1 : i6);
  }
}, { contextual: !0 });
function uf(t, e) {
  return t >= 65 && t <= 90 || t >= 97 && t <= 122 || t == 95 || t >= 192 || !e && t >= 48 && t <= 57;
}
const $6 = new Kt((t, e) => {
  if (t.next != g6 || !e.dialectEnabled(d6) || (t.advance(), t.next == Xh))
    return;
  let r = 0;
  for (; zh.indexOf(t.next) > -1; )
    t.advance(), r++;
  if (uf(t.next, !0)) {
    for (t.advance(), r++; uf(t.next, !1); )
      t.advance(), r++;
    for (; zh.indexOf(t.next) > -1; )
      t.advance(), r++;
    if (t.next == O6)
      return;
    for (let n = 0; ; n++) {
      if (n == 7) {
        if (!uf(t.next, !0))
          return;
        break;
      }
      if (t.next != "extends".charCodeAt(n))
        break;
      t.advance(), r++;
    }
  }
  t.acceptToken(s6, -r);
}), S6 = Io({
  "get set async static": E.modifier,
  "for while do if else switch try catch finally return throw break continue default case": E.controlKeyword,
  "in of await yield void typeof delete instanceof": E.operatorKeyword,
  "let var const using function class extends": E.definitionKeyword,
  "import export from": E.moduleKeyword,
  "with debugger as new": E.keyword,
  TemplateString: E.special(E.string),
  super: E.atom,
  BooleanLiteral: E.bool,
  this: E.self,
  null: E.null,
  Star: E.modifier,
  VariableName: E.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": E.function(E.variableName),
  VariableDefinition: E.definition(E.variableName),
  Label: E.labelName,
  PropertyName: E.propertyName,
  PrivatePropertyName: E.special(E.propertyName),
  "CallExpression/MemberExpression/PropertyName": E.function(E.propertyName),
  "FunctionDeclaration/VariableDefinition": E.function(E.definition(E.variableName)),
  "ClassDeclaration/VariableDefinition": E.definition(E.className),
  PropertyDefinition: E.definition(E.propertyName),
  PrivatePropertyDefinition: E.definition(E.special(E.propertyName)),
  UpdateOp: E.updateOperator,
  "LineComment Hashbang": E.lineComment,
  BlockComment: E.blockComment,
  Number: E.number,
  String: E.string,
  Escape: E.escape,
  ArithOp: E.arithmeticOperator,
  LogicOp: E.logicOperator,
  BitOp: E.bitwiseOperator,
  CompareOp: E.compareOperator,
  RegExp: E.regexp,
  Equals: E.definitionOperator,
  Arrow: E.function(E.punctuation),
  ": Spread": E.punctuation,
  "( )": E.paren,
  "[ ]": E.squareBracket,
  "{ }": E.brace,
  "InterpolationStart InterpolationEnd": E.special(E.brace),
  ".": E.derefOperator,
  ", ;": E.separator,
  "@": E.meta,
  TypeName: E.typeName,
  TypeDefinition: E.definition(E.typeName),
  "type enum interface implements namespace module declare": E.definitionKeyword,
  "abstract global Privacy readonly override": E.modifier,
  "is keyof unique infer": E.operatorKeyword,
  JSXAttributeValue: E.attributeValue,
  JSXText: E.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": E.angleBracket,
  "JSXIdentifier JSXNameSpacedName": E.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": E.attributeName,
  "JSXBuiltin/JSXIdentifier": E.standard(E.tagName)
}), k6 = { __proto__: null, export: 18, as: 23, from: 31, default: 34, async: 39, function: 40, extends: 52, this: 56, true: 64, false: 64, null: 76, void: 80, typeof: 84, super: 102, new: 136, delete: 152, yield: 161, await: 165, class: 170, public: 227, private: 227, protected: 227, readonly: 229, instanceof: 248, satisfies: 251, in: 252, const: 254, import: 286, keyof: 339, unique: 343, infer: 349, is: 385, abstract: 405, implements: 407, type: 409, let: 412, var: 414, using: 417, interface: 423, enum: 427, namespace: 433, module: 435, declare: 439, global: 443, for: 462, of: 471, while: 474, with: 478, do: 482, if: 486, else: 488, switch: 492, case: 498, try: 504, catch: 508, finally: 512, return: 516, throw: 520, break: 524, continue: 528, debugger: 532 }, _6 = { __proto__: null, async: 123, get: 125, set: 127, declare: 187, public: 189, private: 189, protected: 189, static: 191, abstract: 193, override: 195, readonly: 201, accessor: 203, new: 389 }, P6 = { __proto__: null, "<": 143 }, x6 = Si.deserialize({
  version: 14,
  states: "$<UO%TQ^OOO%[Q^OOO'_Q`OOP(lOWOOO*zQ08SO'#ChO+RO!bO'#CiO+aO#tO'#CiO+oO?MpO'#D^O.QQ^O'#DdO.bQ^O'#DoO%[Q^O'#DyO0fQ^O'#EROOQ07b'#EZ'#EZO1PQWO'#EWOOQO'#El'#ElOOQO'#Ie'#IeO1XQWO'#GmO1dQWO'#EkO1iQWO'#EkO3kQ08SO'#JiO6[Q08SO'#JjO6xQWO'#FZO6}Q&jO'#FqOOQ07b'#Fc'#FcO7YO,YO'#FcO7hQ7[O'#FxO9UQWO'#FwOOQ07b'#Jj'#JjOOQ07`'#Ji'#JiO9ZQWO'#GqOOQU'#KU'#KUO9fQWO'#IRO9kQ07hO'#ISOOQU'#JW'#JWOOQU'#IW'#IWQ`Q^OOO`Q^OOO%[Q^O'#DqO9sQ^O'#D}O9zQ^O'#EPO9aQWO'#GmO:RQ7[O'#CnO:aQWO'#EjO:lQWO'#EuO:qQ7[O'#FbO;`QWO'#GmOOQO'#KV'#KVO;eQWO'#KVO;sQWO'#GuO;sQWO'#GvO;sQWO'#GxO9aQWO'#G{O<jQWO'#HOO>RQWO'#CdO>cQWO'#H[O>kQWO'#HbO>kQWO'#HdO`Q^O'#HfO>kQWO'#HhO>kQWO'#HkO>pQWO'#HqO>uQ07iO'#HwO%[Q^O'#HyO?QQ07iO'#H{O?]Q07iO'#H}O9kQ07hO'#IPO?hQ08SO'#ChO@jQ`O'#DiQOQWOOO%[Q^O'#EPOAQQWO'#ESO:RQ7[O'#EjOA]QWO'#EjOAhQpO'#FbOOQU'#Cf'#CfOOQ07`'#Dn'#DnOOQ07`'#Jm'#JmO%[Q^O'#JmOOQO'#Jq'#JqOOQO'#Ib'#IbOBhQ`O'#EcOOQ07`'#Eb'#EbOCdQ07pO'#EcOCnQ`O'#EVOOQO'#Jp'#JpODSQ`O'#JqOEaQ`O'#EVOCnQ`O'#EcPEnO!0LbO'#CaPOOO)CDu)CDuOOOO'#IX'#IXOEyO!bO,59TOOQ07b,59T,59TOOOO'#IY'#IYOFXO#tO,59TO%[Q^O'#D`OOOO'#I['#I[OFgO?MpO,59xOOQ07b,59x,59xOFuQ^O'#I]OGYQWO'#JkOI[QrO'#JkO+}Q^O'#JkOIcQWO,5:OOIyQWO'#ElOJWQWO'#JyOJcQWO'#JxOJcQWO'#JxOJkQWO,5;YOJpQWO'#JwOOQ07f,5:Z,5:ZOJwQ^O,5:ZOLxQ08SO,5:eOMiQWO,5:mONSQ07hO'#JvONZQWO'#JuO9ZQWO'#JuONoQWO'#JuONwQWO,5;XON|QWO'#JuO!#UQrO'#JjOOQ07b'#Ch'#ChO%[Q^O'#ERO!#tQpO,5:rOOQO'#Jr'#JrOOQO-E<c-E<cO9aQWO,5=XO!$[QWO,5=XO!$aQ^O,5;VO!&dQ7[O'#EgO!'}QWO,5;VO!)mQ7[O'#DsO!)tQ^O'#DxO!*OQ`O,5;`O!*WQ`O,5;`O%[Q^O,5;`OOQU'#FR'#FROOQU'#FT'#FTO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aOOQU'#FX'#FXO!*fQ^O,5;rOOQ07b,5;w,5;wOOQ07b,5;x,5;xO!,iQWO,5;xOOQ07b,5;y,5;yO%[Q^O'#IiO!,qQ07hO,5<eO!&dQ7[O,5;aO!-`Q7[O,5;aO%[Q^O,5;uO!-gQ&jO'#FgO!.dQ&jO'#J}O!.OQ&jO'#J}O!.kQ&jO'#J}OOQO'#J}'#J}O!/PQ&jO,5<POOOS,5<],5<]O!/bQ^O'#FsOOOS'#Ih'#IhO7YO,YO,5;}O!/iQ&jO'#FuOOQ07b,5;},5;}O!0YQMhO'#CuOOQ07b'#Cy'#CyO!0mQWO'#CyO!0rO?MpO'#C}O!1`Q7[O,5<bO!1gQWO,5<dO!3SQ!LQO'#GSO!3aQWO'#GTO!3fQWO'#GTO!3kQ!LQO'#GXO!4jQ`O'#G]OOQO'#Gh'#GhO!(SQ7[O'#GgOOQO'#Gj'#GjO!(SQ7[O'#GiO!5]QMhO'#JdOOQ07b'#Jd'#JdO!5gQWO'#JcO!5uQWO'#JbO!5}QWO'#CtOOQ07b'#Cw'#CwOOQ07b'#DR'#DROOQ07b'#DT'#DTO1SQWO'#DVO!(SQ7[O'#FzO!(SQ7[O'#F|O!6VQWO'#GOO!6[QWO'#GPO!3fQWO'#GVO!(SQ7[O'#G[O!6aQWO'#EmO!7OQWO,5<cOOQ07`'#Cq'#CqO!7WQWO'#EnO!8QQ`O'#EoOOQ07`'#Jw'#JwO!8XQ07hO'#KWO9kQ07hO,5=]O`Q^O,5>mOOQU'#J`'#J`OOQU,5>n,5>nOOQU-E<U-E<UO!:ZQ08SO,5:]O!<wQ08SO,5:iO%[Q^O,5:iO!?bQ08SO,5:kOOQO,5@q,5@qO!@RQ7[O,5=XO!@aQ07hO'#JaO9UQWO'#JaO!@rQ07hO,59YO!@}Q`O,59YO!AVQ7[O,59YO:RQ7[O,59YO!AbQWO,5;VO!AjQWO'#HZO!BOQWO'#KZO%[Q^O,5;zO!7{Q`O,5;|O!BWQWO,5=tO!B]QWO,5=tO!BbQWO,5=tO9kQ07hO,5=tO;sQWO,5=dOOQO'#Cu'#CuO!BpQ`O,5=aO!BxQ7[O,5=bO!CTQWO,5=dO!CYQpO,5=gO!CbQWO'#KVO>pQWO'#HQO9aQWO'#HSO!CgQWO'#HSO:RQ7[O'#HUO!ClQWO'#HUOOQU,5=j,5=jO!CqQWO'#HVO!DSQWO'#CnO!DXQWO,59OO!DcQWO,59OO!FhQ^O,59OOOQU,59O,59OO!FxQ07hO,59OO%[Q^O,59OO!ITQ^O'#H^OOQU'#H_'#H_OOQU'#H`'#H`O`Q^O,5=vO!IkQWO,5=vO`Q^O,5=|O`Q^O,5>OO!IpQWO,5>QO`Q^O,5>SO!IuQWO,5>VO!IzQ^O,5>]OOQU,5>c,5>cO%[Q^O,5>cO9kQ07hO,5>eOOQU,5>g,5>gO!NUQWO,5>gOOQU,5>i,5>iO!NUQWO,5>iOOQU,5>k,5>kO!NZQ`O'#D[O%[Q^O'#JmO!NxQ`O'#JmO# gQ`O'#DjO# xQ`O'#DjO#$ZQ^O'#DjO#$bQWO'#JlO#$jQWO,5:TO#$oQWO'#EpO#$}QWO'#JzO#%VQWO,5;ZO#%[Q`O'#DjO#%iQ`O'#EUOOQ07b,5:n,5:nO%[Q^O,5:nO#%pQWO,5:nO>pQWO,5;UO!@}Q`O,5;UO!AVQ7[O,5;UO:RQ7[O,5;UO#%xQWO,5@XO#%}Q$ISO,5:rOOQO-E<`-E<`O#'TQ07pO,5:}OCnQ`O,5:qO#'_Q`O,5:qOCnQ`O,5:}O!@rQ07hO,5:qOOQ07`'#Ef'#EfOOQO,5:},5:}O%[Q^O,5:}O#'lQ07hO,5:}O#'wQ07hO,5:}O!@}Q`O,5:qOOQO,5;T,5;TO#(VQ07hO,5:}POOO'#IV'#IVP#(kO!0LbO,58{POOO,58{,58{OOOO-E<V-E<VOOQ07b1G.o1G.oOOOO-E<W-E<WO#(vQpO,59zOOOO-E<Y-E<YOOQ07b1G/d1G/dO#({QrO,5>wO+}Q^O,5>wOOQO,5>},5>}O#)VQ^O'#I]OOQO-E<Z-E<ZO#)dQWO,5@VO#)lQrO,5@VO#)sQWO,5@dOOQ07b1G/j1G/jO%[Q^O,5@eO#){QWO'#IcOOQO-E<a-E<aO#)sQWO,5@dOOQ07`1G0t1G0tOOQ07f1G/u1G/uOOQ07f1G0X1G0XO%[Q^O,5@bO#*aQ07hO,5@bO#*rQ07hO,5@bO#*yQWO,5@aO9ZQWO,5@aO#+RQWO,5@aO#+aQWO'#IfO#*yQWO,5@aOOQ07`1G0s1G0sO!*OQ`O,5:tO!*ZQ`O,5:tOOQO,5:v,5:vO#,RQWO,5:vO#,ZQ7[O1G2sO9aQWO1G2sOOQ07b1G0q1G0qO#,iQ08SO1G0qO#-nQ08QO,5;ROOQ07b'#GR'#GRO#.[Q08SO'#JdO!$aQ^O1G0qO#0dQ7[O'#JnO#0nQWO,5:_O#0sQrO'#JoO%[Q^O'#JoO#0}QWO,5:dOOQ07b'#D['#D[OOQ07b1G0z1G0zO%[Q^O1G0zOOQ07b1G1d1G1dO#1SQWO1G0zO#3kQ08SO1G0{O#3rQ08SO1G0{O#6]Q08SO1G0{O#6dQ08SO1G0{O#8nQ08SO1G0{O#9UQ08SO1G0{O#<OQ08SO1G0{O#<VQ08SO1G0{O#>jQ08SO1G0{O#>wQ08SO1G0{O#@uQ08SO1G0{O#CuQ(CYO'#ChO#EsQ(CYO1G1^O#EzQ(CYO'#JjO!,lQWO1G1dO#F[Q08SO,5?TOOQ07`-E<g-E<gO#GOQ08SO1G0{OOQ07b1G0{1G0{O#IZQ08SO1G1aO#I}Q&jO,5<TO#JVQ&jO,5<UO#J_Q&jO'#FlO#JvQWO'#FkOOQO'#KO'#KOOOQO'#Ig'#IgO#J{Q&jO1G1kOOQ07b1G1k1G1kOOOS1G1v1G1vO#K^Q(CYO'#JiO#KhQWO,5<_O!*fQ^O,5<_OOOS-E<f-E<fOOQ07b1G1i1G1iO#KmQ`O'#J}OOQ07b,5<a,5<aO#KuQ`O,5<aOOQ07b,59e,59eO!&dQ7[O'#DPOOOO'#IZ'#IZO#KzO?MpO,59iOOQ07b,59i,59iO%[Q^O1G1|O!6[QWO'#IkO#LVQ7[O,5<uOOQ07b,5<r,5<rO!(SQ7[O'#InO#LuQ7[O,5=RO!(SQ7[O'#IpO#MhQ7[O,5=TO!&dQ7[O,5=VOOQO1G2O1G2OO#MrQpO'#CqO#NVQpO,5<nO#N^QWO'#KRO9aQWO'#KRO#NlQWO,5<pO!(SQ7[O,5<oO#NqQWO'#GUO#N|QWO,5<oO$ RQpO'#GRO$ `QpO'#KSO$ jQWO'#KSO!&dQ7[O'#KSO$ oQWO,5<sO$ tQ`O'#G^O!4eQ`O'#G^O$!VQWO'#G`O$![QWO'#GbO!3fQWO'#GeO$!aQ07hO'#ImO$!lQ`O,5<wOOQ07f,5<w,5<wO$!sQ`O'#G^O$#RQ`O'#G_O$#ZQ`O'#G_O$#`Q7[O,5=RO$#pQ7[O,5=TOOQ07b,5=W,5=WO!(SQ7[O,5?}O!(SQ7[O,5?}O$$QQWO'#IrO$$]QWO,5?|O$$eQWO,59`O$%UQ7[O,59qOOQ07b,59q,59qO$%wQ7[O,5<fO$&jQ7[O,5<hO@bQWO,5<jOOQ07b,5<k,5<kO$&tQWO,5<qO$&yQ7[O,5<vO$'ZQWO'#JuO!$aQ^O1G1}O$'`QWO1G1}O9ZQWO'#JxO9ZQWO'#EpO%[Q^O'#EpO9ZQWO'#ItO$'eQ07hO,5@rOOQU1G2w1G2wOOQU1G4X1G4XOOQ07b1G/w1G/wO!,iQWO1G/wO$)jQ08SO1G0TOOQU1G2s1G2sO!&dQ7[O1G2sO%[Q^O1G2sO#,^QWO1G2sO$+nQ7[O'#EgOOQ07`,5?{,5?{O$+xQ07hO,5?{OOQU1G.t1G.tO!@rQ07hO1G.tO!@}Q`O1G.tO!AVQ7[O1G.tO$,ZQWO1G0qO$,`QWO'#ChO$,kQWO'#K[O$,sQWO,5=uO$,xQWO'#K[O$,}QWO'#K[O$-]QWO'#IzO$-kQWO,5@uO$-sQrO1G1fOOQ07b1G1h1G1hO9aQWO1G3`O@bQWO1G3`O$-zQWO1G3`O$.PQWO1G3`OOQU1G3`1G3`O!CTQWO1G3OO!&dQ7[O1G2{O$.UQWO1G2{OOQU1G2|1G2|O!&dQ7[O1G2|O$.ZQWO1G2|O$.cQ`O'#GzOOQU1G3O1G3OO!4eQ`O'#IvO!CYQpO1G3ROOQU1G3R1G3ROOQU,5=l,5=lO$.kQ7[O,5=nO9aQWO,5=nO$![QWO,5=pO9UQWO,5=pO!@}Q`O,5=pO!AVQ7[O,5=pO:RQ7[O,5=pO$.yQWO'#KYO$/UQWO,5=qOOQU1G.j1G.jO$/ZQ07hO1G.jO@bQWO1G.jO$/fQWO1G.jO9kQ07hO1G.jO$1kQrO,5@wO$1{QWO,5@wO9ZQWO,5@wO$2WQ^O,5=xO$2_QWO,5=xOOQU1G3b1G3bO`Q^O1G3bOOQU1G3h1G3hOOQU1G3j1G3jO>kQWO1G3lO$2dQ^O1G3nO$6hQ^O'#HmOOQU1G3q1G3qO$6uQWO'#HsO>pQWO'#HuOOQU1G3w1G3wO$6}Q^O1G3wO9kQ07hO1G3}OOQU1G4P1G4POOQ07`'#GY'#GYO9kQ07hO1G4RO9kQ07hO1G4TO$;UQWO,5@XO!*fQ^O,5;[O9ZQWO,5;[O>pQWO,5:UO!*fQ^O,5:UO!@}Q`O,5:UO$;ZQ(CYO,5:UOOQO,5;[,5;[O$;eQ`O'#I^O$;{QWO,5@WOOQ07b1G/o1G/oO$<TQ`O'#IdO$<_QWO,5@fOOQ07`1G0u1G0uO# xQ`O,5:UOOQO'#Ia'#IaO$<gQ`O,5:pOOQ07f,5:p,5:pO#%sQWO1G0YOOQ07b1G0Y1G0YO%[Q^O1G0YOOQ07b1G0p1G0pO>pQWO1G0pO!@}Q`O1G0pO!AVQ7[O1G0pOOQ07`1G5s1G5sO!@rQ07hO1G0]OOQO1G0i1G0iO%[Q^O1G0iO$<nQ07hO1G0iO$<yQ07hO1G0iO!@}Q`O1G0]OCnQ`O1G0]O$=XQ07hO1G0iOOQO1G0]1G0]O$=mQ08SO1G0iPOOO-E<T-E<TPOOO1G.g1G.gOOOO1G/f1G/fO$=wQpO,5<eO$>PQrO1G4cOOQO1G4i1G4iO%[Q^O,5>wO$>ZQWO1G5qO$>cQWO1G6OO$>kQrO1G6PO9ZQWO,5>}O$>uQ08SO1G5|O%[Q^O1G5|O$?VQ07hO1G5|O$?hQWO1G5{O$?hQWO1G5{O9ZQWO1G5{O$?pQWO,5?QO9ZQWO,5?QOOQO,5?Q,5?QO$@UQWO,5?QO$'ZQWO,5?QOOQO-E<d-E<dOOQO1G0`1G0`OOQO1G0b1G0bO!,lQWO1G0bOOQU7+(_7+(_O!&dQ7[O7+(_O%[Q^O7+(_O$@dQWO7+(_O$@oQ7[O7+(_O$@}Q08SO,5=RO$CYQ08SO,5=TO$EeQ08SO,5=RO$GvQ08SO,5=TO$JXQ08SO,59qO$LaQ08SO,5<fO$NlQ08SO,5<hO%!wQ08SO,5<vOOQ07b7+&]7+&]O%%YQ08SO7+&]O%%|Q7[O'#I_O%&WQWO,5@YOOQ07b1G/y1G/yO%&`Q^O'#I`O%&mQWO,5@ZO%&uQrO,5@ZOOQ07b1G0O1G0OO%'PQWO7+&fOOQ07b7+&f7+&fO%'UQ(CYO,5:eO%[Q^O7+&xO%'`Q(CYO,5:]O%'mQ(CYO,5:iO%'wQ(CYO,5:kOOQ07b7+'O7+'OOOQO1G1o1G1oOOQO1G1p1G1pO%(RQtO,5<WO!*fQ^O,5<VOOQO-E<e-E<eOOQ07b7+'V7+'VOOOS7+'b7+'bOOOS1G1y1G1yO%(^QWO1G1yOOQ07b1G1{1G1{O%(cQpO,59kOOOO-E<X-E<XOOQ07b1G/T1G/TO%(jQ08SO7+'hOOQ07b,5?V,5?VO%)^QpO,5?VOOQ07b1G2a1G2aP!&dQ7[O'#IkPOQ07b-E<i-E<iO%)|Q7[O,5?YOOQ07b-E<l-E<lO%*oQ7[O,5?[OOQ07b-E<n-E<nO%*yQpO1G2qOOQ07b1G2Y1G2YO%+QQWO'#IjO%+`QWO,5@mO%+`QWO,5@mO%+hQWO,5@mO%+sQWO,5@mOOQO1G2[1G2[O%,RQ7[O1G2ZO!(SQ7[O1G2ZO%,cQ!LQO'#IlO%,sQWO,5@nO!&dQ7[O,5@nO%,{QpO,5@nOOQ07b1G2_1G2_OOQ07`,5<x,5<xOOQ07`,5<y,5<yO$'ZQWO,5<yOC_QWO,5<yO!@}Q`O,5<xOOQO'#Ga'#GaO%-VQWO,5<zOOQ07`,5<|,5<|O$'ZQWO,5=POOQO,5?X,5?XOOQO-E<k-E<kOOQ07f1G2c1G2cO!4eQ`O,5<xO%-_QWO,5<yO$!VQWO,5<zO!4eQ`O,5<yO!(SQ7[O'#InO%.RQ7[O1G2mO!(SQ7[O'#IpO%.tQ7[O1G2oO%/OQ7[O1G5iO%/YQ7[O1G5iOOQO,5?^,5?^OOQO-E<p-E<pOOQO1G.z1G.zO!7{Q`O,59sO%[Q^O,59sO%/gQWO1G2UO!(SQ7[O1G2]O%/lQ08SO7+'iOOQ07b7+'i7+'iO!$aQ^O7+'iO%0`QWO,5;[OOQ07`,5?`,5?`OOQ07`-E<r-E<rOOQ07b7+%c7+%cO%0eQpO'#KTO#%sQWO7+(_O%0oQrO7+(_O$@gQWO7+(_O%0vQ08QO'#ChO%1ZQ08QO,5<}O%1{QWO,5<}OOQ07`1G5g1G5gOOQU7+$`7+$`O!@rQ07hO7+$`O!@}Q`O7+$`O!$aQ^O7+&]O%2QQWO'#IyO%2iQWO,5@vOOQO1G3a1G3aO9aQWO,5@vO%2iQWO,5@vO%2qQWO,5@vOOQO,5?f,5?fOOQO-E<x-E<xOOQ07b7+'Q7+'QO%2vQWO7+(zO9kQ07hO7+(zO9aQWO7+(zO@bQWO7+(zOOQU7+(j7+(jO%2{Q08QO7+(gO!&dQ7[O7+(gO%3VQpO7+(hOOQU7+(h7+(hO!&dQ7[O7+(hO%3^QWO'#KXO%3iQWO,5=fOOQO,5?b,5?bOOQO-E<t-E<tOOQU7+(m7+(mO%4xQ`O'#HTOOQU1G3Y1G3YO!&dQ7[O1G3YO%[Q^O1G3YO%5PQWO1G3YO%5[Q7[O1G3YO9kQ07hO1G3[O$![QWO1G3[O9UQWO1G3[O!@}Q`O1G3[O!AVQ7[O1G3[O%5jQWO'#IxO%6OQWO,5@tO%6WQ`O,5@tOOQ07`1G3]1G3]OOQU7+$U7+$UO@bQWO7+$UO9kQ07hO7+$UO%6cQWO7+$UO%[Q^O1G6cO%[Q^O1G6dO%6hQ07hO1G6cO%6rQ^O1G3dO%6yQWO1G3dO%7OQ^O1G3dOOQU7+(|7+(|O9kQ07hO7+)WO`Q^O7+)YOOQU'#K_'#K_OOQU'#I{'#I{O%7VQ^O,5>XOOQU,5>X,5>XO%[Q^O'#HnO%7dQWO'#HpOOQU,5>_,5>_O9ZQWO,5>_OOQU,5>a,5>aOOQU7+)c7+)cOOQU7+)i7+)iOOQU7+)m7+)mOOQU7+)o7+)oO%7iQ`O1G5sO%7}Q(CYO1G0vO%8XQWO1G0vOOQO1G/p1G/pO%8dQ(CYO1G/pO>pQWO1G/pO!*fQ^O'#DjOOQO,5>x,5>xOOQO-E<[-E<[OOQO,5?O,5?OOOQO-E<b-E<bO!@}Q`O1G/pOOQO-E<_-E<_OOQ07f1G0[1G0[OOQ07b7+%t7+%tO#%sQWO7+%tOOQ07b7+&[7+&[O>pQWO7+&[O!@}Q`O7+&[OOQO7+%w7+%wO$=mQ08SO7+&TOOQO7+&T7+&TO%[Q^O7+&TO%8nQ07hO7+&TO!@rQ07hO7+%wO!@}Q`O7+%wO%8yQ07hO7+&TO%9XQ08SO7++hO%[Q^O7++hO%9iQWO7++gO%9iQWO7++gOOQO1G4l1G4lO9ZQWO1G4lO%9qQWO1G4lOOQO7+%|7+%|O#%sQWO<<KyO%0oQrO<<KyO%:PQWO<<KyOOQU<<Ky<<KyO!&dQ7[O<<KyO%[Q^O<<KyO%:XQWO<<KyO%:dQ08SO,5?YO%<oQ08SO,5?[O%>zQ08SO1G2ZO%A]Q08SO1G2mO%ChQ08SO1G2oO%EsQ7[O,5>yOOQO-E<]-E<]O%E}QrO,5>zO%[Q^O,5>zOOQO-E<^-E<^O%FXQWO1G5uOOQ07b<<JQ<<JQO%FaQ(CYO1G0qO%HkQ(CYO1G0{O%HrQ(CYO1G0{O%JvQ(CYO1G0{O%J}Q(CYO1G0{O%LrQ(CYO1G0{O%MYQ(CYO1G0{O& mQ(CYO1G0{O& tQ(CYO1G0{O&#rQ(CYO1G0{O&$PQ(CYO1G0{O&%}Q(CYO1G0{O&&bQ08SO<<JdO&'gQ(CYO1G0{O&)]Q(CYO'#JdO&+`Q(CYO1G1aO&+mQ(CYO1G0TO!*fQ^O'#FnOOQO'#KP'#KPOOQO1G1r1G1rO&+wQWO1G1qO&+|Q(CYO,5?TOOOS7+'e7+'eOOOO1G/V1G/VOOQ07b1G4q1G4qO!(SQ7[O7+(]O&,WQWO,5?UO9aQWO,5?UOOQO-E<h-E<hO&,fQWO1G6XO&,fQWO1G6XO&,nQWO1G6XO&,yQ7[O7+'uO&-ZQpO,5?WO&-eQWO,5?WO!&dQ7[O,5?WOOQO-E<j-E<jO&-jQpO1G6YO&-tQWO1G6YOOQ07`1G2e1G2eO$'ZQWO1G2eOOQ07`1G2d1G2dO&-|QWO1G2fO!&dQ7[O1G2fOOQ07`1G2k1G2kO!@}Q`O1G2dOC_QWO1G2eO&.RQWO1G2fO&.ZQWO1G2eO&.}Q7[O,5?YOOQ07b-E<m-E<mO&/pQ7[O,5?[OOQ07b-E<o-E<oO!(SQ7[O7++TOOQ07b1G/_1G/_O&/zQWO1G/_OOQ07b7+'p7+'pO&0PQ7[O7+'wO&0aQ08SO<<KTOOQ07b<<KT<<KTO&1TQWO1G0vO!&dQ7[O'#IsO&1YQWO,5@oO!&dQ7[O1G2iOOQU<<Gz<<GzO!@rQ07hO<<GzO&1bQ08SO<<IwOOQ07b<<Iw<<IwOOQO,5?e,5?eO&2UQWO,5?eO&2ZQWO,5?eOOQO-E<w-E<wO&2iQWO1G6bO&2iQWO1G6bO9aQWO1G6bO@bQWO<<LfOOQU<<Lf<<LfO&2qQWO<<LfO9kQ07hO<<LfOOQU<<LR<<LRO%2{Q08QO<<LROOQU<<LS<<LSO%3VQpO<<LSO&2vQ`O'#IuO&3RQWO,5@sO!*fQ^O,5@sOOQU1G3Q1G3QO&3ZQ^O'#JmOOQO'#Iw'#IwO9kQ07hO'#IwO&3eQ`O,5=oOOQU,5=o,5=oO&3lQ`O'#EcO&4QQWO7+(tO&4VQWO7+(tOOQU7+(t7+(tO!&dQ7[O7+(tO%[Q^O7+(tO&4_QWO7+(tOOQU7+(v7+(vO9kQ07hO7+(vO$![QWO7+(vO9UQWO7+(vO!@}Q`O7+(vO&4jQWO,5?dOOQO-E<v-E<vOOQO'#HW'#HWO&4uQWO1G6`O9kQ07hO<<GpOOQU<<Gp<<GpO@bQWO<<GpO&4}QWO7++}O&5SQWO7+,OO%[Q^O7++}O%[Q^O7+,OOOQU7+)O7+)OO&5XQWO7+)OO&5^Q^O7+)OO&5eQWO7+)OOOQU<<Lr<<LrOOQU<<Lt<<LtOOQU-E<y-E<yOOQU1G3s1G3sO&5jQWO,5>YOOQU,5>[,5>[O&5oQWO1G3yO9ZQWO7+&bO!*fQ^O7+&bOOQO7+%[7+%[O&5tQ(CYO1G6PO>pQWO7+%[OOQ07b<<I`<<I`OOQ07b<<Iv<<IvO>pQWO<<IvOOQO<<Io<<IoO$=mQ08SO<<IoO%[Q^O<<IoOOQO<<Ic<<IcO!@rQ07hO<<IcO&6OQ07hO<<IoO&6ZQ08SO<= SO&6kQWO<= ROOQO7+*W7+*WO9ZQWO7+*WOOQUANAeANAeO&6sQWOANAeO!&dQ7[OANAeO#%sQWOANAeO%0oQrOANAeO%[Q^OANAeO&6{Q08SO7+'uO&9^Q08SO,5?YO&;iQ08SO,5?[O&=tQ08SO7+'wO&@VQrO1G4fO&@aQ(CYO7+&]O&BeQ(CYO,5=RO&DlQ(CYO,5=TO&D|Q(CYO,5=RO&E^Q(CYO,5=TO&EnQ(CYO,59qO&GqQ(CYO,5<fO&ItQ(CYO,5<hO&KwQ(CYO,5<vO&MmQ(CYO7+'hO&MzQ(CYO7+'iO&NXQWO,5<YOOQO7+']7+']O&N^Q7[O<<KwOOQO1G4p1G4pO&NeQWO1G4pO&NpQWO1G4pO' OQWO7++sO' OQWO7++sO!&dQ7[O1G4rO' WQpO1G4rO' bQWO7++tOOQ07`7+(P7+(PO$'ZQWO7+(QO' jQpO7+(QOOQ07`7+(O7+(OO$'ZQWO7+(PO' qQWO7+(QO!&dQ7[O7+(QOC_QWO7+(PO' vQ7[O<<NoOOQ07b7+$y7+$yO'!QQpO,5?_OOQO-E<q-E<qO'![Q08QO7+(TOOQUAN=fAN=fO9aQWO1G5POOQO1G5P1G5PO'!lQWO1G5PO'!qQWO7++|O'!qQWO7++|O9kQ07hOANBQO@bQWOANBQOOQUANBQANBQOOQUANAmANAmOOQUANAnANAnO'!yQWO,5?aOOQO-E<s-E<sO'#UQ(CYO1G6_O'%fQrO'#ChOOQO,5?c,5?cOOQO-E<u-E<uOOQU1G3Z1G3ZO&3ZQ^O,5<zOOQU<<L`<<L`O!&dQ7[O<<L`O&4QQWO<<L`O'%pQWO<<L`O%[Q^O<<L`OOQU<<Lb<<LbO9kQ07hO<<LbO$![QWO<<LbO9UQWO<<LbO'%xQ`O1G5OO'&TQWO7++zOOQUAN=[AN=[O9kQ07hOAN=[OOQU<= i<= iOOQU<= j<= jO'&]QWO<= iO'&bQWO<= jOOQU<<Lj<<LjO'&gQWO<<LjO'&lQ^O<<LjOOQU1G3t1G3tO>pQWO7+)eO'&sQWO<<I|O''OQ(CYO<<I|OOQO<<Hv<<HvOOQ07bAN?bAN?bOOQOAN?ZAN?ZO$=mQ08SOAN?ZOOQOAN>}AN>}O%[Q^OAN?ZOOQO<<Mr<<MrOOQUG27PG27PO!&dQ7[OG27PO#%sQWOG27PO''YQWOG27PO%0oQrOG27PO''bQ(CYO<<JdO''oQ(CYO1G2ZO')eQ(CYO,5?YO'+hQ(CYO,5?[O'-kQ(CYO1G2mO'/nQ(CYO1G2oO'1qQ(CYO<<KTO'2OQ(CYO<<IwOOQO1G1t1G1tO!(SQ7[OANAcOOQO7+*[7+*[O'2]QWO7+*[O'2hQWO<= _O'2pQpO7+*^OOQ07`<<Kl<<KlO$'ZQWO<<KlOOQ07`<<Kk<<KkO'2zQpO<<KlO$'ZQWO<<KkOOQO7+*k7+*kO9aQWO7+*kO'3RQWO<= hOOQUG27lG27lO9kQ07hOG27lO!*fQ^O1G4{O'3ZQWO7++yO&4QQWOANAzOOQUANAzANAzO!&dQ7[OANAzO'3cQWOANAzOOQUANA|ANA|O9kQ07hOANA|O$![QWOANA|OOQO'#HX'#HXOOQO7+*j7+*jOOQUG22vG22vOOQUANETANETOOQUANEUANEUOOQUANBUANBUO'3kQWOANBUOOQU<<MP<<MPO!*fQ^OAN?hOOQOG24uG24uO$=mQ08SOG24uO#%sQWOLD,kOOQULD,kLD,kO!&dQ7[OLD,kO'3pQWOLD,kO'3xQ(CYO7+'uO'5nQ(CYO,5?YO'7qQ(CYO,5?[O'9tQ(CYO7+'wO';jQ7[OG26}OOQO<<Mv<<MvOOQ07`ANAWANAWO$'ZQWOANAWOOQ07`ANAVANAVOOQO<<NV<<NVOOQULD-WLD-WO';zQ(CYO7+*gOOQUG27fG27fO&4QQWOG27fO!&dQ7[OG27fOOQUG27hG27hO9kQ07hOG27hOOQUG27pG27pO'<UQ(CYOG25SOOQOLD*aLD*aOOQU!$(!V!$(!VO#%sQWO!$(!VO!&dQ7[O!$(!VO'<`Q08SOG26}OOQ07`G26rG26rOOQULD-QLD-QO&4QQWOLD-QOOQULD-SLD-SOOQU!)9Eq!)9EqO#%sQWO!)9EqOOQU!$(!l!$(!lOOQU!.K;]!.K;]O'>qQ(CYOG26}O!*fQ^O'#DyO1PQWO'#EWO'@gQrO'#JiO!*fQ^O'#DqO'@nQ^O'#D}O'@uQrO'#ChO'C]QrO'#ChO!*fQ^O'#EPO'CmQ^O,5;VO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O'#IiO'EpQWO,5<eO'ExQ7[O,5;aO'GcQ7[O,5;aO!*fQ^O,5;uO!&dQ7[O'#GgO'ExQ7[O'#GgO!&dQ7[O'#GiO'ExQ7[O'#GiO1SQWO'#DVO1SQWO'#DVO!&dQ7[O'#FzO'ExQ7[O'#FzO!&dQ7[O'#F|O'ExQ7[O'#F|O!&dQ7[O'#G[O'ExQ7[O'#G[O!*fQ^O,5:iO!*fQ^O,5@eO'CmQ^O1G0qO'GjQ(CYO'#ChO!*fQ^O1G1|O!&dQ7[O'#InO'ExQ7[O'#InO!&dQ7[O'#IpO'ExQ7[O'#IpO!&dQ7[O,5<oO'ExQ7[O,5<oO'CmQ^O1G1}O!*fQ^O7+&xO!&dQ7[O1G2ZO'ExQ7[O1G2ZO!&dQ7[O'#InO'ExQ7[O'#InO!&dQ7[O'#IpO'ExQ7[O'#IpO!&dQ7[O1G2]O'ExQ7[O1G2]O'CmQ^O7+'iO'CmQ^O7+&]O!&dQ7[OANAcO'ExQ7[OANAcO'GtQWO'#EkO'GyQWO'#EkO'HRQWO'#FZO'HWQWO'#EuO'H]QWO'#JyO'HhQWO'#JwO'HsQWO,5;VO'HxQ7[O,5<bO'IPQWO'#GTO'IUQWO'#GTO'IZQWO,5<cO'IcQWO,5;VO'IkQ(CYO1G1^O'IrQWO,5<oO'IwQWO,5<oO'I|QWO,5<qO'JRQWO,5<qO'JWQWO1G1}O'J]QWO1G0qO'JbQ7[O<<KwO'JiQ7[O<<KwO7hQ7[O'#FxO9UQWO'#FwOA]QWO'#EjO!*fQ^O,5;rO!3fQWO'#GTO!3fQWO'#GTO!3fQWO'#GVO!3fQWO'#GVO!(SQ7[O7+(]O!(SQ7[O7+(]O%*yQpO1G2qO%*yQpO1G2qO!&dQ7[O,5=VO!&dQ7[O,5=V",
  stateData: "'Km~O'tOS'uOSSOS'vRQ~OPYOQYORfOX!VO`qOczOdyOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![XO!fuO!kZO!nYO!oYO!pYO!rvO!twO!wxO!{]O#s!PO$T|O%b}O%d!QO%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO%s!UO&P!WO&V!XO&X!YO&Z!ZO&]![O&`!]O&f!^O&l!_O&n!`O&p!aO&r!bO&t!cO'{SO'}TO(QUO(XVO(g[O(tiO~OVtO~P`OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~O`!vOo!nO!P!oO!_!xO!`!uO!a!uO!{:dO#P!pO#Q!pO#R!wO#S!pO#T!pO#W!yO#X!yO'|!lO'}TO(QUO([!mO(g!sO~O'v!zO~OP[XZ[X`[Xn[X|[X}[X!P[X!Y[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X'r[X(X[X(h[X(o[X(p[X~O!d$|X~P(qO^!|O'}#OO(O!|O(P#OO~O^#PO(P#OO(Q#OO(R#PO~Ot#RO!R#SO(Y#SO(Z#UO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{:hO'}TO(QUO(XVO(g[O(tiO~O!X#YO!Y#VO!V(_P!V(lP~P+}O!Z#bO~P`OPYOQYORfOc!jOd!iOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'}TO(QUO(XVO(g[O(tiO~Ol#lO!X#hO!{]O#e#kO#f#hO'{:iO!j(iP~P.iO!k#nO'{#mO~O!w#rO!{]O%b#sO~O#g#tO~O!d#uO#g#tO~OP$]OZ$dOn$QO|#yO}#zO!P#{O!Y$aO!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O`(]X'r(]X'p(]X!j(]X!V(]X![(]X%c(]X!d(]X~P1qO#[$eO$O$eOP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X![(^X%c(^X~O`(^X!i(^X'r(^X'p(^X!V(^X!j(^Xr(^X!d(^X~P4XO#[$eO~O$Y$gO$[$fO$c$lO~ORfO![$mO$f$nO$h$pO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz%ZO!P${O![$|O!f%`O!k$xO#f%aO$T%^O$o%[O$q%]O$t%_O'{$rO'}TO(QUO(X$uO(o$}O(p%POf(UP~O!k%bO~O!P%eO![%fO'{%dO~O!d%jO~O`%kO'r%kO~O'|!lO~P%[O%h%rO~P%[Og%VO!k%bO'{%dO'|!lO~Od%yO!k%bO'{%dO~O#r$SO~O|&OO![%{O!k%}O%d&RO'{%dO'|!lO'}TO(QUO_(}P~O!w#rO~O%m&TO!P(yX![(yX'{(yX~O'{&UO~O!t&ZO#s!PO%d!QO%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO~Oc&`Od&_O!w&]O%b&^O%u&[O~P;xOc&cOdyO![&bO!t&ZO!wxO!{]O#s!PO%b}O%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO%s!UO~Oa&fO#[&iO%d&dO'|!lO~P<}O!k&jO!t&nO~O!k#nO~O![XO~O`%kO'q&vO'r%kO~O`%kO'q&yO'r%kO~O`%kO'q&{O'r%kO~O'p[X!V[Xr[X!j[X&T[X![[X%c[X!d[X~P(qO!_'YO!`'RO!a'RO'|!lO'}TO(QUO~Oo'PO!P'OO!X'SO([&}O!Z(`P!Z(nP~P@UOj']O!['ZO'{%dO~Od'bO!k%bO'{%dO~O|&OO!k%}O~Oo!nO!P!oO!{:dO#P!pO#Q!pO#S!pO#T!pO'|!lO'}TO(QUO([!mO(g!sO~O!_'hO!`'gO!a'gO#R!pO#W'iO#X'iO~PApO`%kOg%VO!d#uO!k%bO'r%kO(h'kO~O!o'oO#['mO~PCOOo!nO!P!oO'}TO(QUO([!mO(g!sO~O![XOo(eX!P(eX!_(eX!`(eX!a(eX!{(eX#P(eX#Q(eX#R(eX#S(eX#T(eX#W(eX#X(eX'|(eX'}(eX(Q(eX([(eX(g(eX~O!`'gO!a'gO'|!lO~PCnO'w'sO'x'sO'y'uO~O^!|O'}'wO(O!|O(P'wO~O^#PO(P'wO(Q'wO(R#PO~Ot#RO!R#SO(Y#SO(Z'{O~O!X'}O!V'PX!V'VX!Y'PX!Y'VX~P+}O!Y(PO!V(_X~OP$]OZ$dOn$QO|#yO}#zO!P#{O!Y(PO!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O!V(_X~PGbO!V(UO~O!V(kX!Y(kX!d(kX!j(kX(h(kX~O#[(kX#g#`X!Z(kX~PIhO#[(VO!V(mX!Y(mX~O!Y(WO!V(lX~O!V(ZO~O#[$eO~PIhO!Z([O~P`O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!maZ!man!ma!Y!ma!h!ma!o!ma#j!ma#k!ma#l!ma#m!ma#n!ma#o!ma#p!ma#q!ma#r!ma#t!ma#v!ma#x!ma#y!ma(h!ma(o!ma(p!ma~O`!ma'r!ma'p!ma!V!ma!j!mar!ma![!ma%c!ma!d!ma~PKOO!j(]O~O!d#uO#[(^O(h'kO!Y(jX`(jX'r(jX~O!j(jX~PMnO!P%eO![%fO!{]O#e(cO#f(bO'{%dO~O!Y(dO!j(iX~O!j(fO~O!P%eO![%fO#f(bO'{%dO~OP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!i(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X~O!d#uO!j(^X~P! [O|(gO}(hO!i#wO!k#xO!{!za!P!za~O!w!za%b!za![!za#e!za#f!za'{!za~P!#`O!w(lO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![XO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~O#g(rO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz%ZO!P${O![$|O!f%`O!k$xO#f%aO$T%^O$o%[O$q%]O$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~Of(bP~P!(SO!X(vO!j(cP~P%[O([(xO(g[O~O!P(zO!k#xO([(xO(g[O~OP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![!eO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'{)YO'}TO(QUO(XVO(g[O(t<YO~O})]O!k#xO~O!Y$aO`$ma'r$ma'p$ma!j$ma!V$ma![$ma%c$ma!d$ma~O#s)aO~P!&dO|)dO!d)cO![$ZX$W$ZX$Y$ZX$[$ZX$c$ZX~O!d)cO![(qX$W(qX$Y(qX$[(qX$c(qX~O|)dO~P!.OO|)dO![(qX$W(qX$Y(qX$[(qX$c(qX~O![)fO$W)jO$Y)eO$[)eO$c)kO~O!X)nO~P!*fO$Y$gO$[$fO$c)rO~Oj$uX|$uX!P$uX!i$uX(o$uX(p$uX~OfiXf$uXjiX!YiX#[iX~P!/tOo)tO~Ot)uO(Y)vO(Z)xO~Oj*RO|)zO!P){O(o$}O(p%PO~Of)yO~P!0}Of*SO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'}TO(QUO(X$uO(o$}O(p%PO~O!X*WO'{*TO!j(uP~P!1lO#g*YO~O!k*ZO~O!X*`O'{*]O!V(vP~P!1lOn*lO!P*dO!_*jO!`*cO!a*cO!k*ZO#W*kO%Y*fO'|!lO([!mO~O!Z*iO~P!3xO!i#wOj(WX|(WX!P(WX(o(WX(p(WX!Y(WX#[(WX~Of(WX#|(WX~P!4qOj*qO#[*pOf(VX!Y(VX~O!Y*rOf(UX~O'{&UOf(UP~O!k*yO~O'{(pO~Ol*}O!P%eO!X#hO![%fO!{]O#e#kO#f#hO'{%dO!j(iP~O!d#uO#g+OO~O!P%eO!X+QO!Y(WO![%fO'{%dO!V(lP~Oo'VO!P+SO!X+RO'}TO(QUO([(xO~O!Z(nP~P!7lO!Y+TO`(zX'r(zX~OP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O`!ea!Y!ea'r!ea'p!ea!V!ea!j!ear!ea![!ea%c!ea!d!ea~P!8dO|#yO}#zO!P#{O!i#wO!k#xO(XVOP!qaZ!qan!qa!Y!qa!h!qa!o!qa#j!qa#k!qa#l!qa#m!qa#n!qa#o!qa#p!qa#q!qa#r!qa#t!qa#v!qa#x!qa#y!qa(h!qa(o!qa(p!qa~O`!qa'r!qa'p!qa!V!qa!j!qar!qa![!qa%c!qa!d!qa~P!:}O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!saZ!san!sa!Y!sa!h!sa!o!sa#j!sa#k!sa#l!sa#m!sa#n!sa#o!sa#p!sa#q!sa#r!sa#t!sa#v!sa#x!sa#y!sa(h!sa(o!sa(p!sa~O`!sa'r!sa'p!sa!V!sa!j!sar!sa![!sa%c!sa!d!sa~P!=hOg%VOj+^O!['ZO%c+]O~O!d+`O`(TX![(TX'r(TX!Y(TX~O`%kO![XO'r%kO~Og%VO!k%bO~Og%VO!k%bO'{%dO~O!d#uO#g(rO~Oa+kO%d+lO'{+hO'}TO(QUO!Z)OP~O!Y+mO_(}X~OZ+qO~O_+rO~O![%{O'{%dO'|!lO_(}P~Og%VO#[+wO~Og%VOj+zO![$|O~O![+|O~O|,OO![XO~O%h%rO~O!w,TO~Od,YO~Oa,ZO'{#mO'}TO(QUO!Z(|P~Od%yO~O%d!QO'{&UO~P<}OZ,`O_,_O~OPYOQYORfOczOdyOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO!fuO!kZO!nYO!oYO!pYO!rvO!wxO!{]O%b}O'}TO(QUO(XVO(g[O(tiO~O![!eO!t!gO$T!kO'{!dO~P!DkO_,_O`%kO'r%kO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~O`,eO!twO#s!OO%f!OO%g!OO%h!OO~P!GTO!k&jO~O&V,kO~O![,mO~O&h,oO&j,pOP&eaQ&eaR&eaX&ea`&eac&ead&eal&ean&eao&eap&eav&eax&eaz&ea!P&ea!T&ea!U&ea![&ea!f&ea!k&ea!n&ea!o&ea!p&ea!r&ea!t&ea!w&ea!{&ea#s&ea$T&ea%b&ea%d&ea%f&ea%g&ea%h&ea%k&ea%m&ea%p&ea%q&ea%s&ea&P&ea&V&ea&X&ea&Z&ea&]&ea&`&ea&f&ea&l&ea&n&ea&p&ea&r&ea&t&ea'p&ea'{&ea'}&ea(Q&ea(X&ea(g&ea(t&ea!Z&ea&^&eaa&ea&c&ea~O'{,uO~Og!bX!Y!OX!Y!bX!Z!OX!Z!bX!d!OX!d!bX!k!bX#[!OX~O!d,zO#[,yOg(aX!Y#dX!Y(aX!Z#dX!Z(aX!d(aX!k(aX~Og%VO!d,|O!k%bO!Y!^X!Z!^X~Oo!nO!P!oO'}TO(QUO([!mO~OP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![!eO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'}TO(QUO(XVO(g[O(t<YO~O'{;]O~P#!ZO!Y-QO!Z(`X~O!Z-SO~O!d,zO#[,yO!Y#dX!Z#dX~O!Y-TO!Z(nX~O!Z-VO~O!`-WO!a-WO'|!lO~P# xO!Z-ZO~P'_Oj-^O!['ZO~O!V-cO~Oo!za!_!za!`!za!a!za#P!za#Q!za#R!za#S!za#T!za#W!za#X!za'|!za'}!za(Q!za([!za(g!za~P!#`O!o-hO#[-fO~PCOO!`-jO!a-jO'|!lO~PCnO`%kO#[-fO'r%kO~O`%kO!d#uO#[-fO'r%kO~O`%kO!d#uO!o-hO#[-fO'r%kO(h'kO~O'w'sO'x'sO'y-oO~Or-pO~O!V'Pa!Y'Pa~P!8dO!X-tO!V'PX!Y'PX~P%[O!Y(PO!V(_a~O!V(_a~PGbO!Y(WO!V(la~O!P%eO!X-xO![%fO'{%dO!V'VX!Y'VX~O#[-zO!Y(ja!j(ja`(ja'r(ja~O!d#uO~P#*aO!Y(dO!j(ia~O!P%eO![%fO#f.OO'{%dO~Ol.TO!P%eO!X.QO![%fO!{]O#e.SO#f.QO'{%dO!Y'YX!j'YX~O}.XO!k#xO~Og%VOj.[O!['ZO%c.ZO~O`#_i!Y#_i'r#_i'p#_i!V#_i!j#_ir#_i![#_i%c#_i!d#_i~P!8dOj<fO|)zO!P){O(o$}O(p%PO~O#g#Za`#Za#[#Za'r#Za!Y#Za!j#Za![#Za!V#Za~P#-]O#g(WXP(WXZ(WX`(WXn(WX}(WX!h(WX!k(WX!o(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#p(WX#q(WX#r(WX#t(WX#v(WX#x(WX#y(WX'r(WX(X(WX(h(WX!j(WX!V(WX'p(WXr(WX![(WX%c(WX!d(WX~P!4qO!Y.iOf(bX~P!0}Of.kO~O!Y.lO!j(cX~P!8dO!j.oO~O!V.qO~OP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O(XVOZ#ii`#iin#ii!Y#ii!h#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#j#ii~P#1XO#j$OO~P#1XOP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO(XVOZ#ii`#ii!Y#ii!h#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~On#ii~P#3yOn$QO~P#3yOP$]On$QO|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO(XVO`#ii!Y#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~OZ#ii!h#ii#o#ii#p#ii#q#ii#r#ii~P#6kOZ$dO!h$SO#o$SO#p$SO#q$cO#r$SO~P#6kOP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO(XVO(p#}O`#ii!Y#ii#x#ii#y#ii'r#ii(h#ii(o#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#v$VO~P#9lO#v#ii~P#9lOP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO(XVO`#ii!Y#ii#x#ii#y#ii'r#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#v#ii(o#ii(p#ii~P#<^O#v$VO(o#|O(p#}O~P#<^OP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO(XVO(o#|O(p#}O~O`#ii!Y#ii#y#ii'r#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~P#?UOP[XZ[Xn[X|[X}[X!P[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X!Y[X!Z[X~O#|[X~P#AoOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO#v:sO#x:uO#y:vO(XVO(h$ZO(o#|O(p#}O~O#|.sO~P#C|O#[:{O$O:{O#|(^X!Z(^X~P! [O`']a!Y']a'r']a'p']a!j']a!V']ar']a![']a%c']a!d']a~P!8dOP#iiZ#ii`#iin#ii}#ii!Y#ii!h#ii!i#ii!k#ii!o#ii#j#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(X#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~P#-]O`#}i!Y#}i'r#}i'p#}i!V#}i!j#}ir#}i![#}i%c#}i!d#}i~P!8dO$Y.xO$[.xO~O$Y.yO$[.yO~O!d)cO#[.zO![$`X$W$`X$Y$`X$[$`X$c$`X~O!X.{O~O![)fO$W.}O$Y)eO$[)eO$c/OO~O!Y:wO!Z(]X~P#C|O!Z/PO~O!d)cO$c(qX~O$c/RO~Ot)uO(Y)vO(Z/UO~O!V/YO~P!&dO(o$}Oj%Za|%Za!P%Za(p%Za!Y%Za#[%Za~Of%Za#|%Za~P#L^O(p%POj%]a|%]a!P%]a(o%]a!Y%]a#[%]a~Of%]a#|%]a~P#MPO!YeX!deX!jeX!j$uX(heX~P!/tO!j/bO~P#-]O!Y/cO!d#uO(h'kO!j(uX~O!j/hO~O!X*WO'{%dO!j(uP~O#g/jO~O!V$uX!Y$uX!d$|X~P!/tO!Y/kO!V(vX~P#-]O!d/mO~O!V/oO~Og%VOn/sO!d#uO!k%bO(h'kO~O'{/uO~O!d+`O~O`%kO!Y/yO'r%kO~O!Z/{O~P!3xO!`/|O!a/|O'|!lO([!mO~O!P0OO([!mO~O#W0PO~Of%Za!Y%Za#[%Za#|%Za~P!0}Of%]a!Y%]a#[%]a#|%]a~P!0}O'{&UOf'fX!Y'fX~O!Y*rOf(Ua~Of0YO~O|0ZO}0ZO!P0[Ojya(oya(pya!Yya#[ya~Ofya#|ya~P$$jO|)zO!P){Oj$na(o$na(p$na!Y$na#[$na~Of$na#|$na~P$%`O|)zO!P){Oj$pa(o$pa(p$pa!Y$pa#[$pa~Of$pa#|$pa~P$&RO#g0^O~Of%Oa!Y%Oa#[%Oa#|%Oa~P!0}O!d#uO~O#g0aO~O!Y+TO`(za'r(za~O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!qiZ!qin!qi!Y!qi!h!qi!o!qi#j!qi#k!qi#l!qi#m!qi#n!qi#o!qi#p!qi#q!qi#r!qi#t!qi#v!qi#x!qi#y!qi(h!qi(o!qi(p!qi~O`!qi'r!qi'p!qi!V!qi!j!qir!qi![!qi%c!qi!d!qi~P$'pOg%VOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'}TO(QUO(X$uO(o$}O(p%PO~Ol0kO'{0jO~P$*ZO!d+`O`(Ta![(Ta'r(Ta!Y(Ta~O#g0qO~OZ[X!YeX!ZeX~O!Y0rO!Z)OX~O!Z0tO~OZ0uO~Oa0wO'{+hO'}TO(QUO~O![%{O'{%dO_'nX!Y'nX~O!Y+mO_(}a~O!j0zO~P!8dOZ0}O~O_1OO~O#[1RO~Oj1UO![$|O~O([(xO!Z({P~Og%VOj1_O![1[O%c1^O~OZ1iO!Y1gO!Z(|X~O!Z1jO~O_1lO`%kO'r%kO~O'{#mO'}TO(QUO~O#[$eO$O$eOP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X~O#r1oO&T1pO`(^X!i(^X~P$/qO#[$eO#r1oO&T1pO~O`1rO~P%[O`1tO~O&^1wOP&[iQ&[iR&[iX&[i`&[ic&[id&[il&[in&[io&[ip&[iv&[ix&[iz&[i!P&[i!T&[i!U&[i![&[i!f&[i!k&[i!n&[i!o&[i!p&[i!r&[i!t&[i!w&[i!{&[i#s&[i$T&[i%b&[i%d&[i%f&[i%g&[i%h&[i%k&[i%m&[i%p&[i%q&[i%s&[i&P&[i&V&[i&X&[i&Z&[i&]&[i&`&[i&f&[i&l&[i&n&[i&p&[i&r&[i&t&[i'p&[i'{&[i'}&[i(Q&[i(X&[i(g&[i(t&[i!Z&[ia&[i&c&[i~Oa1}O!Z1{O&c1|O~P`O![XO!k2PO~O&j,pOP&eiQ&eiR&eiX&ei`&eic&eid&eil&ein&eio&eip&eiv&eix&eiz&ei!P&ei!T&ei!U&ei![&ei!f&ei!k&ei!n&ei!o&ei!p&ei!r&ei!t&ei!w&ei!{&ei#s&ei$T&ei%b&ei%d&ei%f&ei%g&ei%h&ei%k&ei%m&ei%p&ei%q&ei%s&ei&P&ei&V&ei&X&ei&Z&ei&]&ei&`&ei&f&ei&l&ei&n&ei&p&ei&r&ei&t&ei'p&ei'{&ei'}&ei(Q&ei(X&ei(g&ei(t&ei!Z&ei&^&eia&ei&c&ei~O!V2VO~O!Y!^a!Z!^a~P#C|Oo!nO!P!oO!X2]O([!mO!Y'QX!Z'QX~P@UO!Y-QO!Z(`a~O!Y'WX!Z'WX~P!7lO!Y-TO!Z(na~O!Z2dO~P'_O`%kO#[2mO'r%kO~O`%kO!d#uO#[2mO'r%kO~O`%kO!d#uO!o2qO#[2mO'r%kO(h'kO~O`%kO'r%kO~P!8dO!Y$aOr$ma~O!V'Pi!Y'Pi~P!8dO!Y(PO!V(_i~O!Y(WO!V(li~O!V(mi!Y(mi~P!8dO!Y(ji!j(ji`(ji'r(ji~P!8dO#[2sO!Y(ji!j(ji`(ji'r(ji~O!Y(dO!j(ii~O!P%eO![%fO!{]O#e2xO#f2wO'{%dO~O!P%eO![%fO#f2wO'{%dO~Oj3PO!['ZO%c3OO~Og%VOj3PO!['ZO%c3OO~O#g%ZaP%ZaZ%Za`%Zan%Za}%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za'r%Za(X%Za(h%Za!j%Za!V%Za'p%Zar%Za![%Za%c%Za!d%Za~P#L^O#g%]aP%]aZ%]a`%]an%]a}%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a'r%]a(X%]a(h%]a!j%]a!V%]a'p%]ar%]a![%]a%c%]a!d%]a~P#MPO#g%ZaP%ZaZ%Za`%Zan%Za}%Za!Y%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za'r%Za(X%Za(h%Za!j%Za!V%Za'p%Za#[%Zar%Za![%Za%c%Za!d%Za~P#-]O#g%]aP%]aZ%]a`%]an%]a}%]a!Y%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a'r%]a(X%]a(h%]a!j%]a!V%]a'p%]a#[%]ar%]a![%]a%c%]a!d%]a~P#-]O#gyaPyaZya`yanya!hya!iya!kya!oya#jya#kya#lya#mya#nya#oya#pya#qya#rya#tya#vya#xya#yya'rya(Xya(hya!jya!Vya'pyarya![ya%cya!dya~P$$jO#g$naP$naZ$na`$nan$na}$na!h$na!i$na!k$na!o$na#j$na#k$na#l$na#m$na#n$na#o$na#p$na#q$na#r$na#t$na#v$na#x$na#y$na'r$na(X$na(h$na!j$na!V$na'p$nar$na![$na%c$na!d$na~P$%`O#g$paP$paZ$pa`$pan$pa}$pa!h$pa!i$pa!k$pa!o$pa#j$pa#k$pa#l$pa#m$pa#n$pa#o$pa#p$pa#q$pa#r$pa#t$pa#v$pa#x$pa#y$pa'r$pa(X$pa(h$pa!j$pa!V$pa'p$par$pa![$pa%c$pa!d$pa~P$&RO#g%OaP%OaZ%Oa`%Oan%Oa}%Oa!Y%Oa!h%Oa!i%Oa!k%Oa!o%Oa#j%Oa#k%Oa#l%Oa#m%Oa#n%Oa#o%Oa#p%Oa#q%Oa#r%Oa#t%Oa#v%Oa#x%Oa#y%Oa'r%Oa(X%Oa(h%Oa!j%Oa!V%Oa'p%Oa#[%Oar%Oa![%Oa%c%Oa!d%Oa~P#-]O`#_q!Y#_q'r#_q'p#_q!V#_q!j#_qr#_q![#_q%c#_q!d#_q~P!8dOf'RX!Y'RX~P!(SO!Y.iOf(ba~O!X3ZO!Y'SX!j'SX~P%[O!Y.lO!j(ca~O!Y.lO!j(ca~P!8dO!V3^O~O#|!ma!Z!ma~PKOO#|!ea!Y!ea!Z!ea~P#C|O#|!qa!Z!qa~P!:}O#|!sa!Z!sa~P!=hORfO![3pO$a3qO~O!Z3uO~Or3vO~P#-]O`$jq!Y$jq'r$jq'p$jq!V$jq!j$jqr$jq![$jq%c$jq!d$jq~P!8dO!V3wO~P#-]O|)zO!P){O(p%POj'ba(o'ba!Y'ba#['ba~Of'ba#|'ba~P%)eO|)zO!P){Oj'da(o'da(p'da!Y'da#['da~Of'da#|'da~P%*WO(h$ZO~P#-]O!X3zO'{%dO!Y'^X!j'^X~O!Y/cO!j(ua~O!Y/cO!d#uO!j(ua~O!Y/cO!d#uO(h'kO!j(ua~Of$wi!Y$wi#[$wi#|$wi~P!0}O!X4SO'{*]O!V'`X!Y'`X~P!1lO!Y/kO!V(va~O!Y/kO!V(va~P#-]O!d#uO#r4[O~On4_O!d#uO(h'kO~O(o$}Oj%Zi|%Zi!P%Zi(p%Zi!Y%Zi#[%Zi~Of%Zi#|%Zi~P%-jO(p%POj%]i|%]i!P%]i(o%]i!Y%]i#[%]i~Of%]i#|%]i~P%.]Of(Vi!Y(Vi~P!0}O#[4fOf(Vi!Y(Vi~P!0}O!j4iO~O`$kq!Y$kq'r$kq'p$kq!V$kq!j$kqr$kq![$kq%c$kq!d$kq~P!8dO!V4mO~O!Y4nO![(wX~P#-]O!i#wO~P4XO`$uX![$uX%W[X'r$uX!Y$uX~P!/tO%W4pO`kXjkX|kX!PkX![kX'rkX(okX(pkX!YkX~O%W4pO~Oa4vO%d4wO'{+hO'}TO(QUO!Y'mX!Z'mX~O!Y0rO!Z)Oa~OZ4{O~O_4|O~O`%kO'r%kO~P#-]O![$|O~P#-]O!Y5UO#[5WO!Z({X~O!Z5XO~Oo!nO!P5YO!_!xO!`!uO!a!uO!{:dO#P!pO#Q!pO#R!pO#S!pO#T!pO#W5_O#X!yO'|!lO'}TO(QUO([!mO(g!sO~O!Z5^O~P%3nOj5dO![1[O%c5cO~Og%VOj5dO![1[O%c5cO~Oa5kO'{#mO'}TO(QUO!Y'lX!Z'lX~O!Y1gO!Z(|a~O'}TO(QUO([5mO~O_5qO~O#r5tO&T5uO~PMnO!j5vO~P%[O`5xO~O`5xO~P%[Oa1}O!Z5}O&c1|O~P`O!d6PO~O!d6ROg(ai!Y(ai!Z(ai!d(ai!k(ai~O!Y#di!Z#di~P#C|O#[6SO!Y#di!Z#di~O!Y!^i!Z!^i~P#C|O`%kO#[6]O'r%kO~O`%kO!d#uO#[6]O'r%kO~O!Y(jq!j(jq`(jq'r(jq~P!8dO!Y(dO!j(iq~O!P%eO![%fO#f6dO'{%dO~O!['ZO%c6gO~Oj6jO!['ZO%c6gO~O#g'baP'baZ'ba`'ban'ba}'ba!h'ba!i'ba!k'ba!o'ba#j'ba#k'ba#l'ba#m'ba#n'ba#o'ba#p'ba#q'ba#r'ba#t'ba#v'ba#x'ba#y'ba'r'ba(X'ba(h'ba!j'ba!V'ba'p'bar'ba!['ba%c'ba!d'ba~P%)eO#g'daP'daZ'da`'dan'da}'da!h'da!i'da!k'da!o'da#j'da#k'da#l'da#m'da#n'da#o'da#p'da#q'da#r'da#t'da#v'da#x'da#y'da'r'da(X'da(h'da!j'da!V'da'p'dar'da!['da%c'da!d'da~P%*WO#g$wiP$wiZ$wi`$win$wi}$wi!Y$wi!h$wi!i$wi!k$wi!o$wi#j$wi#k$wi#l$wi#m$wi#n$wi#o$wi#p$wi#q$wi#r$wi#t$wi#v$wi#x$wi#y$wi'r$wi(X$wi(h$wi!j$wi!V$wi'p$wi#[$wir$wi![$wi%c$wi!d$wi~P#-]O#g%ZiP%ZiZ%Zi`%Zin%Zi}%Zi!h%Zi!i%Zi!k%Zi!o%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#p%Zi#q%Zi#r%Zi#t%Zi#v%Zi#x%Zi#y%Zi'r%Zi(X%Zi(h%Zi!j%Zi!V%Zi'p%Zir%Zi![%Zi%c%Zi!d%Zi~P%-jO#g%]iP%]iZ%]i`%]in%]i}%]i!h%]i!i%]i!k%]i!o%]i#j%]i#k%]i#l%]i#m%]i#n%]i#o%]i#p%]i#q%]i#r%]i#t%]i#v%]i#x%]i#y%]i'r%]i(X%]i(h%]i!j%]i!V%]i'p%]ir%]i![%]i%c%]i!d%]i~P%.]Of'Ra!Y'Ra~P!0}O!Y'Sa!j'Sa~P!8dO!Y.lO!j(ci~O#|#_i!Y#_i!Z#_i~P#C|OP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O(XVOZ#iin#ii!h#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~O#j#ii~P%FnO#j:lO~P%FnOP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO(XVOZ#ii!h#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~On#ii~P%HyOn:nO~P%HyOP$]On:nO|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO(XVO#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~OZ#ii!h#ii#o#ii#p#ii#q#ii#r#ii~P%KUOZ:zO!h:pO#o:pO#p:pO#q:yO#r:pO~P%KUOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO(XVO(p#}O#x#ii#y#ii#|#ii(h#ii(o#ii!Y#ii!Z#ii~O#v:sO~P%MpO#v#ii~P%MpOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO(XVO#x#ii#y#ii#|#ii(h#ii!Y#ii!Z#ii~O#v#ii(o#ii(p#ii~P& {O#v:sO(o#|O(p#}O~P& {OP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO#v:sO#x:uO(XVO(o#|O(p#}O~O#y#ii#|#ii(h#ii!Y#ii!Z#ii~P&$^O`#zy!Y#zy'r#zy'p#zy!V#zy!j#zyr#zy![#zy%c#zy!d#zy~P!8dOj<gO|)zO!P){O(o$}O(p%PO~OP#iiZ#iin#ii}#ii!h#ii!i#ii!k#ii!o#ii#j#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(X#ii(h#ii!Y#ii!Z#ii~P&'UO!i#wOP(WXZ(WXj(WXn(WX|(WX}(WX!P(WX!h(WX!k(WX!o(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#p(WX#q(WX#r(WX#t(WX#v(WX#x(WX#y(WX#|(WX(X(WX(h(WX(o(WX(p(WX!Y(WX!Z(WX~O#|#}i!Y#}i!Z#}i~P#C|O#|!qi!Z!qi~P$'pO!Z6|O~O!Y']a!Z']a~P#C|O!d#uO(h'kO!Y'^a!j'^a~O!Y/cO!j(ui~O!Y/cO!d#uO!j(ui~Of$wq!Y$wq#[$wq#|$wq~P!0}O!V'`a!Y'`a~P#-]O!d7TO~O!Y/kO!V(vi~P#-]O!Y/kO!V(vi~O!V7XO~O!d#uO#r7^O~On7_O!d#uO(h'kO~O|)zO!P){O(p%POj'ca(o'ca!Y'ca#['ca~Of'ca#|'ca~P&.fO|)zO!P){Oj'ea(o'ea(p'ea!Y'ea#['ea~Of'ea#|'ea~P&/XO!V7aO~Of$yq!Y$yq#[$yq#|$yq~P!0}O`$ky!Y$ky'r$ky'p$ky!V$ky!j$kyr$ky![$ky%c$ky!d$ky~P!8dO!d6RO~O!Y4nO![(wa~O`#_y!Y#_y'r#_y'p#_y!V#_y!j#_yr#_y![#_y%c#_y!d#_y~P!8dOZ7fO~Oa7hO'{+hO'}TO(QUO~O!Y0rO!Z)Oi~O_7lO~O([(xO!Y'iX!Z'iX~O!Y5UO!Z({a~OlkO'{7sO~P.iO!Z7vO~P%3nOo!nO!P7wO'}TO(QUO([!mO(g!sO~O![1[O~O![1[O%c7yO~Oj7|O![1[O%c7yO~OZ8RO!Y'la!Z'la~O!Y1gO!Z(|i~O!j8VO~O!j8WO~O!j8ZO~O!j8ZO~P%[O`8]O~O!d8^O~O!j8_O~O!Y(mi!Z(mi~P#C|O`%kO#[8gO'r%kO~O!Y(jy!j(jy`(jy'r(jy~P!8dO!Y(dO!j(iy~O!['ZO%c8jO~O#g$wqP$wqZ$wq`$wqn$wq}$wq!Y$wq!h$wq!i$wq!k$wq!o$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#p$wq#q$wq#r$wq#t$wq#v$wq#x$wq#y$wq'r$wq(X$wq(h$wq!j$wq!V$wq'p$wq#[$wqr$wq![$wq%c$wq!d$wq~P#-]O#g'caP'caZ'ca`'can'ca}'ca!h'ca!i'ca!k'ca!o'ca#j'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#q'ca#r'ca#t'ca#v'ca#x'ca#y'ca'r'ca(X'ca(h'ca!j'ca!V'ca'p'car'ca!['ca%c'ca!d'ca~P&.fO#g'eaP'eaZ'ea`'ean'ea}'ea!h'ea!i'ea!k'ea!o'ea#j'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#t'ea#v'ea#x'ea#y'ea'r'ea(X'ea(h'ea!j'ea!V'ea'p'ear'ea!['ea%c'ea!d'ea~P&/XO#g$yqP$yqZ$yq`$yqn$yq}$yq!Y$yq!h$yq!i$yq!k$yq!o$yq#j$yq#k$yq#l$yq#m$yq#n$yq#o$yq#p$yq#q$yq#r$yq#t$yq#v$yq#x$yq#y$yq'r$yq(X$yq(h$yq!j$yq!V$yq'p$yq#[$yqr$yq![$yq%c$yq!d$yq~P#-]O!Y'Si!j'Si~P!8dO#|#_q!Y#_q!Z#_q~P#C|O(o$}OP%ZaZ%Zan%Za}%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za#|%Za(X%Za(h%Za!Y%Za!Z%Za~Oj%Za|%Za!P%Za(p%Za~P&@nO(p%POP%]aZ%]an%]a}%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a#|%]a(X%]a(h%]a!Y%]a!Z%]a~Oj%]a|%]a!P%]a(o%]a~P&BuOj<gO|)zO!P){O(p%PO~P&@nOj<gO|)zO!P){O(o$}O~P&BuO|0ZO}0ZO!P0[OPyaZyajyanya!hya!iya!kya!oya#jya#kya#lya#mya#nya#oya#pya#qya#rya#tya#vya#xya#yya#|ya(Xya(hya(oya(pya!Yya!Zya~O|)zO!P){OP$naZ$naj$nan$na}$na!h$na!i$na!k$na!o$na#j$na#k$na#l$na#m$na#n$na#o$na#p$na#q$na#r$na#t$na#v$na#x$na#y$na#|$na(X$na(h$na(o$na(p$na!Y$na!Z$na~O|)zO!P){OP$paZ$paj$pan$pa}$pa!h$pa!i$pa!k$pa!o$pa#j$pa#k$pa#l$pa#m$pa#n$pa#o$pa#p$pa#q$pa#r$pa#t$pa#v$pa#x$pa#y$pa#|$pa(X$pa(h$pa(o$pa(p$pa!Y$pa!Z$pa~OP%OaZ%Oan%Oa}%Oa!h%Oa!i%Oa!k%Oa!o%Oa#j%Oa#k%Oa#l%Oa#m%Oa#n%Oa#o%Oa#p%Oa#q%Oa#r%Oa#t%Oa#v%Oa#x%Oa#y%Oa#|%Oa(X%Oa(h%Oa!Y%Oa!Z%Oa~P&'UO#|$jq!Y$jq!Z$jq~P#C|O#|$kq!Y$kq!Z$kq~P#C|O!Z8vO~O#|8wO~P!0}O!d#uO!Y'^i!j'^i~O!d#uO(h'kO!Y'^i!j'^i~O!Y/cO!j(uq~O!V'`i!Y'`i~P#-]O!Y/kO!V(vq~O!V8}O~P#-]O!V8}O~Of(Vy!Y(Vy~P!0}O!Y'ga!['ga~P#-]O`%Vq![%Vq'r%Vq!Y%Vq~P#-]OZ9SO~O!Y0rO!Z)Oq~O#[9WO!Y'ia!Z'ia~O!Y5UO!Z({i~P#C|OP[XZ[Xn[X|[X}[X!P[X!V[X!Y[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X~O!d%TX#r%TX~P'#`O![1[O%c9[O~O'}TO(QUO([9aO~O!Y1gO!Z(|q~O!j9dO~O!j9eO~O!j9fO~O!j9fO~P%[O#[9iO!Y#dy!Z#dy~O!Y#dy!Z#dy~P#C|O!['ZO%c9nO~O#|#zy!Y#zy!Z#zy~P#C|OP$wiZ$win$wi}$wi!h$wi!i$wi!k$wi!o$wi#j$wi#k$wi#l$wi#m$wi#n$wi#o$wi#p$wi#q$wi#r$wi#t$wi#v$wi#x$wi#y$wi#|$wi(X$wi(h$wi!Y$wi!Z$wi~P&'UO|)zO!P){O(p%POP'baZ'baj'ban'ba}'ba!h'ba!i'ba!k'ba!o'ba#j'ba#k'ba#l'ba#m'ba#n'ba#o'ba#p'ba#q'ba#r'ba#t'ba#v'ba#x'ba#y'ba#|'ba(X'ba(h'ba(o'ba!Y'ba!Z'ba~O|)zO!P){OP'daZ'daj'dan'da}'da!h'da!i'da!k'da!o'da#j'da#k'da#l'da#m'da#n'da#o'da#p'da#q'da#r'da#t'da#v'da#x'da#y'da#|'da(X'da(h'da(o'da(p'da!Y'da!Z'da~O(o$}OP%ZiZ%Zij%Zin%Zi|%Zi}%Zi!P%Zi!h%Zi!i%Zi!k%Zi!o%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#p%Zi#q%Zi#r%Zi#t%Zi#v%Zi#x%Zi#y%Zi#|%Zi(X%Zi(h%Zi(p%Zi!Y%Zi!Z%Zi~O(p%POP%]iZ%]ij%]in%]i|%]i}%]i!P%]i!h%]i!i%]i!k%]i!o%]i#j%]i#k%]i#l%]i#m%]i#n%]i#o%]i#p%]i#q%]i#r%]i#t%]i#v%]i#x%]i#y%]i#|%]i(X%]i(h%]i(o%]i!Y%]i!Z%]i~O#|$ky!Y$ky!Z$ky~P#C|O#|#_y!Y#_y!Z#_y~P#C|O!d#uO!Y'^q!j'^q~O!Y/cO!j(uy~O!V'`q!Y'`q~P#-]O!V9wO~P#-]O!Y0rO!Z)Oy~O!Y5UO!Z({q~O![1[O%c:OO~O!j:RO~O!['ZO%c:WO~OP$wqZ$wqn$wq}$wq!h$wq!i$wq!k$wq!o$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#p$wq#q$wq#r$wq#t$wq#v$wq#x$wq#y$wq#|$wq(X$wq(h$wq!Y$wq!Z$wq~P&'UO|)zO!P){O(p%POP'caZ'caj'can'ca}'ca!h'ca!i'ca!k'ca!o'ca#j'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#q'ca#r'ca#t'ca#v'ca#x'ca#y'ca#|'ca(X'ca(h'ca(o'ca!Y'ca!Z'ca~O|)zO!P){OP'eaZ'eaj'ean'ea}'ea!h'ea!i'ea!k'ea!o'ea#j'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#t'ea#v'ea#x'ea#y'ea#|'ea(X'ea(h'ea(o'ea(p'ea!Y'ea!Z'ea~OP$yqZ$yqn$yq}$yq!h$yq!i$yq!k$yq!o$yq#j$yq#k$yq#l$yq#m$yq#n$yq#o$yq#p$yq#q$yq#r$yq#t$yq#v$yq#x$yq#y$yq#|$yq(X$yq(h$yq!Y$yq!Z$yq~P&'UOf%_!Z!Y%_!Z#[%_!Z#|%_!Z~P!0}O!Y'iq!Z'iq~P#C|O!Y#d!Z!Z#d!Z~P#C|O#g%_!ZP%_!ZZ%_!Z`%_!Zn%_!Z}%_!Z!Y%_!Z!h%_!Z!i%_!Z!k%_!Z!o%_!Z#j%_!Z#k%_!Z#l%_!Z#m%_!Z#n%_!Z#o%_!Z#p%_!Z#q%_!Z#r%_!Z#t%_!Z#v%_!Z#x%_!Z#y%_!Z'r%_!Z(X%_!Z(h%_!Z!j%_!Z!V%_!Z'p%_!Z#[%_!Zr%_!Z![%_!Z%c%_!Z!d%_!Z~P#-]OP%_!ZZ%_!Zn%_!Z}%_!Z!h%_!Z!i%_!Z!k%_!Z!o%_!Z#j%_!Z#k%_!Z#l%_!Z#m%_!Z#n%_!Z#o%_!Z#p%_!Z#q%_!Z#r%_!Z#t%_!Z#v%_!Z#x%_!Z#y%_!Z#|%_!Z(X%_!Z(h%_!Z!Y%_!Z!Z%_!Z~P&'UOr(]X~P1qO'|!lO~P!*fO!VeX!YeX#[eX~P'#`OP[XZ[Xn[X|[X}[X!P[X!Y[X!YeX!h[X!i[X!k[X!o[X#[[X#[eX#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X~O!deX!j[X!jeX(heX~P'ASOP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![XO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'{)YO'}TO(QUO(XVO(g[O(t<YO~O!Y:wO!Z$ma~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;RO!P${O![$|O!f<aO!k$xO#f;XO$T%^O$o;TO$q;VO$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~O#s)aO~P'ExO!Z[X!ZeX~P'ASO#g:kO~O!d#uO#g:kO~O#[:{O~O#r:pO~O#[;ZO!Y(mX!Z(mX~O#[:{O!Y(kX!Z(kX~O#g;[O~Of;^O~P!0}O#g;cO~O#g;dO~O!d#uO#g;eO~O!d#uO#g;[O~O#|;fO~P#C|O#g;gO~O#g;hO~O#g;mO~O#g;nO~O#g;oO~O#g;pO~O#|;qO~P!0}O#|;rO~P!0}O!i#P#Q#S#T#W#e#f#q(t$o$q$t%W%b%c%d%k%m%p%q%s%u~'vS#k!U't'|#lo#j#mn|'u$Y'u'{$[([~",
  goto: "$2p)SPPPPP)TPP)WP)iP*x.|PPPP5pPP6WPP<S?gP?zP?zPPP?zPAxP?zP?zP?zPA|PPBRPBlPGdPPPGhPPPPGhJiPPPJoKjPGhPMxPPPP!!WGhPPPGhPGhP!$fGhP!'z!(|!)VP!)y!)}!)yPPPPP!-Y!(|PP!-v!.pP!1dGhGh!1i!4s!9Y!9Y!=OPPP!=VGhPPPPPPPPPPP!@dP!AqPPGh!CSPGhPGhGhGhGhPGh!DfP!GnP!JrP!Jv!KQ!KU!KUP!GkP!KY!KYP!N^P!NbGhGh!Nh##k?zP?zP?z?zP#$v?z?z#'O?z#)k?z#+m?z?z#,[#.f#.f#.j#.r#.f#.zP#.fP?z#/d?z#3R?z?z5pPPP#6vPPP#7a#7aP#7aP#7w#7aPP#7}P#7tP#7t#8b#7t#8|#9S5m)W#9V)WP#9^#9^#9^P)WP)WP)WP)WPP)WP#9d#9gP#9g)WP#9kP#9nP)WP)WP)WP)WP)WP)W)WPP#9t#9z#:V#:]#:c#:i#:o#:}#;T#;Z#;e#;k#;u#<U#<[#<|#=`#=f#=l#=z#>a#@O#@^#@d#Ax#BW#Cr#DQ#DW#D^#Dd#Dn#Dt#Dz#EU#Eh#EnPPPPPPPPPP#EtPPPPPPP#Fi#Ip#KP#KW#K`PPPP$!d$%Z$+r$+u$+x$,q$,t$,w$-O$-WPP$-^$-b$.Y$/X$/]$/qPP$/u$/{$0PP$0S$0W$0Z$1P$1h$2P$2T$2W$2Z$2a$2d$2h$2lR!{RoqOXst!Z#c%j&m&o&p&r,h,m1w1zY!uQ'Z-Y1[5]Q%pvQ%xyQ&P|Q&e!VS'R!e-QQ'a!iS'g!r!xS*c$|*hQ+f%yQ+s&RQ,X&_Q-W'YQ-b'bQ-j'hQ/|*jQ1f,YR;Y:g%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S,e,h,m-^-f-t-z.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3Z5Y5d5t5u5x6]7w7|8]8gS#p]:d!r)[$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q*u%ZQ+k%{Q,Z&bQ,b&jQ.c;QQ0h+^Q0l+`Q0w+lQ1n,`Q2{.[Q4v0rQ5k1gQ6i3PQ6u;RQ7h4wR8m6j&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]t!nQ!r!u!x!y'R'Y'Z'g'h'i-Q-W-Y-j1[5]5_$v$si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gQ&S|Q'P!eS'V%f-TQ+k%{Q,Z&bQ0]*yQ0w+lQ0|+rQ1m,_Q1n,`Q4v0rQ5P1OQ5k1gQ5n1iQ5o1lQ7h4wQ7k4|Q8U5qQ9V7lR9b8RrnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zR,]&f&v^OPXYstuvwz!Z!`!g!j!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O']'m(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<[<][#[WZ#V#Y'S'}!S%gm#g#h#k%b%e(W(b(c(d+Q+R+T,d,z-x.O.P.Q.S2P2w2x6R6dQ%sxQ%wyS%||&RQ&Y!TQ'^!hQ'`!iQ(k#rS*V$x*ZS+e%x%yQ+i%{Q,S&]Q,W&_S-a'a'bQ.^(lQ/g*WQ0p+fQ0v+lQ0x+mQ0{+qQ1a,TS1e,X,YQ2i-bQ3y/cQ4u0rQ4y0uQ5O0}Q5j1fQ7Q3zQ7g4wQ7j4{Q9R7fR9y9S!O$zi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c!S%uy!i!t%w%x%y'Q'`'a'b'f'p*b+e+f,}-a-b-i/t0p2b2i2p4^Q+_%sQ+x&VQ+{&WQ,V&_Q.](kQ1`,SU1d,W,X,YQ3Q.^Q5e1aS5i1e1fQ8Q5j#W<^#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<go<_:y:z:};P;T;V;X;`;b;d;h;j;l;n;rW%Ti%V*r<YS&V!Q&dQ&W!RQ&X!SR+v&T$w%Si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gT)v$u)wV*v%Z;Q;RU'V!e%f-TS(y#y#zQ+p&OS.V(g(hQ1V+|Q4g0ZR7p5U&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]$i$`c#X#d%n%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.t.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PT#SV#T&}kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q'T!eR2^-Qv!nQ!e!r!u!x!y'R'Y'Z'g'h'i-Q-W-Y-j1[5]5_S*b$|*hS/t*c*jQ/}*kQ1X,OQ4^/|R4a0PnqOXst!Z#c%j&m&o&p&r,h,m1w1zQ&t!^Q'q!wS(m#t:kQ+c%vQ,Q&YQ,R&[Q-_'_Q-l'jS.g(r;[S0`+O;eQ0n+dQ1Z,PQ2O,oQ2Q,pQ2Y,{Q2g-`Q2j-dS4l0a;oQ4q0oS4t0q;pQ6T2[Q6X2hQ6^2oQ7e4rQ8b6VQ8c6YQ8f6_R9h8_$d$_c#X#d%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PS(j#o'dU*o%R(q3mS+Y%n.tQ2|0hQ6f2{Q8l6iR9o8m$d$^c#X#d%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PS(i#o'dS({#z$_S+X%n.tS.W(h(jQ.w)]Q0e+YR2y.X&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]S#p]:dQ&o!XQ&p!YQ&r![Q&s!]R1v,kQ'[!hQ+[%sQ-]'^S.Y(k+_Q2e-[W2}.].^0g0iQ6W2fU6e2z2|3QS8i6f6hS9m8k8lS:U9l9oQ:^:VR:a:_U!vQ'Z-YT5Z1[5]!Q_OXZ`st!V!Z#c#g%b%j&d&f&m&o&p&r(d,h,m.P1w1z]!pQ!r'Z-Y1[5]T#p]:d%Y{OPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gS(y#y#zS.V(g(h!s;v$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Y!tQ'Z-Y1[5]Q'f!rS'p!u!xS'r!y5_S-i'g'hQ-k'iR2p-jQ'o!tS(`#f1qS-h'f'rQ/f*VQ/r*bQ2q-kQ4O/gS4X/s/}Q7P3yS7[4_4aQ8y7QR9Q7_Q#vbQ'n!tS(_#f1qS(a#l*}Q+P%cQ+a%tQ+g%zU-g'f'o'rQ-{(`Q/e*VQ/q*bQ/w*eQ0m+bQ1b,US2n-h-kQ2v.TS3}/f/gS4W/r/}Q4Z/vQ4]/xQ5g1cQ6`2qQ7O3yQ7S4OS7W4X4aQ7]4`Q8O5hS8x7P7QQ8|7XQ9O7[Q9_8PQ9u8yQ9v8}Q9x9QQ:Q9`Q:Y9wQ;y;tQ<U;}R<V<OV!vQ'Z-Y%YaOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gS#vz!j!r;s$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]R;y<[%YbOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gQ%cj!S%ty!i!t%w%x%y'Q'`'a'b'f'p*b+e+f,}-a-b-i/t0p2b2i2p4^S%zz!jQ+b%uQ,U&_W1c,V,W,X,YU5h1d1e1fS8P5i5jQ9`8Q!r;t$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q;}<ZR<O<[$|eOPXYstuvw!Z!`!g!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gY#aWZ#V#Y'}!S%gm#g#h#k%b%e(W(b(c(d+Q+R+T,d,z-x.O.P.Q.S2P2w2x6R6dQ,c&j!p;u$[$m)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]R;x'SS'W!e%fR2`-T%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S,e,h,m-^-f-t-z.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3Z5Y5d5t5u5x6]7w7|8]8g!r)[$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q,b&jQ0h+^Q2{.[Q6i3PR8m6j!b$Uc#X%n'|(S(n(u)W)X)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:e!P:r)Z)l-O.t2W2Z3_3i3j3n3t6U6p6y6z7r8a8n8t8u9{:S<P!f$Wc#X%n'|(S(n(u)T)U)W)X)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:e!T:t)Z)l-O.t2W2Z3_3f3g3i3j3n3t6U6p6y6z7r8a8n8t8u9{:S<P!^$[c#X%n'|(S(n(u)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:eQ3x/az<])Z)l-O.t2W2Z3_3n3t6U6p6y6z7r8a8n8t8u9{:S<PQ<b<dR<c<e&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]S$nh$oR3q.z'TgOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.z.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]T$jf$pQ$hfS)e$k)iR)q$pT$if$pT)g$k)i'ThOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.z.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]T$nh$oQ$qhR)p$o%YjOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8g!s<Z$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]#clOPXZst!Z!`!o#R#c#n#{$m%j&f&i&j&m&o&p&r&v'O'](z)n+S+^,e,h,m-^.[.{0[1_1o1p1r1t1w1z1|3P3p5Y5d5t5u5x6j7w7|8]!O%Ri#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c#W(q#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gQ*z%_Q/W)zo3m:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!O$yi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cQ*[$zS*e$|*hQ*{%`Q/x*f#W;{#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn;|:y:z:};P;T;V;X;`;b;d;h;j;l;n;rQ<Q<^Q<R<_Q<S<`R<T<a!O%Ri#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c#W(q#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<go3m:y:z:};P;T;V;X;`;b;d;h;j;l;n;rnoOXst!Z#c%j&m&o&p&r,h,m1w1zQ*_${Q,v&yQ,w&{R4R/k$v%Si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gQ+y&WQ1T+{Q5S1SR7o5TT*g$|*hS*g$|*hT5[1[5]S/v*d5YT4`0O7wQ+a%tQ/w*eQ0m+bQ1b,UQ5g1cQ8O5hQ9_8PR:Q9`!O%Oi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cr)}$v(s*O*n*|/i0U0V3W4P4j6}7`9t;z<W<XS0Q*m0R#W:|#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn:}:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!^;_(o)`*U*^._.b.f/S/X/a/n0f1Q1S3T4Q4U5R5T6k6n7U7Y7b7d8{9P:X<d<e`;`3l6q6t6x8o9p9s:bS;i.a3UT;j6s8r!O%Qi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cv*P$v(s*Q*m*|/]/i0U0V3W4P4b4j6}7`9t;z<W<XS0S*n0T#W;O#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn;P:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!b;a(o)`*U*^.`.a.f/S/X/a/n0f1Q1S3R3T4Q4U5R5T6k6l6n7U7Y7b7d8{9P:X<d<ed;b3l6r6s6x8o8p9p9q9s:bS;k.b3VT;l6t8srnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zQ&a!UR,e&jrnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zR&a!UQ+}&XR1P+vsnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zQ1],SS5b1`1aU7x5`5a5eS9Z7z7{S9|9Y9]Q:Z9}R:`:[Q&h!VR,^&dR5n1iS%||&RR0x+mQ&m!WR,h&nR,n&sT1x,m1zR,r&tQ,q&tR2R,rQ't!zR-n'tSsOtQ#cXT%ms#cQ!}TR'v!}Q#QUR'x#QQ)w$uR/T)wQ#TVR'z#TQ#WWU(Q#W(R-uQ(R#XR-u(SQ-R'TR2_-RQ.j(sR3X.jQ.m(uS3[.m3]R3].nQ-Y'ZR2c-YY!rQ'Z-Y1[5]R'e!rS#^W%eU(X#^(Y-vQ(Y#_R-v(TQ-U'WR2a-Ut`OXst!V!Z#c%j&d&f&m&o&p&r,h,m1w1zS#gZ%bU#q`#g.PR.P(dQ(e#iQ-|(aW.U(e-|2t6bQ2t-}R6b2uQ)i$kR.|)iQ$ohR)o$oQ$bcU)_$b-q:xQ-q:eR:x)lQ/d*VW3{/d3|7R8zU3|/e/f/gS7R3}4OR8z7S$X)|$v(o(s)`*U*^*m*n*w*x*|.a.b.d.e.f/S/X/]/_/a/i/n0U0V0f1Q1S3R3S3T3W3l4P4Q4U4b4d4j5R5T6k6l6m6n6s6t6v6w6x6}7U7Y7`7b7d8o8p8q8{9P9p9q9r9s9t:X:b;z<W<X<d<eQ/l*^U4T/l4V7VQ4V/nR7V4UQ*h$|R/z*hr*O$v(s*m*n*|/i0U0V3W4P4j6}7`9t;z<W<X!^._(o)`*U*^.a.b.f/S/X/a/n0f1Q1S3T4Q4U5R5T6k6n7U7Y7b7d8{9P:X<d<eU/^*O._6qa6q3l6s6t6x8o9p9s:bQ0R*mQ3U.aU4c0R3U8rR8r6sv*Q$v(s*m*n*|/]/i0U0V3W4P4b4j6}7`9t;z<W<X!b.`(o)`*U*^.a.b.f/S/X/a/n0f1Q1S3R3T4Q4U5R5T6k6l6n7U7Y7b7d8{9P:X<d<eU/`*Q.`6re6r3l6s6t6x8o8p9p9q9s:bQ0T*nQ3V.bU4e0T3V8sR8s6tQ*s%UR0X*sQ4o0fR7c4oQ+U%hR0d+UQ5V1VS7q5V9XR9X7rQ,P&YR1Y,PQ5]1[R7u5]Q1h,ZS5l1h8SR8S5nQ0s+iW4x0s4z7i9TQ4z0vQ7i4yR9T7jQ+n%|R0y+nQ1z,mR5|1zYrOXst#cQ&q!ZQ+W%jQ,g&mQ,i&oQ,j&pQ,l&rQ1u,hS1x,m1zR5{1wQ%lpQ&u!_Q&x!aQ&z!bQ&|!cQ'l!tQ+V%iQ+c%vQ+u&SQ,]&hQ,t&wW-e'f'n'o'rQ-l'jQ/y*gQ0n+dS1k,^,aQ2S,sQ2T,vQ2U,wQ2j-dW2l-g-h-k-mQ4q0oQ4}0|Q5Q1QQ5f1bQ5p1mQ5z1vU6Z2k2n2qQ6^2oQ7e4rQ7m5PQ7n5RQ7t5[Q7}5gQ8T5oS8d6[6`Q8f6_Q9U7kQ9^8OQ9c8UQ9j8eQ9z9VQ:P9_Q:T9kR:]:QQ%vyQ'_!iQ'j!tU+d%w%x%yQ,{'QU-`'`'a'bS-d'f'pQ/p*bS0o+e+fQ2[,}S2h-a-bQ2o-iQ4Y/tQ4r0pQ6V2bQ6Y2iQ6_2pR7Z4^S$wi<YR*t%VU%Ui%V<YR0W*rQ$viS(o#u+`Q(s#wS)`$c$dQ*U$xQ*^${Q*m%OQ*n%QQ*w%[Q*x%]Q*|%aQ.a:|Q.b;OQ.d;SQ.e;UQ.f;WQ/S)uS/X){/ZQ/])}Q/_*PQ/a*RQ/i*YQ/n*`Q0U*pQ0V*qh0f+].Z1^3O5c6g7y8j9[9n:O:WQ1Q+wQ1S+zQ3R;_Q3S;aQ3T;cQ3W.iS3l:y:zQ4P/jQ4Q/kQ4U/mQ4b0QQ4d0SQ4j0^Q5R1RQ5T1UQ6k;gQ6l;iQ6m;kQ6n;mQ6s:}Q6t;PQ6v;TQ6w;VQ6x;XQ6}3xQ7U4SQ7Y4[Q7`4fQ7b4nQ7d4pQ8o;dQ8p;`Q8q;bQ8{7TQ9P7^Q9p;hQ9q;jQ9r;lQ9s;nQ9t8wQ:X;qQ:b;rQ;z<YQ<W<bQ<X<cQ<d<fR<e<gnpOXst!Z#c%j&m&o&p&r,h,m1w1zQ!fPS#eZ#nQ&w!`U'c!o5Y7wQ'y#RQ(|#{Q)m$mS,a&f&iQ,f&jQ,s&vQ,x'OQ-[']Q.p(zQ/Q)nQ0b+SQ0i+^Q1s,eQ2f-^Q2|.[Q3s.{Q4h0[Q5a1_Q5r1oQ5s1pQ5w1rQ5y1tQ6O1|Q6f3PQ6{3pQ7{5dQ8X5tQ8Y5uQ8[5xQ8l6jQ9]7|R9g8]#WcOPXZst!Z!`!o#c#n#{%j&f&i&j&m&o&p&r&v'O'](z+S+^,e,h,m-^.[0[1_1o1p1r1t1w1z1|3P5Y5d5t5u5x6j7w7|8]Q#XWQ#dYQ%nuQ%ovS%qw!gS'|#V(PQ(S#YQ(n#tQ(u#xQ(}$OQ)O$PQ)P$QQ)Q$RQ)R$SQ)S$TQ)T$UQ)U$VQ)V$WQ)W$XQ)X$YQ)Z$[Q)^$aQ)b$eW)l$m)n.{3pQ+Z%pQ+o%}S-O'S2]Q-m'mS-r'}-tQ-w(VQ-y(^Q.h(rQ.n(vQ.r:cQ.t:fQ.u:gQ.v:jQ/V)yQ0_+OQ2W,yQ2Z,|Q2k-fQ2r-zQ3Y.lQ3_:kQ3`:lQ3a:mQ3b:nQ3c:oQ3d:pQ3e:qQ3f:rQ3g:sQ3h:tQ3i:uQ3j:vQ3k.sQ3n:{Q3o;YQ3t:wQ4k0aQ4s0qQ6U;ZQ6[2mQ6a2sQ6o3ZQ6p;[Q6y;^Q6z;eQ7r5WQ8a6SQ8e6]Q8n;fQ8t;oQ8u;pQ9k8gQ9{9WQ:S9iQ:e#RR<P<]R#ZWR'U!eY!tQ'Z-Y1[5]S'Q!e-QQ'f!rS'p!u!xS'r!y5_S,}'R'YS-i'g'hQ-k'iQ2b-WR2p-jR(t#wR(w#xQ!fQT-X'Z-Y]!qQ!r'Z-Y1[5]Q#o]R'd:dT#jZ%bS#iZ%bS%hm,dU(a#g#h#kS-}(b(cQ.R(dQ0c+TQ2u.OU2v.P.Q.SS6c2w2xR8h6d`#]W#V#Y%e'}(W+Q-xr#fZm#g#h#k%b(b(c(d+T.O.P.Q.S2w2x6dQ1q,dQ2X,zQ6Q2PQ8`6RT;w'S+RT#`W%eS#_W%eS(O#V(WS(T#Y+QS-P'S+RT-s'}-xT'X!e%fQ$kfR)s$pT)h$k)iR3r.zT*X$x*ZR*a${Q0g+]Q2z.ZQ5`1^Q6h3OQ7z5cQ8k6gQ9Y7yQ9l8jQ9}9[Q:V9nQ:[:OR:_:WnqOXst!Z#c%j&m&o&p&r,h,m1w1zQ&g!VR,]&dtmOXst!U!V!Z#c%j&d&m&o&p&r,h,m1w1zR,d&jT%im,dR1W+|R,[&bQ&Q|R+t&RR+j%{T&k!W&nT&l!W&nT1y,m1z",
  nodeNames: "âš  ArithOp ArithOp JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 371,
  context: y6,
  nodeProps: [
    ["isolate", -8, 4, 5, 13, 33, 35, 48, 50, 52, ""],
    ["group", -26, 8, 16, 18, 65, 201, 205, 209, 210, 212, 215, 218, 228, 230, 236, 238, 240, 242, 245, 251, 257, 259, 261, 263, 265, 267, 268, "Statement", -32, 12, 13, 28, 31, 32, 38, 48, 51, 52, 54, 59, 67, 75, 79, 81, 83, 84, 106, 107, 116, 117, 134, 137, 139, 140, 141, 142, 144, 145, 164, 165, 167, "Expression", -23, 27, 29, 33, 37, 39, 41, 168, 170, 172, 173, 175, 176, 177, 179, 180, 181, 183, 184, 185, 195, 197, 199, 200, "Type", -3, 87, 99, 105, "ClassItem"],
    ["openedBy", 22, "<", 34, "InterpolationStart", 53, "[", 57, "{", 72, "(", 157, "JSXStartCloseTag"],
    ["closedBy", 23, ">", 36, "InterpolationEnd", 47, "]", 58, "}", 73, ")", 162, "JSXEndTag"]
  ],
  propSources: [S6],
  skippedNodes: [0, 4, 5, 271],
  repeatNodeCount: 37,
  tokenData: "$Fj(CSR!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#8g!R![#:v![!]#Gv!]!^#IS!^!_#J^!_!`#Ns!`!a$#_!a!b$(l!b!c$,k!c!}Er!}#O$-u#O#P$/P#P#Q$4h#Q#R$5r#R#SEr#S#T$7P#T#o$8Z#o#p$<k#p#q$=a#q#r$>q#r#s$?}#s$f%Z$f$g+g$g#BYEr#BY#BZ$AX#BZ$ISEr$IS$I_$AX$I_$I|Er$I|$I}$Dd$I}$JO$Dd$JO$JTEr$JT$JU$AX$JU$KVEr$KV$KW$AX$KW&FUEr&FU&FV$AX&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AX?HUOEr(n%d_$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$f&j(R!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(R!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$f&j(OpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(OpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z(CS+rq$f&j(Op(R!b't(;dOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z(CS.ST(P#S$f&j'u(;dO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c(CS.n_$f&j(Op(R!b'u(;dOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`/x`$f&j!o$Ip(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S1V`#t$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S2d_#t$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/|3l_'}$(n$f&j(R!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$f&j(R!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$f&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$a`$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$a``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$a`$f&j(R!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(R!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$a`(R!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k#%|:hh$f&j(Op(R!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__VS$f&j(Op(R!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]VS$f&j(R!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXVS$f&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSVSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWVS(R!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]VS$f&j(OpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWVS(OpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYVS(Op(R!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S#%|C}i$f&j(g!L^(Op(R!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr#%|EoP;=`<%lCr(CSFRk$f&j(Op(R!b$Y#t'{&;d([!LYOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$f&j(Op(R!b$Y#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv(CSJPP;=`<%lEr%#SJ_`$f&j(Op(R!b#l$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SKl_$f&j$O$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&COLva(p&;`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SNW`$f&j#x$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/|! c_(Q$)`$f&j(OpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$f&j(OpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$f&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$a`$f&j(OpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(OpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$a`(OpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b(*Q!'t_!k(!b$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'l!)O_!jM|$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h!*[b$f&j(Op(R!b'|#)d#m$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S!+o`$f&j(Op(R!b#j$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&-O!,|`$f&j(Op(R!bn&%`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&C[!.Z_!Y&;l$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!/ec$f&j(Op(R!b|'<nOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!0ya$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!2Z_!XMt$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!3eg$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!5Vg$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!6wc$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!8_c$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!9uf$f&j(Op(R!b#k$IdOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpxz!;Zz{#,f{!P!;Z!P!Q#-{!Q!^!;Z!^!_#'Z!_!`#5k!`!a#7Q!a!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(r!;fb$f&j(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(Q!<w`$f&j(R!b!USOY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eb!Q!^!<n!^!_!GY!_!}!<n!}#O!Ja#O#P!Dj#P#o!<n#o#p!GY#p;'S!<n;'S;=`!Kj<%lO!<n&n!>Q^$f&j!USOY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@Y!_!}!=y!}#O!Bw#O#P!Dj#P#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!?Ta$f&j!USO!^&c!_#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&cS!@_X!USOY!@YZ!P!@Y!P!Q!@z!Q!}!@Y!}#O!Ac#O#P!Bb#P;'S!@Y;'S;=`!Bq<%lO!@YS!APU!US#Z#[!@z#]#^!@z#a#b!@z#g#h!@z#i#j!@z#m#n!@zS!AfVOY!AcZ#O!Ac#O#P!A{#P#Q!@Y#Q;'S!Ac;'S;=`!B[<%lO!AcS!BOSOY!AcZ;'S!Ac;'S;=`!B[<%lO!AcS!B_P;=`<%l!AcS!BeSOY!@YZ;'S!@Y;'S;=`!Bq<%lO!@YS!BtP;=`<%l!@Y&n!B|[$f&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#O!Bw#O#P!Cr#P#Q!=y#Q#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!CwX$f&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!DgP;=`<%l!Bw&n!DoX$f&jOY!=yYZ&cZ!^!=y!^!_!@Y!_#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!E_P;=`<%l!=y(Q!Eki$f&j(R!b!USOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#Z&}#Z#[!Eb#[#]&}#]#^!Eb#^#a&}#a#b!Eb#b#g&}#g#h!Eb#h#i&}#i#j!Eb#j#m&}#m#n!Eb#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!f!GaZ(R!b!USOY!GYZw!GYwx!@Yx!P!GY!P!Q!HS!Q!}!GY!}#O!Ic#O#P!Bb#P;'S!GY;'S;=`!JZ<%lO!GY!f!HZb(R!b!USOY'}Zw'}x#O'}#P#Z'}#Z#[!HS#[#]'}#]#^!HS#^#a'}#a#b!HS#b#g'}#g#h!HS#h#i'}#i#j!HS#j#m'}#m#n!HS#n;'S'};'S;=`(f<%lO'}!f!IhX(R!bOY!IcZw!Icwx!Acx#O!Ic#O#P!A{#P#Q!GY#Q;'S!Ic;'S;=`!JT<%lO!Ic!f!JWP;=`<%l!Ic!f!J^P;=`<%l!GY(Q!Jh^$f&j(R!bOY!JaYZ&cZw!Jawx!Bwx!^!Ja!^!_!Ic!_#O!Ja#O#P!Cr#P#Q!<n#Q#o!Ja#o#p!Ic#p;'S!Ja;'S;=`!Kd<%lO!Ja(Q!KgP;=`<%l!Ja(Q!KmP;=`<%l!<n'`!Ky`$f&j(Op!USOY!KpYZ&cZr!Kprs!=ys!P!Kp!P!Q!L{!Q!^!Kp!^!_!Ns!_!}!Kp!}#O##z#O#P!Dj#P#o!Kp#o#p!Ns#p;'S!Kp;'S;=`#%T<%lO!Kp'`!MUi$f&j(Op!USOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#Z(r#Z#[!L{#[#](r#]#^!L{#^#a(r#a#b!L{#b#g(r#g#h!L{#h#i(r#i#j!L{#j#m(r#m#n!L{#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rt!NzZ(Op!USOY!NsZr!Nsrs!@Ys!P!Ns!P!Q# m!Q!}!Ns!}#O#!|#O#P!Bb#P;'S!Ns;'S;=`##t<%lO!Nst# tb(Op!USOY)rZr)rs#O)r#P#Z)r#Z#[# m#[#])r#]#^# m#^#a)r#a#b# m#b#g)r#g#h# m#h#i)r#i#j# m#j#m)r#m#n# m#n;'S)r;'S;=`*Z<%lO)rt##RX(OpOY#!|Zr#!|rs!Acs#O#!|#O#P!A{#P#Q!Ns#Q;'S#!|;'S;=`##n<%lO#!|t##qP;=`<%l#!|t##wP;=`<%l!Ns'`#$R^$f&j(OpOY##zYZ&cZr##zrs!Bws!^##z!^!_#!|!_#O##z#O#P!Cr#P#Q!Kp#Q#o##z#o#p#!|#p;'S##z;'S;=`#$}<%lO##z'`#%QP;=`<%l##z'`#%WP;=`<%l!Kp(r#%fk$f&j(Op(R!b!USOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#Z%Z#Z#[#%Z#[#]%Z#]#^#%Z#^#a%Z#a#b#%Z#b#g%Z#g#h#%Z#h#i%Z#i#j#%Z#j#m%Z#m#n#%Z#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#W#'d](Op(R!b!USOY#'ZZr#'Zrs!GYsw#'Zwx!Nsx!P#'Z!P!Q#(]!Q!}#'Z!}#O#)w#O#P!Bb#P;'S#'Z;'S;=`#*w<%lO#'Z#W#(fe(Op(R!b!USOY*gZr*grs'}sw*gwx)rx#O*g#P#Z*g#Z#[#(]#[#]*g#]#^#(]#^#a*g#a#b#(]#b#g*g#g#h#(]#h#i*g#i#j#(]#j#m*g#m#n#(]#n;'S*g;'S;=`+Z<%lO*g#W#*OZ(Op(R!bOY#)wZr#)wrs!Icsw#)wwx#!|x#O#)w#O#P!A{#P#Q#'Z#Q;'S#)w;'S;=`#*q<%lO#)w#W#*tP;=`<%l#)w#W#*zP;=`<%l#'Z(r#+W`$f&j(Op(R!bOY#*}YZ&cZr#*}rs!Jasw#*}wx##zx!^#*}!^!_#)w!_#O#*}#O#P!Cr#P#Q!;Z#Q#o#*}#o#p#)w#p;'S#*};'S;=`#,Y<%lO#*}(r#,]P;=`<%l#*}(r#,cP;=`<%l!;Z(CS#,sb$f&j(Op(R!b'v(;d!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(CS#.W_$f&j(Op(R!bS(;dOY#-{YZ&cZr#-{rs#/Vsw#-{wx#2gx!^#-{!^!_#4f!_#O#-{#O#P#0X#P#o#-{#o#p#4f#p;'S#-{;'S;=`#5e<%lO#-{(Bb#/`]$f&j(R!bS(;dOY#/VYZ&cZw#/Vwx#0Xx!^#/V!^!_#1j!_#O#/V#O#P#0X#P#o#/V#o#p#1j#p;'S#/V;'S;=`#2a<%lO#/V(AO#0`X$f&jS(;dOY#0XYZ&cZ!^#0X!^!_#0{!_#o#0X#o#p#0{#p;'S#0X;'S;=`#1d<%lO#0X(;d#1QSS(;dOY#0{Z;'S#0{;'S;=`#1^<%lO#0{(;d#1aP;=`<%l#0{(AO#1gP;=`<%l#0X(<v#1qW(R!bS(;dOY#1jZw#1jwx#0{x#O#1j#O#P#0{#P;'S#1j;'S;=`#2Z<%lO#1j(<v#2^P;=`<%l#1j(Bb#2dP;=`<%l#/V(Ap#2p]$f&j(OpS(;dOY#2gYZ&cZr#2grs#0Xs!^#2g!^!_#3i!_#O#2g#O#P#0X#P#o#2g#o#p#3i#p;'S#2g;'S;=`#4`<%lO#2g(<U#3pW(OpS(;dOY#3iZr#3irs#0{s#O#3i#O#P#0{#P;'S#3i;'S;=`#4Y<%lO#3i(<U#4]P;=`<%l#3i(Ap#4cP;=`<%l#2g(=h#4oY(Op(R!bS(;dOY#4fZr#4frs#1jsw#4fwx#3ix#O#4f#O#P#0{#P;'S#4f;'S;=`#5_<%lO#4f(=h#5bP;=`<%l#4f(CS#5hP;=`<%l#-{%#W#5xb$f&j$O$Id(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z+h#7_b$W#t$f&j(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z$/l#8rp$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#U%Z#U#V#>Q#V#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#d#AY#d#l%Z#l#m#D[#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#;Rk$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#=R_$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#>Zd$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#?tf$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Acc$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Bye$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Deg$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#FXi$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#HT_!d$b$f&j#|%<f(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#I__`l$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^#Jk^g!*v!h'.r(Op(R!b(tSOY*gZr*grs'}sw*gwx)rx!P*g!P!Q#Kg!Q!^*g!^!_#L]!_!`#M}!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#KpX$h&j(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#LfZ#n$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#MX!`#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#MbX$O$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#NWX#o$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Gh$ Oa#[%?x$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$!T!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#W$!`_#g$Ih$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh$#nafBf#o$Id$c#|$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$$s!`!a$%}!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$%O_#o$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$&Ya#n$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$'_!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$'j`#n$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h$(wc(h$Ip$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P$*S!P!^%Z!^!_*g!_!a%Z!a!b$+^!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+`$*__}'#p$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$+i`$f&j#y$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&^$,v_!{!Ln$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^$.Q_!P(8n$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/UZ$f&jO!^$/w!^!_$0_!_#i$/w#i#j$0d#j#l$/w#l#m$2V#m#o$/w#o#p$0_#p;'S$/w;'S;=`$4b<%lO$/w(n$0OT^#S$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0dO^#S(n$0i[$f&jO!Q&c!Q![$1_![!^&c!_!c&c!c!i$1_!i#T&c#T#Z$1_#Z#o&c#o#p$3u#p;'S&c;'S;=`&w<%lO&c(n$1dZ$f&jO!Q&c!Q![$2V![!^&c!_!c&c!c!i$2V!i#T&c#T#Z$2V#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2[Z$f&jO!Q&c!Q![$2}![!^&c!_!c&c!c!i$2}!i#T&c#T#Z$2}#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3SZ$f&jO!Q&c!Q![$/w![!^&c!_!c&c!c!i$/w!i#T&c#T#Z$/w#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$3xR!Q![$4R!c!i$4R#T#Z$4R#S$4US!Q![$4R!c!i$4R#T#Z$4R#q#r$0_(n$4eP;=`<%l$/w!2r$4s_!V!+S$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$5}`#v$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&,v$7[_$f&j(Op(R!b(X&%WOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$8jk$f&j(Op(R!b'{&;d$[#t([!LYOY%ZYZ&cZr%Zrs&}st%Ztu$8Zuw%Zwx(rx}%Z}!O$:_!O!Q%Z!Q![$8Z![!^%Z!^!_*g!_!c%Z!c!}$8Z!}#O%Z#O#P&c#P#R%Z#R#S$8Z#S#T%Z#T#o$8Z#o#p*g#p$g%Z$g;'S$8Z;'S;=`$<e<%lO$8Z+d$:jk$f&j(Op(R!b$[#tOY%ZYZ&cZr%Zrs&}st%Ztu$:_uw%Zwx(rx}%Z}!O$:_!O!Q%Z!Q![$:_![!^%Z!^!_*g!_!c%Z!c!}$:_!}#O%Z#O#P&c#P#R%Z#R#S$:_#S#T%Z#T#o$:_#o#p*g#p$g%Z$g;'S$:_;'S;=`$<_<%lO$:_+d$<bP;=`<%l$:_(CS$<hP;=`<%l$8Z!5p$<tX![!3l(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g&CO$=la(o&;`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+^#q;'S%Z;'S;=`+a<%lO%Z%#`$?O_!Z$I`r`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(r$@Y_!pS$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$Aj|$f&j(Op(R!b't(;d$Y#t'{&;d([!LYOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$AX#BZ$ISEr$IS$I_$AX$I_$JTEr$JT$JU$AX$JU$KVEr$KV$KW$AX$KW&FUEr&FU&FV$AX&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AX?HUOEr(CS$Duk$f&j(Op(R!b'u(;d$Y#t'{&;d([!LYOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [v6, w6, $6, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, b6, new uu("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOt~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!R~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(Z~~", 141, 332), new uu("j~RQYZXz{^~^O'x~~aP!P!Qd~iO'y~~", 25, 315)],
  topRules: { Script: [0, 6], SingleExpression: [1, 269], SingleClassItem: [2, 270] },
  dialects: { jsx: 0, ts: 14614 },
  dynamicPrecedences: { 69: 1, 79: 1, 81: 1, 165: 1, 193: 1 },
  specialized: [{ term: 319, get: (t) => k6[t] || -1 }, { term: 334, get: (t) => _6[t] || -1 }, { term: 70, get: (t) => P6[t] || -1 }],
  tokenPrec: 14638
}), _2 = [
  /* @__PURE__ */ rr("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ rr("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ rr("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ rr("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ rr("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ rr(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ rr("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ rr(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ rr(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ rr('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ rr('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], T6 = /* @__PURE__ */ _2.concat([
  /* @__PURE__ */ rr("interface ${name} {\n	${}\n}", {
    label: "interface",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ rr("type ${name} = ${type}", {
    label: "type",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ rr("enum ${name} {\n	${}\n}", {
    label: "enum",
    detail: "definition",
    type: "keyword"
  })
]), g1 = /* @__PURE__ */ new Aw(), P2 = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function ua(t) {
  return (e, r) => {
    let n = e.node.getChild("VariableDefinition");
    return n && r(n, t), !0;
  };
}
const C6 = ["FunctionDeclaration"], Q6 = {
  FunctionDeclaration: /* @__PURE__ */ ua("function"),
  ClassDeclaration: /* @__PURE__ */ ua("class"),
  ClassExpression: () => !0,
  EnumDeclaration: /* @__PURE__ */ ua("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ ua("type"),
  NamespaceDeclaration: /* @__PURE__ */ ua("namespace"),
  VariableDefinition(t, e) {
    t.matchContext(C6) || e(t, "variable");
  },
  TypeDefinition(t, e) {
    e(t, "type");
  },
  __proto__: null
};
function x2(t, e) {
  let r = g1.get(e);
  if (r)
    return r;
  let n = [], i = !0;
  function s(o, a) {
    let l = t.sliceString(o.from, o.to);
    n.push({ label: l, type: a });
  }
  return e.cursor(Be.IncludeAnonymous).iterate((o) => {
    if (i)
      i = !1;
    else if (o.name) {
      let a = Q6[o.name];
      if (a && a(o, s) || P2.has(o.name))
        return !1;
    } else if (o.to - o.from > 8192) {
      for (let a of x2(t, o.node))
        n.push(a);
      return !1;
    }
  }), g1.set(e, n), n;
}
const O1 = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, T2 = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName",
  ".",
  "?."
];
function A6(t) {
  let e = Xt(t.state).resolveInner(t.pos, -1);
  if (T2.indexOf(e.name) > -1)
    return null;
  let r = e.name == "VariableName" || e.to - e.from < 20 && O1.test(t.state.sliceDoc(e.from, e.to));
  if (!r && !t.explicit)
    return null;
  let n = [];
  for (let i = e; i; i = i.parent)
    P2.has(i.name) && (n = n.concat(x2(t.state.doc, i)));
  return {
    options: n,
    from: r ? e.from : t.pos,
    validFor: O1
  };
}
const gn = /* @__PURE__ */ $i.define({
  name: "javascript",
  parser: /* @__PURE__ */ x6.configure({
    props: [
      /* @__PURE__ */ jo.add({
        IfStatement: /* @__PURE__ */ to({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ to({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: T4,
        SwitchBody: (t) => {
          let e = t.textAfter, r = /^\s*\}/.test(e), n = /^\s*(case|default)\b/.test(e);
          return t.baseIndent + (r ? 0 : n ? 1 : 2) * t.unit;
        },
        Block: /* @__PURE__ */ Ih({ closing: "}" }),
        ArrowFunction: (t) => t.baseIndent + t.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ to({ except: /^{/ }),
        JSXElement(t) {
          let e = /^\s*<\//.test(t.textAfter);
          return t.lineIndent(t.node.from) + (e ? 0 : t.unit);
        },
        JSXEscape(t) {
          let e = /\s*\}/.test(t.textAfter);
          return t.lineIndent(t.node.from) + (e ? 0 : t.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(t) {
          return t.column(t.node.from) + t.unit;
        }
      }),
      /* @__PURE__ */ yl.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": Gu,
        BlockComment(t) {
          return { from: t.from + 2, to: t.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), C2 = {
  test: (t) => /^JSX/.test(t.name),
  facet: /* @__PURE__ */ Zw({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
}, Q2 = /* @__PURE__ */ gn.configure({ dialect: "ts" }, "typescript"), A2 = /* @__PURE__ */ gn.configure({
  dialect: "jsx",
  props: [/* @__PURE__ */ hm.add((t) => t.isTop ? [C2] : void 0)]
}), E2 = /* @__PURE__ */ gn.configure({
  dialect: "jsx ts",
  props: [/* @__PURE__ */ hm.add((t) => t.isTop ? [C2] : void 0)]
}, "typescript");
let R2 = (t) => ({ label: t, type: "keyword" });
const I2 = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(R2), E6 = /* @__PURE__ */ I2.concat(/* @__PURE__ */ ["declare", "implements", "private", "protected", "public"].map(R2));
function R6(t = {}) {
  let e = t.jsx ? t.typescript ? E2 : A2 : t.typescript ? Q2 : gn, r = t.typescript ? T6.concat(E6) : _2.concat(I2);
  return new Ol(e, [
    gn.data.of({
      autocomplete: Y4(T2, Bw(r))
    }),
    gn.data.of({
      autocomplete: A6
    }),
    t.jsx ? Z6 : []
  ]);
}
function I6(t) {
  for (; ; ) {
    if (t.name == "JSXOpenTag" || t.name == "JSXSelfClosingTag" || t.name == "JSXFragmentTag")
      return t;
    if (t.name == "JSXEscape" || !t.parent)
      return null;
    t = t.parent;
  }
}
function y1(t, e, r = t.length) {
  for (let n = e == null ? void 0 : e.firstChild; n; n = n.nextSibling)
    if (n.name == "JSXIdentifier" || n.name == "JSXBuiltin" || n.name == "JSXNamespacedName" || n.name == "JSXMemberExpression")
      return t.sliceString(n.from, Math.min(n.to, r));
  return "";
}
const j6 = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), Z6 = /* @__PURE__ */ Se.inputHandler.of((t, e, r, n, i) => {
  if ((j6 ? t.composing : t.compositionStarted) || t.state.readOnly || e != r || n != ">" && n != "/" || !gn.isActiveAt(t.state, e, -1))
    return !1;
  let s = i(), { state: o } = s, a = o.changeByRange((l) => {
    var c;
    let { head: u } = l, d = Xt(o).resolveInner(u - 1, -1), f;
    if (d.name == "JSXStartTag" && (d = d.parent), !(o.doc.sliceString(u - 1, u) != n || d.name == "JSXAttributeValue" && d.to > u)) {
      if (n == ">" && d.name == "JSXFragmentTag")
        return { range: l, changes: { from: u, insert: "</>" } };
      if (n == "/" && d.name == "JSXStartCloseTag") {
        let h = d.parent, p = h.parent;
        if (p && h.from == u - 2 && ((f = y1(o.doc, p.firstChild, u)) || ((c = p.firstChild) === null || c === void 0 ? void 0 : c.name) == "JSXFragmentTag")) {
          let g = `${f}>`;
          return { range: ce.cursor(u + g.length, -1), changes: { from: u, insert: g } };
        }
      } else if (n == ">") {
        let h = I6(d);
        if (h && h.name == "JSXOpenTag" && !/^\/?>|^<\//.test(o.doc.sliceString(u, u + 2)) && (f = y1(o.doc, h, u)))
          return { range: l, changes: { from: u, insert: `</${f}>` } };
      }
    }
    return { range: l };
  });
  return a.changes.empty ? !1 : (t.dispatch([
    s,
    o.update(a, { userEvent: "input.complete", scrollIntoView: !0 })
  ]), !0);
}), da = ["_blank", "_self", "_top", "_parent"], df = ["ascii", "utf-8", "utf-16", "latin1", "latin1"], ff = ["get", "post", "put", "delete"], hf = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], lr = ["true", "false"], he = {}, M6 = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: da,
      hreflang: null
    }
  },
  abbr: he,
  address: he,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: he,
  aside: he,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: he,
  base: { attrs: { href: null, target: da } },
  bdi: he,
  bdo: he,
  blockquote: { attrs: { cite: null } },
  body: he,
  br: he,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: hf,
      formmethod: ff,
      formnovalidate: ["novalidate"],
      formtarget: da,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: he,
  center: he,
  cite: he,
  code: he,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: he,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: he,
  div: he,
  dl: he,
  dt: he,
  em: he,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: he,
  figure: he,
  footer: he,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": df,
      autocomplete: ["on", "off"],
      enctype: hf,
      method: ff,
      novalidate: ["novalidate"],
      target: da
    }
  },
  h1: he,
  h2: he,
  h3: he,
  h4: he,
  h5: he,
  h6: he,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: he,
  hgroup: he,
  hr: he,
  html: {
    attrs: { manifest: null }
  },
  i: he,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: hf,
      formmethod: ff,
      formnovalidate: ["novalidate"],
      formtarget: da,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: he,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: he,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: he,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: df,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: he,
  noscript: he,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: he,
  param: { attrs: { name: null, value: null } },
  pre: he,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: he,
  rt: he,
  ruby: he,
  samp: he,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: df
    }
  },
  section: he,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: he,
  source: { attrs: { src: null, type: null, media: null } },
  span: he,
  strong: he,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: he,
  summary: he,
  sup: he,
  table: he,
  tbody: he,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: he,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: he,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: he,
  time: { attrs: { datetime: null } },
  title: he,
  tr: he,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: he,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: he
}, j2 = {
  accesskey: null,
  class: null,
  contenteditable: lr,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: lr,
  autocorrect: lr,
  autocapitalize: lr,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": lr,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": lr,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": lr,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": lr,
  "aria-hidden": lr,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": lr,
  "aria-multiselectable": lr,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": lr,
  "aria-relevant": null,
  "aria-required": lr,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
}, Z2 = /* @__PURE__ */ "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map((t) => "on" + t);
for (let t of Z2)
  j2[t] = null;
let pu = class {
  constructor(e, r) {
    this.tags = Object.assign(Object.assign({}, M6), e), this.globalAttrs = Object.assign(Object.assign({}, j2), r), this.allTags = Object.keys(this.tags), this.globalAttrNames = Object.keys(this.globalAttrs);
  }
};
pu.default = /* @__PURE__ */ new pu();
function yo(t, e, r = t.length) {
  if (!e)
    return "";
  let n = e.firstChild, i = n && n.getChild("TagName");
  return i ? t.sliceString(i.from, Math.min(i.to, r)) : "";
}
function bo(t, e = !1) {
  for (; t; t = t.parent)
    if (t.name == "Element")
      if (e)
        e = !1;
      else
        return t;
  return null;
}
function M2(t, e, r) {
  let n = r.tags[yo(t, bo(e))];
  return (n == null ? void 0 : n.children) || r.allTags;
}
function Sm(t, e) {
  let r = [];
  for (let n = bo(e); n && !n.type.isTop; n = bo(n.parent)) {
    let i = yo(t, n);
    if (i && n.lastChild.name == "CloseTag")
      break;
    i && r.indexOf(i) < 0 && (e.name == "EndTag" || e.from >= n.firstChild.to) && r.push(i);
  }
  return r;
}
const q2 = /^[:\-\.\w\u00b7-\uffff]*$/;
function b1(t, e, r, n, i) {
  let s = /\s*>/.test(t.sliceDoc(i, i + 5)) ? "" : ">", o = bo(r, !0);
  return {
    from: n,
    to: i,
    options: M2(t.doc, o, e).map((a) => ({ label: a, type: "type" })).concat(Sm(t.doc, r).map((a, l) => ({
      label: "/" + a,
      apply: "/" + a + s,
      type: "type",
      boost: 99 - l
    }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
function v1(t, e, r, n) {
  let i = /\s*>/.test(t.sliceDoc(n, n + 5)) ? "" : ">";
  return {
    from: r,
    to: n,
    options: Sm(t.doc, e).map((s, o) => ({ label: s, apply: s + i, type: "type", boost: 99 - o })),
    validFor: q2
  };
}
function q6(t, e, r, n) {
  let i = [], s = 0;
  for (let o of M2(t.doc, r, e))
    i.push({ label: "<" + o, type: "type" });
  for (let o of Sm(t.doc, r))
    i.push({ label: "</" + o + ">", type: "type", boost: 99 - s++ });
  return { from: n, to: n, options: i, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function N6(t, e, r, n, i) {
  let s = bo(r), o = s ? e.tags[yo(t.doc, s)] : null, a = o && o.attrs ? Object.keys(o.attrs) : [], l = o && o.globalAttrs === !1 ? a : a.length ? a.concat(e.globalAttrNames) : e.globalAttrNames;
  return {
    from: n,
    to: i,
    options: l.map((c) => ({ label: c, type: "property" })),
    validFor: q2
  };
}
function D6(t, e, r, n, i) {
  var s;
  let o = (s = r.parent) === null || s === void 0 ? void 0 : s.getChild("AttributeName"), a = [], l;
  if (o) {
    let c = t.sliceDoc(o.from, o.to), u = e.globalAttrs[c];
    if (!u) {
      let d = bo(r), f = d ? e.tags[yo(t.doc, d)] : null;
      u = (f == null ? void 0 : f.attrs) && f.attrs[c];
    }
    if (u) {
      let d = t.sliceDoc(n, i).toLowerCase(), f = '"', h = '"';
      /^['"]/.test(d) ? (l = d[0] == '"' ? /^[^"]*$/ : /^[^']*$/, f = "", h = t.sliceDoc(i, i + 1) == d[0] ? "" : d[0], d = d.slice(1), n++) : l = /^[^\s<>='"]*$/;
      for (let p of u)
        a.push({ label: p, apply: f + p + h, type: "constant" });
    }
  }
  return { from: n, to: i, options: a, validFor: l };
}
function z6(t, e) {
  let { state: r, pos: n } = e, i = Xt(r).resolveInner(n, -1), s = i.resolve(n);
  for (let o = n, a; s == i && (a = i.childBefore(o)); ) {
    let l = a.lastChild;
    if (!l || !l.type.isError || l.from < l.to)
      break;
    s = i = a, o = l.from;
  }
  return i.name == "TagName" ? i.parent && /CloseTag$/.test(i.parent.name) ? v1(r, i, i.from, n) : b1(r, t, i, i.from, n) : i.name == "StartTag" ? b1(r, t, i, n, n) : i.name == "StartCloseTag" || i.name == "IncompleteCloseTag" ? v1(r, i, n, n) : i.name == "OpenTag" || i.name == "SelfClosingTag" || i.name == "AttributeName" ? N6(r, t, i, i.name == "AttributeName" ? i.from : n, n) : i.name == "Is" || i.name == "AttributeValue" || i.name == "UnquotedAttributeValue" ? D6(r, t, i, i.name == "Is" ? n : i.from, n) : e.explicit && (s.name == "Element" || s.name == "Text" || s.name == "Document") ? q6(r, t, i, n) : null;
}
function X6(t) {
  let { extraTags: e, extraGlobalAttributes: r } = t, n = r || e ? new pu(e, r) : pu.default;
  return (i) => z6(n, i);
}
const W6 = /* @__PURE__ */ gn.parser.configure({ top: "SingleExpression" }), N2 = [
  {
    tag: "script",
    attrs: (t) => t.type == "text/typescript" || t.lang == "ts",
    parser: Q2.parser
  },
  {
    tag: "script",
    attrs: (t) => t.type == "text/babel" || t.type == "text/jsx",
    parser: A2.parser
  },
  {
    tag: "script",
    attrs: (t) => t.type == "text/typescript-jsx",
    parser: E2.parser
  },
  {
    tag: "script",
    attrs(t) {
      return /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(t.type);
    },
    parser: W6
  },
  {
    tag: "script",
    attrs(t) {
      return !t.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(t.type);
    },
    parser: gn.parser
  },
  {
    tag: "style",
    attrs(t) {
      return (!t.lang || t.lang == "css") && (!t.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(t.type));
    },
    parser: du.parser
  }
], D2 = /* @__PURE__ */ [
  {
    name: "style",
    parser: /* @__PURE__ */ du.parser.configure({ top: "Styles" })
  }
].concat(/* @__PURE__ */ Z2.map((t) => ({ name: t, parser: gn.parser }))), z2 = /* @__PURE__ */ $i.define({
  name: "html",
  parser: /* @__PURE__ */ r6.configure({
    props: [
      /* @__PURE__ */ jo.add({
        Element(t) {
          let e = /^(\s*)(<\/)?/.exec(t.textAfter);
          return t.node.to <= t.pos + e[0].length ? t.continue() : t.lineIndent(t.node.from) + (e[2] ? 0 : t.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(t) {
          return t.column(t.node.from) + t.unit;
        },
        Document(t) {
          if (t.pos + /\s*/.exec(t.textAfter)[0].length < t.node.to)
            return t.continue();
          let e = null, r;
          for (let n = t.node; ; ) {
            let i = n.lastChild;
            if (!i || i.name != "Element" || i.to != n.to)
              break;
            e = n = i;
          }
          return e && !((r = e.lastChild) && (r.name == "CloseTag" || r.name == "SelfClosingTag")) ? t.lineIndent(e.from) + t.unit : null;
        }
      }),
      /* @__PURE__ */ yl.add({
        Element(t) {
          let e = t.firstChild, r = t.lastChild;
          return !e || e.name != "OpenTag" ? null : { from: e.to, to: r.name == "CloseTag" ? r.from : t.to };
        }
      }),
      /* @__PURE__ */ Lw.add({
        "OpenTag CloseTag": (t) => t.getChild("TagName")
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-._"
  }
}), Zc = /* @__PURE__ */ z2.configure({
  wrap: /* @__PURE__ */ S2(N2, D2)
});
function U6(t = {}) {
  let e = "", r;
  t.matchClosingTags === !1 && (e = "noMatch"), t.selfClosingTags === !0 && (e = (e ? e + " " : "") + "selfClosing"), (t.nestedLanguages && t.nestedLanguages.length || t.nestedAttributes && t.nestedAttributes.length) && (r = S2((t.nestedLanguages || []).concat(N2), (t.nestedAttributes || []).concat(D2)));
  let n = r ? z2.configure({ wrap: r, dialect: e }) : e ? Zc.configure({ dialect: e }) : Zc;
  return new Ol(n, [
    Zc.data.of({ autocomplete: X6(t) }),
    t.autoCloseTags !== !1 ? V6 : [],
    R6().support,
    f2().support
  ]);
}
const w1 = /* @__PURE__ */ new Set(/* @__PURE__ */ "area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" ")), V6 = /* @__PURE__ */ Se.inputHandler.of((t, e, r, n, i) => {
  if (t.composing || t.state.readOnly || e != r || n != ">" && n != "/" || !Zc.isActiveAt(t.state, e, -1))
    return !1;
  let s = i(), { state: o } = s, a = o.changeByRange((l) => {
    var c, u, d;
    let f = o.doc.sliceString(l.from - 1, l.to) == n, { head: h } = l, p = Xt(o).resolveInner(h - 1, -1), g;
    if ((p.name == "TagName" || p.name == "StartTag") && (p = p.parent), f && n == ">" && p.name == "OpenTag") {
      if (((u = (c = p.parent) === null || c === void 0 ? void 0 : c.lastChild) === null || u === void 0 ? void 0 : u.name) != "CloseTag" && (g = yo(o.doc, p.parent, h)) && !w1.has(g)) {
        let m = h + (o.doc.sliceString(h, h + 1) === ">" ? 1 : 0), y = `</${g}>`;
        return { range: l, changes: { from: h, to: m, insert: y } };
      }
    } else if (f && n == "/" && p.name == "IncompleteCloseTag") {
      let m = p.parent;
      if (p.from == h - 2 && ((d = m.lastChild) === null || d === void 0 ? void 0 : d.name) != "CloseTag" && (g = yo(o.doc, m, h)) && !w1.has(g)) {
        let y = h + (o.doc.sliceString(h, h + 1) === ">" ? 1 : 0), O = `${g}>`;
        return {
          range: ce.cursor(h + O.length, -1),
          changes: { from: h, to: y, insert: O }
        };
      }
    }
    return { range: l };
  });
  return a.changes.empty ? !1 : (t.dispatch([
    s,
    o.update(a, {
      userEvent: "input.complete",
      scrollIntoView: !0
    })
  ]), !0);
}), L6 = Io({
  String: E.string,
  Number: E.number,
  "True False": E.bool,
  PropertyName: E.propertyName,
  Null: E.null,
  ",": E.separator,
  "[ ]": E.squareBracket,
  "{ }": E.brace
}), Y6 = Si.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j",
  stateData: "#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O",
  goto: "!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: "âš  JsonText True False Null Number String } { Object Property PropertyName ] [ Array",
  maxTerm: 25,
  nodeProps: [
    ["isolate", -2, 6, 11, ""],
    ["openedBy", 7, "{", 12, "["],
    ["closedBy", 8, "}", 13, "]"]
  ],
  propSources: [L6],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oc~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Oe~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zOh~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yOg~~'OO]~~'TO[~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~",
  tokenizers: [0],
  topRules: { JsonText: [0, 1] },
  tokenPrec: 0
}), B6 = /* @__PURE__ */ $i.define({
  name: "json",
  parser: /* @__PURE__ */ Y6.configure({
    props: [
      /* @__PURE__ */ jo.add({
        Object: /* @__PURE__ */ to({ except: /^\s*\}/ }),
        Array: /* @__PURE__ */ to({ except: /^\s*\]/ })
      }),
      /* @__PURE__ */ yl.add({
        "Object Array": Gu
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function F6() {
  return new Ol(B6);
}
const qs = 63, $1 = 64, H6 = 1, G6 = 2, X2 = 3, K6 = 4, W2 = 5, J6 = 6, eT = 7, U2 = 65, tT = 66, rT = 8, nT = 9, iT = 10, sT = 11, oT = 12, V2 = 13, aT = 19, lT = 20, cT = 29, uT = 33, dT = 34, fT = 47, hT = 0, km = 1, Wh = 2, sl = 3, Uh = 4, Du = class Du {
  constructor(e, r, n) {
    this.parent = e, this.depth = r, this.type = n, this.hash = (e ? e.hash + e.hash << 8 : 0) + r + (r << 4) + n;
  }
};
Zd(Du, "top", new Du(null, -1, hT));
let Wi = Du;
function Ia(t, e) {
  for (let r = 0, n = e - t.pos - 1; ; n--, r++) {
    let i = t.peek(n);
    if (Dn(i) || i == -1)
      return r;
  }
}
function Vh(t) {
  return t == 32 || t == 9;
}
function Dn(t) {
  return t == 10 || t == 13;
}
function L2(t) {
  return Vh(t) || Dn(t);
}
function Ki(t) {
  return t < 0 || L2(t);
}
const pT = new vm({
  start: Wi.top,
  reduce(t, e) {
    return t.type == sl && (e == lT || e == dT) ? t.parent : t;
  },
  shift(t, e, r, n) {
    if (e == X2)
      return new Wi(t, Ia(n, n.pos), km);
    if (e == U2 || e == W2)
      return new Wi(t, Ia(n, n.pos), Wh);
    if (e == qs)
      return t.parent;
    if (e == aT || e == uT)
      return new Wi(t, 0, sl);
    if (e == V2 && t.type == Uh)
      return t.parent;
    if (e == fT) {
      let i = /[1-9]/.exec(n.read(n.pos, r.pos));
      if (i)
        return new Wi(t, t.depth + +i[0], Uh);
    }
    return t;
  },
  hash(t) {
    return t.hash;
  }
});
function vo(t, e, r = 0) {
  return t.peek(r) == e && t.peek(r + 1) == e && t.peek(r + 2) == e && Ki(t.peek(r + 3));
}
const mT = new Kt((t, e) => {
  if (t.next == -1 && e.canShift($1))
    return t.acceptToken($1);
  let r = t.peek(-1);
  if ((Dn(r) || r < 0) && e.context.type != sl) {
    if (vo(
      t,
      45
      /* '-' */
    ))
      if (e.canShift(qs))
        t.acceptToken(qs);
      else
        return t.acceptToken(H6, 3);
    if (vo(
      t,
      46
      /* '.' */
    ))
      if (e.canShift(qs))
        t.acceptToken(qs);
      else
        return t.acceptToken(G6, 3);
    let n = 0;
    for (; t.next == 32; )
      n++, t.advance();
    (n < e.context.depth || n == e.context.depth && e.context.type == km && (t.next != 45 || !Ki(t.peek(1)))) && // Not blank
    t.next != -1 && !Dn(t.next) && t.next != 35 && t.acceptToken(qs, -n);
  }
}, { contextual: !0 }), gT = new Kt((t, e) => {
  if (e.context.type == sl) {
    t.next == 63 && (t.advance(), Ki(t.next) && t.acceptToken(eT));
    return;
  }
  if (t.next == 45)
    t.advance(), Ki(t.next) && t.acceptToken(e.context.type == km && e.context.depth == Ia(t, t.pos - 1) ? K6 : X2);
  else if (t.next == 63)
    t.advance(), Ki(t.next) && t.acceptToken(e.context.type == Wh && e.context.depth == Ia(t, t.pos - 1) ? J6 : W2);
  else {
    let r = t.pos;
    for (; ; )
      if (Vh(t.next)) {
        if (t.pos == r)
          return;
        t.advance();
      } else if (t.next == 33)
        Y2(t);
      else if (t.next == 38)
        Lh(t);
      else if (t.next == 42) {
        Lh(t);
        break;
      } else if (t.next == 39 || t.next == 34) {
        if (_m(t, !0))
          break;
        return;
      } else if (t.next == 91 || t.next == 123) {
        if (!yT(t))
          return;
        break;
      } else {
        B2(t, !0, !1, 0);
        break;
      }
    for (; Vh(t.next); )
      t.advance();
    if (t.next == 58) {
      if (t.pos == r && e.canShift(cT))
        return;
      let n = t.peek(1);
      Ki(n) && t.acceptTokenTo(e.context.type == Wh && e.context.depth == Ia(t, r) ? tT : U2, r);
    }
  }
}, { contextual: !0 });
function OT(t) {
  return t > 32 && t < 127 && t != 34 && t != 37 && t != 44 && t != 60 && t != 62 && t != 92 && t != 94 && t != 96 && t != 123 && t != 124 && t != 125;
}
function S1(t) {
  return t >= 48 && t <= 57 || t >= 97 && t <= 102 || t >= 65 && t <= 70;
}
function k1(t, e) {
  return t.next == 37 ? (t.advance(), S1(t.next) && t.advance(), S1(t.next) && t.advance(), !0) : OT(t.next) || e && t.next == 44 ? (t.advance(), !0) : !1;
}
function Y2(t) {
  if (t.advance(), t.next == 60) {
    for (t.advance(); ; )
      if (!k1(t, !0)) {
        t.next == 62 && t.advance();
        break;
      }
  } else
    for (; k1(t, !1); )
      ;
}
function Lh(t) {
  for (t.advance(); !Ki(t.next) && mu(t.tag) != "f"; )
    t.advance();
}
function _m(t, e) {
  let r = t.next, n = !1, i = t.pos;
  for (t.advance(); ; ) {
    let s = t.next;
    if (s < 0)
      break;
    if (t.advance(), s == r)
      if (s == 39)
        if (t.next == 39)
          t.advance();
        else
          break;
      else
        break;
    else if (s == 92 && r == 34)
      t.next >= 0 && t.advance();
    else if (Dn(s)) {
      if (e)
        return !1;
      n = !0;
    } else if (e && t.pos >= i + 1024)
      return !1;
  }
  return !n;
}
function yT(t) {
  for (let e = [], r = t.pos + 1024; ; )
    if (t.next == 91 || t.next == 123)
      e.push(t.next), t.advance();
    else if (t.next == 39 || t.next == 34) {
      if (!_m(t, !0))
        return !1;
    } else if (t.next == 93 || t.next == 125) {
      if (e[e.length - 1] != t.next - 2)
        return !1;
      if (e.pop(), t.advance(), !e.length)
        return !0;
    } else {
      if (t.next < 0 || t.pos > r || Dn(t.next))
        return !1;
      t.advance();
    }
}
const bT = "iiisiiissisfissssssssssssisssiiissssssssssssssssssssssssssfsfssissssssssssssssssssssssssssfif";
function mu(t) {
  return t < 33 ? "u" : t > 125 ? "s" : bT[t - 33];
}
function pf(t, e) {
  let r = mu(t);
  return r != "u" && !(e && r == "f");
}
function B2(t, e, r, n) {
  if (mu(t.next) == "s" || (t.next == 63 || t.next == 58 || t.next == 45) && pf(t.peek(1), r))
    t.advance();
  else
    return !1;
  let i = t.pos;
  for (; ; ) {
    let s = t.next, o = 0, a = n + 1;
    for (; L2(s); ) {
      if (Dn(s)) {
        if (e)
          return !1;
        a = 0;
      } else
        a++;
      s = t.peek(++o);
    }
    if (!(s >= 0 && (s == 58 ? pf(t.peek(o + 1), r) : s == 35 ? t.peek(o - 1) != 32 : pf(s, r))) || !r && a <= n || a == 0 && !r && (vo(t, 45, o) || vo(t, 46, o)))
      break;
    if (e && mu(s) == "f")
      return !1;
    for (let c = o; c >= 0; c--)
      t.advance();
    if (e && t.pos > i + 1024)
      return !1;
  }
  return !0;
}
const vT = new Kt((t, e) => {
  if (t.next == 33)
    Y2(t), t.acceptToken(oT);
  else if (t.next == 38 || t.next == 42) {
    let r = t.next == 38 ? iT : sT;
    Lh(t), t.acceptToken(r);
  } else
    t.next == 39 || t.next == 34 ? (_m(t, !1), t.acceptToken(nT)) : B2(t, !1, e.context.type == sl, e.context.depth) && t.acceptToken(rT);
}), wT = new Kt((t, e) => {
  let r = e.context.type == Uh ? e.context.depth : -1, n = t.pos;
  e:
    for (; ; ) {
      let i = 0, s = t.next;
      for (; s == 32; )
        s = t.peek(++i);
      if (!i && (vo(t, 45, i) || vo(t, 46, i)) || !Dn(s) && (r < 0 && (r = Math.max(e.context.depth + 1, i)), i < r))
        break;
      for (; ; ) {
        if (t.next < 0)
          break e;
        let o = Dn(t.next);
        if (t.advance(), o)
          continue e;
        n = t.pos;
      }
    }
  t.acceptTokenTo(V2, n);
}), $T = Io({
  DirectiveName: E.keyword,
  DirectiveContent: E.attributeValue,
  "DirectiveEnd DocEnd": E.meta,
  QuotedLiteral: E.string,
  BlockLiteralHeader: E.special(E.string),
  BlockLiteralContent: E.content,
  Literal: E.content,
  "Key/Literal Key/QuotedLiteral": E.definition(E.propertyName),
  "Anchor Alias": E.labelName,
  Tag: E.typeName,
  Comment: E.lineComment,
  ": , -": E.separator,
  "?": E.punctuation,
  "[ ]": E.squareBracket,
  "{ }": E.brace
}), ST = Si.deserialize({
  version: 14,
  states: "5lQ!ZQgOOO#PQfO'#CpO#uQfO'#DOOOQR'#Dv'#DvO$qQgO'#DRO%gQdO'#DUO%nQgO'#DUO&ROaO'#D[OOQR'#Du'#DuO&{QgO'#D^O'rQgO'#D`OOQR'#Dt'#DtO(iOqO'#DbOOQP'#Dj'#DjO(zQaO'#CmO)YQgO'#CmOOQP'#Cm'#CmQ)jQaOOQ)uQgOOQ]QgOOO*PQdO'#CrO*nQdO'#CtOOQO'#Dw'#DwO+]Q`O'#CxO+hQdO'#CwO+rQ`O'#CwOOQO'#Cv'#CvO+wQdO'#CvOOQO'#Cq'#CqO,UQ`O,59[O,^QfO,59[OOQR,59[,59[OOQO'#Cx'#CxO,eQ`O'#DPO,pQdO'#DPOOQO'#Dx'#DxO,zQdO'#DxO-XQ`O,59jO-aQfO,59jOOQR,59j,59jOOQR'#DS'#DSO-hQcO,59mO-sQgO'#DVO.TQ`O'#DVO.YQcO,59pOOQR'#DX'#DXO#|QfO'#DWO.hQcO'#DWOOQR,59v,59vO.yOWO,59vO/OOaO,59vO/WOaO,59vO/cQgO'#D_OOQR,59x,59xO0VQgO'#DaOOQR,59z,59zOOQP,59|,59|O0yOaO,59|O1ROaO,59|O1aOqO,59|OOQP-E7h-E7hO1oQgO,59XOOQP,59X,59XO2PQaO'#DeO2_QgO'#DeO2oQgO'#DkOOQP'#Dk'#DkQ)jQaOOO3PQdO'#CsOOQO,59^,59^O3kQdO'#CuOOQO,59`,59`OOQO,59c,59cO4VQdO,59cO4aQdO'#CzO4kQ`O'#CzOOQO,59b,59bOOQU,5:Q,5:QOOQR1G.v1G.vO4pQ`O1G.vOOQU-E7d-E7dO4xQdO,59kOOQO,59k,59kO5SQdO'#DQO5^Q`O'#DQOOQO,5:d,5:dOOQU,5:R,5:ROOQR1G/U1G/UO5cQ`O1G/UOOQU-E7e-E7eO5kQgO'#DhO5xQcO1G/XOOQR1G/X1G/XOOQR,59q,59qO6TQgO,59qO6eQdO'#DiO6lQgO'#DiO7PQcO1G/[OOQR1G/[1G/[OOQR,59r,59rO#|QfO,59rOOQR1G/b1G/bO7_OWO1G/bO7dOaO1G/bOOQR,59y,59yOOQR,59{,59{OOQP1G/h1G/hO7lOaO1G/hO7tOaO1G/hO8POaO1G/hOOQP1G.s1G.sO8_QgO,5:POOQP,5:P,5:POOQP,5:V,5:VOOQP-E7i-E7iOOQO,59_,59_OOQO,59a,59aOOQO1G.}1G.}OOQO,59f,59fO8oQdO,59fOOQR7+$b7+$bP,XQ`O'#DfOOQO1G/V1G/VOOQO,59l,59lO8yQdO,59lOOQR7+$p7+$pP9TQ`O'#DgOOQR'#DT'#DTOOQR,5:S,5:SOOQR-E7f-E7fOOQR7+$s7+$sOOQR1G/]1G/]O9YQgO'#DYO9jQ`O'#DYOOQR,5:T,5:TO#|QfO'#DZO9oQcO'#DZOOQR-E7g-E7gOOQR7+$v7+$vOOQR1G/^1G/^OOQR7+$|7+$|O:QOWO7+$|OOQP7+%S7+%SO:VOaO7+%SO:_OaO7+%SOOQP1G/k1G/kOOQO1G/Q1G/QOOQO1G/W1G/WOOQR,59t,59tO:jQgO,59tOOQR,59u,59uO#|QfO,59uOOQR<<Hh<<HhOOQP<<Hn<<HnO:zOaO<<HnOOQR1G/`1G/`OOQR1G/a1G/aOOQPAN>YAN>Y",
  stateData: ";S~O!fOS!gOS^OS~OP_OQbORSOTUOWROXROYYOZZO[XOcPOqQO!PVO!V[O!cTO~O`cO~P]OVkOWROXROYeOZfO[dOcPOmhOqQO~OboO~P!bOVtOWROXROYeOZfO[dOcPOmrOqQO~OpwO~P#WORSOTUOWROXROYYOZZO[XOcPOqQO!PVO!cTO~OSvP!avP!bvP~P#|OWROXROYeOZfO[dOcPOqQO~OmzO~P%OOm!OOUzP!azP!bzP!dzP~P#|O^!SO!b!QO!f!TO!g!RO~ORSOTUOWROXROcPOqQO!PVO!cTO~OY!UOP!QXQ!QX!V!QX!`!QXS!QX!a!QX!b!QXU!QXm!QX!d!QX~P&aO[!WOP!SXQ!SX!V!SX!`!SXS!SX!a!SX!b!SXU!SXm!SX!d!SX~P&aO^!ZO!W![O!b!YO!f!]O!g!YO~OP!_O!V[OQaX!`aX~OPaXQaX!VaX!`aX~P#|OP!bOQ!cO!V[O~OP_O!V[O~P#|OWROXROY!fOcPOqQObfXmfXofXpfX~OWROXRO[!hOcPOqQObhXmhXohXphX~ObeXmlXoeX~ObkXokX~P%OOm!kO~Om!lObnPonP~P%OOb!pOo!oO~Ob!pO~P!bOm!sOosXpsX~OosXpsX~P%OOm!uOotPptP~P%OOo!xOp!yO~Op!yO~P#WOS!|O!a#OO!b#OO~OUyX!ayX!byX!dyX~P#|Om#QO~OU#SO!a#UO!b#UO!d#RO~Om#WOUzX!azX!bzX!dzX~O]#XO~O!b#XO!g#YO~O^#ZO!b#XO!g#YO~OP!RXQ!RX!V!RX!`!RXS!RX!a!RX!b!RXU!RXm!RX!d!RX~P&aOP!TXQ!TX!V!TX!`!TXS!TX!a!TX!b!TXU!TXm!TX!d!TX~P&aO!b#^O!g#^O~O^#_O!b#^O!f#`O!g#^O~O^#_O!W#aO!b#^O!g#^O~OPaaQaa!Vaa!`aa~P#|OP#cO!V[OQ!XX!`!XX~OP!XXQ!XX!V!XX!`!XX~P#|OP_O!V[OQ!_X!`!_X~P#|OWROXROcPOqQObgXmgXogXpgX~OWROXROcPOqQObiXmiXoiXpiX~Obkaoka~P%OObnXonX~P%OOm#kO~Ob#lOo!oO~Oosapsa~P%OOotXptX~P%OOm#pO~Oo!xOp#qO~OSwP!awP!bwP~P#|OS!|O!a#vO!b#vO~OUya!aya!bya!dya~P#|Om#xO~P%OOm#{OU}P!a}P!b}P!d}P~P#|OU#SO!a$OO!b$OO!d#RO~O]$QO~O!b$QO!g$RO~O!b$SO!g$SO~O^$TO!b$SO!g$SO~O^$TO!b$SO!f$UO!g$SO~OP!XaQ!Xa!V!Xa!`!Xa~P#|Obnaona~P%OOotapta~P%OOo!xO~OU|X!a|X!b|X!d|X~P#|Om$ZO~Om$]OU}X!a}X!b}X!d}X~O]$^O~O!b$_O!g$_O~O^$`O!b$_O!g$_O~OU|a!a|a!b|a!d|a~P#|O!b$cO!g$cO~O",
  goto: ",]!mPPPPPPPPPPPPPPPPP!nPP!v#v#|$`#|$c$f$j$nP%VPPP!v%Y%^%a%{&O%a&R&U&X&_&b%aP&e&{&e'O'RPP']'a'g'm's'y(XPPPPPPPP(_)e*X+c,VUaObcR#e!c!{ROPQSTUXY_bcdehknrtvz!O!U!W!_!b!c!f!h!k!l!s!u!|#Q#R#S#W#c#k#p#x#{$Z$]QmPR!qnqfPQThknrtv!k!l!s!u#R#k#pR!gdR!ieTlPnTjPnSiPnSqQvQ{TQ!mkQ!trQ!vtR#y#RR!nkTsQvR!wt!RWOSUXY_bcz!O!U!W!_!b!c!|#Q#S#W#c#x#{$Z$]RySR#t!|R|TR|UQ!PUR#|#SR#z#RR#z#SyZOSU_bcz!O!_!b!c!|#Q#S#W#c#x#{$Z$]R!VXR!XYa]O^abc!a!c!eT!da!eQnPR!rnQvQR!{vQ!}yR#u!}Q#T|R#}#TW^Obc!cS!^^!aT!aa!eQ!eaR#f!eW`Obc!cQxSS}U#SQ!`_Q#PzQ#V!OQ#b!_Q#d!bQ#s!|Q#w#QQ$P#WQ$V#cQ$Y#xQ$[#{Q$a$ZR$b$]xZOSU_bcz!O!_!b!c!|#Q#S#W#c#x#{$Z$]Q!VXQ!XYQ#[!UR#]!W!QWOSUXY_bcz!O!U!W!_!b!c!|#Q#S#W#c#x#{$Z$]pfPQThknrtv!k!l!s!u#R#k#pQ!gdQ!ieQ#g!fR#h!hSgPn^pQTkrtv#RQ!jhQ#i!kQ#j!lQ#n!sQ#o!uQ$W#kR$X#pQuQR!zv",
  nodeNames: "âš  DirectiveEnd DocEnd - - ? ? ? Literal QuotedLiteral Anchor Alias Tag BlockLiteralContent Comment Stream BOM Document ] [ FlowSequence Item Tagged Anchored Anchored Tagged FlowMapping Pair Key : Pair , } { FlowMapping Pair Pair BlockSequence Item Item BlockMapping Pair Pair Key Pair Pair BlockLiteral BlockLiteralHeader Tagged Anchored Anchored Tagged Directive DirectiveName DirectiveContent Document",
  maxTerm: 74,
  context: pT,
  nodeProps: [
    ["isolate", -3, 8, 9, 14, ""],
    ["openedBy", 18, "[", 32, "{"],
    ["closedBy", 19, "]", 33, "}"]
  ],
  propSources: [$T],
  skippedNodes: [0],
  repeatNodeCount: 6,
  tokenData: "-Y~RnOX#PXY$QYZ$]Z]#P]^$]^p#Ppq$Qqs#Pst$btu#Puv$yv|#P|}&e}![#P![!]'O!]!`#P!`!a'i!a!}#P!}#O*g#O#P#P#P#Q+Q#Q#o#P#o#p+k#p#q'i#q#r,U#r;'S#P;'S;=`#z<%l?HT#P?HT?HU,o?HUO#PQ#UU!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PQ#kTOY#PZs#Pt;'S#P;'S;=`#z<%lO#PQ#}P;=`<%l#P~$VQ!f~XY$Qpq$Q~$bO!g~~$gS^~OY$bZ;'S$b;'S;=`$s<%lO$b~$vP;=`<%l$bR%OX!WQOX%kXY#PZ]%k]^#P^p%kpq#hq;'S%k;'S;=`&_<%lO%kR%rX!WQ!VPOX%kXY#PZ]%k]^#P^p%kpq#hq;'S%k;'S;=`&_<%lO%kR&bP;=`<%l%kR&lUoP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR'VUmP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR'p[!PP!WQOY#PZp#Ppq#hq{#P{|(f|}#P}!O(f!O!R#P!R![)p![;'S#P;'S;=`#z<%lO#PR(mW!PP!WQOY#PZp#Ppq#hq!R#P!R![)V![;'S#P;'S;=`#z<%lO#PR)^U!PP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR)wY!PP!WQOY#PZp#Ppq#hq{#P{|)V|}#P}!O)V!O;'S#P;'S;=`#z<%lO#PR*nUcP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR+XUbP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR+rUqP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR,]UpP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR,vU`P!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#P",
  tokenizers: [mT, gT, vT, wT, 0, 1],
  topRules: { Stream: [0, 15] },
  tokenPrec: 0
}), kT = /* @__PURE__ */ $i.define({
  name: "yaml",
  parser: /* @__PURE__ */ ST.configure({
    props: [
      /* @__PURE__ */ jo.add({
        Stream: (t) => {
          for (let e = t.node.resolve(t.pos, -1); e && e.to >= t.pos; e = e.parent) {
            if (e.name == "BlockLiteralContent" && e.from < e.to)
              return t.baseIndentFor(e);
            if (e.name == "BlockLiteral")
              return t.baseIndentFor(e) + t.unit;
            if (e.name == "BlockSequence" || e.name == "BlockMapping")
              return t.column(e.from, 1);
            if (e.name == "QuotedLiteral")
              return null;
            if (e.name == "Literal") {
              let r = t.column(e.from, 1);
              if (r == t.lineIndent(e.from, 1))
                return r;
              if (e.to > t.pos)
                return null;
            }
          }
          return null;
        },
        FlowMapping: /* @__PURE__ */ Ih({ closing: "}" }),
        FlowSequence: /* @__PURE__ */ Ih({ closing: "]" })
      }),
      /* @__PURE__ */ yl.add({
        "FlowMapping FlowSequence": Gu,
        "BlockSequence BlockMapping BlockLiteral": (t, e) => ({ from: e.doc.lineAt(t.from).to, to: t.to })
      })
    ]
  }),
  languageData: {
    commentTokens: { line: "#" },
    indentOnInput: /^\s*[\]\}]$/
  }
});
function _T() {
  return new Ol(kT);
}
var PT = (t) => {
  var {
    theme: e,
    settings: r = {},
    styles: n = []
  } = t, i = {
    ".cm-gutters": {}
  }, s = {};
  r.background && (s.backgroundColor = r.background), r.backgroundImage && (s.backgroundImage = r.backgroundImage), r.foreground && (s.color = r.foreground), (r.background || r.foreground) && (i["&"] = s), r.fontFamily && (i["&.cm-editor .cm-scroller"] = {
    fontFamily: r.fontFamily
  }), r.gutterBackground && (i[".cm-gutters"].backgroundColor = r.gutterBackground), r.gutterForeground && (i[".cm-gutters"].color = r.gutterForeground), r.gutterBorder && (i[".cm-gutters"].borderRightColor = r.gutterBorder), r.caret && (i[".cm-content"] = {
    caretColor: r.caret
  }, i[".cm-cursor, .cm-dropCursor"] = {
    borderLeftColor: r.caret
  });
  var o = {};
  r.gutterActiveForeground && (o.color = r.gutterActiveForeground), r.lineHighlight && (i[".cm-activeLine"] = {
    backgroundColor: r.lineHighlight
  }, o.backgroundColor = r.lineHighlight), i[".cm-activeLineGutter"] = o, r.selection && (i["&.cm-focused .cm-selectionBackground, & .cm-line::selection, & .cm-selectionLayer .cm-selectionBackground, .cm-content ::selection"] = {
    background: r.selection + " !important"
  }), r.selectionMatch && (i["& .cm-selectionMatch"] = {
    backgroundColor: r.selectionMatch
  });
  var a = Se.theme(i, {
    dark: e === "dark"
  }), l = bl.define(n), c = [a, Xw(l)];
  return c;
};
const xT = PT({
  theme: "light",
  settings: {
    background: "var(--theme-background-2, var(--default-theme-background-2))",
    foreground: "var(--theme-color-1, var(--default-theme-color-1))",
    caret: "var(--theme-color-1, var(--default-theme-color-1))",
    // Selection likely needs a hardcoded color due to it not accepting variables
    selection: "rgba(151, 183, 205, 0.2)",
    selectionMatch: "#e3dcce",
    gutterBackground: "var(--theme-background-2, var(--default-theme-background-2))",
    gutterForeground: "var(--theme-color-3, var(--default-theme-color-3))",
    gutterBorder: "transparent",
    lineHighlight: "var(--theme-background-3, var(--default-theme-background-3))",
    fontFamily: "var(--theme-font-code, var(--default-theme-font-code))"
  },
  styles: [
    {
      tag: [E.standard(E.tagName), E.tagName],
      color: "var(--theme-color-purple, var(--default-theme-color-purple))"
    },
    {
      tag: [E.comment],
      color: "var(--theme-color-3, var(--default-theme-color-3))"
    },
    {
      tag: [E.className],
      color: "var(--theme-color-orange, var(--default-theme-color-orange))"
    },
    {
      tag: [E.variableName, E.propertyName, E.attributeName],
      color: "var(--theme-color-1, var(--default-theme-color-1))"
    },
    {
      tag: [E.operator],
      color: "var(--theme-color-2, var(--default-theme-color-2))"
    },
    {
      tag: [E.keyword, E.typeName, E.typeOperator],
      color: "var(--theme-color-green, var(--default-theme-color-green))"
    },
    {
      tag: [E.string],
      color: "var(--theme-color-blue, var(--default-theme-color-blue))"
    },
    {
      tag: [E.bracket, E.regexp, E.meta],
      color: "var(--theme-color-3, var(--default-theme-color-3))"
    },
    {
      tag: [E.number],
      color: "var(--theme-color-blue, var(--default-theme-color-blue))"
    },
    {
      tag: [E.name, E.quote],
      color: "var(--theme-color-3, var(--default-theme-color-3))"
    },
    {
      tag: [E.heading],
      color: "var(--theme-color-3, var(--default-theme-color-3))",
      fontWeight: "bold"
    },
    {
      tag: [E.emphasis],
      color: "var(--theme-color-3, var(--default-theme-color-3))",
      fontStyle: "italic"
    },
    {
      tag: [E.deleted],
      color: "var(--theme-color-3, var(--default-theme-color-3))",
      backgroundColor: "transparent"
    },
    {
      tag: [E.atom, E.bool, E.special(E.variableName)],
      color: "var(--theme-color-3, var(--default-theme-color-3))"
    },
    {
      tag: [E.url, E.escape, E.regexp, E.link],
      color: "var(--theme-color-1, var(--default-theme-color-1))"
    },
    { tag: E.link, textDecoration: "underline" },
    { tag: E.strikethrough, textDecoration: "line-through" },
    {
      tag: E.invalid,
      color: "var(--theme-color-3, var(--default-theme-color-3))"
    }
  ]
}), _1 = new $w({
  regexp: /(\{[^}]+\})/g,
  decoration: () => We.mark({
    attributes: {
      class: "api-client-url-variable"
    }
  })
}), TT = () => Pr.fromClass(
  class {
    constructor(t) {
      Zd(this, "variables");
      this.variables = _1.createDeco(t);
    }
    update(t) {
      this.variables = _1.updateDeco(
        t,
        this.variables
      );
    }
  },
  {
    decorations: (t) => t.variables,
    provide: (t) => Se.atomicRanges.of(
      (e) => {
        var r;
        return ((r = e.plugin(t)) == null ? void 0 : r.variables) || We.none;
      }
    )
  }
), Cs = (t) => "provider" in t && !!Pt(t.provider), CT = {
  key: "Mod-a",
  run: (t) => (t.dispatch({
    selection: { anchor: 0, head: t.state.doc.length },
    scrollIntoView: !1
  }), !0)
}, QT = (t) => {
  const e = ge(null);
  Ve(
    t.codeMirrorRef,
    () => {
      var s;
      (s = e.value) == null || s.destroy(), r();
    },
    { immediate: !0 }
  ), G5(() => {
    var s;
    return (s = e.value) == null ? void 0 : s.destroy();
  });
  function r() {
    if (t.codeMirrorRef.value) {
      const s = Cs(t) ? Pt(t.provider) : null, o = x1({
        ...n.value,
        provider: s
      });
      e.value = new Se({
        parent: t.codeMirrorRef.value,
        extensions: o
      }), Cs(t) || i(Pt(t.content));
    }
  }
  const n = fe(() => ({
    onChange: t.onChange,
    onBlur: t.onBlur,
    onFocus: t.onFocus,
    language: Pt(t.language),
    classes: Pt(t.classes),
    readOnly: Pt(t.readOnly),
    lineNumbers: Pt(t.lineNumbers),
    withVariables: Pt(t.withVariables),
    disableEnter: Pt(t.withVariables),
    withoutTheme: Pt(t.withoutTheme),
    additionalExtensions: Pt(t.extensions)
  }));
  Ve(
    () => Cs(t) ? Pt(t.provider) : null,
    () => {
      var s;
      Cs(t) && ((s = e.value) == null || s.destroy(), r());
    }
  ), Ve(
    n,
    () => {
      if (e.value) {
        const s = Cs(t) ? Pt(t.provider) : null, o = x1({
          ...n.value,
          provider: s
        });
        e.value.dispatch({
          effects: Le.reconfigure.of(o)
        });
      } else
        return;
    },
    { immediate: !0 }
  );
  const i = (s = "") => {
    e.value && e.value.state.doc.toString() !== s && e.value.dispatch({
      changes: {
        from: 0,
        to: e.value.state.doc.length,
        insert: s
      },
      selection: {
        anchor: Math.min(
          e.value.state.selection.main.anchor,
          s.length
        )
      }
    });
  };
  return Ve(
    () => Pt(t.content),
    () => {
      Cs(t) || i(Pt(t.content));
    },
    { immediate: !0 }
  ), {
    /** Replaces the current content with the given value. */
    setCodeMirrorContent: i,
    /** Codemirror instance */
    codeMirror: e
  };
}, P1 = {
  html: U6,
  json: F6,
  yaml: _T,
  css: f2
};
function x1({
  onChange: t,
  onBlur: e,
  onFocus: r,
  provider: n,
  language: i,
  classes: s = [],
  readOnly: o = !1,
  lineNumbers: a = !1,
  withVariables: l = !1,
  disableEnter: c = !1,
  withoutTheme: u = !1,
  additionalExtensions: d = []
}) {
  const f = [
    Ax(),
    Xw(R4, { fallback: !0 }),
    Se.theme({
      ".cm-line": {
        lineHeight: "20px"
      },
      ".cm-gutterElement": {
        lineHeight: "20px"
      }
    }),
    // Listen to updates
    Se.updateListener.of((h) => {
      h.docChanged && (t == null || t(h.state.doc.toString()));
    }),
    Se.domEventHandlers({
      blur: (h, p) => {
        e == null || e(p.state.doc.toString());
      },
      focus: (h, p) => {
        r == null || r(p.state.doc.toString());
      }
    }),
    // Add Classes
    Se.editorAttributes.of({ class: s.join(" ") }),
    ...d
  ];
  return n && f.push(n), u || f.push(xT), o ? f.push(Se.editable.of(!1)) : f.push(
    Q4(),
    D4(),
    M7(),
    P7(),
    Ka.of([
      ...o2,
      ...Q7,
      CT
    ])
  ), i && P1[i] && f.push(P1[i]()), a && f.push(Yx()), l && f.push(TT()), c && f.push(
    Ka.of([
      {
        key: "Enter",
        run: () => !0
      },
      {
        key: "Ctrl-Enter",
        mac: "Cmd-Enter",
        run: () => !0
      },
      {
        key: "Shift-Enter",
        run: () => !0
      }
    ])
  ), f;
}
const AT = /* @__PURE__ */ G({
  __name: "CodeMirror",
  props: {
    content: {},
    readOnly: { type: Boolean },
    language: {},
    withVariables: { type: Boolean },
    lineNumbers: { type: Boolean },
    withoutTheme: { type: Boolean },
    disableEnter: { type: Boolean, default: !1 }
  },
  emits: ["change"],
  setup(t, { emit: e }) {
    const r = t, n = e, i = ge(null);
    return QT({
      content: an(() => r.content),
      readOnly: an(() => r.readOnly),
      language: an(() => r.language),
      withVariables: an(() => r.withVariables),
      lineNumbers: an(() => r.lineNumbers),
      withoutTheme: an(() => r.withoutTheme),
      disableEnter: an(() => r.disableEnter),
      onChange: (s) => n("change", s || ""),
      codeMirrorRef: i,
      classes: ["codemirror"]
    }), (s, o) => (k(), C("div", {
      ref_key: "codeMirrorRef",
      ref: i,
      class: "codemirror-container"
    }, null, 512));
  }
}), oe = (t, e) => {
  const r = t.__vccOpts || t;
  for (const [n, i] of e)
    r[n] = i;
  return r;
}, F2 = /* @__PURE__ */ oe(AT, [["__scopeId", "data-v-9f50a430"]]), ET = { class: "scalar-modal-layout modal-layout" }, RT = /* @__PURE__ */ G({
  __name: "FlowModal",
  props: {
    state: {},
    title: {},
    bodyClass: {},
    maxWidth: {},
    variant: { default: "normal" }
  },
  setup(t) {
    return (e, r) => (k(), Y(v(n3), {
      open: e.state.open,
      onClose: r[0] || (r[0] = (n) => e.state.hide())
    }, {
      default: I(() => [
        x("div", ET, [
          Z(v(i3), {
            class: $e(["modal", {
              "modal-content-large": e.variant === "large",
              "modal-content-normal": e.variant === "normal",
              "modal-content-small": e.variant === "small",
              "modal-content-search": e.variant === "search",
              "modal-content-history": e.variant === "history"
            }]),
            style: Eo({ maxWidth: e.maxWidth })
          }, {
            default: I(() => [
              e.title ? (k(), Y(v(s3), {
                key: 0,
                class: "modal-header"
              }, {
                default: I(() => [
                  re(te(e.title), 1)
                ]),
                _: 1
              })) : H("", !0),
              Z(v(o3), {
                class: $e(["modal-body custom-scroll", [e.bodyClass]])
              }, {
                default: I(() => [
                  se(e.$slots, "default", {}, void 0, !0)
                ]),
                _: 3
              }, 8, ["class"])
            ]),
            _: 3
          }, 8, ["class", "style"])
        ])
      ]),
      _: 3
    }, 8, ["open"]));
  }
}), H2 = /* @__PURE__ */ oe(RT, [["__scopeId", "data-v-a06b8e92"]]), G2 = () => vn({
  open: !1,
  show() {
    this.open = !0;
  },
  hide() {
    this.open = !1;
  }
}), IT = (t, e) => {
  if (typeof e != "string" || !e.length)
    return t;
  const r = t.endsWith("/") ? t : `${t}/`, n = e.startsWith("/") ? e.slice(1) : e;
  return [r, n].join("");
}, jT = (t) => {
  const e = /(?:\{+)\s*(\w+)\s*(?:\}+)/g;
  return [...t.matchAll(e)].map((r) => r[1].trim()) || [];
};
function K2(t) {
  const e = Math.floor(((/* @__PURE__ */ new Date()).getTime() - t) / 1e3);
  if (e < 45)
    return "just now";
  if (e < 60)
    return `${e} seconds ago`;
  const r = Math.floor(e / 60);
  if (r < 60)
    return `${r} minute${r === 1 ? "" : "s"} ago`;
  const n = Math.floor(r / 60);
  if (n < 24)
    return `${n} hour${n === 1 ? "" : "s"} ago`;
  const i = Math.floor(n / 24);
  if (i < 30)
    return `${i} day${i === 1 ? "" : "s"} ago`;
  const s = Math.floor(i / 30);
  return s < 12 ? `${s} month${s === 1 ? "" : "s"} ago` : "more than a year ago";
}
function _a(t, e, r) {
  const n = {};
  return t.forEach((i) => {
    n[i[e]] = i[r];
  }), n;
}
const ZT = (t) => {
  if (typeof t != "string")
    return "";
  let e = t.trim();
  return e.length > 1 && e.startsWith("/") && (e = e.slice(1)), e;
}, dc = "GET", MT = (t) => {
  if (typeof t != "string")
    return console.warn(
      `[sendRequest] Request method is not a string. Using ${dc} as the default.`
    ), dc;
  const e = t.trim().toUpperCase();
  return Kf(e) ? e : (console.warn(
    `[sendRequest] ${t} is not a valid request method. Using ${dc} as the default.`
  ), dc);
}, qT = (t) => {
  if (typeof t != "string")
    return console.warn(
      "[sendRequest] URL is not a string. Using an empty string as the default."
    ), "";
  let e = t.trim().toLowerCase();
  return e.startsWith("http") || (console.warn(
    "[sendRequest] URL does not start with http. Adding http:// as the default prefix."
  ), e = `http://${e}`), e;
}, Pm = Symbol.for("yaml.alias"), Yh = Symbol.for("yaml.document"), hi = Symbol.for("yaml.map"), J2 = Symbol.for("yaml.pair"), zn = Symbol.for("yaml.scalar"), Mo = Symbol.for("yaml.seq"), xr = Symbol.for("yaml.node.type"), qo = (t) => !!t && typeof t == "object" && t[xr] === Pm, Ju = (t) => !!t && typeof t == "object" && t[xr] === Yh, wl = (t) => !!t && typeof t == "object" && t[xr] === hi, ft = (t) => !!t && typeof t == "object" && t[xr] === J2, tt = (t) => !!t && typeof t == "object" && t[xr] === zn, $l = (t) => !!t && typeof t == "object" && t[xr] === Mo;
function dt(t) {
  if (t && typeof t == "object")
    switch (t[xr]) {
      case hi:
      case Mo:
        return !0;
    }
  return !1;
}
function yt(t) {
  if (t && typeof t == "object")
    switch (t[xr]) {
      case Pm:
      case hi:
      case zn:
      case Mo:
        return !0;
    }
  return !1;
}
const NT = (t) => (tt(t) || dt(t)) && !!t.anchor, zi = Symbol("break visit"), DT = Symbol("skip children"), ja = Symbol("remove node");
function ds(t, e) {
  const r = zT(e);
  Ju(t) ? Us(null, t.contents, r, Object.freeze([t])) === ja && (t.contents = null) : Us(null, t, r, Object.freeze([]));
}
ds.BREAK = zi;
ds.SKIP = DT;
ds.REMOVE = ja;
function Us(t, e, r, n) {
  const i = XT(t, e, r, n);
  if (yt(i) || ft(i))
    return WT(t, n, i), Us(t, i, r, n);
  if (typeof i != "symbol") {
    if (dt(e)) {
      n = Object.freeze(n.concat(e));
      for (let s = 0; s < e.items.length; ++s) {
        const o = Us(s, e.items[s], r, n);
        if (typeof o == "number")
          s = o - 1;
        else {
          if (o === zi)
            return zi;
          o === ja && (e.items.splice(s, 1), s -= 1);
        }
      }
    } else if (ft(e)) {
      n = Object.freeze(n.concat(e));
      const s = Us("key", e.key, r, n);
      if (s === zi)
        return zi;
      s === ja && (e.key = null);
      const o = Us("value", e.value, r, n);
      if (o === zi)
        return zi;
      o === ja && (e.value = null);
    }
  }
  return i;
}
function zT(t) {
  return typeof t == "object" && (t.Collection || t.Node || t.Value) ? Object.assign({
    Alias: t.Node,
    Map: t.Node,
    Scalar: t.Node,
    Seq: t.Node
  }, t.Value && {
    Map: t.Value,
    Scalar: t.Value,
    Seq: t.Value
  }, t.Collection && {
    Map: t.Collection,
    Seq: t.Collection
  }, t) : t;
}
function XT(t, e, r, n) {
  var i, s, o, a, l;
  if (typeof r == "function")
    return r(t, e, n);
  if (wl(e))
    return (i = r.Map) == null ? void 0 : i.call(r, t, e, n);
  if ($l(e))
    return (s = r.Seq) == null ? void 0 : s.call(r, t, e, n);
  if (ft(e))
    return (o = r.Pair) == null ? void 0 : o.call(r, t, e, n);
  if (tt(e))
    return (a = r.Scalar) == null ? void 0 : a.call(r, t, e, n);
  if (qo(e))
    return (l = r.Alias) == null ? void 0 : l.call(r, t, e, n);
}
function WT(t, e, r) {
  const n = e[e.length - 1];
  if (dt(n))
    n.items[t] = r;
  else if (ft(n))
    t === "key" ? n.key = r : n.value = r;
  else if (Ju(n))
    n.contents = r;
  else {
    const i = qo(n) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${i} parent`);
  }
}
const UT = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
}, VT = (t) => t.replace(/[!,[\]{}]/g, (e) => UT[e]);
class Lt {
  constructor(e, r) {
    this.docStart = null, this.docEnd = !1, this.yaml = Object.assign({}, Lt.defaultYaml, e), this.tags = Object.assign({}, Lt.defaultTags, r);
  }
  clone() {
    const e = new Lt(this.yaml, this.tags);
    return e.docStart = this.docStart, e;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const e = new Lt(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = !0;
        break;
      case "1.2":
        this.atNextDocument = !1, this.yaml = {
          explicit: Lt.defaultYaml.explicit,
          version: "1.2"
        }, this.tags = Object.assign({}, Lt.defaultTags);
        break;
    }
    return e;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(e, r) {
    this.atNextDocument && (this.yaml = { explicit: Lt.defaultYaml.explicit, version: "1.1" }, this.tags = Object.assign({}, Lt.defaultTags), this.atNextDocument = !1);
    const n = e.trim().split(/[ \t]+/), i = n.shift();
    switch (i) {
      case "%TAG": {
        if (n.length !== 2 && (r(0, "%TAG directive should contain exactly two parts"), n.length < 2))
          return !1;
        const [s, o] = n;
        return this.tags[s] = o, !0;
      }
      case "%YAML": {
        if (this.yaml.explicit = !0, n.length !== 1)
          return r(0, "%YAML directive should contain exactly one part"), !1;
        const [s] = n;
        if (s === "1.1" || s === "1.2")
          return this.yaml.version = s, !0;
        {
          const o = /^\d+\.\d+$/.test(s);
          return r(6, `Unsupported YAML version ${s}`, o), !1;
        }
      }
      default:
        return r(0, `Unknown directive ${i}`, !0), !1;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(e, r) {
    if (e === "!")
      return "!";
    if (e[0] !== "!")
      return r(`Not a valid tag: ${e}`), null;
    if (e[1] === "<") {
      const o = e.slice(2, -1);
      return o === "!" || o === "!!" ? (r(`Verbatim tags aren't resolved, so ${e} is invalid.`), null) : (e[e.length - 1] !== ">" && r("Verbatim tags must end with a >"), o);
    }
    const [, n, i] = e.match(/^(.*!)([^!]*)$/s);
    i || r(`The ${e} tag has no suffix`);
    const s = this.tags[n];
    if (s)
      try {
        return s + decodeURIComponent(i);
      } catch (o) {
        return r(String(o)), null;
      }
    return n === "!" ? e : (r(`Could not resolve tag: ${e}`), null);
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(e) {
    for (const [r, n] of Object.entries(this.tags))
      if (e.startsWith(n))
        return r + VT(e.substring(n.length));
    return e[0] === "!" ? e : `!<${e}>`;
  }
  toString(e) {
    const r = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [], n = Object.entries(this.tags);
    let i;
    if (e && n.length > 0 && yt(e.contents)) {
      const s = {};
      ds(e.contents, (o, a) => {
        yt(a) && a.tag && (s[a.tag] = !0);
      }), i = Object.keys(s);
    } else
      i = [];
    for (const [s, o] of n)
      s === "!!" && o === "tag:yaml.org,2002:" || (!e || i.some((a) => a.startsWith(o))) && r.push(`%TAG ${s} ${o}`);
    return r.join(`
`);
  }
}
Lt.defaultYaml = { explicit: !1, version: "1.2" };
Lt.defaultTags = { "!!": "tag:yaml.org,2002:" };
function e$(t) {
  if (/[\x00-\x19\s,[\]{}]/.test(t)) {
    const r = `Anchor must not contain whitespace or control characters: ${JSON.stringify(t)}`;
    throw new Error(r);
  }
  return !0;
}
function t$(t) {
  const e = /* @__PURE__ */ new Set();
  return ds(t, {
    Value(r, n) {
      n.anchor && e.add(n.anchor);
    }
  }), e;
}
function r$(t, e) {
  for (let r = 1; ; ++r) {
    const n = `${t}${r}`;
    if (!e.has(n))
      return n;
  }
}
function LT(t, e) {
  const r = [], n = /* @__PURE__ */ new Map();
  let i = null;
  return {
    onAnchor: (s) => {
      r.push(s), i || (i = t$(t));
      const o = r$(e, i);
      return i.add(o), o;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const s of r) {
        const o = n.get(s);
        if (typeof o == "object" && o.anchor && (tt(o.node) || dt(o.node)))
          o.node.anchor = o.anchor;
        else {
          const a = new Error("Failed to resolve repeated object (this should not happen)");
          throw a.source = s, a;
        }
      }
    },
    sourceObjects: n
  };
}
function Vs(t, e, r, n) {
  if (n && typeof n == "object")
    if (Array.isArray(n))
      for (let i = 0, s = n.length; i < s; ++i) {
        const o = n[i], a = Vs(t, n, String(i), o);
        a === void 0 ? delete n[i] : a !== o && (n[i] = a);
      }
    else if (n instanceof Map)
      for (const i of Array.from(n.keys())) {
        const s = n.get(i), o = Vs(t, n, i, s);
        o === void 0 ? n.delete(i) : o !== s && n.set(i, o);
      }
    else if (n instanceof Set)
      for (const i of Array.from(n)) {
        const s = Vs(t, n, i, i);
        s === void 0 ? n.delete(i) : s !== i && (n.delete(i), n.add(s));
      }
    else
      for (const [i, s] of Object.entries(n)) {
        const o = Vs(t, n, i, s);
        o === void 0 ? delete n[i] : o !== s && (n[i] = o);
      }
  return t.call(e, r, n);
}
function kr(t, e, r) {
  if (Array.isArray(t))
    return t.map((n, i) => kr(n, String(i), r));
  if (t && typeof t.toJSON == "function") {
    if (!r || !NT(t))
      return t.toJSON(e, r);
    const n = { aliasCount: 0, count: 1, res: void 0 };
    r.anchors.set(t, n), r.onCreate = (s) => {
      n.res = s, delete r.onCreate;
    };
    const i = t.toJSON(e, r);
    return r.onCreate && r.onCreate(i), i;
  }
  return typeof t == "bigint" && !(r != null && r.keep) ? Number(t) : t;
}
class xm {
  constructor(e) {
    Object.defineProperty(this, xr, { value: e });
  }
  /** Create a copy of this node.  */
  clone() {
    const e = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    return this.range && (e.range = this.range.slice()), e;
  }
  /** A plain JavaScript representation of this node. */
  toJS(e, { mapAsMap: r, maxAliasCount: n, onAnchor: i, reviver: s } = {}) {
    if (!Ju(e))
      throw new TypeError("A document argument is required");
    const o = {
      anchors: /* @__PURE__ */ new Map(),
      doc: e,
      keep: !0,
      mapAsMap: r === !0,
      mapKeyWarned: !1,
      maxAliasCount: typeof n == "number" ? n : 100
    }, a = kr(this, "", o);
    if (typeof i == "function")
      for (const { count: l, res: c } of o.anchors.values())
        i(c, l);
    return typeof s == "function" ? Vs(s, { "": a }, "", a) : a;
  }
}
class Tm extends xm {
  constructor(e) {
    super(Pm), this.source = e, Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(e) {
    let r;
    return ds(e, {
      Node: (n, i) => {
        if (i === this)
          return ds.BREAK;
        i.anchor === this.source && (r = i);
      }
    }), r;
  }
  toJSON(e, r) {
    if (!r)
      return { source: this.source };
    const { anchors: n, doc: i, maxAliasCount: s } = r, o = this.resolve(i);
    if (!o) {
      const l = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(l);
    }
    let a = n.get(o);
    if (a || (kr(o, null, r), a = n.get(o)), !a || a.res === void 0) {
      const l = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(l);
    }
    if (s >= 0 && (a.count += 1, a.aliasCount === 0 && (a.aliasCount = Mc(i, o, n)), a.count * a.aliasCount > s)) {
      const l = "Excessive alias count indicates a resource exhaustion attack";
      throw new ReferenceError(l);
    }
    return a.res;
  }
  toString(e, r, n) {
    const i = `*${this.source}`;
    if (e) {
      if (e$(this.source), e.options.verifyAliasOrder && !e.anchors.has(this.source)) {
        const s = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(s);
      }
      if (e.implicitKey)
        return `${i} `;
    }
    return i;
  }
}
function Mc(t, e, r) {
  if (qo(e)) {
    const n = e.resolve(t), i = r && n && r.get(n);
    return i ? i.count * i.aliasCount : 0;
  } else if (dt(e)) {
    let n = 0;
    for (const i of e.items) {
      const s = Mc(t, i, r);
      s > n && (n = s);
    }
    return n;
  } else if (ft(e)) {
    const n = Mc(t, e.key, r), i = Mc(t, e.value, r);
    return Math.max(n, i);
  }
  return 1;
}
const n$ = (t) => !t || typeof t != "function" && typeof t != "object";
class Ee extends xm {
  constructor(e) {
    super(zn), this.value = e;
  }
  toJSON(e, r) {
    return r != null && r.keep ? this.value : kr(this.value, e, r);
  }
  toString() {
    return String(this.value);
  }
}
Ee.BLOCK_FOLDED = "BLOCK_FOLDED";
Ee.BLOCK_LITERAL = "BLOCK_LITERAL";
Ee.PLAIN = "PLAIN";
Ee.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Ee.QUOTE_SINGLE = "QUOTE_SINGLE";
const YT = "tag:yaml.org,2002:";
function BT(t, e, r) {
  if (e) {
    const n = r.filter((s) => s.tag === e), i = n.find((s) => !s.format) ?? n[0];
    if (!i)
      throw new Error(`Tag ${e} not found`);
    return i;
  }
  return r.find((n) => {
    var i;
    return ((i = n.identify) == null ? void 0 : i.call(n, t)) && !n.format;
  });
}
function ol(t, e, r) {
  var d, f, h;
  if (Ju(t) && (t = t.contents), yt(t))
    return t;
  if (ft(t)) {
    const p = (f = (d = r.schema[hi]).createNode) == null ? void 0 : f.call(d, r.schema, null, r);
    return p.items.push(t), p;
  }
  (t instanceof String || t instanceof Number || t instanceof Boolean || typeof BigInt < "u" && t instanceof BigInt) && (t = t.valueOf());
  const { aliasDuplicateObjects: n, onAnchor: i, onTagObj: s, schema: o, sourceObjects: a } = r;
  let l;
  if (n && t && typeof t == "object") {
    if (l = a.get(t), l)
      return l.anchor || (l.anchor = i(t)), new Tm(l.anchor);
    l = { anchor: null, node: null }, a.set(t, l);
  }
  e != null && e.startsWith("!!") && (e = YT + e.slice(2));
  let c = BT(t, e, o.tags);
  if (!c) {
    if (t && typeof t.toJSON == "function" && (t = t.toJSON()), !t || typeof t != "object") {
      const p = new Ee(t);
      return l && (l.node = p), p;
    }
    c = t instanceof Map ? o[hi] : Symbol.iterator in Object(t) ? o[Mo] : o[hi];
  }
  s && (s(c), delete r.onTagObj);
  const u = c != null && c.createNode ? c.createNode(r.schema, t, r) : typeof ((h = c == null ? void 0 : c.nodeClass) == null ? void 0 : h.from) == "function" ? c.nodeClass.from(r.schema, t, r) : new Ee(t);
  return e ? u.tag = e : c.default || (u.tag = c.tag), l && (l.node = u), u;
}
function gu(t, e, r) {
  let n = r;
  for (let i = e.length - 1; i >= 0; --i) {
    const s = e[i];
    if (typeof s == "number" && Number.isInteger(s) && s >= 0) {
      const o = [];
      o[s] = n, n = o;
    } else
      n = /* @__PURE__ */ new Map([[s, n]]);
  }
  return ol(n, void 0, {
    aliasDuplicateObjects: !1,
    keepUndefined: !1,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: t,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
const Pa = (t) => t == null || typeof t == "object" && !!t[Symbol.iterator]().next().done;
class Cm extends xm {
  constructor(e, r) {
    super(e), Object.defineProperty(this, "schema", {
      value: r,
      configurable: !0,
      enumerable: !1,
      writable: !0
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(e) {
    const r = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    return e && (r.schema = e), r.items = r.items.map((n) => yt(n) || ft(n) ? n.clone(e) : n), this.range && (r.range = this.range.slice()), r;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(e, r) {
    if (Pa(e))
      this.add(r);
    else {
      const [n, ...i] = e, s = this.get(n, !0);
      if (dt(s))
        s.addIn(i, r);
      else if (s === void 0 && this.schema)
        this.set(n, gu(this.schema, i, r));
      else
        throw new Error(`Expected YAML collection at ${n}. Remaining path: ${i}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(e) {
    const [r, ...n] = e;
    if (n.length === 0)
      return this.delete(r);
    const i = this.get(r, !0);
    if (dt(i))
      return i.deleteIn(n);
    throw new Error(`Expected YAML collection at ${r}. Remaining path: ${n}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(e, r) {
    const [n, ...i] = e, s = this.get(n, !0);
    return i.length === 0 ? !r && tt(s) ? s.value : s : dt(s) ? s.getIn(i, r) : void 0;
  }
  hasAllNullValues(e) {
    return this.items.every((r) => {
      if (!ft(r))
        return !1;
      const n = r.value;
      return n == null || e && tt(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(e) {
    const [r, ...n] = e;
    if (n.length === 0)
      return this.has(r);
    const i = this.get(r, !0);
    return dt(i) ? i.hasIn(n) : !1;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(e, r) {
    const [n, ...i] = e;
    if (i.length === 0)
      this.set(n, r);
    else {
      const s = this.get(n, !0);
      if (dt(s))
        s.setIn(i, r);
      else if (s === void 0 && this.schema)
        this.set(n, gu(this.schema, i, r));
      else
        throw new Error(`Expected YAML collection at ${n}. Remaining path: ${i}`);
    }
  }
}
Cm.maxFlowStringSingleLineLength = 60;
const FT = (t) => t.replace(/^(?!$)(?: $)?/gm, "#");
function En(t, e) {
  return /^\n+$/.test(t) ? t.substring(1) : e ? t.replace(/^(?! *$)/gm, e) : t;
}
const Ji = (t, e, r) => t.endsWith(`
`) ? En(r, e) : r.includes(`
`) ? `
` + En(r, e) : (t.endsWith(" ") ? "" : " ") + r, i$ = "flow", Bh = "block", qc = "quoted";
function ed(t, e, r = "flow", { indentAtStart: n, lineWidth: i = 80, minContentWidth: s = 20, onFold: o, onOverflow: a } = {}) {
  if (!i || i < 0)
    return t;
  const l = Math.max(1 + s, 1 + i - e.length);
  if (t.length <= l)
    return t;
  const c = [], u = {};
  let d = i - e.length;
  typeof n == "number" && (n > i - Math.max(2, s) ? c.push(0) : d = i - n);
  let f, h, p = !1, g = -1, m = -1, y = -1;
  r === Bh && (g = T1(t, g, e.length), g !== -1 && (d = g + l));
  for (let b; b = t[g += 1]; ) {
    if (r === qc && b === "\\") {
      switch (m = g, t[g + 1]) {
        case "x":
          g += 3;
          break;
        case "u":
          g += 5;
          break;
        case "U":
          g += 9;
          break;
        default:
          g += 1;
      }
      y = g;
    }
    if (b === `
`)
      r === Bh && (g = T1(t, g, e.length)), d = g + e.length + l, f = void 0;
    else {
      if (b === " " && h && h !== " " && h !== `
` && h !== "	") {
        const w = t[g + 1];
        w && w !== " " && w !== `
` && w !== "	" && (f = g);
      }
      if (g >= d)
        if (f)
          c.push(f), d = f + l, f = void 0;
        else if (r === qc) {
          for (; h === " " || h === "	"; )
            h = b, b = t[g += 1], p = !0;
          const w = g > y + 1 ? g - 2 : m - 1;
          if (u[w])
            return t;
          c.push(w), u[w] = !0, d = w + l, f = void 0;
        } else
          p = !0;
    }
    h = b;
  }
  if (p && a && a(), c.length === 0)
    return t;
  o && o();
  let O = t.slice(0, c[0]);
  for (let b = 0; b < c.length; ++b) {
    const w = c[b], S = c[b + 1] || t.length;
    w === 0 ? O = `
${e}${t.slice(0, S)}` : (r === qc && u[w] && (O += `${t[w]}\\`), O += `
${e}${t.slice(w + 1, S)}`);
  }
  return O;
}
function T1(t, e, r) {
  let n = e, i = e + 1, s = t[i];
  for (; s === " " || s === "	"; )
    if (e < i + r)
      s = t[++e];
    else {
      do
        s = t[++e];
      while (s && s !== `
`);
      n = e, i = e + 1, s = t[i];
    }
  return n;
}
const td = (t, e) => ({
  indentAtStart: e ? t.indent.length : t.indentAtStart,
  lineWidth: t.options.lineWidth,
  minContentWidth: t.options.minContentWidth
}), rd = (t) => /^(%|---|\.\.\.)/m.test(t);
function HT(t, e, r) {
  if (!e || e < 0)
    return !1;
  const n = e - r, i = t.length;
  if (i <= n)
    return !1;
  for (let s = 0, o = 0; s < i; ++s)
    if (t[s] === `
`) {
      if (s - o > n)
        return !0;
      if (o = s + 1, i - o <= n)
        return !1;
    }
  return !0;
}
function Za(t, e) {
  const r = JSON.stringify(t);
  if (e.options.doubleQuotedAsJSON)
    return r;
  const { implicitKey: n } = e, i = e.options.doubleQuotedMinMultiLineLength, s = e.indent || (rd(t) ? "  " : "");
  let o = "", a = 0;
  for (let l = 0, c = r[l]; c; c = r[++l])
    if (c === " " && r[l + 1] === "\\" && r[l + 2] === "n" && (o += r.slice(a, l) + "\\ ", l += 1, a = l, c = "\\"), c === "\\")
      switch (r[l + 1]) {
        case "u":
          {
            o += r.slice(a, l);
            const u = r.substr(l + 2, 4);
            switch (u) {
              case "0000":
                o += "\\0";
                break;
              case "0007":
                o += "\\a";
                break;
              case "000b":
                o += "\\v";
                break;
              case "001b":
                o += "\\e";
                break;
              case "0085":
                o += "\\N";
                break;
              case "00a0":
                o += "\\_";
                break;
              case "2028":
                o += "\\L";
                break;
              case "2029":
                o += "\\P";
                break;
              default:
                u.substr(0, 2) === "00" ? o += "\\x" + u.substr(2) : o += r.substr(l, 6);
            }
            l += 5, a = l + 1;
          }
          break;
        case "n":
          if (n || r[l + 2] === '"' || r.length < i)
            l += 1;
          else {
            for (o += r.slice(a, l) + `

`; r[l + 2] === "\\" && r[l + 3] === "n" && r[l + 4] !== '"'; )
              o += `
`, l += 2;
            o += s, r[l + 2] === " " && (o += "\\"), l += 1, a = l + 1;
          }
          break;
        default:
          l += 1;
      }
  return o = a ? o + r.slice(a) : r, n ? o : ed(o, s, qc, td(e, !1));
}
function Fh(t, e) {
  if (e.options.singleQuote === !1 || e.implicitKey && t.includes(`
`) || /[ \t]\n|\n[ \t]/.test(t))
    return Za(t, e);
  const r = e.indent || (rd(t) ? "  " : ""), n = "'" + t.replace(/'/g, "''").replace(/\n+/g, `$&
${r}`) + "'";
  return e.implicitKey ? n : ed(n, r, i$, td(e, !1));
}
function Ls(t, e) {
  const { singleQuote: r } = e.options;
  let n;
  if (r === !1)
    n = Za;
  else {
    const i = t.includes('"'), s = t.includes("'");
    i && !s ? n = Fh : s && !i ? n = Za : n = r ? Fh : Za;
  }
  return n(t, e);
}
let Hh;
try {
  Hh = new RegExp(`(^|(?<!
))
+(?!
|$)`, "g");
} catch {
  Hh = /\n+(?!\n|$)/g;
}
function Nc({ comment: t, type: e, value: r }, n, i, s) {
  const { blockQuote: o, commentString: a, lineWidth: l } = n.options;
  if (!o || /\n[\t ]+$/.test(r) || /^\s*$/.test(r))
    return Ls(r, n);
  const c = n.indent || (n.forceBlockIndent || rd(r) ? "  " : ""), u = o === "literal" ? !0 : o === "folded" || e === Ee.BLOCK_FOLDED ? !1 : e === Ee.BLOCK_LITERAL ? !0 : !HT(r, l, c.length);
  if (!r)
    return u ? `|
` : `>
`;
  let d, f;
  for (f = r.length; f > 0; --f) {
    const $ = r[f - 1];
    if ($ !== `
` && $ !== "	" && $ !== " ")
      break;
  }
  let h = r.substring(f);
  const p = h.indexOf(`
`);
  p === -1 ? d = "-" : r === h || p !== h.length - 1 ? (d = "+", s && s()) : d = "", h && (r = r.slice(0, -h.length), h[h.length - 1] === `
` && (h = h.slice(0, -1)), h = h.replace(Hh, `$&${c}`));
  let g = !1, m, y = -1;
  for (m = 0; m < r.length; ++m) {
    const $ = r[m];
    if ($ === " ")
      g = !0;
    else if ($ === `
`)
      y = m;
    else
      break;
  }
  let O = r.substring(0, y < m ? y + 1 : m);
  O && (r = r.substring(O.length), O = O.replace(/\n+/g, `$&${c}`));
  let w = (u ? "|" : ">") + (g ? c ? "2" : "1" : "") + d;
  if (t && (w += " " + a(t.replace(/ ?[\r\n]+/g, " ")), i && i()), u)
    return r = r.replace(/\n+/g, `$&${c}`), `${w}
${c}${O}${r}${h}`;
  r = r.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${c}`);
  const S = ed(`${O}${r}${h}`, c, Bh, td(n, !0));
  return `${w}
${c}${S}`;
}
function GT(t, e, r, n) {
  const { type: i, value: s } = t, { actualString: o, implicitKey: a, indent: l, indentStep: c, inFlow: u } = e;
  if (a && s.includes(`
`) || u && /[[\]{},]/.test(s))
    return Ls(s, e);
  if (!s || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(s))
    return a || u || !s.includes(`
`) ? Ls(s, e) : Nc(t, e, r, n);
  if (!a && !u && i !== Ee.PLAIN && s.includes(`
`))
    return Nc(t, e, r, n);
  if (rd(s)) {
    if (l === "")
      return e.forceBlockIndent = !0, Nc(t, e, r, n);
    if (a && l === c)
      return Ls(s, e);
  }
  const d = s.replace(/\n+/g, `$&
${l}`);
  if (o) {
    const f = (g) => {
      var m;
      return g.default && g.tag !== "tag:yaml.org,2002:str" && ((m = g.test) == null ? void 0 : m.test(d));
    }, { compat: h, tags: p } = e.doc.schema;
    if (p.some(f) || h != null && h.some(f))
      return Ls(s, e);
  }
  return a ? d : ed(d, l, i$, td(e, !1));
}
function Qm(t, e, r, n) {
  const { implicitKey: i, inFlow: s } = e, o = typeof t.value == "string" ? t : Object.assign({}, t, { value: String(t.value) });
  let { type: a } = t;
  a !== Ee.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(o.value) && (a = Ee.QUOTE_DOUBLE);
  const l = (u) => {
    switch (u) {
      case Ee.BLOCK_FOLDED:
      case Ee.BLOCK_LITERAL:
        return i || s ? Ls(o.value, e) : Nc(o, e, r, n);
      case Ee.QUOTE_DOUBLE:
        return Za(o.value, e);
      case Ee.QUOTE_SINGLE:
        return Fh(o.value, e);
      case Ee.PLAIN:
        return GT(o, e, r, n);
      default:
        return null;
    }
  };
  let c = l(a);
  if (c === null) {
    const { defaultKeyType: u, defaultStringType: d } = e.options, f = i && u || d;
    if (c = l(f), c === null)
      throw new Error(`Unsupported default string type ${f}`);
  }
  return c;
}
function s$(t, e) {
  const r = Object.assign({
    blockQuote: !0,
    commentString: FT,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: !1,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: !0,
    indentSeq: !0,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: !1,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: !0
  }, t.schema.toStringOptions, e);
  let n;
  switch (r.collectionStyle) {
    case "block":
      n = !1;
      break;
    case "flow":
      n = !0;
      break;
    default:
      n = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc: t,
    flowCollectionPadding: r.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof r.indent == "number" ? " ".repeat(r.indent) : "  ",
    inFlow: n,
    options: r
  };
}
function KT(t, e) {
  var i;
  if (e.tag) {
    const s = t.filter((o) => o.tag === e.tag);
    if (s.length > 0)
      return s.find((o) => o.format === e.format) ?? s[0];
  }
  let r, n;
  if (tt(e)) {
    n = e.value;
    const s = t.filter((o) => {
      var a;
      return (a = o.identify) == null ? void 0 : a.call(o, n);
    });
    r = s.find((o) => o.format === e.format) ?? s.find((o) => !o.format);
  } else
    n = e, r = t.find((s) => s.nodeClass && n instanceof s.nodeClass);
  if (!r) {
    const s = ((i = n == null ? void 0 : n.constructor) == null ? void 0 : i.name) ?? typeof n;
    throw new Error(`Tag not resolved for ${s} value`);
  }
  return r;
}
function JT(t, e, { anchors: r, doc: n }) {
  if (!n.directives)
    return "";
  const i = [], s = (tt(t) || dt(t)) && t.anchor;
  s && e$(s) && (r.add(s), i.push(`&${s}`));
  const o = t.tag ? t.tag : e.default ? null : e.tag;
  return o && i.push(n.directives.tagString(o)), i.join(" ");
}
function wo(t, e, r, n) {
  var l;
  if (ft(t))
    return t.toString(e, r, n);
  if (qo(t)) {
    if (e.doc.directives)
      return t.toString(e);
    if ((l = e.resolvedAliases) != null && l.has(t))
      throw new TypeError("Cannot stringify circular structure without alias nodes");
    e.resolvedAliases ? e.resolvedAliases.add(t) : e.resolvedAliases = /* @__PURE__ */ new Set([t]), t = t.resolve(e.doc);
  }
  let i;
  const s = yt(t) ? t : e.doc.createNode(t, { onTagObj: (c) => i = c });
  i || (i = KT(e.doc.schema.tags, s));
  const o = JT(s, i, e);
  o.length > 0 && (e.indentAtStart = (e.indentAtStart ?? 0) + o.length + 1);
  const a = typeof i.stringify == "function" ? i.stringify(s, e, r, n) : tt(s) ? Qm(s, e, r, n) : s.toString(e, r, n);
  return o ? tt(s) || a[0] === "{" || a[0] === "[" ? `${o} ${a}` : `${o}
${e.indent}${a}` : a;
}
function eC({ key: t, value: e }, r, n, i) {
  const { allNullValues: s, doc: o, indent: a, indentStep: l, options: { commentString: c, indentSeq: u, simpleKeys: d } } = r;
  let f = yt(t) && t.comment || null;
  if (d) {
    if (f)
      throw new Error("With simple keys, key nodes cannot have comments");
    if (dt(t)) {
      const _ = "With simple keys, collection cannot be used as a key value";
      throw new Error(_);
    }
  }
  let h = !d && (!t || f && e == null && !r.inFlow || dt(t) || (tt(t) ? t.type === Ee.BLOCK_FOLDED || t.type === Ee.BLOCK_LITERAL : typeof t == "object"));
  r = Object.assign({}, r, {
    allNullValues: !1,
    implicitKey: !h && (d || !s),
    indent: a + l
  });
  let p = !1, g = !1, m = wo(t, r, () => p = !0, () => g = !0);
  if (!h && !r.inFlow && m.length > 1024) {
    if (d)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    h = !0;
  }
  if (r.inFlow) {
    if (s || e == null)
      return p && n && n(), m === "" ? "?" : h ? `? ${m}` : m;
  } else if (s && !d || e == null && h)
    return m = `? ${m}`, f && !p ? m += Ji(m, r.indent, c(f)) : g && i && i(), m;
  p && (f = null), h ? (f && (m += Ji(m, r.indent, c(f))), m = `? ${m}
${a}:`) : (m = `${m}:`, f && (m += Ji(m, r.indent, c(f))));
  let y, O, b;
  yt(e) ? (y = !!e.spaceBefore, O = e.commentBefore, b = e.comment) : (y = !1, O = null, b = null, e && typeof e == "object" && (e = o.createNode(e))), r.implicitKey = !1, !h && !f && tt(e) && (r.indentAtStart = m.length + 1), g = !1, !u && l.length >= 2 && !r.inFlow && !h && $l(e) && !e.flow && !e.tag && !e.anchor && (r.indent = r.indent.substring(2));
  let w = !1;
  const S = wo(e, r, () => w = !0, () => g = !0);
  let $ = " ";
  if (f || y || O) {
    if ($ = y ? `
` : "", O) {
      const _ = c(O);
      $ += `
${En(_, r.indent)}`;
    }
    S === "" && !r.inFlow ? $ === `
` && ($ = `

`) : $ += `
${r.indent}`;
  } else if (!h && dt(e)) {
    const _ = S[0], Q = S.indexOf(`
`), N = Q !== -1, B = r.inFlow ?? e.flow ?? e.items.length === 0;
    if (N || !B) {
      let J = !1;
      if (N && (_ === "&" || _ === "!")) {
        let U = S.indexOf(" ");
        _ === "&" && U !== -1 && U < Q && S[U + 1] === "!" && (U = S.indexOf(" ", U + 1)), (U === -1 || Q < U) && (J = !0);
      }
      J || ($ = `
${r.indent}`);
    }
  } else
    (S === "" || S[0] === `
`) && ($ = "");
  return m += $ + S, r.inFlow ? w && n && n() : b && !w ? m += Ji(m, r.indent, c(b)) : g && i && i(), m;
}
function o$(t, e) {
  (t === "debug" || t === "warn") && (typeof process < "u" && process.emitWarning ? process.emitWarning(e) : console.warn(e));
}
const C1 = "<<";
function a$(t, e, { key: r, value: n }) {
  if (t != null && t.doc.schema.merge && tC(r))
    if (n = qo(n) ? n.resolve(t.doc) : n, $l(n))
      for (const i of n.items)
        mf(t, e, i);
    else if (Array.isArray(n))
      for (const i of n)
        mf(t, e, i);
    else
      mf(t, e, n);
  else {
    const i = kr(r, "", t);
    if (e instanceof Map)
      e.set(i, kr(n, i, t));
    else if (e instanceof Set)
      e.add(i);
    else {
      const s = rC(r, i, t), o = kr(n, s, t);
      s in e ? Object.defineProperty(e, s, {
        value: o,
        writable: !0,
        enumerable: !0,
        configurable: !0
      }) : e[s] = o;
    }
  }
  return e;
}
const tC = (t) => t === C1 || tt(t) && t.value === C1 && (!t.type || t.type === Ee.PLAIN);
function mf(t, e, r) {
  const n = t && qo(r) ? r.resolve(t.doc) : r;
  if (!wl(n))
    throw new Error("Merge sources must be maps or map aliases");
  const i = n.toJSON(null, t, Map);
  for (const [s, o] of i)
    e instanceof Map ? e.has(s) || e.set(s, o) : e instanceof Set ? e.add(s) : Object.prototype.hasOwnProperty.call(e, s) || Object.defineProperty(e, s, {
      value: o,
      writable: !0,
      enumerable: !0,
      configurable: !0
    });
  return e;
}
function rC(t, e, r) {
  if (e === null)
    return "";
  if (typeof e != "object")
    return String(e);
  if (yt(t) && (r != null && r.doc)) {
    const n = s$(r.doc, {});
    n.anchors = /* @__PURE__ */ new Set();
    for (const s of r.anchors.keys())
      n.anchors.add(s.anchor);
    n.inFlow = !0, n.inStringifyKey = !0;
    const i = t.toString(n);
    if (!r.mapKeyWarned) {
      let s = JSON.stringify(i);
      s.length > 40 && (s = s.substring(0, 36) + '..."'), o$(r.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${s}. Set mapAsMap: true to use object keys.`), r.mapKeyWarned = !0;
    }
    return i;
  }
  return JSON.stringify(e);
}
function Am(t, e, r) {
  const n = ol(t, void 0, r), i = ol(e, void 0, r);
  return new Ht(n, i);
}
class Ht {
  constructor(e, r = null) {
    Object.defineProperty(this, xr, { value: J2 }), this.key = e, this.value = r;
  }
  clone(e) {
    let { key: r, value: n } = this;
    return yt(r) && (r = r.clone(e)), yt(n) && (n = n.clone(e)), new Ht(r, n);
  }
  toJSON(e, r) {
    const n = r != null && r.mapAsMap ? /* @__PURE__ */ new Map() : {};
    return a$(r, n, this);
  }
  toString(e, r, n) {
    return e != null && e.doc ? eC(this, e, r, n) : JSON.stringify(this);
  }
}
function l$(t, e, r) {
  return (e.inFlow ?? t.flow ? iC : nC)(t, e, r);
}
function nC({ comment: t, items: e }, r, { blockItemPrefix: n, flowChars: i, itemIndent: s, onChompKeep: o, onComment: a }) {
  const { indent: l, options: { commentString: c } } = r, u = Object.assign({}, r, { indent: s, type: null });
  let d = !1;
  const f = [];
  for (let p = 0; p < e.length; ++p) {
    const g = e[p];
    let m = null;
    if (yt(g))
      !d && g.spaceBefore && f.push(""), Ou(r, f, g.commentBefore, d), g.comment && (m = g.comment);
    else if (ft(g)) {
      const O = yt(g.key) ? g.key : null;
      O && (!d && O.spaceBefore && f.push(""), Ou(r, f, O.commentBefore, d));
    }
    d = !1;
    let y = wo(g, u, () => m = null, () => d = !0);
    m && (y += Ji(y, s, c(m))), d && m && (d = !1), f.push(n + y);
  }
  let h;
  if (f.length === 0)
    h = i.start + i.end;
  else {
    h = f[0];
    for (let p = 1; p < f.length; ++p) {
      const g = f[p];
      h += g ? `
${l}${g}` : `
`;
    }
  }
  return t ? (h += `
` + En(c(t), l), a && a()) : d && o && o(), h;
}
function iC({ items: t }, e, { flowChars: r, itemIndent: n }) {
  const { indent: i, indentStep: s, flowCollectionPadding: o, options: { commentString: a } } = e;
  n += s;
  const l = Object.assign({}, e, {
    indent: n,
    inFlow: !0,
    type: null
  });
  let c = !1, u = 0;
  const d = [];
  for (let p = 0; p < t.length; ++p) {
    const g = t[p];
    let m = null;
    if (yt(g))
      g.spaceBefore && d.push(""), Ou(e, d, g.commentBefore, !1), g.comment && (m = g.comment);
    else if (ft(g)) {
      const O = yt(g.key) ? g.key : null;
      O && (O.spaceBefore && d.push(""), Ou(e, d, O.commentBefore, !1), O.comment && (c = !0));
      const b = yt(g.value) ? g.value : null;
      b ? (b.comment && (m = b.comment), b.commentBefore && (c = !0)) : g.value == null && (O != null && O.comment) && (m = O.comment);
    }
    m && (c = !0);
    let y = wo(g, l, () => m = null);
    p < t.length - 1 && (y += ","), m && (y += Ji(y, n, a(m))), !c && (d.length > u || y.includes(`
`)) && (c = !0), d.push(y), u = d.length;
  }
  const { start: f, end: h } = r;
  if (d.length === 0)
    return f + h;
  if (!c) {
    const p = d.reduce((g, m) => g + m.length + 2, 2);
    c = e.options.lineWidth > 0 && p > e.options.lineWidth;
  }
  if (c) {
    let p = f;
    for (const g of d)
      p += g ? `
${s}${i}${g}` : `
`;
    return `${p}
${i}${h}`;
  } else
    return `${f}${o}${d.join(" ")}${o}${h}`;
}
function Ou({ indent: t, options: { commentString: e } }, r, n, i) {
  if (n && i && (n = n.replace(/^\n+/, "")), n) {
    const s = En(e(n), t);
    r.push(s.trimStart());
  }
}
function es(t, e) {
  const r = tt(e) ? e.value : e;
  for (const n of t)
    if (ft(n) && (n.key === e || n.key === r || tt(n.key) && n.key.value === r))
      return n;
}
class vr extends Cm {
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  constructor(e) {
    super(hi, e), this.items = [];
  }
  /**
   * A generic collection parsing method that can be extended
   * to other node classes that inherit from YAMLMap
   */
  static from(e, r, n) {
    const { keepUndefined: i, replacer: s } = n, o = new this(e), a = (l, c) => {
      if (typeof s == "function")
        c = s.call(r, l, c);
      else if (Array.isArray(s) && !s.includes(l))
        return;
      (c !== void 0 || i) && o.items.push(Am(l, c, n));
    };
    if (r instanceof Map)
      for (const [l, c] of r)
        a(l, c);
    else if (r && typeof r == "object")
      for (const l of Object.keys(r))
        a(l, r[l]);
    return typeof e.sortMapEntries == "function" && o.items.sort(e.sortMapEntries), o;
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(e, r) {
    var o;
    let n;
    ft(e) ? n = e : !e || typeof e != "object" || !("key" in e) ? n = new Ht(e, e == null ? void 0 : e.value) : n = new Ht(e.key, e.value);
    const i = es(this.items, n.key), s = (o = this.schema) == null ? void 0 : o.sortMapEntries;
    if (i) {
      if (!r)
        throw new Error(`Key ${n.key} already set`);
      tt(i.value) && n$(n.value) ? i.value.value = n.value : i.value = n.value;
    } else if (s) {
      const a = this.items.findIndex((l) => s(n, l) < 0);
      a === -1 ? this.items.push(n) : this.items.splice(a, 0, n);
    } else
      this.items.push(n);
  }
  delete(e) {
    const r = es(this.items, e);
    return r ? this.items.splice(this.items.indexOf(r), 1).length > 0 : !1;
  }
  get(e, r) {
    const n = es(this.items, e), i = n == null ? void 0 : n.value;
    return (!r && tt(i) ? i.value : i) ?? void 0;
  }
  has(e) {
    return !!es(this.items, e);
  }
  set(e, r) {
    this.add(new Ht(e, r), !0);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(e, r, n) {
    const i = n ? new n() : r != null && r.mapAsMap ? /* @__PURE__ */ new Map() : {};
    r != null && r.onCreate && r.onCreate(i);
    for (const s of this.items)
      a$(r, i, s);
    return i;
  }
  toString(e, r, n) {
    if (!e)
      return JSON.stringify(this);
    for (const i of this.items)
      if (!ft(i))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(i)} instead`);
    return !e.allNullValues && this.hasAllNullValues(!1) && (e = Object.assign({}, e, { allNullValues: !0 })), l$(this, e, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: e.indent || "",
      onChompKeep: n,
      onComment: r
    });
  }
}
const No = {
  collection: "map",
  default: !0,
  nodeClass: vr,
  tag: "tag:yaml.org,2002:map",
  resolve(t, e) {
    return wl(t) || e("Expected a mapping for this tag"), t;
  },
  createNode: (t, e, r) => vr.from(t, e, r)
};
class fs extends Cm {
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  constructor(e) {
    super(Mo, e), this.items = [];
  }
  add(e) {
    this.items.push(e);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(e) {
    const r = fc(e);
    return typeof r != "number" ? !1 : this.items.splice(r, 1).length > 0;
  }
  get(e, r) {
    const n = fc(e);
    if (typeof n != "number")
      return;
    const i = this.items[n];
    return !r && tt(i) ? i.value : i;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(e) {
    const r = fc(e);
    return typeof r == "number" && r < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(e, r) {
    const n = fc(e);
    if (typeof n != "number")
      throw new Error(`Expected a valid index, not ${e}.`);
    const i = this.items[n];
    tt(i) && n$(r) ? i.value = r : this.items[n] = r;
  }
  toJSON(e, r) {
    const n = [];
    r != null && r.onCreate && r.onCreate(n);
    let i = 0;
    for (const s of this.items)
      n.push(kr(s, String(i++), r));
    return n;
  }
  toString(e, r, n) {
    return e ? l$(this, e, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (e.indent || "") + "  ",
      onChompKeep: n,
      onComment: r
    }) : JSON.stringify(this);
  }
  static from(e, r, n) {
    const { replacer: i } = n, s = new this(e);
    if (r && Symbol.iterator in Object(r)) {
      let o = 0;
      for (let a of r) {
        if (typeof i == "function") {
          const l = r instanceof Set ? a : String(o++);
          a = i.call(r, l, a);
        }
        s.items.push(ol(a, void 0, n));
      }
    }
    return s;
  }
}
function fc(t) {
  let e = tt(t) ? t.value : t;
  return e && typeof e == "string" && (e = Number(e)), typeof e == "number" && Number.isInteger(e) && e >= 0 ? e : null;
}
const Do = {
  collection: "seq",
  default: !0,
  nodeClass: fs,
  tag: "tag:yaml.org,2002:seq",
  resolve(t, e) {
    return $l(t) || e("Expected a sequence for this tag"), t;
  },
  createNode: (t, e, r) => fs.from(t, e, r)
}, nd = {
  identify: (t) => typeof t == "string",
  default: !0,
  tag: "tag:yaml.org,2002:str",
  resolve: (t) => t,
  stringify(t, e, r, n) {
    return e = Object.assign({ actualString: !0 }, e), Qm(t, e, r, n);
  }
}, id = {
  identify: (t) => t == null,
  createNode: () => new Ee(null),
  default: !0,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new Ee(null),
  stringify: ({ source: t }, e) => typeof t == "string" && id.test.test(t) ? t : e.options.nullStr
}, Em = {
  identify: (t) => typeof t == "boolean",
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (t) => new Ee(t[0] === "t" || t[0] === "T"),
  stringify({ source: t, value: e }, r) {
    if (t && Em.test.test(t)) {
      const n = t[0] === "t" || t[0] === "T";
      if (e === n)
        return t;
    }
    return e ? r.options.trueStr : r.options.falseStr;
  }
};
function Fr({ format: t, minFractionDigits: e, tag: r, value: n }) {
  if (typeof n == "bigint")
    return String(n);
  const i = typeof n == "number" ? n : Number(n);
  if (!isFinite(i))
    return isNaN(i) ? ".nan" : i < 0 ? "-.inf" : ".inf";
  let s = JSON.stringify(n);
  if (!t && e && (!r || r === "tag:yaml.org,2002:float") && /^\d/.test(s)) {
    let o = s.indexOf(".");
    o < 0 && (o = s.length, s += ".");
    let a = e - (s.length - o - 1);
    for (; a-- > 0; )
      s += "0";
  }
  return s;
}
const c$ = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
  resolve: (t) => t.slice(-3).toLowerCase() === "nan" ? NaN : t[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: Fr
}, u$ = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (t) => parseFloat(t),
  stringify(t) {
    const e = Number(t.value);
    return isFinite(e) ? e.toExponential() : Fr(t);
  }
}, d$ = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(t) {
    const e = new Ee(parseFloat(t)), r = t.indexOf(".");
    return r !== -1 && t[t.length - 1] === "0" && (e.minFractionDigits = t.length - r - 1), e;
  },
  stringify: Fr
}, sd = (t) => typeof t == "bigint" || Number.isInteger(t), Rm = (t, e, r, { intAsBigInt: n }) => n ? BigInt(t) : parseInt(t.substring(e), r);
function f$(t, e, r) {
  const { value: n } = t;
  return sd(n) && n >= 0 ? r + n.toString(e) : Fr(t);
}
const h$ = {
  identify: (t) => sd(t) && t >= 0,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (t, e, r) => Rm(t, 2, 8, r),
  stringify: (t) => f$(t, 8, "0o")
}, p$ = {
  identify: sd,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (t, e, r) => Rm(t, 0, 10, r),
  stringify: Fr
}, m$ = {
  identify: (t) => sd(t) && t >= 0,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (t, e, r) => Rm(t, 2, 16, r),
  stringify: (t) => f$(t, 16, "0x")
}, sC = [
  No,
  Do,
  nd,
  id,
  Em,
  h$,
  p$,
  m$,
  c$,
  u$,
  d$
];
function Q1(t) {
  return typeof t == "bigint" || Number.isInteger(t);
}
const hc = ({ value: t }) => JSON.stringify(t), oC = [
  {
    identify: (t) => typeof t == "string",
    default: !0,
    tag: "tag:yaml.org,2002:str",
    resolve: (t) => t,
    stringify: hc
  },
  {
    identify: (t) => t == null,
    createNode: () => new Ee(null),
    default: !0,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: hc
  },
  {
    identify: (t) => typeof t == "boolean",
    default: !0,
    tag: "tag:yaml.org,2002:bool",
    test: /^true|false$/,
    resolve: (t) => t === "true",
    stringify: hc
  },
  {
    identify: Q1,
    default: !0,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (t, e, { intAsBigInt: r }) => r ? BigInt(t) : parseInt(t, 10),
    stringify: ({ value: t }) => Q1(t) ? t.toString() : JSON.stringify(t)
  },
  {
    identify: (t) => typeof t == "number",
    default: !0,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (t) => parseFloat(t),
    stringify: hc
  }
], aC = {
  default: !0,
  tag: "",
  test: /^/,
  resolve(t, e) {
    return e(`Unresolved plain scalar ${JSON.stringify(t)}`), t;
  }
}, lC = [No, Do].concat(oC, aC), Im = {
  identify: (t) => t instanceof Uint8Array,
  // Buffer inherits from Uint8Array
  default: !1,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(t, e) {
    if (typeof Buffer == "function")
      return Buffer.from(t, "base64");
    if (typeof atob == "function") {
      const r = atob(t.replace(/[\n\r]/g, "")), n = new Uint8Array(r.length);
      for (let i = 0; i < r.length; ++i)
        n[i] = r.charCodeAt(i);
      return n;
    } else
      return e("This environment does not support reading binary tags; either Buffer or atob is required"), t;
  },
  stringify({ comment: t, type: e, value: r }, n, i, s) {
    const o = r;
    let a;
    if (typeof Buffer == "function")
      a = o instanceof Buffer ? o.toString("base64") : Buffer.from(o.buffer).toString("base64");
    else if (typeof btoa == "function") {
      let l = "";
      for (let c = 0; c < o.length; ++c)
        l += String.fromCharCode(o[c]);
      a = btoa(l);
    } else
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    if (e || (e = Ee.BLOCK_LITERAL), e !== Ee.QUOTE_DOUBLE) {
      const l = Math.max(n.options.lineWidth - n.indent.length, n.options.minContentWidth), c = Math.ceil(a.length / l), u = new Array(c);
      for (let d = 0, f = 0; d < c; ++d, f += l)
        u[d] = a.substr(f, l);
      a = u.join(e === Ee.BLOCK_LITERAL ? `
` : " ");
    }
    return Qm({ comment: t, type: e, value: a }, n, i, s);
  }
};
function g$(t, e) {
  if ($l(t))
    for (let r = 0; r < t.items.length; ++r) {
      let n = t.items[r];
      if (!ft(n)) {
        if (wl(n)) {
          n.items.length > 1 && e("Each pair must have its own sequence indicator");
          const i = n.items[0] || new Ht(new Ee(null));
          if (n.commentBefore && (i.key.commentBefore = i.key.commentBefore ? `${n.commentBefore}
${i.key.commentBefore}` : n.commentBefore), n.comment) {
            const s = i.value ?? i.key;
            s.comment = s.comment ? `${n.comment}
${s.comment}` : n.comment;
          }
          n = i;
        }
        t.items[r] = ft(n) ? n : new Ht(n);
      }
    }
  else
    e("Expected a sequence for this tag");
  return t;
}
function O$(t, e, r) {
  const { replacer: n } = r, i = new fs(t);
  i.tag = "tag:yaml.org,2002:pairs";
  let s = 0;
  if (e && Symbol.iterator in Object(e))
    for (let o of e) {
      typeof n == "function" && (o = n.call(e, String(s++), o));
      let a, l;
      if (Array.isArray(o))
        if (o.length === 2)
          a = o[0], l = o[1];
        else
          throw new TypeError(`Expected [key, value] tuple: ${o}`);
      else if (o && o instanceof Object) {
        const c = Object.keys(o);
        if (c.length === 1)
          a = c[0], l = o[a];
        else
          throw new TypeError(`Expected tuple with one key, not ${c.length} keys`);
      } else
        a = o;
      i.items.push(Am(a, l, r));
    }
  return i;
}
const jm = {
  collection: "seq",
  default: !1,
  tag: "tag:yaml.org,2002:pairs",
  resolve: g$,
  createNode: O$
};
class io extends fs {
  constructor() {
    super(), this.add = vr.prototype.add.bind(this), this.delete = vr.prototype.delete.bind(this), this.get = vr.prototype.get.bind(this), this.has = vr.prototype.has.bind(this), this.set = vr.prototype.set.bind(this), this.tag = io.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(e, r) {
    if (!r)
      return super.toJSON(e);
    const n = /* @__PURE__ */ new Map();
    r != null && r.onCreate && r.onCreate(n);
    for (const i of this.items) {
      let s, o;
      if (ft(i) ? (s = kr(i.key, "", r), o = kr(i.value, s, r)) : s = kr(i, "", r), n.has(s))
        throw new Error("Ordered maps must not include duplicate keys");
      n.set(s, o);
    }
    return n;
  }
  static from(e, r, n) {
    const i = O$(e, r, n), s = new this();
    return s.items = i.items, s;
  }
}
io.tag = "tag:yaml.org,2002:omap";
const Zm = {
  collection: "seq",
  identify: (t) => t instanceof Map,
  nodeClass: io,
  default: !1,
  tag: "tag:yaml.org,2002:omap",
  resolve(t, e) {
    const r = g$(t, e), n = [];
    for (const { key: i } of r.items)
      tt(i) && (n.includes(i.value) ? e(`Ordered maps must not include duplicate keys: ${i.value}`) : n.push(i.value));
    return Object.assign(new io(), r);
  },
  createNode: (t, e, r) => io.from(t, e, r)
};
function y$({ value: t, source: e }, r) {
  return e && (t ? b$ : v$).test.test(e) ? e : t ? r.options.trueStr : r.options.falseStr;
}
const b$ = {
  identify: (t) => t === !0,
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new Ee(!0),
  stringify: y$
}, v$ = {
  identify: (t) => t === !1,
  default: !0,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
  resolve: () => new Ee(!1),
  stringify: y$
}, cC = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
  resolve: (t) => t.slice(-3).toLowerCase() === "nan" ? NaN : t[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: Fr
}, uC = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (t) => parseFloat(t.replace(/_/g, "")),
  stringify(t) {
    const e = Number(t.value);
    return isFinite(e) ? e.toExponential() : Fr(t);
  }
}, dC = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(t) {
    const e = new Ee(parseFloat(t.replace(/_/g, ""))), r = t.indexOf(".");
    if (r !== -1) {
      const n = t.substring(r + 1).replace(/_/g, "");
      n[n.length - 1] === "0" && (e.minFractionDigits = n.length);
    }
    return e;
  },
  stringify: Fr
}, Sl = (t) => typeof t == "bigint" || Number.isInteger(t);
function od(t, e, r, { intAsBigInt: n }) {
  const i = t[0];
  if ((i === "-" || i === "+") && (e += 1), t = t.substring(e).replace(/_/g, ""), n) {
    switch (r) {
      case 2:
        t = `0b${t}`;
        break;
      case 8:
        t = `0o${t}`;
        break;
      case 16:
        t = `0x${t}`;
        break;
    }
    const o = BigInt(t);
    return i === "-" ? BigInt(-1) * o : o;
  }
  const s = parseInt(t, r);
  return i === "-" ? -1 * s : s;
}
function Mm(t, e, r) {
  const { value: n } = t;
  if (Sl(n)) {
    const i = n.toString(e);
    return n < 0 ? "-" + r + i.substr(1) : r + i;
  }
  return Fr(t);
}
const fC = {
  identify: Sl,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (t, e, r) => od(t, 2, 2, r),
  stringify: (t) => Mm(t, 2, "0b")
}, hC = {
  identify: Sl,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (t, e, r) => od(t, 1, 8, r),
  stringify: (t) => Mm(t, 8, "0")
}, pC = {
  identify: Sl,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (t, e, r) => od(t, 0, 10, r),
  stringify: Fr
}, mC = {
  identify: Sl,
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (t, e, r) => od(t, 2, 16, r),
  stringify: (t) => Mm(t, 16, "0x")
};
class so extends vr {
  constructor(e) {
    super(e), this.tag = so.tag;
  }
  add(e) {
    let r;
    ft(e) ? r = e : e && typeof e == "object" && "key" in e && "value" in e && e.value === null ? r = new Ht(e.key, null) : r = new Ht(e, null), es(this.items, r.key) || this.items.push(r);
  }
  /**
   * If `keepPair` is `true`, returns the Pair matching `key`.
   * Otherwise, returns the value of that Pair's key.
   */
  get(e, r) {
    const n = es(this.items, e);
    return !r && ft(n) ? tt(n.key) ? n.key.value : n.key : n;
  }
  set(e, r) {
    if (typeof r != "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof r}`);
    const n = es(this.items, e);
    n && !r ? this.items.splice(this.items.indexOf(n), 1) : !n && r && this.items.push(new Ht(e));
  }
  toJSON(e, r) {
    return super.toJSON(e, r, Set);
  }
  toString(e, r, n) {
    if (!e)
      return JSON.stringify(this);
    if (this.hasAllNullValues(!0))
      return super.toString(Object.assign({}, e, { allNullValues: !0 }), r, n);
    throw new Error("Set items must all have null values");
  }
  static from(e, r, n) {
    const { replacer: i } = n, s = new this(e);
    if (r && Symbol.iterator in Object(r))
      for (let o of r)
        typeof i == "function" && (o = i.call(r, o, o)), s.items.push(Am(o, null, n));
    return s;
  }
}
so.tag = "tag:yaml.org,2002:set";
const qm = {
  collection: "map",
  identify: (t) => t instanceof Set,
  nodeClass: so,
  default: !1,
  tag: "tag:yaml.org,2002:set",
  createNode: (t, e, r) => so.from(t, e, r),
  resolve(t, e) {
    if (wl(t)) {
      if (t.hasAllNullValues(!0))
        return Object.assign(new so(), t);
      e("Set items must all have null values");
    } else
      e("Expected a mapping for this tag");
    return t;
  }
};
function Nm(t, e) {
  const r = t[0], n = r === "-" || r === "+" ? t.substring(1) : t, i = (o) => e ? BigInt(o) : Number(o), s = n.replace(/_/g, "").split(":").reduce((o, a) => o * i(60) + i(a), i(0));
  return r === "-" ? i(-1) * s : s;
}
function w$(t) {
  let { value: e } = t, r = (o) => o;
  if (typeof e == "bigint")
    r = (o) => BigInt(o);
  else if (isNaN(e) || !isFinite(e))
    return Fr(t);
  let n = "";
  e < 0 && (n = "-", e *= r(-1));
  const i = r(60), s = [e % i];
  return e < 60 ? s.unshift(0) : (e = (e - s[0]) / i, s.unshift(e % i), e >= 60 && (e = (e - s[0]) / i, s.unshift(e))), n + s.map((o) => String(o).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
const $$ = {
  identify: (t) => typeof t == "bigint" || Number.isInteger(t),
  default: !0,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (t, e, { intAsBigInt: r }) => Nm(t, r),
  stringify: w$
}, S$ = {
  identify: (t) => typeof t == "number",
  default: !0,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (t) => Nm(t, !1),
  stringify: w$
}, ad = {
  identify: (t) => t instanceof Date,
  default: !0,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(t) {
    const e = t.match(ad.test);
    if (!e)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, r, n, i, s, o, a] = e.map(Number), l = e[7] ? Number((e[7] + "00").substr(1, 3)) : 0;
    let c = Date.UTC(r, n - 1, i, s || 0, o || 0, a || 0, l);
    const u = e[8];
    if (u && u !== "Z") {
      let d = Nm(u, !1);
      Math.abs(d) < 30 && (d *= 60), c -= 6e4 * d;
    }
    return new Date(c);
  },
  stringify: ({ value: t }) => t.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
}, A1 = [
  No,
  Do,
  nd,
  id,
  b$,
  v$,
  fC,
  hC,
  pC,
  mC,
  cC,
  uC,
  dC,
  Im,
  Zm,
  jm,
  qm,
  $$,
  S$,
  ad
], E1 = /* @__PURE__ */ new Map([
  ["core", sC],
  ["failsafe", [No, Do, nd]],
  ["json", lC],
  ["yaml11", A1],
  ["yaml-1.1", A1]
]), R1 = {
  binary: Im,
  bool: Em,
  float: d$,
  floatExp: u$,
  floatNaN: c$,
  floatTime: S$,
  int: p$,
  intHex: m$,
  intOct: h$,
  intTime: $$,
  map: No,
  null: id,
  omap: Zm,
  pairs: jm,
  seq: Do,
  set: qm,
  timestamp: ad
}, gC = {
  "tag:yaml.org,2002:binary": Im,
  "tag:yaml.org,2002:omap": Zm,
  "tag:yaml.org,2002:pairs": jm,
  "tag:yaml.org,2002:set": qm,
  "tag:yaml.org,2002:timestamp": ad
};
function gf(t, e) {
  let r = E1.get(e);
  if (!r)
    if (Array.isArray(t))
      r = [];
    else {
      const n = Array.from(E1.keys()).filter((i) => i !== "yaml11").map((i) => JSON.stringify(i)).join(", ");
      throw new Error(`Unknown schema "${e}"; use one of ${n} or define customTags array`);
    }
  if (Array.isArray(t))
    for (const n of t)
      r = r.concat(n);
  else
    typeof t == "function" && (r = t(r.slice()));
  return r.map((n) => {
    if (typeof n != "string")
      return n;
    const i = R1[n];
    if (i)
      return i;
    const s = Object.keys(R1).map((o) => JSON.stringify(o)).join(", ");
    throw new Error(`Unknown custom tag "${n}"; use one of ${s}`);
  });
}
const OC = (t, e) => t.key < e.key ? -1 : t.key > e.key ? 1 : 0;
let yC = class k$ {
  constructor({ compat: e, customTags: r, merge: n, resolveKnownTags: i, schema: s, sortMapEntries: o, toStringDefaults: a }) {
    this.compat = Array.isArray(e) ? gf(e, "compat") : e ? gf(null, e) : null, this.merge = !!n, this.name = typeof s == "string" && s || "core", this.knownTags = i ? gC : {}, this.tags = gf(r, this.name), this.toStringOptions = a ?? null, Object.defineProperty(this, hi, { value: No }), Object.defineProperty(this, zn, { value: nd }), Object.defineProperty(this, Mo, { value: Do }), this.sortMapEntries = typeof o == "function" ? o : o === !0 ? OC : null;
  }
  clone() {
    const e = Object.create(k$.prototype, Object.getOwnPropertyDescriptors(this));
    return e.tags = this.tags.slice(), e;
  }
};
function bC(t, e) {
  var l;
  const r = [];
  let n = e.directives === !0;
  if (e.directives !== !1 && t.directives) {
    const c = t.directives.toString(t);
    c ? (r.push(c), n = !0) : t.directives.docStart && (n = !0);
  }
  n && r.push("---");
  const i = s$(t, e), { commentString: s } = i.options;
  if (t.commentBefore) {
    r.length !== 1 && r.unshift("");
    const c = s(t.commentBefore);
    r.unshift(En(c, ""));
  }
  let o = !1, a = null;
  if (t.contents) {
    if (yt(t.contents)) {
      if (t.contents.spaceBefore && n && r.push(""), t.contents.commentBefore) {
        const d = s(t.contents.commentBefore);
        r.push(En(d, ""));
      }
      i.forceBlockIndent = !!t.comment, a = t.contents.comment;
    }
    const c = a ? void 0 : () => o = !0;
    let u = wo(t.contents, i, () => a = null, c);
    a && (u += Ji(u, "", s(a))), (u[0] === "|" || u[0] === ">") && r[r.length - 1] === "---" ? r[r.length - 1] = `--- ${u}` : r.push(u);
  } else
    r.push(wo(t.contents, i));
  if ((l = t.directives) != null && l.docEnd)
    if (t.comment) {
      const c = s(t.comment);
      c.includes(`
`) ? (r.push("..."), r.push(En(c, ""))) : r.push(`... ${c}`);
    } else
      r.push("...");
  else {
    let c = t.comment;
    c && o && (c = c.replace(/^\n+/, "")), c && ((!o || a) && r[r.length - 1] !== "" && r.push(""), r.push(En(s(c), "")));
  }
  return r.join(`
`) + `
`;
}
class kl {
  constructor(e, r, n) {
    this.commentBefore = null, this.comment = null, this.errors = [], this.warnings = [], Object.defineProperty(this, xr, { value: Yh });
    let i = null;
    typeof r == "function" || Array.isArray(r) ? i = r : n === void 0 && r && (n = r, r = void 0);
    const s = Object.assign({
      intAsBigInt: !1,
      keepSourceTokens: !1,
      logLevel: "warn",
      prettyErrors: !0,
      strict: !0,
      uniqueKeys: !0,
      version: "1.2"
    }, n);
    this.options = s;
    let { version: o } = s;
    n != null && n._directives ? (this.directives = n._directives.atDocument(), this.directives.yaml.explicit && (o = this.directives.yaml.version)) : this.directives = new Lt({ version: o }), this.setSchema(o, n), this.contents = e === void 0 ? null : this.createNode(e, i, n);
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const e = Object.create(kl.prototype, {
      [xr]: { value: Yh }
    });
    return e.commentBefore = this.commentBefore, e.comment = this.comment, e.errors = this.errors.slice(), e.warnings = this.warnings.slice(), e.options = Object.assign({}, this.options), this.directives && (e.directives = this.directives.clone()), e.schema = this.schema.clone(), e.contents = yt(this.contents) ? this.contents.clone(e.schema) : this.contents, this.range && (e.range = this.range.slice()), e;
  }
  /** Adds a value to the document. */
  add(e) {
    Qs(this.contents) && this.contents.add(e);
  }
  /** Adds a value to the document. */
  addIn(e, r) {
    Qs(this.contents) && this.contents.addIn(e, r);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(e, r) {
    if (!e.anchor) {
      const n = t$(this);
      e.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      !r || n.has(r) ? r$(r || "a", n) : r;
    }
    return new Tm(e.anchor);
  }
  createNode(e, r, n) {
    let i;
    if (typeof r == "function")
      e = r.call({ "": e }, "", e), i = r;
    else if (Array.isArray(r)) {
      const m = (O) => typeof O == "number" || O instanceof String || O instanceof Number, y = r.filter(m).map(String);
      y.length > 0 && (r = r.concat(y)), i = r;
    } else
      n === void 0 && r && (n = r, r = void 0);
    const { aliasDuplicateObjects: s, anchorPrefix: o, flow: a, keepUndefined: l, onTagObj: c, tag: u } = n ?? {}, { onAnchor: d, setAnchors: f, sourceObjects: h } = LT(
      this,
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      o || "a"
    ), p = {
      aliasDuplicateObjects: s ?? !0,
      keepUndefined: l ?? !1,
      onAnchor: d,
      onTagObj: c,
      replacer: i,
      schema: this.schema,
      sourceObjects: h
    }, g = ol(e, u, p);
    return a && dt(g) && (g.flow = !0), f(), g;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(e, r, n = {}) {
    const i = this.createNode(e, null, n), s = this.createNode(r, null, n);
    return new Ht(i, s);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(e) {
    return Qs(this.contents) ? this.contents.delete(e) : !1;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(e) {
    return Pa(e) ? this.contents == null ? !1 : (this.contents = null, !0) : Qs(this.contents) ? this.contents.deleteIn(e) : !1;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(e, r) {
    return dt(this.contents) ? this.contents.get(e, r) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(e, r) {
    return Pa(e) ? !r && tt(this.contents) ? this.contents.value : this.contents : dt(this.contents) ? this.contents.getIn(e, r) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(e) {
    return dt(this.contents) ? this.contents.has(e) : !1;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(e) {
    return Pa(e) ? this.contents !== void 0 : dt(this.contents) ? this.contents.hasIn(e) : !1;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(e, r) {
    this.contents == null ? this.contents = gu(this.schema, [e], r) : Qs(this.contents) && this.contents.set(e, r);
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(e, r) {
    Pa(e) ? this.contents = r : this.contents == null ? this.contents = gu(this.schema, Array.from(e), r) : Qs(this.contents) && this.contents.setIn(e, r);
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(e, r = {}) {
    typeof e == "number" && (e = String(e));
    let n;
    switch (e) {
      case "1.1":
        this.directives ? this.directives.yaml.version = "1.1" : this.directives = new Lt({ version: "1.1" }), n = { merge: !0, resolveKnownTags: !1, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        this.directives ? this.directives.yaml.version = e : this.directives = new Lt({ version: e }), n = { merge: !1, resolveKnownTags: !0, schema: "core" };
        break;
      case null:
        this.directives && delete this.directives, n = null;
        break;
      default: {
        const i = JSON.stringify(e);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${i}`);
      }
    }
    if (r.schema instanceof Object)
      this.schema = r.schema;
    else if (n)
      this.schema = new yC(Object.assign(n, r));
    else
      throw new Error("With a null YAML version, the { schema: Schema } option is required");
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json: e, jsonArg: r, mapAsMap: n, maxAliasCount: i, onAnchor: s, reviver: o } = {}) {
    const a = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !e,
      mapAsMap: n === !0,
      mapKeyWarned: !1,
      maxAliasCount: typeof i == "number" ? i : 100
    }, l = kr(this.contents, r ?? "", a);
    if (typeof s == "function")
      for (const { count: c, res: u } of a.anchors.values())
        s(u, c);
    return typeof o == "function" ? Vs(o, { "": l }, "", l) : l;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(e, r) {
    return this.toJS({ json: !0, jsonArg: e, mapAsMap: !1, onAnchor: r });
  }
  /** A YAML representation of the document. */
  toString(e = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in e && (!Number.isInteger(e.indent) || Number(e.indent) <= 0)) {
      const r = JSON.stringify(e.indent);
      throw new Error(`"indent" option must be a positive integer, not ${r}`);
    }
    return bC(this, e);
  }
}
function Qs(t) {
  if (dt(t))
    return !0;
  throw new Error("Expected a YAML collection as document contents");
}
class _$ extends Error {
  constructor(e, r, n, i) {
    super(), this.name = e, this.code = n, this.message = i, this.pos = r;
  }
}
class xa extends _$ {
  constructor(e, r, n) {
    super("YAMLParseError", e, r, n);
  }
}
class vC extends _$ {
  constructor(e, r, n) {
    super("YAMLWarning", e, r, n);
  }
}
const I1 = (t, e) => (r) => {
  if (r.pos[0] === -1)
    return;
  r.linePos = r.pos.map((a) => e.linePos(a));
  const { line: n, col: i } = r.linePos[0];
  r.message += ` at line ${n}, column ${i}`;
  let s = i - 1, o = t.substring(e.lineStarts[n - 1], e.lineStarts[n]).replace(/[\n\r]+$/, "");
  if (s >= 60 && o.length > 80) {
    const a = Math.min(s - 39, o.length - 79);
    o = "â€¦" + o.substring(a), s -= a - 1;
  }
  if (o.length > 80 && (o = o.substring(0, 79) + "â€¦"), n > 1 && /^ *$/.test(o.substring(0, s))) {
    let a = t.substring(e.lineStarts[n - 2], e.lineStarts[n - 1]);
    a.length > 80 && (a = a.substring(0, 79) + `â€¦
`), o = a + o;
  }
  if (/[^ ]/.test(o)) {
    let a = 1;
    const l = r.linePos[1];
    l && l.line === n && l.col > i && (a = Math.max(1, Math.min(l.col - i, 80 - s)));
    const c = " ".repeat(s) + "^".repeat(a);
    r.message += `:

${o}
${c}
`;
  }
};
function $o(t, { flow: e, indicator: r, next: n, offset: i, onError: s, startOnNewline: o }) {
  let a = !1, l = o, c = o, u = "", d = "", f = !1, h = !1, p = !1, g = null, m = null, y = null, O = null, b = null;
  for (const $ of t)
    switch (p && ($.type !== "space" && $.type !== "newline" && $.type !== "comma" && s($.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), p = !1), $.type) {
      case "space":
        !e && l && r !== "doc-start" && $.source[0] === "	" && s($, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), c = !0;
        break;
      case "comment": {
        c || s($, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const _ = $.source.substring(1) || " ";
        u ? u += d + _ : u = _, d = "", l = !1;
        break;
      }
      case "newline":
        l ? u ? u += $.source : a = !0 : d += $.source, l = !0, f = !0, (g || m) && (h = !0), c = !0;
        break;
      case "anchor":
        g && s($, "MULTIPLE_ANCHORS", "A node can have at most one anchor"), $.source.endsWith(":") && s($.offset + $.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", !0), g = $, b === null && (b = $.offset), l = !1, c = !1, p = !0;
        break;
      case "tag": {
        m && s($, "MULTIPLE_TAGS", "A node can have at most one tag"), m = $, b === null && (b = $.offset), l = !1, c = !1, p = !0;
        break;
      }
      case r:
        (g || m) && s($, "BAD_PROP_ORDER", `Anchors and tags must be after the ${$.source} indicator`), O && s($, "UNEXPECTED_TOKEN", `Unexpected ${$.source} in ${e ?? "collection"}`), O = $, l = !1, c = !1;
        break;
      case "comma":
        if (e) {
          y && s($, "UNEXPECTED_TOKEN", `Unexpected , in ${e}`), y = $, l = !1, c = !1;
          break;
        }
      default:
        s($, "UNEXPECTED_TOKEN", `Unexpected ${$.type} token`), l = !1, c = !1;
    }
  const w = t[t.length - 1], S = w ? w.offset + w.source.length : i;
  return p && n && n.type !== "space" && n.type !== "newline" && n.type !== "comma" && (n.type !== "scalar" || n.source !== "") && s(n.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), {
    comma: y,
    found: O,
    spaceBefore: a,
    comment: u,
    hasNewline: f,
    hasNewlineAfterProp: h,
    anchor: g,
    tag: m,
    end: S,
    start: b ?? S
  };
}
function al(t) {
  if (!t)
    return null;
  switch (t.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (t.source.includes(`
`))
        return !0;
      if (t.end) {
        for (const e of t.end)
          if (e.type === "newline")
            return !0;
      }
      return !1;
    case "flow-collection":
      for (const e of t.items) {
        for (const r of e.start)
          if (r.type === "newline")
            return !0;
        if (e.sep) {
          for (const r of e.sep)
            if (r.type === "newline")
              return !0;
        }
        if (al(e.key) || al(e.value))
          return !0;
      }
      return !1;
    default:
      return !0;
  }
}
function Gh(t, e, r) {
  if ((e == null ? void 0 : e.type) === "flow-collection") {
    const n = e.end[0];
    n.indent === t && (n.source === "]" || n.source === "}") && al(e) && r(n, "BAD_INDENT", "Flow end indicator should be more indented than parent", !0);
  }
}
function P$(t, e, r) {
  const { uniqueKeys: n } = t.options;
  if (n === !1)
    return !1;
  const i = typeof n == "function" ? n : (s, o) => s === o || tt(s) && tt(o) && s.value === o.value && !(s.value === "<<" && t.schema.merge);
  return e.some((s) => i(s.key, r));
}
const j1 = "All mapping items must start at the same column";
function wC({ composeNode: t, composeEmptyNode: e }, r, n, i, s) {
  var u;
  const o = (s == null ? void 0 : s.nodeClass) ?? vr, a = new o(r.schema);
  r.atRoot && (r.atRoot = !1);
  let l = n.offset, c = null;
  for (const d of n.items) {
    const { start: f, key: h, sep: p, value: g } = d, m = $o(f, {
      indicator: "explicit-key-ind",
      next: h ?? (p == null ? void 0 : p[0]),
      offset: l,
      onError: i,
      startOnNewline: !0
    }), y = !m.found;
    if (y) {
      if (h && (h.type === "block-seq" ? i(l, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key") : "indent" in h && h.indent !== n.indent && i(l, "BAD_INDENT", j1)), !m.anchor && !m.tag && !p) {
        c = m.end, m.comment && (a.comment ? a.comment += `
` + m.comment : a.comment = m.comment);
        continue;
      }
      (m.hasNewlineAfterProp || al(h)) && i(h ?? f[f.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
    } else
      ((u = m.found) == null ? void 0 : u.indent) !== n.indent && i(l, "BAD_INDENT", j1);
    const O = m.end, b = h ? t(r, h, m, i) : e(r, O, f, null, m, i);
    r.schema.compat && Gh(n.indent, h, i), P$(r, a.items, b) && i(O, "DUPLICATE_KEY", "Map keys must be unique");
    const w = $o(p ?? [], {
      indicator: "map-value-ind",
      next: g,
      offset: b.range[2],
      onError: i,
      startOnNewline: !h || h.type === "block-scalar"
    });
    if (l = w.end, w.found) {
      y && ((g == null ? void 0 : g.type) === "block-map" && !w.hasNewline && i(l, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings"), r.options.strict && m.start < w.found.offset - 1024 && i(b.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key"));
      const S = g ? t(r, g, w, i) : e(r, l, p, null, w, i);
      r.schema.compat && Gh(n.indent, g, i), l = S.range[2];
      const $ = new Ht(b, S);
      r.options.keepSourceTokens && ($.srcToken = d), a.items.push($);
    } else {
      y && i(b.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values"), w.comment && (b.comment ? b.comment += `
` + w.comment : b.comment = w.comment);
      const S = new Ht(b);
      r.options.keepSourceTokens && (S.srcToken = d), a.items.push(S);
    }
  }
  return c && c < l && i(c, "IMPOSSIBLE", "Map comment with trailing content"), a.range = [n.offset, l, c ?? l], a;
}
function $C({ composeNode: t, composeEmptyNode: e }, r, n, i, s) {
  const o = (s == null ? void 0 : s.nodeClass) ?? fs, a = new o(r.schema);
  r.atRoot && (r.atRoot = !1);
  let l = n.offset, c = null;
  for (const { start: u, value: d } of n.items) {
    const f = $o(u, {
      indicator: "seq-item-ind",
      next: d,
      offset: l,
      onError: i,
      startOnNewline: !0
    });
    if (!f.found)
      if (f.anchor || f.tag || d)
        d && d.type === "block-seq" ? i(f.end, "BAD_INDENT", "All sequence items must start at the same column") : i(l, "MISSING_CHAR", "Sequence item without - indicator");
      else {
        c = f.end, f.comment && (a.comment = f.comment);
        continue;
      }
    const h = d ? t(r, d, f, i) : e(r, f.end, u, null, f, i);
    r.schema.compat && Gh(n.indent, d, i), l = h.range[2], a.items.push(h);
  }
  return a.range = [n.offset, l, c ?? l], a;
}
function _l(t, e, r, n) {
  let i = "";
  if (t) {
    let s = !1, o = "";
    for (const a of t) {
      const { source: l, type: c } = a;
      switch (c) {
        case "space":
          s = !0;
          break;
        case "comment": {
          r && !s && n(a, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const u = l.substring(1) || " ";
          i ? i += o + u : i = u, o = "";
          break;
        }
        case "newline":
          i && (o += l), s = !0;
          break;
        default:
          n(a, "UNEXPECTED_TOKEN", `Unexpected ${c} at node end`);
      }
      e += l.length;
    }
  }
  return { comment: i, offset: e };
}
const Of = "Block collections are not allowed within flow collections", yf = (t) => t && (t.type === "block-map" || t.type === "block-seq");
function SC({ composeNode: t, composeEmptyNode: e }, r, n, i, s) {
  const o = n.start.source === "{", a = o ? "flow map" : "flow sequence", l = (s == null ? void 0 : s.nodeClass) ?? (o ? vr : fs), c = new l(r.schema);
  c.flow = !0;
  const u = r.atRoot;
  u && (r.atRoot = !1);
  let d = n.offset + n.start.source.length;
  for (let m = 0; m < n.items.length; ++m) {
    const y = n.items[m], { start: O, key: b, sep: w, value: S } = y, $ = $o(O, {
      flow: a,
      indicator: "explicit-key-ind",
      next: b ?? (w == null ? void 0 : w[0]),
      offset: d,
      onError: i,
      startOnNewline: !1
    });
    if (!$.found) {
      if (!$.anchor && !$.tag && !w && !S) {
        m === 0 && $.comma ? i($.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${a}`) : m < n.items.length - 1 && i($.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${a}`), $.comment && (c.comment ? c.comment += `
` + $.comment : c.comment = $.comment), d = $.end;
        continue;
      }
      !o && r.options.strict && al(b) && i(
        b,
        // checked by containsNewline()
        "MULTILINE_IMPLICIT_KEY",
        "Implicit keys of flow sequence pairs need to be on a single line"
      );
    }
    if (m === 0)
      $.comma && i($.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${a}`);
    else if ($.comma || i($.start, "MISSING_CHAR", `Missing , between ${a} items`), $.comment) {
      let _ = "";
      e:
        for (const Q of O)
          switch (Q.type) {
            case "comma":
            case "space":
              break;
            case "comment":
              _ = Q.source.substring(1);
              break e;
            default:
              break e;
          }
      if (_) {
        let Q = c.items[c.items.length - 1];
        ft(Q) && (Q = Q.value ?? Q.key), Q.comment ? Q.comment += `
` + _ : Q.comment = _, $.comment = $.comment.substring(_.length + 1);
      }
    }
    if (!o && !w && !$.found) {
      const _ = S ? t(r, S, $, i) : e(r, $.end, w, null, $, i);
      c.items.push(_), d = _.range[2], yf(S) && i(_.range, "BLOCK_IN_FLOW", Of);
    } else {
      const _ = $.end, Q = b ? t(r, b, $, i) : e(r, _, O, null, $, i);
      yf(b) && i(Q.range, "BLOCK_IN_FLOW", Of);
      const N = $o(w ?? [], {
        flow: a,
        indicator: "map-value-ind",
        next: S,
        offset: Q.range[2],
        onError: i,
        startOnNewline: !1
      });
      if (N.found) {
        if (!o && !$.found && r.options.strict) {
          if (w)
            for (const U of w) {
              if (U === N.found)
                break;
              if (U.type === "newline") {
                i(U, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          $.start < N.found.offset - 1024 && i(N.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else
        S && ("source" in S && S.source && S.source[0] === ":" ? i(S, "MISSING_CHAR", `Missing space after : in ${a}`) : i(N.start, "MISSING_CHAR", `Missing , or : between ${a} items`));
      const B = S ? t(r, S, N, i) : N.found ? e(r, N.end, w, null, N, i) : null;
      B ? yf(S) && i(B.range, "BLOCK_IN_FLOW", Of) : N.comment && (Q.comment ? Q.comment += `
` + N.comment : Q.comment = N.comment);
      const J = new Ht(Q, B);
      if (r.options.keepSourceTokens && (J.srcToken = y), o) {
        const U = c;
        P$(r, U.items, Q) && i(_, "DUPLICATE_KEY", "Map keys must be unique"), U.items.push(J);
      } else {
        const U = new vr(r.schema);
        U.flow = !0, U.items.push(J), c.items.push(U);
      }
      d = B ? B.range[2] : N.end;
    }
  }
  const f = o ? "}" : "]", [h, ...p] = n.end;
  let g = d;
  if (h && h.source === f)
    g = h.offset + h.source.length;
  else {
    const m = a[0].toUpperCase() + a.substring(1), y = u ? `${m} must end with a ${f}` : `${m} in block collection must be sufficiently indented and end with a ${f}`;
    i(d, u ? "MISSING_CHAR" : "BAD_INDENT", y), h && h.source.length !== 1 && p.unshift(h);
  }
  if (p.length > 0) {
    const m = _l(p, g, r.options.strict, i);
    m.comment && (c.comment ? c.comment += `
` + m.comment : c.comment = m.comment), c.range = [n.offset, g, m.offset];
  } else
    c.range = [n.offset, g, g];
  return c;
}
function bf(t, e, r, n, i, s) {
  const o = r.type === "block-map" ? wC(t, e, r, n, s) : r.type === "block-seq" ? $C(t, e, r, n, s) : SC(t, e, r, n, s), a = o.constructor;
  return i === "!" || i === a.tagName ? (o.tag = a.tagName, o) : (i && (o.tag = i), o);
}
function kC(t, e, r, n, i) {
  var d;
  const s = n ? e.directives.tagName(n.source, (f) => i(n, "TAG_RESOLVE_FAILED", f)) : null, o = r.type === "block-map" ? "map" : r.type === "block-seq" ? "seq" : r.start.source === "{" ? "map" : "seq";
  if (!n || !s || s === "!" || s === vr.tagName && o === "map" || s === fs.tagName && o === "seq" || !o)
    return bf(t, e, r, i, s);
  let a = e.schema.tags.find((f) => f.tag === s && f.collection === o);
  if (!a) {
    const f = e.schema.knownTags[s];
    if (f && f.collection === o)
      e.schema.tags.push(Object.assign({}, f, { default: !1 })), a = f;
    else
      return f != null && f.collection ? i(n, "BAD_COLLECTION_TYPE", `${f.tag} used for ${o} collection, but expects ${f.collection}`, !0) : i(n, "TAG_RESOLVE_FAILED", `Unresolved tag: ${s}`, !0), bf(t, e, r, i, s);
  }
  const l = bf(t, e, r, i, s, a), c = ((d = a.resolve) == null ? void 0 : d.call(a, l, (f) => i(n, "TAG_RESOLVE_FAILED", f), e.options)) ?? l, u = yt(c) ? c : new Ee(c);
  return u.range = l.range, u.tag = s, a != null && a.format && (u.format = a.format), u;
}
function _C(t, e, r) {
  const n = t.offset, i = PC(t, e, r);
  if (!i)
    return { value: "", type: null, comment: "", range: [n, n, n] };
  const s = i.mode === ">" ? Ee.BLOCK_FOLDED : Ee.BLOCK_LITERAL, o = t.source ? xC(t.source) : [];
  let a = o.length;
  for (let g = o.length - 1; g >= 0; --g) {
    const m = o[g][1];
    if (m === "" || m === "\r")
      a = g;
    else
      break;
  }
  if (a === 0) {
    const g = i.chomp === "+" && o.length > 0 ? `
`.repeat(Math.max(1, o.length - 1)) : "";
    let m = n + i.length;
    return t.source && (m += t.source.length), { value: g, type: s, comment: i.comment, range: [n, m, m] };
  }
  let l = t.indent + i.indent, c = t.offset + i.length, u = 0;
  for (let g = 0; g < a; ++g) {
    const [m, y] = o[g];
    if (y === "" || y === "\r")
      i.indent === 0 && m.length > l && (l = m.length);
    else {
      m.length < l && r(c + m.length, "MISSING_CHAR", "Block scalars with more-indented leading empty lines must use an explicit indentation indicator"), i.indent === 0 && (l = m.length), u = g;
      break;
    }
    c += m.length + y.length + 1;
  }
  for (let g = o.length - 1; g >= a; --g)
    o[g][0].length > l && (a = g + 1);
  let d = "", f = "", h = !1;
  for (let g = 0; g < u; ++g)
    d += o[g][0].slice(l) + `
`;
  for (let g = u; g < a; ++g) {
    let [m, y] = o[g];
    c += m.length + y.length + 1;
    const O = y[y.length - 1] === "\r";
    if (O && (y = y.slice(0, -1)), y && m.length < l) {
      const w = `Block scalar lines must not be less indented than their ${i.indent ? "explicit indentation indicator" : "first line"}`;
      r(c - y.length - (O ? 2 : 1), "BAD_INDENT", w), m = "";
    }
    s === Ee.BLOCK_LITERAL ? (d += f + m.slice(l) + y, f = `
`) : m.length > l || y[0] === "	" ? (f === " " ? f = `
` : !h && f === `
` && (f = `

`), d += f + m.slice(l) + y, f = `
`, h = !0) : y === "" ? f === `
` ? d += `
` : f = `
` : (d += f + y, f = " ", h = !1);
  }
  switch (i.chomp) {
    case "-":
      break;
    case "+":
      for (let g = a; g < o.length; ++g)
        d += `
` + o[g][0].slice(l);
      d[d.length - 1] !== `
` && (d += `
`);
      break;
    default:
      d += `
`;
  }
  const p = n + i.length + t.source.length;
  return { value: d, type: s, comment: i.comment, range: [n, p, p] };
}
function PC({ offset: t, props: e }, r, n) {
  if (e[0].type !== "block-scalar-header")
    return n(e[0], "IMPOSSIBLE", "Block scalar header not found"), null;
  const { source: i } = e[0], s = i[0];
  let o = 0, a = "", l = -1;
  for (let f = 1; f < i.length; ++f) {
    const h = i[f];
    if (!a && (h === "-" || h === "+"))
      a = h;
    else {
      const p = Number(h);
      !o && p ? o = p : l === -1 && (l = t + f);
    }
  }
  l !== -1 && n(l, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${i}`);
  let c = !1, u = "", d = i.length;
  for (let f = 1; f < e.length; ++f) {
    const h = e[f];
    switch (h.type) {
      case "space":
        c = !0;
      case "newline":
        d += h.source.length;
        break;
      case "comment":
        r && !c && n(h, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters"), d += h.source.length, u = h.source.substring(1);
        break;
      case "error":
        n(h, "UNEXPECTED_TOKEN", h.message), d += h.source.length;
        break;
      default: {
        const p = `Unexpected token in block scalar header: ${h.type}`;
        n(h, "UNEXPECTED_TOKEN", p);
        const g = h.source;
        g && typeof g == "string" && (d += g.length);
      }
    }
  }
  return { mode: s, indent: o, chomp: a, comment: u, length: d };
}
function xC(t) {
  const e = t.split(/\n( *)/), r = e[0], n = r.match(/^( *)/), s = [n != null && n[1] ? [n[1], r.slice(n[1].length)] : ["", r]];
  for (let o = 1; o < e.length; o += 2)
    s.push([e[o], e[o + 1]]);
  return s;
}
function TC(t, e, r) {
  const { offset: n, type: i, source: s, end: o } = t;
  let a, l;
  const c = (f, h, p) => r(n + f, h, p);
  switch (i) {
    case "scalar":
      a = Ee.PLAIN, l = CC(s, c);
      break;
    case "single-quoted-scalar":
      a = Ee.QUOTE_SINGLE, l = QC(s, c);
      break;
    case "double-quoted-scalar":
      a = Ee.QUOTE_DOUBLE, l = AC(s, c);
      break;
    default:
      return r(t, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${i}`), {
        value: "",
        type: null,
        comment: "",
        range: [n, n + s.length, n + s.length]
      };
  }
  const u = n + s.length, d = _l(o, u, e, r);
  return {
    value: l,
    type: a,
    comment: d.comment,
    range: [n, u, d.offset]
  };
}
function CC(t, e) {
  let r = "";
  switch (t[0]) {
    case "	":
      r = "a tab character";
      break;
    case ",":
      r = "flow indicator character ,";
      break;
    case "%":
      r = "directive indicator character %";
      break;
    case "|":
    case ">": {
      r = `block scalar indicator ${t[0]}`;
      break;
    }
    case "@":
    case "`": {
      r = `reserved character ${t[0]}`;
      break;
    }
  }
  return r && e(0, "BAD_SCALAR_START", `Plain value cannot start with ${r}`), x$(t);
}
function QC(t, e) {
  return (t[t.length - 1] !== "'" || t.length === 1) && e(t.length, "MISSING_CHAR", "Missing closing 'quote"), x$(t.slice(1, -1)).replace(/''/g, "'");
}
function x$(t) {
  let e, r;
  try {
    e = new RegExp(`(.*?)(?<![ 	])[ 	]*\r?
`, "sy"), r = new RegExp(`[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?
`, "sy");
  } catch {
    e = /(.*?)[ \t]*\r?\n/sy, r = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let n = e.exec(t);
  if (!n)
    return t;
  let i = n[1], s = " ", o = e.lastIndex;
  for (r.lastIndex = o; n = r.exec(t); )
    n[1] === "" ? s === `
` ? i += s : s = `
` : (i += s + n[1], s = " "), o = r.lastIndex;
  const a = /[ \t]*(.*)/sy;
  return a.lastIndex = o, n = a.exec(t), i + s + ((n == null ? void 0 : n[1]) ?? "");
}
function AC(t, e) {
  let r = "";
  for (let n = 1; n < t.length - 1; ++n) {
    const i = t[n];
    if (!(i === "\r" && t[n + 1] === `
`))
      if (i === `
`) {
        const { fold: s, offset: o } = EC(t, n);
        r += s, n = o;
      } else if (i === "\\") {
        let s = t[++n];
        const o = RC[s];
        if (o)
          r += o;
        else if (s === `
`)
          for (s = t[n + 1]; s === " " || s === "	"; )
            s = t[++n + 1];
        else if (s === "\r" && t[n + 1] === `
`)
          for (s = t[++n + 1]; s === " " || s === "	"; )
            s = t[++n + 1];
        else if (s === "x" || s === "u" || s === "U") {
          const a = { x: 2, u: 4, U: 8 }[s];
          r += IC(t, n + 1, a, e), n += a;
        } else {
          const a = t.substr(n - 1, 2);
          e(n - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${a}`), r += a;
        }
      } else if (i === " " || i === "	") {
        const s = n;
        let o = t[n + 1];
        for (; o === " " || o === "	"; )
          o = t[++n + 1];
        o !== `
` && !(o === "\r" && t[n + 2] === `
`) && (r += n > s ? t.slice(s, n + 1) : i);
      } else
        r += i;
  }
  return (t[t.length - 1] !== '"' || t.length === 1) && e(t.length, "MISSING_CHAR", 'Missing closing "quote'), r;
}
function EC(t, e) {
  let r = "", n = t[e + 1];
  for (; (n === " " || n === "	" || n === `
` || n === "\r") && !(n === "\r" && t[e + 2] !== `
`); )
    n === `
` && (r += `
`), e += 1, n = t[e + 1];
  return r || (r = " "), { fold: r, offset: e };
}
const RC = {
  0: "\0",
  // null character
  a: "\x07",
  // bell character
  b: "\b",
  // backspace
  e: "\x1B",
  // escape character
  f: "\f",
  // form feed
  n: `
`,
  // line feed
  r: "\r",
  // carriage return
  t: "	",
  // horizontal tab
  v: "\v",
  // vertical tab
  N: "Â…",
  // Unicode next line
  _: "Â ",
  // Unicode non-breaking space
  L: "\u2028",
  // Unicode line separator
  P: "\u2029",
  // Unicode paragraph separator
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function IC(t, e, r, n) {
  const i = t.substr(e, r), o = i.length === r && /^[0-9a-fA-F]+$/.test(i) ? parseInt(i, 16) : NaN;
  if (isNaN(o)) {
    const a = t.substr(e - 2, r + 2);
    return n(e - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${a}`), a;
  }
  return String.fromCodePoint(o);
}
function T$(t, e, r, n) {
  const { value: i, type: s, comment: o, range: a } = e.type === "block-scalar" ? _C(e, t.options.strict, n) : TC(e, t.options.strict, n), l = r ? t.directives.tagName(r.source, (d) => n(r, "TAG_RESOLVE_FAILED", d)) : null, c = r && l ? jC(t.schema, i, l, r, n) : e.type === "scalar" ? ZC(t, i, e, n) : t.schema[zn];
  let u;
  try {
    const d = c.resolve(i, (f) => n(r ?? e, "TAG_RESOLVE_FAILED", f), t.options);
    u = tt(d) ? d : new Ee(d);
  } catch (d) {
    const f = d instanceof Error ? d.message : String(d);
    n(r ?? e, "TAG_RESOLVE_FAILED", f), u = new Ee(i);
  }
  return u.range = a, u.source = i, s && (u.type = s), l && (u.tag = l), c.format && (u.format = c.format), o && (u.comment = o), u;
}
function jC(t, e, r, n, i) {
  var a;
  if (r === "!")
    return t[zn];
  const s = [];
  for (const l of t.tags)
    if (!l.collection && l.tag === r)
      if (l.default && l.test)
        s.push(l);
      else
        return l;
  for (const l of s)
    if ((a = l.test) != null && a.test(e))
      return l;
  const o = t.knownTags[r];
  return o && !o.collection ? (t.tags.push(Object.assign({}, o, { default: !1, test: void 0 })), o) : (i(n, "TAG_RESOLVE_FAILED", `Unresolved tag: ${r}`, r !== "tag:yaml.org,2002:str"), t[zn]);
}
function ZC({ directives: t, schema: e }, r, n, i) {
  const s = e.tags.find((o) => {
    var a;
    return o.default && ((a = o.test) == null ? void 0 : a.test(r));
  }) || e[zn];
  if (e.compat) {
    const o = e.compat.find((a) => {
      var l;
      return a.default && ((l = a.test) == null ? void 0 : l.test(r));
    }) ?? e[zn];
    if (s.tag !== o.tag) {
      const a = t.tagString(s.tag), l = t.tagString(o.tag), c = `Value may be parsed as either ${a} or ${l}`;
      i(n, "TAG_RESOLVE_FAILED", c, !0);
    }
  }
  return s;
}
function MC(t, e, r) {
  if (e) {
    r === null && (r = e.length);
    for (let n = r - 1; n >= 0; --n) {
      let i = e[n];
      switch (i.type) {
        case "space":
        case "comment":
        case "newline":
          t -= i.source.length;
          continue;
      }
      for (i = e[++n]; (i == null ? void 0 : i.type) === "space"; )
        t += i.source.length, i = e[++n];
      break;
    }
  }
  return t;
}
const qC = { composeNode: C$, composeEmptyNode: Dm };
function C$(t, e, r, n) {
  const { spaceBefore: i, comment: s, anchor: o, tag: a } = r;
  let l, c = !0;
  switch (e.type) {
    case "alias":
      l = NC(t, e, n), (o || a) && n(e, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      l = T$(t, e, a, n), o && (l.anchor = o.source.substring(1));
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      l = kC(qC, t, e, a, n), o && (l.anchor = o.source.substring(1));
      break;
    default: {
      const u = e.type === "error" ? e.message : `Unsupported token (type: ${e.type})`;
      n(e, "UNEXPECTED_TOKEN", u), l = Dm(t, e.offset, void 0, null, r, n), c = !1;
    }
  }
  return o && l.anchor === "" && n(o, "BAD_ALIAS", "Anchor cannot be an empty string"), i && (l.spaceBefore = !0), s && (e.type === "scalar" && e.source === "" ? l.comment = s : l.commentBefore = s), t.options.keepSourceTokens && c && (l.srcToken = e), l;
}
function Dm(t, e, r, n, { spaceBefore: i, comment: s, anchor: o, tag: a, end: l }, c) {
  const u = {
    type: "scalar",
    offset: MC(e, r, n),
    indent: -1,
    source: ""
  }, d = T$(t, u, a, c);
  return o && (d.anchor = o.source.substring(1), d.anchor === "" && c(o, "BAD_ALIAS", "Anchor cannot be an empty string")), i && (d.spaceBefore = !0), s && (d.comment = s, d.range[2] = l), d;
}
function NC({ options: t }, { offset: e, source: r, end: n }, i) {
  const s = new Tm(r.substring(1));
  s.source === "" && i(e, "BAD_ALIAS", "Alias cannot be an empty string"), s.source.endsWith(":") && i(e + r.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", !0);
  const o = e + r.length, a = _l(n, o, t.strict, i);
  return s.range = [e, o, a.offset], a.comment && (s.comment = a.comment), s;
}
function DC(t, e, { offset: r, start: n, value: i, end: s }, o) {
  const a = Object.assign({ _directives: e }, t), l = new kl(void 0, a), c = {
    atRoot: !0,
    directives: l.directives,
    options: l.options,
    schema: l.schema
  }, u = $o(n, {
    indicator: "doc-start",
    next: i ?? (s == null ? void 0 : s[0]),
    offset: r,
    onError: o,
    startOnNewline: !0
  });
  u.found && (l.directives.docStart = !0, i && (i.type === "block-map" || i.type === "block-seq") && !u.hasNewline && o(u.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker")), l.contents = i ? C$(c, i, u, o) : Dm(c, u.end, n, null, u, o);
  const d = l.contents.range[2], f = _l(s, d, !1, o);
  return f.comment && (l.comment = f.comment), l.range = [r, d, f.offset], l;
}
function fa(t) {
  if (typeof t == "number")
    return [t, t + 1];
  if (Array.isArray(t))
    return t.length === 2 ? t : [t[0], t[1]];
  const { offset: e, source: r } = t;
  return [e, e + (typeof r == "string" ? r.length : 1)];
}
function Z1(t) {
  var i;
  let e = "", r = !1, n = !1;
  for (let s = 0; s < t.length; ++s) {
    const o = t[s];
    switch (o[0]) {
      case "#":
        e += (e === "" ? "" : n ? `

` : `
`) + (o.substring(1) || " "), r = !0, n = !1;
        break;
      case "%":
        ((i = t[s + 1]) == null ? void 0 : i[0]) !== "#" && (s += 1), r = !1;
        break;
      default:
        r || (n = !0), r = !1;
    }
  }
  return { comment: e, afterEmptyLine: n };
}
class zC {
  constructor(e = {}) {
    this.doc = null, this.atDirectives = !1, this.prelude = [], this.errors = [], this.warnings = [], this.onError = (r, n, i, s) => {
      const o = fa(r);
      s ? this.warnings.push(new vC(o, n, i)) : this.errors.push(new xa(o, n, i));
    }, this.directives = new Lt({ version: e.version || "1.2" }), this.options = e;
  }
  decorate(e, r) {
    const { comment: n, afterEmptyLine: i } = Z1(this.prelude);
    if (n) {
      const s = e.contents;
      if (r)
        e.comment = e.comment ? `${e.comment}
${n}` : n;
      else if (i || e.directives.docStart || !s)
        e.commentBefore = n;
      else if (dt(s) && !s.flow && s.items.length > 0) {
        let o = s.items[0];
        ft(o) && (o = o.key);
        const a = o.commentBefore;
        o.commentBefore = a ? `${n}
${a}` : n;
      } else {
        const o = s.commentBefore;
        s.commentBefore = o ? `${n}
${o}` : n;
      }
    }
    r ? (Array.prototype.push.apply(e.errors, this.errors), Array.prototype.push.apply(e.warnings, this.warnings)) : (e.errors = this.errors, e.warnings = this.warnings), this.prelude = [], this.errors = [], this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: Z1(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(e, r = !1, n = -1) {
    for (const i of e)
      yield* this.next(i);
    yield* this.end(r, n);
  }
  /** Advance the composer by one CST token. */
  *next(e) {
    switch (e.type) {
      case "directive":
        this.directives.add(e.source, (r, n, i) => {
          const s = fa(e);
          s[0] += r, this.onError(s, "BAD_DIRECTIVE", n, i);
        }), this.prelude.push(e.source), this.atDirectives = !0;
        break;
      case "document": {
        const r = DC(this.options, this.directives, e, this.onError);
        this.atDirectives && !r.directives.docStart && this.onError(e, "MISSING_CHAR", "Missing directives-end/doc-start indicator line"), this.decorate(r, !1), this.doc && (yield this.doc), this.doc = r, this.atDirectives = !1;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(e.source);
        break;
      case "error": {
        const r = e.source ? `${e.message}: ${JSON.stringify(e.source)}` : e.message, n = new xa(fa(e), "UNEXPECTED_TOKEN", r);
        this.atDirectives || !this.doc ? this.errors.push(n) : this.doc.errors.push(n);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const n = "Unexpected doc-end without preceding document";
          this.errors.push(new xa(fa(e), "UNEXPECTED_TOKEN", n));
          break;
        }
        this.doc.directives.docEnd = !0;
        const r = _l(e.end, e.offset + e.source.length, this.doc.options.strict, this.onError);
        if (this.decorate(this.doc, !0), r.comment) {
          const n = this.doc.comment;
          this.doc.comment = n ? `${n}
${r.comment}` : r.comment;
        }
        this.doc.range[2] = r.offset;
        break;
      }
      default:
        this.errors.push(new xa(fa(e), "UNEXPECTED_TOKEN", `Unsupported token ${e.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(e = !1, r = -1) {
    if (this.doc)
      this.decorate(this.doc, !0), yield this.doc, this.doc = null;
    else if (e) {
      const n = Object.assign({ _directives: this.directives }, this.options), i = new kl(void 0, n);
      this.atDirectives && this.onError(r, "MISSING_CHAR", "Missing directives-end indicator line"), i.range = [0, r, r], this.decorate(i, !1), yield i;
    }
  }
}
const Q$ = "\uFEFF", A$ = "", E$ = "", Kh = "";
function XC(t) {
  switch (t) {
    case Q$:
      return "byte-order-mark";
    case A$:
      return "doc-mode";
    case E$:
      return "flow-error-end";
    case Kh:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case `
`:
    case `\r
`:
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (t[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}
function yr(t) {
  switch (t) {
    case void 0:
    case " ":
    case `
`:
    case "\r":
    case "	":
      return !0;
    default:
      return !1;
  }
}
const M1 = "0123456789ABCDEFabcdef".split(""), WC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split(""), vf = ",[]{}".split(""), UC = ` ,[]{}
\r	`.split(""), wf = (t) => !t || UC.includes(t);
class VC {
  constructor() {
    this.atEnd = !1, this.blockScalarIndent = -1, this.blockScalarKeep = !1, this.buffer = "", this.flowKey = !1, this.flowLevel = 0, this.indentNext = 0, this.indentValue = 0, this.lineEndPos = null, this.next = null, this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(e, r = !1) {
    e && (this.buffer = this.buffer ? this.buffer + e : e, this.lineEndPos = null), this.atEnd = !r;
    let n = this.next ?? "stream";
    for (; n && (r || this.hasChars(1)); )
      n = yield* this.parseNext(n);
  }
  atLineEnd() {
    let e = this.pos, r = this.buffer[e];
    for (; r === " " || r === "	"; )
      r = this.buffer[++e];
    return !r || r === "#" || r === `
` ? !0 : r === "\r" ? this.buffer[e + 1] === `
` : !1;
  }
  charAt(e) {
    return this.buffer[this.pos + e];
  }
  continueScalar(e) {
    let r = this.buffer[e];
    if (this.indentNext > 0) {
      let n = 0;
      for (; r === " "; )
        r = this.buffer[++n + e];
      if (r === "\r") {
        const i = this.buffer[n + e + 1];
        if (i === `
` || !i && !this.atEnd)
          return e + n + 1;
      }
      return r === `
` || n >= this.indentNext || !r && !this.atEnd ? e + n : -1;
    }
    if (r === "-" || r === ".") {
      const n = this.buffer.substr(e, 3);
      if ((n === "---" || n === "...") && yr(this.buffer[e + 3]))
        return -1;
    }
    return e;
  }
  getLine() {
    let e = this.lineEndPos;
    return (typeof e != "number" || e !== -1 && e < this.pos) && (e = this.buffer.indexOf(`
`, this.pos), this.lineEndPos = e), e === -1 ? this.atEnd ? this.buffer.substring(this.pos) : null : (this.buffer[e - 1] === "\r" && (e -= 1), this.buffer.substring(this.pos, e));
  }
  hasChars(e) {
    return this.pos + e <= this.buffer.length;
  }
  setNext(e) {
    return this.buffer = this.buffer.substring(this.pos), this.pos = 0, this.lineEndPos = null, this.next = e, null;
  }
  peek(e) {
    return this.buffer.substr(this.pos, e);
  }
  *parseNext(e) {
    switch (e) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let e = this.getLine();
    if (e === null)
      return this.setNext("stream");
    if (e[0] === Q$ && (yield* this.pushCount(1), e = e.substring(1)), e[0] === "%") {
      let r = e.length;
      const n = e.indexOf("#");
      if (n !== -1) {
        const s = e[n - 1];
        (s === " " || s === "	") && (r = n - 1);
      }
      for (; ; ) {
        const s = e[r - 1];
        if (s === " " || s === "	")
          r -= 1;
        else
          break;
      }
      const i = (yield* this.pushCount(r)) + (yield* this.pushSpaces(!0));
      return yield* this.pushCount(e.length - i), this.pushNewline(), "stream";
    }
    if (this.atLineEnd()) {
      const r = yield* this.pushSpaces(!0);
      return yield* this.pushCount(e.length - r), yield* this.pushNewline(), "stream";
    }
    return yield A$, yield* this.parseLineStart();
  }
  *parseLineStart() {
    const e = this.charAt(0);
    if (!e && !this.atEnd)
      return this.setNext("line-start");
    if (e === "-" || e === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const r = this.peek(3);
      if (r === "---" && yr(this.charAt(3)))
        return yield* this.pushCount(3), this.indentValue = 0, this.indentNext = 0, "doc";
      if (r === "..." && yr(this.charAt(3)))
        return yield* this.pushCount(3), "stream";
    }
    return this.indentValue = yield* this.pushSpaces(!1), this.indentNext > this.indentValue && !yr(this.charAt(1)) && (this.indentNext = this.indentValue), yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [e, r] = this.peek(2);
    if (!r && !this.atEnd)
      return this.setNext("block-start");
    if ((e === "-" || e === "?" || e === ":") && yr(r)) {
      const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0));
      return this.indentNext = this.indentValue + 1, this.indentValue += n, yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(!0);
    const e = this.getLine();
    if (e === null)
      return this.setNext("doc");
    let r = yield* this.pushIndicators();
    switch (e[r]) {
      case "#":
        yield* this.pushCount(e.length - r);
      case void 0:
        return yield* this.pushNewline(), yield* this.parseLineStart();
      case "{":
      case "[":
        return yield* this.pushCount(1), this.flowKey = !1, this.flowLevel = 1, "flow";
      case "}":
      case "]":
        return yield* this.pushCount(1), "doc";
      case "*":
        return yield* this.pushUntil(wf), "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        return r += yield* this.parseBlockScalarHeader(), r += yield* this.pushSpaces(!0), yield* this.pushCount(e.length - r), yield* this.pushNewline(), yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let e, r, n = -1;
    do
      e = yield* this.pushNewline(), e > 0 ? (r = yield* this.pushSpaces(!1), this.indentValue = n = r) : r = 0, r += yield* this.pushSpaces(!0);
    while (e + r > 0);
    const i = this.getLine();
    if (i === null)
      return this.setNext("flow");
    if ((n !== -1 && n < this.indentNext && i[0] !== "#" || n === 0 && (i.startsWith("---") || i.startsWith("...")) && yr(i[3])) && !(n === this.indentNext - 1 && this.flowLevel === 1 && (i[0] === "]" || i[0] === "}")))
      return this.flowLevel = 0, yield E$, yield* this.parseLineStart();
    let s = 0;
    for (; i[s] === ","; )
      s += yield* this.pushCount(1), s += yield* this.pushSpaces(!0), this.flowKey = !1;
    switch (s += yield* this.pushIndicators(), i[s]) {
      case void 0:
        return "flow";
      case "#":
        return yield* this.pushCount(i.length - s), "flow";
      case "{":
      case "[":
        return yield* this.pushCount(1), this.flowKey = !1, this.flowLevel += 1, "flow";
      case "}":
      case "]":
        return yield* this.pushCount(1), this.flowKey = !0, this.flowLevel -= 1, this.flowLevel ? "flow" : "doc";
      case "*":
        return yield* this.pushUntil(wf), "flow";
      case '"':
      case "'":
        return this.flowKey = !0, yield* this.parseQuotedScalar();
      case ":": {
        const o = this.charAt(1);
        if (this.flowKey || yr(o) || o === ",")
          return this.flowKey = !1, yield* this.pushCount(1), yield* this.pushSpaces(!0), "flow";
      }
      default:
        return this.flowKey = !1, yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const e = this.charAt(0);
    let r = this.buffer.indexOf(e, this.pos + 1);
    if (e === "'")
      for (; r !== -1 && this.buffer[r + 1] === "'"; )
        r = this.buffer.indexOf("'", r + 2);
    else
      for (; r !== -1; ) {
        let s = 0;
        for (; this.buffer[r - 1 - s] === "\\"; )
          s += 1;
        if (s % 2 === 0)
          break;
        r = this.buffer.indexOf('"', r + 1);
      }
    const n = this.buffer.substring(0, r);
    let i = n.indexOf(`
`, this.pos);
    if (i !== -1) {
      for (; i !== -1; ) {
        const s = this.continueScalar(i + 1);
        if (s === -1)
          break;
        i = n.indexOf(`
`, s);
      }
      i !== -1 && (r = i - (n[i - 1] === "\r" ? 2 : 1));
    }
    if (r === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      r = this.buffer.length;
    }
    return yield* this.pushToIndex(r + 1, !1), this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1, this.blockScalarKeep = !1;
    let e = this.pos;
    for (; ; ) {
      const r = this.buffer[++e];
      if (r === "+")
        this.blockScalarKeep = !0;
      else if (r > "0" && r <= "9")
        this.blockScalarIndent = Number(r) - 1;
      else if (r !== "-")
        break;
    }
    return yield* this.pushUntil((r) => yr(r) || r === "#");
  }
  *parseBlockScalar() {
    let e = this.pos - 1, r = 0, n;
    e:
      for (let i = this.pos; n = this.buffer[i]; ++i)
        switch (n) {
          case " ":
            r += 1;
            break;
          case `
`:
            e = i, r = 0;
            break;
          case "\r": {
            const s = this.buffer[i + 1];
            if (!s && !this.atEnd)
              return this.setNext("block-scalar");
            if (s === `
`)
              break;
          }
          default:
            break e;
        }
    if (!n && !this.atEnd)
      return this.setNext("block-scalar");
    if (r >= this.indentNext) {
      this.blockScalarIndent === -1 ? this.indentNext = r : this.indentNext += this.blockScalarIndent;
      do {
        const i = this.continueScalar(e + 1);
        if (i === -1)
          break;
        e = this.buffer.indexOf(`
`, i);
      } while (e !== -1);
      if (e === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        e = this.buffer.length;
      }
    }
    if (!this.blockScalarKeep)
      do {
        let i = e - 1, s = this.buffer[i];
        s === "\r" && (s = this.buffer[--i]);
        const o = i;
        for (; s === " " || s === "	"; )
          s = this.buffer[--i];
        if (s === `
` && i >= this.pos && i + 1 + r > o)
          e = i;
        else
          break;
      } while (!0);
    return yield Kh, yield* this.pushToIndex(e + 1, !0), yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const e = this.flowLevel > 0;
    let r = this.pos - 1, n = this.pos - 1, i;
    for (; i = this.buffer[++n]; )
      if (i === ":") {
        const s = this.buffer[n + 1];
        if (yr(s) || e && s === ",")
          break;
        r = n;
      } else if (yr(i)) {
        let s = this.buffer[n + 1];
        if (i === "\r" && (s === `
` ? (n += 1, i = `
`, s = this.buffer[n + 1]) : r = n), s === "#" || e && vf.includes(s))
          break;
        if (i === `
`) {
          const o = this.continueScalar(n + 1);
          if (o === -1)
            break;
          n = Math.max(n, o - 2);
        }
      } else {
        if (e && vf.includes(i))
          break;
        r = n;
      }
    return !i && !this.atEnd ? this.setNext("plain-scalar") : (yield Kh, yield* this.pushToIndex(r + 1, !0), e ? "flow" : "doc");
  }
  *pushCount(e) {
    return e > 0 ? (yield this.buffer.substr(this.pos, e), this.pos += e, e) : 0;
  }
  *pushToIndex(e, r) {
    const n = this.buffer.slice(this.pos, e);
    return n ? (yield n, this.pos += n.length, n.length) : (r && (yield ""), 0);
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(wf)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      case "-":
      case "?":
      case ":": {
        const e = this.flowLevel > 0, r = this.charAt(1);
        if (yr(r) || e && vf.includes(r))
          return e ? this.flowKey && (this.flowKey = !1) : this.indentNext = this.indentValue + 1, (yield* this.pushCount(1)) + (yield* this.pushSpaces(!0)) + (yield* this.pushIndicators());
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let e = this.pos + 2, r = this.buffer[e];
      for (; !yr(r) && r !== ">"; )
        r = this.buffer[++e];
      return yield* this.pushToIndex(r === ">" ? e + 1 : e, !1);
    } else {
      let e = this.pos + 1, r = this.buffer[e];
      for (; r; )
        if (WC.includes(r))
          r = this.buffer[++e];
        else if (r === "%" && M1.includes(this.buffer[e + 1]) && M1.includes(this.buffer[e + 2]))
          r = this.buffer[e += 3];
        else
          break;
      return yield* this.pushToIndex(e, !1);
    }
  }
  *pushNewline() {
    const e = this.buffer[this.pos];
    return e === `
` ? yield* this.pushCount(1) : e === "\r" && this.charAt(1) === `
` ? yield* this.pushCount(2) : 0;
  }
  *pushSpaces(e) {
    let r = this.pos - 1, n;
    do
      n = this.buffer[++r];
    while (n === " " || e && n === "	");
    const i = r - this.pos;
    return i > 0 && (yield this.buffer.substr(this.pos, i), this.pos = r), i;
  }
  *pushUntil(e) {
    let r = this.pos, n = this.buffer[r];
    for (; !e(n); )
      n = this.buffer[++r];
    return yield* this.pushToIndex(r, !1);
  }
}
class LC {
  constructor() {
    this.lineStarts = [], this.addNewLine = (e) => this.lineStarts.push(e), this.linePos = (e) => {
      let r = 0, n = this.lineStarts.length;
      for (; r < n; ) {
        const s = r + n >> 1;
        this.lineStarts[s] < e ? r = s + 1 : n = s;
      }
      if (this.lineStarts[r] === e)
        return { line: r + 1, col: 1 };
      if (r === 0)
        return { line: 0, col: e };
      const i = this.lineStarts[r - 1];
      return { line: r, col: e - i + 1 };
    };
  }
}
function Zr(t, e) {
  for (let r = 0; r < t.length; ++r)
    if (t[r].type === e)
      return !0;
  return !1;
}
function q1(t) {
  for (let e = 0; e < t.length; ++e)
    switch (t[e].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return e;
    }
  return -1;
}
function R$(t) {
  switch (t == null ? void 0 : t.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return !0;
    default:
      return !1;
  }
}
function pc(t) {
  switch (t.type) {
    case "document":
      return t.start;
    case "block-map": {
      const e = t.items[t.items.length - 1];
      return e.sep ?? e.start;
    }
    case "block-seq":
      return t.items[t.items.length - 1].start;
    default:
      return [];
  }
}
function As(t) {
  var r;
  if (t.length === 0)
    return [];
  let e = t.length;
  e:
    for (; --e >= 0; )
      switch (t[e].type) {
        case "doc-start":
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
        case "newline":
          break e;
      }
  for (; ((r = t[++e]) == null ? void 0 : r.type) === "space"; )
    ;
  return t.splice(e, t.length);
}
function N1(t) {
  if (t.start.type === "flow-seq-start")
    for (const e of t.items)
      e.sep && !e.value && !Zr(e.start, "explicit-key-ind") && !Zr(e.sep, "map-value-ind") && (e.key && (e.value = e.key), delete e.key, R$(e.value) ? e.value.end ? Array.prototype.push.apply(e.value.end, e.sep) : e.value.end = e.sep : Array.prototype.push.apply(e.start, e.sep), delete e.sep);
}
class YC {
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(e) {
    this.atNewLine = !0, this.atScalar = !1, this.indent = 0, this.offset = 0, this.onKeyLine = !1, this.stack = [], this.source = "", this.type = "", this.lexer = new VC(), this.onNewLine = e;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(e, r = !1) {
    this.onNewLine && this.offset === 0 && this.onNewLine(0);
    for (const n of this.lexer.lex(e, r))
      yield* this.next(n);
    r || (yield* this.end());
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(e) {
    if (this.source = e, this.atScalar) {
      this.atScalar = !1, yield* this.step(), this.offset += e.length;
      return;
    }
    const r = XC(e);
    if (r)
      if (r === "scalar")
        this.atNewLine = !1, this.atScalar = !0, this.type = "scalar";
      else {
        switch (this.type = r, yield* this.step(), r) {
          case "newline":
            this.atNewLine = !0, this.indent = 0, this.onNewLine && this.onNewLine(this.offset + e.length);
            break;
          case "space":
            this.atNewLine && e[0] === " " && (this.indent += e.length);
            break;
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
            this.atNewLine && (this.indent += e.length);
            break;
          case "doc-mode":
          case "flow-error-end":
            return;
          default:
            this.atNewLine = !1;
        }
        this.offset += e.length;
      }
    else {
      const n = `Not a YAML token: ${e}`;
      yield* this.pop({ type: "error", offset: this.offset, message: n, source: e }), this.offset += e.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    for (; this.stack.length > 0; )
      yield* this.pop();
  }
  get sourceToken() {
    return {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  *step() {
    const e = this.peek(1);
    if (this.type === "doc-end" && (!e || e.type !== "doc-end")) {
      for (; this.stack.length > 0; )
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!e)
      return yield* this.stream();
    switch (e.type) {
      case "document":
        return yield* this.document(e);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(e);
      case "block-scalar":
        return yield* this.blockScalar(e);
      case "block-map":
        return yield* this.blockMap(e);
      case "block-seq":
        return yield* this.blockSequence(e);
      case "flow-collection":
        return yield* this.flowCollection(e);
      case "doc-end":
        return yield* this.documentEnd(e);
    }
    yield* this.pop();
  }
  peek(e) {
    return this.stack[this.stack.length - e];
  }
  *pop(e) {
    const r = e ?? this.stack.pop();
    if (!r)
      yield { type: "error", offset: this.offset, source: "", message: "Tried to pop an empty stack" };
    else if (this.stack.length === 0)
      yield r;
    else {
      const n = this.peek(1);
      switch (r.type === "block-scalar" ? r.indent = "indent" in n ? n.indent : 0 : r.type === "flow-collection" && n.type === "document" && (r.indent = 0), r.type === "flow-collection" && N1(r), n.type) {
        case "document":
          n.value = r;
          break;
        case "block-scalar":
          n.props.push(r);
          break;
        case "block-map": {
          const i = n.items[n.items.length - 1];
          if (i.value) {
            n.items.push({ start: [], key: r, sep: [] }), this.onKeyLine = !0;
            return;
          } else if (i.sep)
            i.value = r;
          else {
            Object.assign(i, { key: r, sep: [] }), this.onKeyLine = !Zr(i.start, "explicit-key-ind");
            return;
          }
          break;
        }
        case "block-seq": {
          const i = n.items[n.items.length - 1];
          i.value ? n.items.push({ start: [], value: r }) : i.value = r;
          break;
        }
        case "flow-collection": {
          const i = n.items[n.items.length - 1];
          !i || i.value ? n.items.push({ start: [], key: r, sep: [] }) : i.sep ? i.value = r : Object.assign(i, { key: r, sep: [] });
          return;
        }
        default:
          yield* this.pop(), yield* this.pop(r);
      }
      if ((n.type === "document" || n.type === "block-map" || n.type === "block-seq") && (r.type === "block-map" || r.type === "block-seq")) {
        const i = r.items[r.items.length - 1];
        i && !i.sep && !i.value && i.start.length > 0 && q1(i.start) === -1 && (r.indent === 0 || i.start.every((s) => s.type !== "comment" || s.indent < r.indent)) && (n.type === "document" ? n.end = i.start : n.items.push({ start: i.start }), r.items.splice(-1, 1));
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const e = {
          type: "document",
          offset: this.offset,
          start: []
        };
        this.type === "doc-start" && e.start.push(this.sourceToken), this.stack.push(e);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(e) {
    if (e.value)
      return yield* this.lineEnd(e);
    switch (this.type) {
      case "doc-start": {
        q1(e.start) !== -1 ? (yield* this.pop(), yield* this.step()) : e.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        e.start.push(this.sourceToken);
        return;
    }
    const r = this.startBlockValue(e);
    r ? this.stack.push(r) : yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML document`,
      source: this.source
    };
  }
  *scalar(e) {
    if (this.type === "map-value-ind") {
      const r = pc(this.peek(2)), n = As(r);
      let i;
      e.end ? (i = e.end, i.push(this.sourceToken), delete e.end) : i = [this.sourceToken];
      const s = {
        type: "block-map",
        offset: e.offset,
        indent: e.indent,
        items: [{ start: n, key: e, sep: i }]
      };
      this.onKeyLine = !0, this.stack[this.stack.length - 1] = s;
    } else
      yield* this.lineEnd(e);
  }
  *blockScalar(e) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        e.props.push(this.sourceToken);
        return;
      case "scalar":
        if (e.source = this.source, this.atNewLine = !0, this.indent = 0, this.onNewLine) {
          let r = this.source.indexOf(`
`) + 1;
          for (; r !== 0; )
            this.onNewLine(this.offset + r), r = this.source.indexOf(`
`, r) + 1;
        }
        yield* this.pop();
        break;
      default:
        yield* this.pop(), yield* this.step();
    }
  }
  *blockMap(e) {
    var n;
    const r = e.items[e.items.length - 1];
    switch (this.type) {
      case "newline":
        if (this.onKeyLine = !1, r.value) {
          const i = "end" in r.value ? r.value.end : void 0, s = Array.isArray(i) ? i[i.length - 1] : void 0;
          (s == null ? void 0 : s.type) === "comment" ? i == null || i.push(this.sourceToken) : e.items.push({ start: [this.sourceToken] });
        } else
          r.sep ? r.sep.push(this.sourceToken) : r.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (r.value)
          e.items.push({ start: [this.sourceToken] });
        else if (r.sep)
          r.sep.push(this.sourceToken);
        else {
          if (this.atIndentedComment(r.start, e.indent)) {
            const i = e.items[e.items.length - 2], s = (n = i == null ? void 0 : i.value) == null ? void 0 : n.end;
            if (Array.isArray(s)) {
              Array.prototype.push.apply(s, r.start), s.push(this.sourceToken), e.items.pop();
              return;
            }
          }
          r.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= e.indent) {
      const i = !this.onKeyLine && this.indent === e.indent && r.sep && this.type !== "seq-item-ind";
      let s = [];
      if (i && r.sep && !r.value) {
        const o = [];
        for (let a = 0; a < r.sep.length; ++a) {
          const l = r.sep[a];
          switch (l.type) {
            case "newline":
              o.push(a);
              break;
            case "space":
              break;
            case "comment":
              l.indent > e.indent && (o.length = 0);
              break;
            default:
              o.length = 0;
          }
        }
        o.length >= 2 && (s = r.sep.splice(o[1]));
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          i || r.value ? (s.push(this.sourceToken), e.items.push({ start: s }), this.onKeyLine = !0) : r.sep ? r.sep.push(this.sourceToken) : r.start.push(this.sourceToken);
          return;
        case "explicit-key-ind":
          !r.sep && !Zr(r.start, "explicit-key-ind") ? r.start.push(this.sourceToken) : i || r.value ? (s.push(this.sourceToken), e.items.push({ start: s })) : this.stack.push({
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: [this.sourceToken] }]
          }), this.onKeyLine = !0;
          return;
        case "map-value-ind":
          if (Zr(r.start, "explicit-key-ind"))
            if (r.sep)
              if (r.value)
                e.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (Zr(r.sep, "map-value-ind"))
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: s, key: null, sep: [this.sourceToken] }]
                });
              else if (R$(r.key) && !Zr(r.sep, "newline")) {
                const o = As(r.start), a = r.key, l = r.sep;
                l.push(this.sourceToken), delete r.key, delete r.sep, this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: o, key: a, sep: l }]
                });
              } else
                s.length > 0 ? r.sep = r.sep.concat(s, this.sourceToken) : r.sep.push(this.sourceToken);
            else if (Zr(r.start, "newline"))
              Object.assign(r, { key: null, sep: [this.sourceToken] });
            else {
              const o = As(r.start);
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: o, key: null, sep: [this.sourceToken] }]
              });
            }
          else
            r.sep ? r.value || i ? e.items.push({ start: s, key: null, sep: [this.sourceToken] }) : Zr(r.sep, "map-value-ind") ? this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [], key: null, sep: [this.sourceToken] }]
            }) : r.sep.push(this.sourceToken) : Object.assign(r, { key: null, sep: [this.sourceToken] });
          this.onKeyLine = !0;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const o = this.flowScalar(this.type);
          i || r.value ? (e.items.push({ start: s, key: o, sep: [] }), this.onKeyLine = !0) : r.sep ? this.stack.push(o) : (Object.assign(r, { key: o, sep: [] }), this.onKeyLine = !0);
          return;
        }
        default: {
          const o = this.startBlockValue(e);
          if (o) {
            i && o.type !== "block-seq" && Zr(r.start, "explicit-key-ind") && e.items.push({ start: s }), this.stack.push(o);
            return;
          }
        }
      }
    }
    yield* this.pop(), yield* this.step();
  }
  *blockSequence(e) {
    var n;
    const r = e.items[e.items.length - 1];
    switch (this.type) {
      case "newline":
        if (r.value) {
          const i = "end" in r.value ? r.value.end : void 0, s = Array.isArray(i) ? i[i.length - 1] : void 0;
          (s == null ? void 0 : s.type) === "comment" ? i == null || i.push(this.sourceToken) : e.items.push({ start: [this.sourceToken] });
        } else
          r.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (r.value)
          e.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(r.start, e.indent)) {
            const i = e.items[e.items.length - 2], s = (n = i == null ? void 0 : i.value) == null ? void 0 : n.end;
            if (Array.isArray(s)) {
              Array.prototype.push.apply(s, r.start), s.push(this.sourceToken), e.items.pop();
              return;
            }
          }
          r.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (r.value || this.indent <= e.indent)
          break;
        r.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== e.indent)
          break;
        r.value || Zr(r.start, "seq-item-ind") ? e.items.push({ start: [this.sourceToken] }) : r.start.push(this.sourceToken);
        return;
    }
    if (this.indent > e.indent) {
      const i = this.startBlockValue(e);
      if (i) {
        this.stack.push(i);
        return;
      }
    }
    yield* this.pop(), yield* this.step();
  }
  *flowCollection(e) {
    const r = e.items[e.items.length - 1];
    if (this.type === "flow-error-end") {
      let n;
      do
        yield* this.pop(), n = this.peek(1);
      while (n && n.type === "flow-collection");
    } else if (e.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          !r || r.sep ? e.items.push({ start: [this.sourceToken] }) : r.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          !r || r.value ? e.items.push({ start: [], key: null, sep: [this.sourceToken] }) : r.sep ? r.sep.push(this.sourceToken) : Object.assign(r, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          !r || r.value ? e.items.push({ start: [this.sourceToken] }) : r.sep ? r.sep.push(this.sourceToken) : r.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const i = this.flowScalar(this.type);
          !r || r.value ? e.items.push({ start: [], key: i, sep: [] }) : r.sep ? this.stack.push(i) : Object.assign(r, { key: i, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          e.end.push(this.sourceToken);
          return;
      }
      const n = this.startBlockValue(e);
      n ? this.stack.push(n) : (yield* this.pop(), yield* this.step());
    } else {
      const n = this.peek(2);
      if (n.type === "block-map" && (this.type === "map-value-ind" && n.indent === e.indent || this.type === "newline" && !n.items[n.items.length - 1].sep))
        yield* this.pop(), yield* this.step();
      else if (this.type === "map-value-ind" && n.type !== "flow-collection") {
        const i = pc(n), s = As(i);
        N1(e);
        const o = e.end.splice(1, e.end.length);
        o.push(this.sourceToken);
        const a = {
          type: "block-map",
          offset: e.offset,
          indent: e.indent,
          items: [{ start: s, key: e, sep: o }]
        };
        this.onKeyLine = !0, this.stack[this.stack.length - 1] = a;
      } else
        yield* this.lineEnd(e);
    }
  }
  flowScalar(e) {
    if (this.onNewLine) {
      let r = this.source.indexOf(`
`) + 1;
      for (; r !== 0; )
        this.onNewLine(this.offset + r), r = this.source.indexOf(`
`, r) + 1;
    }
    return {
      type: e,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(e) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = !0;
        const r = pc(e), n = As(r);
        return n.push(this.sourceToken), {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: n }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = !0;
        const r = pc(e), n = As(r);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: n, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(e, r) {
    return this.type !== "comment" || this.indent <= r ? !1 : e.every((n) => n.type === "newline" || n.type === "space");
  }
  *documentEnd(e) {
    this.type !== "doc-mode" && (e.end ? e.end.push(this.sourceToken) : e.end = [this.sourceToken], this.type === "newline" && (yield* this.pop()));
  }
  *lineEnd(e) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop(), yield* this.step();
        break;
      case "newline":
        this.onKeyLine = !1;
      case "space":
      case "comment":
      default:
        e.end ? e.end.push(this.sourceToken) : e.end = [this.sourceToken], this.type === "newline" && (yield* this.pop());
    }
  }
}
function BC(t) {
  const e = t.prettyErrors !== !1;
  return { lineCounter: t.lineCounter || e && new LC() || null, prettyErrors: e };
}
function FC(t, e = {}) {
  const { lineCounter: r, prettyErrors: n } = BC(e), i = new YC(r == null ? void 0 : r.addNewLine), s = new zC(e);
  let o = null;
  for (const a of s.compose(i.parse(t), !0, t.length))
    if (!o)
      o = a;
    else if (o.options.logLevel !== "silent") {
      o.errors.push(new xa(a.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  return n && r && (o.errors.forEach(I1(t, r)), o.warnings.forEach(I1(t, r))), o;
}
function HC(t, e, r) {
  let n;
  typeof e == "function" ? n = e : r === void 0 && e && typeof e == "object" && (r = e);
  const i = FC(t, r);
  if (!i)
    return null;
  if (i.warnings.forEach((s) => o$(i.options.logLevel, s)), i.errors.length > 0) {
    if (i.options.logLevel !== "silent")
      throw i.errors[0];
    i.errors = [];
  }
  return i.toJS(Object.assign({ reviver: n }, r));
}
function GC(t, e, r) {
  let n = null;
  if (typeof e == "function" || Array.isArray(e) ? n = e : r === void 0 && e && (r = e), typeof r == "string" && (r = r.length), typeof r == "number") {
    const i = Math.round(r);
    r = i < 1 ? void 0 : i > 8 ? { indent: 8 } : { indent: i };
  }
  if (t === void 0) {
    const { keepUndefined: i } = r ?? e ?? {};
    if (!i)
      return;
  }
  return new kl(t, n, r).toString(r);
}
const I$ = {
  /** Parse and throw if the return value is not an object */
  parse: (t) => {
    const e = HC(t);
    if (typeof e != "object")
      throw Error("Invalid YAML object");
    return e;
  },
  /** Parse and return a fallback on failure */
  parseSafe(t, e) {
    try {
      return I$.parse(t);
    } catch (r) {
      return typeof e == "function" ? e(r) : e;
    }
  },
  stringify: GC
}, zm = {
  /** Parse and throw if the return value is not an object */
  parse: (t) => {
    const e = JSON.parse(t);
    if (typeof e != "object")
      throw Error("Invalid JSON object");
    return e;
  },
  /** Parse and return a fallback on failure */
  parseSafe(t, e) {
    try {
      return zm.parse(t);
    } catch (r) {
      return typeof e == "function" ? e(r) : e;
    }
  },
  stringify: (t) => JSON.stringify(t)
}, yu = (t) => typeof t != "string" ? !1 : !!zm.parseSafe(t, !1);
function KC(t) {
  if (t.trim()[0] !== "{")
    return t;
  try {
    return JSON.stringify(JSON.parse(t), null, 2);
  } catch {
    return t;
  }
}
const JC = (t) => {
  if (typeof t != "string")
    return t;
  const e = zm.parseSafe(t, null);
  if (e)
    return e;
  if (t.length > 0 && ["{", "["].includes(t[0]))
    throw Error("Invalid JSON or YAML");
  return I$.parseSafe(t, (r) => {
    throw Error(r);
  });
};
async function D1(t, e) {
  const r = e ? await fetch(e, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      method: "GET",
      url: t
    })
  }) : await fetch(t);
  r.status !== 200 && console.error(
    `[fetchSpecFromUrl] Failed to fetch the spec at ${t}. ${e ? "" : "Trying to fetch the spec file without a proxy. The CORS headers must be set properly or the request will fail."}`
  );
  const n = e ? String((await r.json()).data) : await r.text();
  return KC(n);
}
const eQ = (t) => {
  var n;
  const { authState: e, request: r } = t;
  return e.type === "basic" && e.basic.active ? r.headers = [
    ...r.headers ?? [],
    {
      name: "Authorization",
      value: `Basic ${btoa(
        `${e.basic.username}:${e.basic.password}`
      )}`,
      enabled: !0
    }
  ] : e.type === "bearer" && e.bearer.active && (r.headers = [
    ...r.headers ?? [],
    {
      name: "Authorization",
      value: `Bearer ${e.bearer.token}`,
      enabled: !0
    }
  ]), r.body && yu(r.body) && ((n = r.headers) != null && n.some(
    (s) => s.name.toLowerCase() === "content-type"
  ) || (r.headers = [
    ...r.headers ?? [],
    {
      name: "Content-Type",
      value: "application/json; charset=utf-8",
      enabled: !0
    }
  ]), r.body = JSON.parse(r.body)), {
    ...r
  };
}, tQ = (t, e) => Object.entries(e).reduce((r, [n, i]) => r.replace(`{${n}}`, i.toString()), t), rQ = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let nQ = (t = 21) => {
  let e = "", r = crypto.getRandomValues(new Uint8Array(t));
  for (; t--; )
    e += rQ[r[t] & 63];
  return e;
};
async function iQ(t, e) {
  var y;
  const r = MT(t.type), n = _a(
    (t.headers ?? []).filter((O) => O.enabled),
    "name",
    "value"
  ), i = qT(t.url), s = ZT(t.path), [o, ...a] = IT(
    i,
    s
  ).split("?"), l = tQ(
    o,
    _a(
      (t.variables ?? []).filter((O) => O.enabled),
      "name",
      "value"
    )
  ), c = [];
  a.forEach((O) => {
    new URLSearchParams(O ?? "").forEach((b, w) => {
      c.push({
        name: w,
        value: b,
        enabled: !0
      });
    });
  });
  const u = new URLSearchParams(
    // TODO: No type-casting
    _a(
      [
        ...(t.query ?? []).filter((O) => O.enabled),
        ...c
      ],
      "name",
      "value"
    )
  ).toString(), d = `${l}${u ? "?" + u : ""}`, f = {
    type: "none"
  }, h = Date.now();
  if (t.cookies && ((y = t.cookies) == null ? void 0 : y.length) > 0) {
    const O = _a(
      (t.cookies ?? []).filter((b) => b.enabled),
      "name",
      "value"
    );
    n.Cookie = Object.keys(O).map((b) => `${b}=${O[b]}`).join("; ");
  }
  const p = {
    method: r,
    url: d,
    auth: f,
    headers: n,
    data: t.body
  }, g = e ? {
    method: "POST",
    url: e,
    data: p
  } : {
    method: p.method,
    url: p.url,
    headers: p.headers,
    data: p.data
  };
  n.cookies && (g.withCredentials = !0), console.info(e ? `${p.method} ${e} â†’ ${p.url}` : `${p.method} ${p.url}`);
  const m = await g3(g).then((O) => e ? {
    ...O.data,
    error: !1
  } : {
    ...O,
    statusCode: O.status,
    data: JSON.stringify(O.data),
    error: !1
  }).catch((O) => {
    const { response: b } = O;
    return {
      headers: {
        "content-type": "application/json; charset=utf-8"
      },
      ...b,
      statusCode: (b == null ? void 0 : b.status) ?? 0,
      data: JSON.stringify((b == null ? void 0 : b.data) ?? { error: O.code })
    };
  });
  return {
    sentTime: Date.now(),
    request: {
      ...t,
      type: r,
      url: i,
      path: s
    },
    response: {
      ...m,
      duration: Date.now() - h
    },
    responseId: nQ()
  };
}
const sQ = [
  "B",
  "kB",
  "MB",
  "GB",
  "TB",
  "PB",
  "EB",
  "ZB",
  "YB"
], oQ = [
  "B",
  "KiB",
  "MiB",
  "GiB",
  "TiB",
  "PiB",
  "EiB",
  "ZiB",
  "YiB"
], aQ = [
  "b",
  "kbit",
  "Mbit",
  "Gbit",
  "Tbit",
  "Pbit",
  "Ebit",
  "Zbit",
  "Ybit"
], lQ = [
  "b",
  "kibit",
  "Mibit",
  "Gibit",
  "Tibit",
  "Pibit",
  "Eibit",
  "Zibit",
  "Yibit"
], z1 = (t, e, r) => {
  let n = t;
  return typeof e == "string" || Array.isArray(e) ? n = t.toLocaleString(e, r) : (e === !0 || r !== void 0) && (n = t.toLocaleString(void 0, r)), n;
};
function bu(t, e) {
  if (!Number.isFinite(t))
    throw new TypeError(`Expected a finite number, got ${typeof t}: ${t}`);
  e = {
    bits: !1,
    binary: !1,
    space: !0,
    ...e
  };
  const r = e.bits ? e.binary ? lQ : aQ : e.binary ? oQ : sQ, n = e.space ? " " : "";
  if (e.signed && t === 0)
    return ` 0${n}${r[0]}`;
  const i = t < 0, s = i ? "-" : e.signed ? "+" : "";
  i && (t = -t);
  let o;
  if (e.minimumFractionDigits !== void 0 && (o = { minimumFractionDigits: e.minimumFractionDigits }), e.maximumFractionDigits !== void 0 && (o = { maximumFractionDigits: e.maximumFractionDigits, ...o }), t < 1) {
    const u = z1(t, e.locale, o);
    return s + u + n + r[0];
  }
  const a = Math.min(Math.floor(e.binary ? Math.log(t) / Math.log(1024) : Math.log10(t) / 3), r.length - 1);
  t /= (e.binary ? 1024 : 1e3) ** a, o || (t = t.toPrecision(3));
  const l = z1(Number(t), e.locale, o), c = r[a];
  return s + l + n + c;
}
function cQ(t) {
  if (typeof t != "number")
    throw new TypeError("Expected a number");
  const e = t > 0 ? Math.floor : Math.ceil;
  return {
    days: e(t / 864e5),
    hours: e(t / 36e5) % 24,
    minutes: e(t / 6e4) % 60,
    seconds: e(t / 1e3) % 60,
    milliseconds: e(t) % 1e3,
    microseconds: e(t * 1e3) % 1e3,
    nanoseconds: e(t * 1e6) % 1e3
  };
}
const uQ = (t, e) => e === 1 ? t : `${t}s`, dQ = 1e-7;
function j$(t, e = {}) {
  if (!Number.isFinite(t))
    throw new TypeError("Expected a finite number");
  e.colonNotation && (e.compact = !1, e.formatSubMilliseconds = !1, e.separateMilliseconds = !1, e.verbose = !1), e.compact && (e.secondsDecimalDigits = 0, e.millisecondsDecimalDigits = 0);
  const r = [], n = (o, a) => {
    const l = Math.floor(o * 10 ** a + dQ);
    return (Math.round(l) / 10 ** a).toFixed(a);
  }, i = (o, a, l, c) => {
    if ((r.length === 0 || !e.colonNotation) && o === 0 && !(e.colonNotation && l === "m"))
      return;
    c = (c || o || "0").toString();
    let u, d;
    if (e.colonNotation) {
      u = r.length > 0 ? ":" : "", d = "";
      const f = c.includes(".") ? c.split(".")[0].length : c.length, h = r.length > 0 ? 2 : 1;
      c = "0".repeat(Math.max(0, h - f)) + c;
    } else
      u = "", d = e.verbose ? " " + uQ(a, o) : l;
    r.push(u + c + d);
  }, s = cQ(t);
  if (i(Math.trunc(s.days / 365), "year", "y"), i(s.days % 365, "day", "d"), i(s.hours, "hour", "h"), i(s.minutes, "minute", "m"), e.separateMilliseconds || e.formatSubMilliseconds || !e.colonNotation && t < 1e3)
    if (i(s.seconds, "second", "s"), e.formatSubMilliseconds)
      i(s.milliseconds, "millisecond", "ms"), i(s.microseconds, "microsecond", "Âµs"), i(s.nanoseconds, "nanosecond", "ns");
    else {
      const o = s.milliseconds + s.microseconds / 1e3 + s.nanoseconds / 1e6, a = typeof e.millisecondsDecimalDigits == "number" ? e.millisecondsDecimalDigits : 0, l = o >= 1 ? Math.round(o) : Math.ceil(o), c = a ? o.toFixed(a) : l;
      i(
        Number.parseFloat(c),
        "millisecond",
        "ms",
        c
      );
    }
  else {
    const o = t / 1e3 % 60, a = typeof e.secondsDecimalDigits == "number" ? e.secondsDecimalDigits : 1, l = n(o, a), c = e.keepDecimalsOnWholeSeconds ? l : l.replace(/\.0+$/, "");
    i(Number.parseFloat(c), "second", "s", c);
  }
  if (r.length === 0)
    return "0" + (e.verbose ? " milliseconds" : "ms");
  if (e.compact)
    return r[0];
  if (typeof e.unitCount == "number") {
    const o = e.colonNotation ? "" : " ";
    return r.slice(0, Math.max(e.unitCount, 1)).join(o);
  }
  return e.colonNotation ? r.join("") : r.join(" ");
}
const fQ = { class: "navtable-item-40 navtable-item-request" }, hQ = { class: "navtable-item-40 navtable-item-response" }, pQ = { class: "navtable-item-20 navtable-item-time" }, mQ = /* @__PURE__ */ G({
  __name: "RequestHistoryItem",
  props: {
    history: {}
  },
  setup(t) {
    const { requestHistory: e, activeRequestId: r, setActiveResponse: n } = pr(), i = (s) => {
      var o;
      return (o = s == null ? void 0 : s.headers) != null && o["X-API-Client-Content-Length"] ? bu(
        parseFloat(s.headers["X-API-Client-Content-Length"])
      ) : bu(0);
    };
    return (s, o) => (k(), C("div", {
      class: $e(["navtable-item", { "navtable-item__active": v(r) === s.history }]),
      onClick: o[0] || (o[0] = (a) => v(n)(s.history))
    }, [
      x("div", fQ, [
        x("button", {
          class: $e(["radio", v(e)[s.history].request.type.toLowerCase()]),
          type: "button"
        }, null, 2),
        x("span", null, [
          x("em", null, te(v(e)[s.history].request.type), 1),
          re(" " + te(v(e)[s.history].request.url), 1)
        ])
      ]),
      x("div", hQ, [
        x("span", null, te(v(j$)(v(e)[s.history].response.duration)), 1),
        x("span", {
          class: $e(`scalar-api-client__status--${String(
            v(e)[s.history].response.statusCode
          ).charAt(0)}xx`)
        }, te(v(e)[s.history].response.statusCode), 3),
        x("span", null, te(i(v(e)[s.history].response)), 1)
      ]),
      x("div", pQ, [
        x("span", null, te(v(K2)(v(e)[s.history].sentTime)), 1)
      ])
    ], 2));
  }
}), gQ = /* @__PURE__ */ oe(mQ, [["__scopeId", "data-v-fd992042"]]), OQ = { class: "navigation-content-item" }, yQ = { class: "navtable" }, bQ = { class: "navtable-table" }, vQ = /* @__PURE__ */ gs('<div class="navtable-item navtable-item__top"><div class="navtable-item-40"><label for="">Request</label></div><div class="navtable-item-40"><label for="">Response</label></div><div class="navtable-item-20"><label for="">TIME</label></div></div>', 1), wQ = { class: "navtable-radios" }, $Q = /* @__PURE__ */ gs('<div class="navtable-mock"><div class="navtable-item"><div class="navtable-item-40"></div><div class="navtable-item-40"></div><div class="navtable-item-20"></div></div></div>', 1), SQ = /* @__PURE__ */ G({
  __name: "RequestHistory",
  emits: ["toggle"],
  setup(t) {
    const { requestHistoryOrder: e } = pr();
    return (r, n) => (k(), C("div", OQ, [
      x("div", yQ, [
        x("div", bQ, [
          vQ,
          x("div", wQ, [
            (k(!0), C(ee, null, _e(v(e), (i) => (k(), Y(gQ, {
              key: i,
              history: i
            }, null, 8, ["history"]))), 128))
          ]),
          $Q
        ])
      ])
    ]));
  }
}), kQ = { class: "request-method-select" }, _Q = ["disabled", "value"], PQ = ["value"], xQ = /* @__PURE__ */ G({
  __name: "RequestMethodSelect",
  props: {
    requestMethod: {},
    readOnly: { type: Boolean, default: !0 }
  },
  emits: ["change"],
  setup(t) {
    const e = [
      "GET",
      "POST",
      "PUT",
      // 'HEAD',
      "DELETE",
      "PATCH"
      // 'OPTIONS',
      // 'CONNECT',
      // 'TRACE',
    ];
    return (r, n) => (k(), C("div", kQ, [
      x("span", {
        class: $e(["request-method", { "request-method--disabled": r.readOnly }])
      }, [
        x("i", {
          class: $e(r.requestMethod.toLowerCase())
        }, null, 2),
        x("span", null, te(r.requestMethod), 1)
      ], 2),
      x("select", {
        disabled: r.readOnly,
        value: r.requestMethod.toLowerCase(),
        onInput: n[0] || (n[0] = (i) => r.$emit("change", i.target.value))
      }, [
        (k(), C(ee, null, _e(e, (i) => x("option", {
          key: i,
          value: i.toLocaleLowerCase()
        }, te(i), 9, PQ)), 64))
      ], 40, _Q)
    ]));
  }
}), TQ = /* @__PURE__ */ oe(xQ, [["__scopeId", "data-v-f4f13406"]]), Xm = (t) => (fr("data-v-7050af3f"), t = t(), hr(), t), CQ = {
  key: 0,
  class: "loader"
}, QQ = { class: "url-form" }, AQ = { class: "url-form-field" }, EQ = ["disabled"], RQ = /* @__PURE__ */ Xm(() => /* @__PURE__ */ x("svg", {
  fill: "none",
  height: "48",
  viewBox: "0 0 14 14",
  width: "48",
  xmlns: "http://www.w3.org/2000/svg"
}, [
  /* @__PURE__ */ x("g", { id: "send-email--mail-send-email-paper-airplane" }, [
    /* @__PURE__ */ x("path", {
      id: "Subtract",
      "clip-rule": "evenodd",
      d: "M11.8215 0.0977331C12.1097 -0.0075178 12.422 -0.0287134 12.7219 0.0367172C13.0248 0.102803 13.3024 0.254481 13.5216 0.473719C13.7409 0.692957 13.8926 0.970537 13.9586 1.27346C14.0241 1.57338 14.0029 1.88566 13.8976 2.17389L10.3236 12.8859L10.3234 12.8866C10.2363 13.15 10.083 13.3867 9.87813 13.5739C9.67383 13.7606 9.42512 13.8917 9.15575 13.9549C8.88633 14.0206 8.60444 14.015 8.33777 13.9388C8.07134 13.8627 7.82929 13.7187 7.63532 13.5209L5.71798 11.6123L3.70392 12.6538C3.54687 12.735 3.3586 12.7272 3.20877 12.6333C3.05895 12.5395 2.96984 12.3734 2.97443 12.1967L3.057 9.01294L10.102 3.89553C10.3812 3.69267 10.4432 3.30182 10.2403 3.02255C10.0375 2.74327 9.64662 2.68133 9.36734 2.88419L2.20286 8.0884L0.473156 6.35869L0.473098 6.35864L0.472971 6.35851C0.285648 6.17132 0.147746 5.94054 0.0716498 5.68688C-0.00390565 5.43503 -0.016181 5.16847 0.0358684 4.91079C0.087985 4.62928 0.213827 4.36658 0.400607 4.14951C0.588668 3.93095 0.831681 3.76658 1.10453 3.67339L1.1079 3.67224L1.1079 3.67225L11.8215 0.0977331Z",
      fill: "currentColor",
      "fill-rule": "evenodd"
    })
  ])
], -1)), IQ = /* @__PURE__ */ Xm(() => /* @__PURE__ */ x("span", null, "Send Request", -1)), jQ = [
  RQ,
  IQ
], ZQ = { class: "address-bar-content" }, MQ = {
  key: 0,
  class: "history"
}, qQ = /* @__PURE__ */ Xm(() => /* @__PURE__ */ x("svg", {
  fill: "none",
  height: "48",
  viewBox: "0 0 14 14",
  width: "48",
  xmlns: "http://www.w3.org/2000/svg"
}, [
  /* @__PURE__ */ x("g", { id: "rewind-clock--back-return-clock-timer-countdown" }, [
    /* @__PURE__ */ x("path", {
      id: "Vector 1561 (Stroke)",
      "clip-rule": "evenodd",
      d: "M6.99999 2.75C7.4142 2.75 7.74999 3.08579 7.74999 3.5V7.5C7.74999 7.76345 7.61177 8.00758 7.38586 8.14312L4.88586 9.64312C4.53068 9.85623 4.06998 9.74106 3.85687 9.38587C3.64376 9.03069 3.75893 8.56999 4.11412 8.35688L6.24999 7.07536V3.5C6.24999 3.08579 6.58578 2.75 6.99999 2.75Z",
      fill: "currentColor",
      "fill-rule": "evenodd"
    }),
    /* @__PURE__ */ x("path", {
      id: "Union",
      "clip-rule": "evenodd",
      d: "M12.5 7C12.5 3.96243 10.0376 1.5 7 1.5C5.24916 1.5 3.68853 2.31796 2.68066 3.59456L3.64645 4.56034C3.96143 4.87533 3.73835 5.4139 3.29289 5.4139H0.5C0.223857 5.4139 0 5.19004 0 4.9139V2.121C0 1.67555 0.53857 1.45247 0.853553 1.76745L1.61439 2.52829C2.89781 0.984301 4.83356 0 7 0C10.866 0 14 3.13401 14 7C14 10.866 10.866 14 7 14C3.68902 14 0.916591 11.702 0.187329 8.61473C0.0921059 8.21161 0.341704 7.80762 0.744824 7.7124C1.14794 7.61717 1.55193 7.86677 1.64715 8.26989C2.22013 10.6955 4.40025 12.5 7 12.5C10.0376 12.5 12.5 10.0376 12.5 7Z",
      fill: "currentColor",
      "fill-rule": "evenodd"
    })
  ])
], -1)), NQ = /* @__PURE__ */ G({
  __name: "AddressBar",
  props: {
    proxyUrl: {}
  },
  emits: ["onSend"],
  setup(t, { emit: e }) {
    const r = t, n = e, i = Uu();
    Hs(i.meta_enter, b);
    const s = ge(!1), o = ge(!1), {
      activeRequest: a,
      addRequestToHistory: l,
      requestHistory: c,
      requestHistoryOrder: u,
      readOnly: d,
      setActiveRequest: f,
      authState: h
    } = pr(), p = G2(), g = fe(() => a.url), m = fe(() => a.type), y = fe(() => a.path), O = fe(() => `${g.value}${y.value}`);
    async function b() {
      const _ = eQ({
        request: { ...a },
        authState: h
      });
      o.value = !0, n("onSend");
      const Q = await iQ(_, r.proxyUrl);
      Q && l(Q), o.value = !1;
    }
    const w = fe(() => {
      const _ = u.value[0];
      return c[_] ? K2(c[_].sentTime) : "History";
    }), S = (_) => {
      d.value || a.url + a.path !== _ && f({ ...a, url: _ });
    }, $ = (_) => {
      _ && f({
        ...a,
        type: _.toLocaleLowerCase()
      });
    };
    return (_, Q) => (k(), C(ee, null, [
      o.value ? (k(), C("div", CQ)) : H("", !0),
      x("div", {
        class: $e(["address-bar", { "address-bar--with-history": s.value }])
      }, [
        x("div", QQ, [
          x("div", AQ, [
            Z(TQ, {
              readOnly: v(d),
              requestMethod: m.value,
              onChange: $
            }, null, 8, ["readOnly", "requestMethod"]),
            Z(v(F2), {
              class: "url-form-input",
              content: O.value,
              disableEnter: "",
              readOnly: v(d),
              withoutTheme: "",
              withVariables: "",
              onChange: S
            }, null, 8, ["content", "readOnly"])
          ]),
          x("button", {
            class: "send-button",
            disabled: !O.value.trim().length,
            type: "submit",
            onClick: b
          }, jQ, 8, EQ)
        ]),
        x("div", {
          class: "address-bar-close",
          onClick: Q[0] || (Q[0] = (N) => s.value = !1)
        }),
        x("div", ZQ, [
          Z(v(H2), {
            state: v(p),
            title: "Request History",
            variant: "history"
          }, {
            default: I(() => [
              Z(SQ, {
                showHistory: s.value,
                onToggle: Q[1] || (Q[1] = (N) => s.value = !s.value)
              }, null, 8, ["showHistory"])
            ]),
            _: 1
          }, 8, ["state"])
        ]),
        v(u).length ? (k(), C("div", MQ, [
          x("div", {
            class: "history-toggle",
            onClick: Q[2] || (Q[2] = (N) => v(p).show())
          }, [
            qQ,
            x("span", null, te(w.value), 1)
          ])
        ])) : H("", !0)
      ], 2)
    ], 64));
  }
}), DQ = /* @__PURE__ */ oe(NQ, [["__scopeId", "data-v-7050af3f"]]), zQ = /* @__PURE__ */ x("svg", {
  class: "scalar-api-client__toggle__icon",
  height: "10",
  viewBox: "0 0 5 10",
  width: "5",
  xmlns: "http://www.w3.org/2000/svg"
}, [
  /* @__PURE__ */ x("path", {
    d: "M0 10l5-5-5-5z",
    fill: "currentColor",
    "fill-rule": "nonzero"
  })
], -1), XQ = { class: "scalar-api-client__item__title" }, WQ = {
  key: 0,
  class: "scalar-api-client__item__options"
}, UQ = { class: "scalar-api-client__item__content" }, Wn = /* @__PURE__ */ G({
  __name: "CollapsibleSection",
  props: {
    title: {},
    defaultOpen: { type: Boolean, default: !0 }
  },
  setup(t) {
    const e = t, r = ge(null), n = ge(null), i = ge(e.defaultOpen);
    return Ve(
      () => e.defaultOpen,
      (s, o) => {
        var a;
        s !== o && s !== i.value && ((a = r.value) == null || a.el.click());
      }
    ), (s, o) => (k(), Y(v(zu), {
      ref_key: "disclosureButton",
      ref: n,
      defaultOpen: s.defaultOpen
    }, {
      default: I(({ open: a }) => [
        x("div", {
          class: $e(["scalar-api-client__item", { "scalar-api-client__item--open": a }])
        }, [
          Z(v(Xu), {
            ref_key: "collapseButton",
            ref: r,
            class: "scalar-api-client__toggle",
            onClick: o[0] || (o[0] = (l) => i.value = !i.value)
          }, {
            default: I(() => [
              zQ,
              x("span", XQ, te(s.title), 1),
              s.$slots.options && a ? (k(), C("div", WQ, [
                se(s.$slots, "options")
              ])) : H("", !0)
            ]),
            _: 2
          }, 1536),
          Z(v(Wu), null, {
            default: I(() => [
              x("div", UQ, [
                se(s.$slots, "default")
              ])
            ]),
            _: 3
          })
        ], 2)
      ]),
      _: 3
    }, 8, ["defaultOpen"]));
  }
}), VQ = /* @__PURE__ */ x("svg", {
  fill: "none",
  height: "100%",
  stroke: "currentColor",
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, [
  /* @__PURE__ */ x("path", {
    d: "m19.5 10-7.5 7.5-7.5-7.5",
    xmlns: "http://www.w3.org/2000/svg"
  })
], -1), LQ = ["disabled", "value"], YQ = {
  key: 0,
  class: "scalar-api-client__empty-state"
}, BQ = {
  key: 1,
  class: "authentication-form"
}, FQ = { class: "input input__half" }, HQ = /* @__PURE__ */ x("label", { for: "username" }, "Username", -1), GQ = { class: "input input__half" }, KQ = /* @__PURE__ */ x("label", { for: "password" }, "Password", -1), JQ = { class: "check" }, eA = /* @__PURE__ */ x("span", { class: "checkmark" }, null, -1), tA = /* @__PURE__ */ x("p", null, "Enabled", -1), rA = { class: "input input__half" }, nA = /* @__PURE__ */ x("label", { for: "username" }, "Username", -1), iA = { class: "input input__half" }, sA = /* @__PURE__ */ x("label", { for: "password" }, "Password", -1), oA = { class: "check" }, aA = /* @__PURE__ */ x("span", { class: "checkmark" }, null, -1), lA = /* @__PURE__ */ x("p", null, "Enabled", -1), cA = { class: "input" }, uA = /* @__PURE__ */ x("label", { for: "generatedtoken" }, "Generated Token", -1), dA = { class: "input" }, fA = /* @__PURE__ */ x("label", { for: "discoveryurl" }, "OIDC Discovery URL", -1), hA = { class: "input" }, pA = /* @__PURE__ */ x("label", { for: "authurl" }, "Auth URL", -1), mA = { class: "input" }, gA = /* @__PURE__ */ x("label", { for: "accesstoken" }, "Access Token URL", -1), OA = { class: "input input__half" }, yA = /* @__PURE__ */ x("label", { for: "clientid" }, "Client ID", -1), bA = { class: "input input__half" }, vA = /* @__PURE__ */ x("label", { for: "clientsecret" }, "Client Secret", -1), wA = { class: "input" }, $A = /* @__PURE__ */ x("label", { for: "scope" }, "Scope", -1), SA = /* @__PURE__ */ x("button", {
  class: "scalar-api-client__item__content-button",
  type: "button"
}, [
  /* @__PURE__ */ x("span", null, "Generate Token")
], -1), kA = { class: "input" }, _A = /* @__PURE__ */ x("label", { for: "Username" }, "Token", -1), PA = { class: "check" }, xA = /* @__PURE__ */ x("span", { class: "checkmark" }, null, -1), TA = /* @__PURE__ */ x("p", null, "Enabled", -1), CA = /* @__PURE__ */ G({
  __name: "RequestAuth",
  setup(t) {
    const e = pr(), { authState: r } = e, n = {
      basic: "Basic Auth",
      digest: "Digest Auth",
      oauthOne: "OAuth 1.0",
      oauthTwo: "OAuth 2.0",
      bearer: "Bearer Token",
      none: "None"
    }, i = [
      {
        text: "Basic Auth",
        type: "basic",
        disabled: !1
      },
      {
        text: "OAuth 2.0",
        type: "oauthTwo",
        disabled: !0
      },
      {
        text: "Bearer Token",
        type: "bearer",
        disabled: !1
      },
      {
        text: "None",
        type: "none",
        disabled: !1
      }
    ];
    return (s, o) => (k(), Y(v(Wn), { title: "Authentication" }, {
      options: I(() => [
        x("div", null, [
          x("span", null, [
            re(te(n[v(r).type]) + " ", 1),
            VQ
          ]),
          Ne(x("select", {
            "onUpdate:modelValue": o[0] || (o[0] = (a) => v(r).type = a),
            onClick: o[1] || (o[1] = hl(() => {
            }, ["prevent"]))
          }, [
            (k(), C(ee, null, _e(i, (a) => x("option", {
              key: a.type,
              disabled: a.disabled,
              value: a.type
            }, te(a.text), 9, LQ)), 64))
          ], 512), [
            [Bb, v(r).type]
          ])
        ])
      ]),
      default: I(() => [
        v(r).type === "none" ? (k(), C("div", YQ, "No Authentication")) : (k(), C("div", BQ, [
          v(r).type === "basic" ? (k(), C(ee, { key: 0 }, [
            x("div", FQ, [
              HQ,
              Ne(x("input", {
                id: "username",
                "onUpdate:modelValue": o[2] || (o[2] = (a) => v(r).basic.username = a),
                autocomplete: "off",
                placeholder: "Username",
                spellcheck: "false",
                type: "text"
              }, null, 512), [
                [xt, v(r).basic.username]
              ])
            ]),
            x("div", GQ, [
              KQ,
              Ne(x("input", {
                id: "password",
                "onUpdate:modelValue": o[3] || (o[3] = (a) => v(r).basic.password = a),
                autocomplete: "off",
                placeholder: "Password",
                spellcheck: "false",
                type: "password"
              }, null, 512), [
                [xt, v(r).basic.password]
              ])
            ]),
            x("label", JQ, [
              Ne(x("input", {
                "onUpdate:modelValue": o[4] || (o[4] = (a) => v(r).basic.active = a),
                type: "checkbox"
              }, null, 512), [
                [Ca, v(r).basic.active]
              ]),
              eA,
              tA
            ])
          ], 64)) : v(r).type === "digest" ? (k(), C(ee, { key: 1 }, [
            x("div", rA, [
              nA,
              Ne(x("input", {
                id: "username",
                "onUpdate:modelValue": o[5] || (o[5] = (a) => v(r).digest.username = a),
                autocomplete: "off",
                placeholder: "Username",
                spellcheck: "false",
                type: "text"
              }, null, 512), [
                [xt, v(r).digest.username]
              ])
            ]),
            x("div", iA, [
              sA,
              Ne(x("input", {
                id: "password",
                "onUpdate:modelValue": o[6] || (o[6] = (a) => v(r).digest.password = a),
                autocomplete: "off",
                placeholder: "Password",
                spellcheck: "false",
                type: "password"
              }, null, 512), [
                [xt, v(r).digest.password]
              ])
            ]),
            x("label", oA, [
              Ne(x("input", {
                "onUpdate:modelValue": o[7] || (o[7] = (a) => v(r).digest.active = a),
                type: "checkbox"
              }, null, 512), [
                [Ca, v(r).digest.active]
              ]),
              aA,
              lA
            ])
          ], 64)) : v(r).type === "oauthTwo" ? (k(), C(ee, { key: 2 }, [
            x("div", cA, [
              uA,
              Ne(x("input", {
                id: "generatedtoken",
                "onUpdate:modelValue": o[8] || (o[8] = (a) => v(r).oauthTwo.generatedToken = a),
                autocomplete: "off",
                placeholder: "Generated Token",
                spellcheck: "false",
                type: "text"
              }, null, 512), [
                [xt, v(r).oauthTwo.generatedToken]
              ])
            ]),
            x("div", dA, [
              fA,
              Ne(x("input", {
                id: "discoveryurl",
                "onUpdate:modelValue": o[9] || (o[9] = (a) => v(r).oauthTwo.discoveryURL = a),
                autocomplete: "off",
                placeholder: "Discovery URL",
                spellcheck: "false",
                type: "text"
              }, null, 512), [
                [xt, v(r).oauthTwo.discoveryURL]
              ])
            ]),
            x("div", hA, [
              pA,
              Ne(x("input", {
                id: "authurl",
                "onUpdate:modelValue": o[10] || (o[10] = (a) => v(r).oauthTwo.authURL = a),
                autocomplete: "off",
                placeholder: "Auth URL",
                spellcheck: "false",
                type: "text"
              }, null, 512), [
                [xt, v(r).oauthTwo.authURL]
              ])
            ]),
            x("div", mA, [
              gA,
              Ne(x("input", {
                id: "accesstoken",
                "onUpdate:modelValue": o[11] || (o[11] = (a) => v(r).oauthTwo.accessTokenURL = a),
                autocomplete: "off",
                placeholder: "Access Token URL",
                spellcheck: "false",
                type: "text"
              }, null, 512), [
                [xt, v(r).oauthTwo.accessTokenURL]
              ])
            ]),
            x("div", OA, [
              yA,
              Ne(x("input", {
                id: "clientid",
                "onUpdate:modelValue": o[12] || (o[12] = (a) => v(r).oauthTwo.clientID = a),
                autocomplete: "off",
                placeholder: "Client ID",
                spellcheck: "false",
                type: "text"
              }, null, 512), [
                [xt, v(r).oauthTwo.clientID]
              ])
            ]),
            x("div", bA, [
              vA,
              Ne(x("input", {
                id: "clientsecret",
                "onUpdate:modelValue": o[13] || (o[13] = (a) => v(r).oauthTwo.clientSecret = a),
                autocomplete: "off",
                placeholder: "Client Secret",
                spellcheck: "false",
                type: "text"
              }, null, 512), [
                [xt, v(r).oauthTwo.clientSecret]
              ])
            ]),
            x("div", wA, [
              $A,
              Ne(x("input", {
                id: "scope",
                "onUpdate:modelValue": o[14] || (o[14] = (a) => v(r).oauthTwo.scope = a),
                autocomplete: "off",
                placeholder: "Scope",
                spellcheck: "false",
                type: "text"
              }, null, 512), [
                [xt, v(r).oauthTwo.scope]
              ])
            ]),
            SA
          ], 64)) : v(r).type === "bearer" ? (k(), C(ee, { key: 3 }, [
            x("div", kA, [
              _A,
              Ne(x("input", {
                "onUpdate:modelValue": o[15] || (o[15] = (a) => v(r).bearer.token = a),
                autocomplete: "off",
                placeholder: "Username",
                spellcheck: "false",
                type: "text"
              }, null, 512), [
                [xt, v(r).bearer.token]
              ])
            ]),
            x("label", PA, [
              Ne(x("input", {
                "onUpdate:modelValue": o[16] || (o[16] = (a) => v(r).bearer.active = a),
                type: "checkbox"
              }, null, 512), [
                [Ca, v(r).bearer.active]
              ]),
              xA,
              TA
            ])
          ], 64)) : H("", !0)
        ]))
      ]),
      _: 1
    }));
  }
});
function Z$(t) {
  var e, r, n = "";
  if (typeof t == "string" || typeof t == "number")
    n += t;
  else if (typeof t == "object")
    if (Array.isArray(t))
      for (e = 0; e < t.length; e++)
        t[e] && (r = Z$(t[e])) && (n && (n += " "), n += r);
    else
      for (e in t)
        t[e] && (n && (n += " "), n += e);
  return n;
}
function $f() {
  for (var t, e, r = 0, n = ""; r < arguments.length; )
    (t = arguments[r++]) && (e = Z$(t)) && (n && (n += " "), n += e);
  return n;
}
const X1 = (t) => typeof t == "boolean" ? "".concat(t) : t === 0 ? "0" : t, QA = (t) => {
  const e = function() {
    for (var i = arguments.length, s = new Array(i), o = 0; o < i; o++)
      s[o] = arguments[o];
    var a, l;
    return typeof (t == null || (a = t.hooks) === null || a === void 0 ? void 0 : a["cx:done"]) < "u" ? t == null ? void 0 : t.hooks["cx:done"]($f(s)) : typeof (t == null || (l = t.hooks) === null || l === void 0 ? void 0 : l.onComplete) < "u" ? t == null ? void 0 : t.hooks.onComplete($f(s)) : $f(s);
  };
  return { compose: function() {
    for (var i = arguments.length, s = new Array(i), o = 0; o < i; o++)
      s[o] = arguments[o];
    return (a) => {
      const l = Object.fromEntries(Object.entries(a || {}).filter((c) => {
        let [u] = c;
        return !["class", "className"].includes(u);
      }));
      return e(s.map((c) => c(l)), a == null ? void 0 : a.class, a == null ? void 0 : a.className);
    };
  }, cva: (i) => (s) => {
    var o;
    if ((i == null ? void 0 : i.variants) == null)
      return e(i == null ? void 0 : i.base, s == null ? void 0 : s.class, s == null ? void 0 : s.className);
    const { variants: a, defaultVariants: l } = i, c = Object.keys(a).map((f) => {
      const h = s == null ? void 0 : s[f], p = l == null ? void 0 : l[f], g = X1(h) || X1(p);
      return a[f][g];
    }), u = { ...l, ...s && Object.entries(s).reduce((f, h) => {
      let [p, g] = h;
      return typeof g > "u" ? f : { ...f, [p]: g };
    }, {}) }, d = i == null || (o = i.compoundVariants) === null || o === void 0 ? void 0 : o.reduce((f, h) => {
      let { class: p, className: g, ...m } = h;
      return Object.entries(m).every((y) => {
        let [O, b] = y;
        const w = u[O];
        return Array.isArray(b) ? b.includes(w) : w === b;
      }) ? [...f, p, g] : f;
    }, []);
    return e(i == null ? void 0 : i.base, c, d, s == null ? void 0 : s.class, s == null ? void 0 : s.className);
  }, cx: e };
}, Wm = "-";
function AA(t) {
  const e = RA(t), {
    conflictingClassGroups: r,
    conflictingClassGroupModifiers: n
  } = t;
  function i(o) {
    const a = o.split(Wm);
    return a[0] === "" && a.length !== 1 && a.shift(), M$(a, e) || EA(o);
  }
  function s(o, a) {
    const l = r[o] || [];
    return a && n[o] ? [...l, ...n[o]] : l;
  }
  return {
    getClassGroupId: i,
    getConflictingClassGroupIds: s
  };
}
function M$(t, e) {
  var o;
  if (t.length === 0)
    return e.classGroupId;
  const r = t[0], n = e.nextPart.get(r), i = n ? M$(t.slice(1), n) : void 0;
  if (i)
    return i;
  if (e.validators.length === 0)
    return;
  const s = t.join(Wm);
  return (o = e.validators.find(({
    validator: a
  }) => a(s))) == null ? void 0 : o.classGroupId;
}
const W1 = /^\[(.+)\]$/;
function EA(t) {
  if (W1.test(t)) {
    const e = W1.exec(t)[1], r = e == null ? void 0 : e.substring(0, e.indexOf(":"));
    if (r)
      return "arbitrary.." + r;
  }
}
function RA(t) {
  const {
    theme: e,
    prefix: r
  } = t, n = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return jA(Object.entries(t.classGroups), r).forEach(([s, o]) => {
    Jh(o, n, s, e);
  }), n;
}
function Jh(t, e, r, n) {
  t.forEach((i) => {
    if (typeof i == "string") {
      const s = i === "" ? e : U1(e, i);
      s.classGroupId = r;
      return;
    }
    if (typeof i == "function") {
      if (IA(i)) {
        Jh(i(n), e, r, n);
        return;
      }
      e.validators.push({
        validator: i,
        classGroupId: r
      });
      return;
    }
    Object.entries(i).forEach(([s, o]) => {
      Jh(o, U1(e, s), r, n);
    });
  });
}
function U1(t, e) {
  let r = t;
  return e.split(Wm).forEach((n) => {
    r.nextPart.has(n) || r.nextPart.set(n, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), r = r.nextPart.get(n);
  }), r;
}
function IA(t) {
  return t.isThemeGetter;
}
function jA(t, e) {
  return e ? t.map(([r, n]) => {
    const i = n.map((s) => typeof s == "string" ? e + s : typeof s == "object" ? Object.fromEntries(Object.entries(s).map(([o, a]) => [e + o, a])) : s);
    return [r, i];
  }) : t;
}
function ZA(t) {
  if (t < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let e = 0, r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  function i(s, o) {
    r.set(s, o), e++, e > t && (e = 0, n = r, r = /* @__PURE__ */ new Map());
  }
  return {
    get(s) {
      let o = r.get(s);
      if (o !== void 0)
        return o;
      if ((o = n.get(s)) !== void 0)
        return i(s, o), o;
    },
    set(s, o) {
      r.has(s) ? r.set(s, o) : i(s, o);
    }
  };
}
const q$ = "!";
function MA(t) {
  const e = t.separator, r = e.length === 1, n = e[0], i = e.length;
  return function(o) {
    const a = [];
    let l = 0, c = 0, u;
    for (let g = 0; g < o.length; g++) {
      let m = o[g];
      if (l === 0) {
        if (m === n && (r || o.slice(g, g + i) === e)) {
          a.push(o.slice(c, g)), c = g + i;
          continue;
        }
        if (m === "/") {
          u = g;
          continue;
        }
      }
      m === "[" ? l++ : m === "]" && l--;
    }
    const d = a.length === 0 ? o : o.substring(c), f = d.startsWith(q$), h = f ? d.substring(1) : d, p = u && u > c ? u - c : void 0;
    return {
      modifiers: a,
      hasImportantModifier: f,
      baseClassName: h,
      maybePostfixModifierPosition: p
    };
  };
}
function qA(t) {
  if (t.length <= 1)
    return t;
  const e = [];
  let r = [];
  return t.forEach((n) => {
    n[0] === "[" ? (e.push(...r.sort(), n), r = []) : r.push(n);
  }), e.push(...r.sort()), e;
}
function NA(t) {
  return {
    cache: ZA(t.cacheSize),
    splitModifiers: MA(t),
    ...AA(t)
  };
}
const DA = /\s+/;
function zA(t, e) {
  const {
    splitModifiers: r,
    getClassGroupId: n,
    getConflictingClassGroupIds: i
  } = e, s = /* @__PURE__ */ new Set();
  return t.trim().split(DA).map((o) => {
    const {
      modifiers: a,
      hasImportantModifier: l,
      baseClassName: c,
      maybePostfixModifierPosition: u
    } = r(o);
    let d = n(u ? c.substring(0, u) : c), f = !!u;
    if (!d) {
      if (!u)
        return {
          isTailwindClass: !1,
          originalClassName: o
        };
      if (d = n(c), !d)
        return {
          isTailwindClass: !1,
          originalClassName: o
        };
      f = !1;
    }
    const h = qA(a).join(":");
    return {
      isTailwindClass: !0,
      modifierId: l ? h + q$ : h,
      classGroupId: d,
      originalClassName: o,
      hasPostfixModifier: f
    };
  }).reverse().filter((o) => {
    if (!o.isTailwindClass)
      return !0;
    const {
      modifierId: a,
      classGroupId: l,
      hasPostfixModifier: c
    } = o, u = a + l;
    return s.has(u) ? !1 : (s.add(u), i(l, c).forEach((d) => s.add(a + d)), !0);
  }).reverse().map((o) => o.originalClassName).join(" ");
}
function XA() {
  let t = 0, e, r, n = "";
  for (; t < arguments.length; )
    (e = arguments[t++]) && (r = N$(e)) && (n && (n += " "), n += r);
  return n;
}
function N$(t) {
  if (typeof t == "string")
    return t;
  let e, r = "";
  for (let n = 0; n < t.length; n++)
    t[n] && (e = N$(t[n])) && (r && (r += " "), r += e);
  return r;
}
function V1(t, ...e) {
  let r, n, i, s = o;
  function o(l) {
    const c = e.reduce((u, d) => d(u), t());
    return r = NA(c), n = r.cache.get, i = r.cache.set, s = a, a(l);
  }
  function a(l) {
    const c = n(l);
    if (c)
      return c;
    const u = zA(l, r);
    return i(l, u), u;
  }
  return function() {
    return s(XA.apply(null, arguments));
  };
}
function Ge(t) {
  const e = (r) => r[t] || [];
  return e.isThemeGetter = !0, e;
}
const D$ = /^\[(?:([a-z-]+):)?(.+)\]$/i, WA = /^\d+\/\d+$/, UA = /* @__PURE__ */ new Set(["px", "full", "screen"]), VA = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, LA = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, YA = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, BA = /^-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, FA = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
function xn(t) {
  return ts(t) || UA.has(t) || WA.test(t);
}
function Yn(t) {
  return zo(t, "length", n9);
}
function ts(t) {
  return !!t && !Number.isNaN(Number(t));
}
function mc(t) {
  return zo(t, "number", ts);
}
function ha(t) {
  return !!t && Number.isInteger(Number(t));
}
function HA(t) {
  return t.endsWith("%") && ts(t.slice(0, -1));
}
function Ae(t) {
  return D$.test(t);
}
function Bn(t) {
  return VA.test(t);
}
const GA = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
function KA(t) {
  return zo(t, GA, z$);
}
function JA(t) {
  return zo(t, "position", z$);
}
const e9 = /* @__PURE__ */ new Set(["image", "url"]);
function t9(t) {
  return zo(t, e9, s9);
}
function r9(t) {
  return zo(t, "", i9);
}
function pa() {
  return !0;
}
function zo(t, e, r) {
  const n = D$.exec(t);
  return n ? n[1] ? typeof e == "string" ? n[1] === e : e.has(n[1]) : r(n[2]) : !1;
}
function n9(t) {
  return LA.test(t) && !YA.test(t);
}
function z$() {
  return !1;
}
function i9(t) {
  return BA.test(t);
}
function s9(t) {
  return FA.test(t);
}
function L1() {
  const t = Ge("colors"), e = Ge("spacing"), r = Ge("blur"), n = Ge("brightness"), i = Ge("borderColor"), s = Ge("borderRadius"), o = Ge("borderSpacing"), a = Ge("borderWidth"), l = Ge("contrast"), c = Ge("grayscale"), u = Ge("hueRotate"), d = Ge("invert"), f = Ge("gap"), h = Ge("gradientColorStops"), p = Ge("gradientColorStopPositions"), g = Ge("inset"), m = Ge("margin"), y = Ge("opacity"), O = Ge("padding"), b = Ge("saturate"), w = Ge("scale"), S = Ge("sepia"), $ = Ge("skew"), _ = Ge("space"), Q = Ge("translate"), N = () => ["auto", "contain", "none"], B = () => ["auto", "hidden", "clip", "visible", "scroll"], J = () => ["auto", Ae, e], U = () => [Ae, e], ue = () => ["", xn, Yn], le = () => ["auto", ts, Ae], Pe = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], Ce = () => ["solid", "dashed", "dotted", "double", "none"], X = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-lighter"], F = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], K = () => ["", "0", Ae], z = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], R = () => [ts, mc], D = () => [ts, Ae];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [pa],
      spacing: [xn, Yn],
      blur: ["none", "", Bn, Ae],
      brightness: R(),
      borderColor: [t],
      borderRadius: ["none", "", "full", Bn, Ae],
      borderSpacing: U(),
      borderWidth: ue(),
      contrast: R(),
      grayscale: K(),
      hueRotate: D(),
      invert: K(),
      gap: U(),
      gradientColorStops: [t],
      gradientColorStopPositions: [HA, Yn],
      inset: J(),
      margin: J(),
      opacity: R(),
      padding: U(),
      saturate: R(),
      scale: R(),
      sepia: K(),
      skew: D(),
      space: U(),
      translate: U()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", Ae]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [Bn]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": z()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": z()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...Pe(), Ae]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: B()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": B()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": B()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: N()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": N()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": N()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [g]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [g]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [g]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [g]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [g]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [g]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [g]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [g]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [g]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", ha, Ae]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: J()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", Ae]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: K()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: K()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", ha, Ae]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [pa]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", ha, Ae]
        }, Ae]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": le()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": le()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [pa]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [ha, Ae]
        }, Ae]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": le()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": le()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", Ae]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", Ae]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [f]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [f]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [f]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...F()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...F(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...F(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [O]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [O]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [O]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [O]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [O]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [O]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [O]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [O]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [O]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [m]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [m]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [m]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [m]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [m]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [m]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [m]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [m]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [m]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [_]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [_]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", Ae, e]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [Ae, e, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [Ae, e, "none", "full", "min", "max", "fit", "prose", {
          screen: [Bn]
        }, Bn]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [Ae, e, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [Ae, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [Ae, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [Ae, e, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", Bn, Yn]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", mc]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [pa]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", Ae]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", ts, mc]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", xn, Ae]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", Ae]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", Ae]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [t]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [y]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [t]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [y]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...Ce(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", xn, Yn]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", xn, Ae]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [t]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: U()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", Ae]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", Ae]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [y]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...Pe(), JA]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", KA]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, t9]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [t]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [p]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [p]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [p]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [h]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [h]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [h]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [s]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [s]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [s]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [s]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [s]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [s]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [s]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [s]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [s]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [s]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [s]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [s]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [s]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [s]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [s]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [a]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [a]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [a]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [a]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [a]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [a]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [a]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [a]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [a]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [y]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...Ce(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [a]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [a]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [y]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: Ce()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [i]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [i]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [i]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [i]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [i]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [i]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [i]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [i]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...Ce()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [xn, Ae]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [xn, Yn]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [t]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: ue()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [t]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [y]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [xn, Yn]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [t]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", Bn, r9]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [pa]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [y]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": X()
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": X()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [r]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [n]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [l]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", Bn, Ae]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [c]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [u]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [d]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [b]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [S]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [r]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [n]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [l]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [c]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [u]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [d]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [y]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [b]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [S]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [o]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [o]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [o]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", Ae]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: D()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", Ae]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: D()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", Ae]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [w]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [w]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [w]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [ha, Ae]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [Q]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [Q]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [$]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [$]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", Ae]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", t]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", Ae]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [t]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": U()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": U()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": U()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": U()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": U()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": U()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": U()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": U()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": U()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": U()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": U()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": U()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": U()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": U()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": U()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": U()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": U()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": U()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", Ae]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [t, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [xn, Yn, mc]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [t, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}
function o9(t, {
  cacheSize: e,
  prefix: r,
  separator: n,
  extend: i = {},
  override: s = {}
}) {
  Dc(t, "cacheSize", e), Dc(t, "prefix", r), Dc(t, "separator", n);
  for (const o in s)
    a9(t[o], s[o]);
  for (const o in i)
    l9(t[o], i[o]);
  return t;
}
function Dc(t, e, r) {
  r !== void 0 && (t[e] = r);
}
function a9(t, e) {
  if (e)
    for (const r in e)
      Dc(t, r, e[r]);
}
function l9(t, e) {
  if (e)
    for (const r in e) {
      const n = e[r];
      n !== void 0 && (t[r] = (t[r] || []).concat(n));
    }
}
function c9(t, ...e) {
  return typeof t == "function" ? V1(L1, t, ...e) : V1(() => o9(L1(), t), ...e);
}
var pi = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function X$(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function W$(t) {
  if (t.__esModule)
    return t;
  var e = t.default;
  if (typeof e == "function") {
    var r = function n() {
      return this instanceof n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    r.prototype = e.prototype;
  } else
    r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(t).forEach(function(n) {
    var i = Object.getOwnPropertyDescriptor(t, n);
    Object.defineProperty(r, n, i.get ? i : {
      enumerable: !0,
      get: function() {
        return t[n];
      }
    });
  }), r;
}
var U$ = { exports: {} };
(function(t) {
  var e = typeof window < "u" ? window : typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope ? self : {};
  /**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   */
  var r = function(n) {
    var i = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i, s = 0, o = {}, a = {
      /**
       * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
       * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
       * additional languages or plugins yourself.
       *
       * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
       *
       * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
       * empty Prism object into the global scope before loading the Prism script like this:
       *
       * ```js
       * window.Prism = window.Prism || {};
       * Prism.manual = true;
       * // add a new <script> to load Prism's script
       * ```
       *
       * @default false
       * @type {boolean}
       * @memberof Prism
       * @public
       */
      manual: n.Prism && n.Prism.manual,
      /**
       * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
       * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
       * own worker, you don't want it to do this.
       *
       * By setting this value to `true`, Prism will not add its own listeners to the worker.
       *
       * You obviously have to change this value before Prism executes. To do this, you can add an
       * empty Prism object into the global scope before loading the Prism script like this:
       *
       * ```js
       * window.Prism = window.Prism || {};
       * Prism.disableWorkerMessageHandler = true;
       * // Load Prism's script
       * ```
       *
       * @default false
       * @type {boolean}
       * @memberof Prism
       * @public
       */
      disableWorkerMessageHandler: n.Prism && n.Prism.disableWorkerMessageHandler,
      /**
       * A namespace for utility methods.
       *
       * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
       * change or disappear at any time.
       *
       * @namespace
       * @memberof Prism
       */
      util: {
        encode: function O(b) {
          return b instanceof l ? new l(b.type, O(b.content), b.alias) : Array.isArray(b) ? b.map(O) : b.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
        },
        /**
         * Returns the name of the type of the given value.
         *
         * @param {any} o
         * @returns {string}
         * @example
         * type(null)      === 'Null'
         * type(undefined) === 'Undefined'
         * type(123)       === 'Number'
         * type('foo')     === 'String'
         * type(true)      === 'Boolean'
         * type([1, 2])    === 'Array'
         * type({})        === 'Object'
         * type(String)    === 'Function'
         * type(/abc+/)    === 'RegExp'
         */
        type: function(O) {
          return Object.prototype.toString.call(O).slice(8, -1);
        },
        /**
         * Returns a unique number for the given object. Later calls will still return the same number.
         *
         * @param {Object} obj
         * @returns {number}
         */
        objId: function(O) {
          return O.__id || Object.defineProperty(O, "__id", { value: ++s }), O.__id;
        },
        /**
         * Creates a deep clone of the given object.
         *
         * The main intended use of this function is to clone language definitions.
         *
         * @param {T} o
         * @param {Record<number, any>} [visited]
         * @returns {T}
         * @template T
         */
        clone: function O(b, w) {
          w = w || {};
          var S, $;
          switch (a.util.type(b)) {
            case "Object":
              if ($ = a.util.objId(b), w[$])
                return w[$];
              S = /** @type {Record<string, any>} */
              {}, w[$] = S;
              for (var _ in b)
                b.hasOwnProperty(_) && (S[_] = O(b[_], w));
              return (
                /** @type {any} */
                S
              );
            case "Array":
              return $ = a.util.objId(b), w[$] ? w[$] : (S = [], w[$] = S, /** @type {Array} */
              /** @type {any} */
              b.forEach(function(Q, N) {
                S[N] = O(Q, w);
              }), /** @type {any} */
              S);
            default:
              return b;
          }
        },
        /**
         * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
         *
         * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
         *
         * @param {Element} element
         * @returns {string}
         */
        getLanguage: function(O) {
          for (; O; ) {
            var b = i.exec(O.className);
            if (b)
              return b[1].toLowerCase();
            O = O.parentElement;
          }
          return "none";
        },
        /**
         * Sets the Prism `language-xxxx` class of the given element.
         *
         * @param {Element} element
         * @param {string} language
         * @returns {void}
         */
        setLanguage: function(O, b) {
          O.className = O.className.replace(RegExp(i, "gi"), ""), O.classList.add("language-" + b);
        },
        /**
         * Returns the script element that is currently executing.
         *
         * This does __not__ work for line script element.
         *
         * @returns {HTMLScriptElement | null}
         */
        currentScript: function() {
          if (typeof document > "u")
            return null;
          if ("currentScript" in document && 1 < 2)
            return (
              /** @type {any} */
              document.currentScript
            );
          try {
            throw new Error();
          } catch (S) {
            var O = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(S.stack) || [])[1];
            if (O) {
              var b = document.getElementsByTagName("script");
              for (var w in b)
                if (b[w].src == O)
                  return b[w];
            }
            return null;
          }
        },
        /**
         * Returns whether a given class is active for `element`.
         *
         * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
         * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
         * given class is just the given class with a `no-` prefix.
         *
         * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
         * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
         * ancestors have the given class or the negated version of it, then the default activation will be returned.
         *
         * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
         * version of it, the class is considered active.
         *
         * @param {Element} element
         * @param {string} className
         * @param {boolean} [defaultActivation=false]
         * @returns {boolean}
         */
        isActive: function(O, b, w) {
          for (var S = "no-" + b; O; ) {
            var $ = O.classList;
            if ($.contains(b))
              return !0;
            if ($.contains(S))
              return !1;
            O = O.parentElement;
          }
          return !!w;
        }
      },
      /**
       * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
       *
       * @namespace
       * @memberof Prism
       * @public
       */
      languages: {
        /**
         * The grammar for plain, unformatted text.
         */
        plain: o,
        plaintext: o,
        text: o,
        txt: o,
        /**
         * Creates a deep copy of the language with the given id and appends the given tokens.
         *
         * If a token in `redef` also appears in the copied language, then the existing token in the copied language
         * will be overwritten at its original position.
         *
         * ## Best practices
         *
         * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
         * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
         * understand the language definition because, normally, the order of tokens matters in Prism grammars.
         *
         * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
         * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
         *
         * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
         * @param {Grammar} redef The new tokens to append.
         * @returns {Grammar} The new language created.
         * @public
         * @example
         * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
         *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
         *     // at its original position
         *     'comment': { ... },
         *     // CSS doesn't have a 'color' token, so this token will be appended
         *     'color': /\b(?:red|green|blue)\b/
         * });
         */
        extend: function(O, b) {
          var w = a.util.clone(a.languages[O]);
          for (var S in b)
            w[S] = b[S];
          return w;
        },
        /**
         * Inserts tokens _before_ another token in a language definition or any other grammar.
         *
         * ## Usage
         *
         * This helper method makes it easy to modify existing languages. For example, the CSS language definition
         * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
         * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
         * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
         * this:
         *
         * ```js
         * Prism.languages.markup.style = {
         *     // token
         * };
         * ```
         *
         * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
         * before existing tokens. For the CSS example above, you would use it like this:
         *
         * ```js
         * Prism.languages.insertBefore('markup', 'cdata', {
         *     'style': {
         *         // token
         *     }
         * });
         * ```
         *
         * ## Special cases
         *
         * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
         * will be ignored.
         *
         * This behavior can be used to insert tokens after `before`:
         *
         * ```js
         * Prism.languages.insertBefore('markup', 'comment', {
         *     'comment': Prism.languages.markup.comment,
         *     // tokens after 'comment'
         * });
         * ```
         *
         * ## Limitations
         *
         * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
         * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
         * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
         * deleting properties which is necessary to insert at arbitrary positions.
         *
         * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
         * Instead, it will create a new object and replace all references to the target object with the new one. This
         * can be done without temporarily deleting properties, so the iteration order is well-defined.
         *
         * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
         * you hold the target object in a variable, then the value of the variable will not change.
         *
         * ```js
         * var oldMarkup = Prism.languages.markup;
         * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
         *
         * assert(oldMarkup !== Prism.languages.markup);
         * assert(newMarkup === Prism.languages.markup);
         * ```
         *
         * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
         * object to be modified.
         * @param {string} before The key to insert before.
         * @param {Grammar} insert An object containing the key-value pairs to be inserted.
         * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
         * object to be modified.
         *
         * Defaults to `Prism.languages`.
         * @returns {Grammar} The new grammar object.
         * @public
         */
        insertBefore: function(O, b, w, S) {
          S = S || /** @type {any} */
          a.languages;
          var $ = S[O], _ = {};
          for (var Q in $)
            if ($.hasOwnProperty(Q)) {
              if (Q == b)
                for (var N in w)
                  w.hasOwnProperty(N) && (_[N] = w[N]);
              w.hasOwnProperty(Q) || (_[Q] = $[Q]);
            }
          var B = S[O];
          return S[O] = _, a.languages.DFS(a.languages, function(J, U) {
            U === B && J != O && (this[J] = _);
          }), _;
        },
        // Traverse a language definition with Depth First Search
        DFS: function O(b, w, S, $) {
          $ = $ || {};
          var _ = a.util.objId;
          for (var Q in b)
            if (b.hasOwnProperty(Q)) {
              w.call(b, Q, b[Q], S || Q);
              var N = b[Q], B = a.util.type(N);
              B === "Object" && !$[_(N)] ? ($[_(N)] = !0, O(N, w, null, $)) : B === "Array" && !$[_(N)] && ($[_(N)] = !0, O(N, w, Q, $));
            }
        }
      },
      plugins: {},
      /**
       * This is the most high-level function in Prismâ€™s API.
       * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
       * each one of them.
       *
       * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
       *
       * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
       * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
       * @memberof Prism
       * @public
       */
      highlightAll: function(O, b) {
        a.highlightAllUnder(document, O, b);
      },
      /**
       * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
       * {@link Prism.highlightElement} on each one of them.
       *
       * The following hooks will be run:
       * 1. `before-highlightall`
       * 2. `before-all-elements-highlight`
       * 3. All hooks of {@link Prism.highlightElement} for each element.
       *
       * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
       * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
       * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
       * @memberof Prism
       * @public
       */
      highlightAllUnder: function(O, b, w) {
        var S = {
          callback: w,
          container: O,
          selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
        };
        a.hooks.run("before-highlightall", S), S.elements = Array.prototype.slice.apply(S.container.querySelectorAll(S.selector)), a.hooks.run("before-all-elements-highlight", S);
        for (var $ = 0, _; _ = S.elements[$++]; )
          a.highlightElement(_, b === !0, S.callback);
      },
      /**
       * Highlights the code inside a single element.
       *
       * The following hooks will be run:
       * 1. `before-sanity-check`
       * 2. `before-highlight`
       * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
       * 4. `before-insert`
       * 5. `after-highlight`
       * 6. `complete`
       *
       * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
       * the element's language.
       *
       * @param {Element} element The element containing the code.
       * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
       * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
       * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
       * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
       *
       * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
       * asynchronous highlighting to work. You can build your own bundle on the
       * [Download page](https://prismjs.com/download.html).
       * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
       * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
       * @memberof Prism
       * @public
       */
      highlightElement: function(O, b, w) {
        var S = a.util.getLanguage(O), $ = a.languages[S];
        a.util.setLanguage(O, S);
        var _ = O.parentElement;
        _ && _.nodeName.toLowerCase() === "pre" && a.util.setLanguage(_, S);
        var Q = O.textContent, N = {
          element: O,
          language: S,
          grammar: $,
          code: Q
        };
        function B(U) {
          N.highlightedCode = U, a.hooks.run("before-insert", N), N.element.innerHTML = N.highlightedCode, a.hooks.run("after-highlight", N), a.hooks.run("complete", N), w && w.call(N.element);
        }
        if (a.hooks.run("before-sanity-check", N), _ = N.element.parentElement, _ && _.nodeName.toLowerCase() === "pre" && !_.hasAttribute("tabindex") && _.setAttribute("tabindex", "0"), !N.code) {
          a.hooks.run("complete", N), w && w.call(N.element);
          return;
        }
        if (a.hooks.run("before-highlight", N), !N.grammar) {
          B(a.util.encode(N.code));
          return;
        }
        if (b && n.Worker) {
          var J = new Worker(a.filename);
          J.onmessage = function(U) {
            B(U.data);
          }, J.postMessage(JSON.stringify({
            language: N.language,
            code: N.code,
            immediateClose: !0
          }));
        } else
          B(a.highlight(N.code, N.grammar, N.language));
      },
      /**
       * Low-level function, only use if you know what youâ€™re doing. It accepts a string of text as input
       * and the language definitions to use, and returns a string with the HTML produced.
       *
       * The following hooks will be run:
       * 1. `before-tokenize`
       * 2. `after-tokenize`
       * 3. `wrap`: On each {@link Token}.
       *
       * @param {string} text A string with the code to be highlighted.
       * @param {Grammar} grammar An object containing the tokens to use.
       *
       * Usually a language definition like `Prism.languages.markup`.
       * @param {string} language The name of the language definition passed to `grammar`.
       * @returns {string} The highlighted HTML.
       * @memberof Prism
       * @public
       * @example
       * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
       */
      highlight: function(O, b, w) {
        var S = {
          code: O,
          grammar: b,
          language: w
        };
        if (a.hooks.run("before-tokenize", S), !S.grammar)
          throw new Error('The language "' + S.language + '" has no grammar.');
        return S.tokens = a.tokenize(S.code, S.grammar), a.hooks.run("after-tokenize", S), l.stringify(a.util.encode(S.tokens), S.language);
      },
      /**
       * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
       * and the language definitions to use, and returns an array with the tokenized code.
       *
       * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
       *
       * This method could be useful in other contexts as well, as a very crude parser.
       *
       * @param {string} text A string with the code to be highlighted.
       * @param {Grammar} grammar An object containing the tokens to use.
       *
       * Usually a language definition like `Prism.languages.markup`.
       * @returns {TokenStream} An array of strings and tokens, a token stream.
       * @memberof Prism
       * @public
       * @example
       * let code = `var foo = 0;`;
       * let tokens = Prism.tokenize(code, Prism.languages.javascript);
       * tokens.forEach(token => {
       *     if (token instanceof Prism.Token && token.type === 'number') {
       *         console.log(`Found numeric literal: ${token.content}`);
       *     }
       * });
       */
      tokenize: function(O, b) {
        var w = b.rest;
        if (w) {
          for (var S in w)
            b[S] = w[S];
          delete b.rest;
        }
        var $ = new d();
        return f($, $.head, O), u(O, $, b, $.head, 0), p($);
      },
      /**
       * @namespace
       * @memberof Prism
       * @public
       */
      hooks: {
        all: {},
        /**
         * Adds the given callback to the list of callbacks for the given hook.
         *
         * The callback will be invoked when the hook it is registered for is run.
         * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
         *
         * One callback function can be registered to multiple hooks and the same hook multiple times.
         *
         * @param {string} name The name of the hook.
         * @param {HookCallback} callback The callback function which is given environment variables.
         * @public
         */
        add: function(O, b) {
          var w = a.hooks.all;
          w[O] = w[O] || [], w[O].push(b);
        },
        /**
         * Runs a hook invoking all registered callbacks with the given environment variables.
         *
         * Callbacks will be invoked synchronously and in the order in which they were registered.
         *
         * @param {string} name The name of the hook.
         * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
         * @public
         */
        run: function(O, b) {
          var w = a.hooks.all[O];
          if (!(!w || !w.length))
            for (var S = 0, $; $ = w[S++]; )
              $(b);
        }
      },
      Token: l
    };
    n.Prism = a;
    function l(O, b, w, S) {
      this.type = O, this.content = b, this.alias = w, this.length = (S || "").length | 0;
    }
    l.stringify = function O(b, w) {
      if (typeof b == "string")
        return b;
      if (Array.isArray(b)) {
        var S = "";
        return b.forEach(function(B) {
          S += O(B, w);
        }), S;
      }
      var $ = {
        type: b.type,
        content: O(b.content, w),
        tag: "span",
        classes: ["token", b.type],
        attributes: {},
        language: w
      }, _ = b.alias;
      _ && (Array.isArray(_) ? Array.prototype.push.apply($.classes, _) : $.classes.push(_)), a.hooks.run("wrap", $);
      var Q = "";
      for (var N in $.attributes)
        Q += " " + N + '="' + ($.attributes[N] || "").replace(/"/g, "&quot;") + '"';
      return "<" + $.tag + ' class="' + $.classes.join(" ") + '"' + Q + ">" + $.content + "</" + $.tag + ">";
    };
    function c(O, b, w, S) {
      O.lastIndex = b;
      var $ = O.exec(w);
      if ($ && S && $[1]) {
        var _ = $[1].length;
        $.index += _, $[0] = $[0].slice(_);
      }
      return $;
    }
    function u(O, b, w, S, $, _) {
      for (var Q in w)
        if (!(!w.hasOwnProperty(Q) || !w[Q])) {
          var N = w[Q];
          N = Array.isArray(N) ? N : [N];
          for (var B = 0; B < N.length; ++B) {
            if (_ && _.cause == Q + "," + B)
              return;
            var J = N[B], U = J.inside, ue = !!J.lookbehind, le = !!J.greedy, Pe = J.alias;
            if (le && !J.pattern.global) {
              var Ce = J.pattern.toString().match(/[imsuy]*$/)[0];
              J.pattern = RegExp(J.pattern.source, Ce + "g");
            }
            for (var X = J.pattern || J, F = S.next, K = $; F !== b.tail && !(_ && K >= _.reach); K += F.value.length, F = F.next) {
              var z = F.value;
              if (b.length > O.length)
                return;
              if (!(z instanceof l)) {
                var R = 1, D;
                if (le) {
                  if (D = c(X, K, O, ue), !D || D.index >= O.length)
                    break;
                  var W = D.index, M = D.index + D[0].length, P = K;
                  for (P += F.value.length; W >= P; )
                    F = F.next, P += F.value.length;
                  if (P -= F.value.length, K = P, F.value instanceof l)
                    continue;
                  for (var A = F; A !== b.tail && (P < M || typeof A.value == "string"); A = A.next)
                    R++, P += A.value.length;
                  R--, z = O.slice(K, P), D.index -= K;
                } else if (D = c(X, 0, z, ue), !D)
                  continue;
                var W = D.index, ne = D[0], ie = z.slice(0, W), Oe = z.slice(W + ne.length), ve = K + z.length;
                _ && ve > _.reach && (_.reach = ve);
                var xe = F.prev;
                ie && (xe = f(b, xe, ie), K += ie.length), h(b, xe, R);
                var Fe = new l(Q, U ? a.tokenize(ne, U) : ne, Pe, ne);
                if (F = f(b, xe, Fe), Oe && f(b, F, Oe), R > 1) {
                  var st = {
                    cause: Q + "," + B,
                    reach: ve
                  };
                  u(O, b, w, F.prev, K, st), _ && st.reach > _.reach && (_.reach = st.reach);
                }
              }
            }
          }
        }
    }
    function d() {
      var O = { value: null, prev: null, next: null }, b = { value: null, prev: O, next: null };
      O.next = b, this.head = O, this.tail = b, this.length = 0;
    }
    function f(O, b, w) {
      var S = b.next, $ = { value: w, prev: b, next: S };
      return b.next = $, S.prev = $, O.length++, $;
    }
    function h(O, b, w) {
      for (var S = b.next, $ = 0; $ < w && S !== O.tail; $++)
        S = S.next;
      b.next = S, S.prev = b, O.length -= $;
    }
    function p(O) {
      for (var b = [], w = O.head.next; w !== O.tail; )
        b.push(w.value), w = w.next;
      return b;
    }
    if (!n.document)
      return n.addEventListener && (a.disableWorkerMessageHandler || n.addEventListener("message", function(O) {
        var b = JSON.parse(O.data), w = b.language, S = b.code, $ = b.immediateClose;
        n.postMessage(a.highlight(S, a.languages[w], w)), $ && n.close();
      }, !1)), a;
    var g = a.util.currentScript();
    g && (a.filename = g.src, g.hasAttribute("data-manual") && (a.manual = !0));
    function m() {
      a.manual || a.highlightAll();
    }
    if (!a.manual) {
      var y = document.readyState;
      y === "loading" || y === "interactive" && g && g.defer ? document.addEventListener("DOMContentLoaded", m) : window.requestAnimationFrame ? window.requestAnimationFrame(m) : window.setTimeout(m, 16);
    }
    return a;
  }(e);
  t.exports && (t.exports = r), typeof pi < "u" && (pi.Prism = r), r.languages.markup = {
    comment: {
      pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
      greedy: !0
    },
    prolog: {
      pattern: /<\?[\s\S]+?\?>/,
      greedy: !0
    },
    doctype: {
      // https://www.w3.org/TR/xml/#NT-doctypedecl
      pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
      greedy: !0,
      inside: {
        "internal-subset": {
          pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
          lookbehind: !0,
          greedy: !0,
          inside: null
          // see below
        },
        string: {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: !0
        },
        punctuation: /^<!|>$|[[\]]/,
        "doctype-tag": /^DOCTYPE/i,
        name: /[^\s<>'"]+/
      }
    },
    cdata: {
      pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
      greedy: !0
    },
    tag: {
      pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
      greedy: !0,
      inside: {
        tag: {
          pattern: /^<\/?[^\s>\/]+/,
          inside: {
            punctuation: /^<\/?/,
            namespace: /^[^\s>\/:]+:/
          }
        },
        "special-attr": [],
        "attr-value": {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            punctuation: [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              {
                pattern: /^(\s*)["']|["']$/,
                lookbehind: !0
              }
            ]
          }
        },
        punctuation: /\/?>/,
        "attr-name": {
          pattern: /[^\s>\/]+/,
          inside: {
            namespace: /^[^\s>\/:]+:/
          }
        }
      }
    },
    entity: [
      {
        pattern: /&[\da-z]{1,8};/i,
        alias: "named-entity"
      },
      /&#x?[\da-f]{1,8};/i
    ]
  }, r.languages.markup.tag.inside["attr-value"].inside.entity = r.languages.markup.entity, r.languages.markup.doctype.inside["internal-subset"].inside = r.languages.markup, r.hooks.add("wrap", function(n) {
    n.type === "entity" && (n.attributes.title = n.content.replace(/&amp;/, "&"));
  }), Object.defineProperty(r.languages.markup.tag, "addInlined", {
    /**
     * Adds an inlined language to markup.
     *
     * An example of an inlined language is CSS with `<style>` tags.
     *
     * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addInlined('style', 'css');
     */
    value: function(i, s) {
      var o = {};
      o["language-" + s] = {
        pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
        lookbehind: !0,
        inside: r.languages[s]
      }, o.cdata = /^<!\[CDATA\[|\]\]>$/i;
      var a = {
        "included-cdata": {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          inside: o
        }
      };
      a["language-" + s] = {
        pattern: /[\s\S]+/,
        inside: r.languages[s]
      };
      var l = {};
      l[i] = {
        pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
          return i;
        }), "i"),
        lookbehind: !0,
        greedy: !0,
        inside: a
      }, r.languages.insertBefore("markup", "cdata", l);
    }
  }), Object.defineProperty(r.languages.markup.tag, "addAttribute", {
    /**
     * Adds an pattern to highlight languages embedded in HTML attributes.
     *
     * An example of an inlined language is CSS with `style` attributes.
     *
     * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addAttribute('style', 'css');
     */
    value: function(n, i) {
      r.languages.markup.tag.inside["special-attr"].push({
        pattern: RegExp(
          /(^|["'\s])/.source + "(?:" + n + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
          "i"
        ),
        lookbehind: !0,
        inside: {
          "attr-name": /^[^\s=]+/,
          "attr-value": {
            pattern: /=[\s\S]+/,
            inside: {
              value: {
                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                lookbehind: !0,
                alias: [i, "language-" + i],
                inside: r.languages[i]
              },
              punctuation: [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                /"|'/
              ]
            }
          }
        }
      });
    }
  }), r.languages.html = r.languages.markup, r.languages.mathml = r.languages.markup, r.languages.svg = r.languages.markup, r.languages.xml = r.languages.extend("markup", {}), r.languages.ssml = r.languages.xml, r.languages.atom = r.languages.xml, r.languages.rss = r.languages.xml, function(n) {
    var i = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
    n.languages.css = {
      comment: /\/\*[\s\S]*?\*\//,
      atrule: {
        pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + i.source + ")*?" + /(?:;|(?=\s*\{))/.source),
        inside: {
          rule: /^@[\w-]+/,
          "selector-function-argument": {
            pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
            lookbehind: !0,
            alias: "selector"
          },
          keyword: {
            pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
            lookbehind: !0
          }
          // See rest below
        }
      },
      url: {
        // https://drafts.csswg.org/css-values-3/#urls
        pattern: RegExp("\\burl\\((?:" + i.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
        greedy: !0,
        inside: {
          function: /^url/i,
          punctuation: /^\(|\)$/,
          string: {
            pattern: RegExp("^" + i.source + "$"),
            alias: "url"
          }
        }
      },
      selector: {
        pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + i.source + ")*(?=\\s*\\{)"),
        lookbehind: !0
      },
      string: {
        pattern: i,
        greedy: !0
      },
      property: {
        pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
        lookbehind: !0
      },
      important: /!important\b/i,
      function: {
        pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
        lookbehind: !0
      },
      punctuation: /[(){};:,]/
    }, n.languages.css.atrule.inside.rest = n.languages.css;
    var s = n.languages.markup;
    s && (s.tag.addInlined("style", "css"), s.tag.addAttribute("style", "css"));
  }(r), r.languages.clike = {
    comment: [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: !0,
        greedy: !0
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
      }
    ],
    string: {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
      lookbehind: !0,
      inside: {
        punctuation: /[.\\]/
      }
    },
    keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    boolean: /\b(?:false|true)\b/,
    function: /\b\w+(?=\()/,
    number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    punctuation: /[{}[\];(),.:]/
  }, r.languages.javascript = r.languages.extend("clike", {
    "class-name": [
      r.languages.clike["class-name"],
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
        lookbehind: !0
      }
    ],
    keyword: [
      {
        pattern: /((?:^|\})\s*)catch\b/,
        lookbehind: !0
      },
      {
        pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
        lookbehind: !0
      }
    ],
    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    number: {
      pattern: RegExp(
        /(^|[^\w$])/.source + "(?:" + // constant
        (/NaN|Infinity/.source + "|" + // binary integer
        /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
        /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
        /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
        /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
      ),
      lookbehind: !0
    },
    operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
  }), r.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, r.languages.insertBefore("javascript", "keyword", {
    regex: {
      pattern: RegExp(
        // lookbehind
        // eslint-disable-next-line regexp/no-dupe-characters-character-class
        /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
        // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
        // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
        // with the only syntax, so we have to define 2 different regex patterns.
        /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
        /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
        /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
      ),
      lookbehind: !0,
      greedy: !0,
      inside: {
        "regex-source": {
          pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
          lookbehind: !0,
          alias: "language-regex",
          inside: r.languages.regex
        },
        "regex-delimiter": /^\/|\/$/,
        "regex-flags": /^[a-z]+$/
      }
    },
    // This must be declared before keyword because we use "function" inside the look-forward
    "function-variable": {
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
      alias: "function"
    },
    parameter: [
      {
        pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
        lookbehind: !0,
        inside: r.languages.javascript
      },
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
        lookbehind: !0,
        inside: r.languages.javascript
      },
      {
        pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
        lookbehind: !0,
        inside: r.languages.javascript
      },
      {
        pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
        lookbehind: !0,
        inside: r.languages.javascript
      }
    ],
    constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
  }), r.languages.insertBefore("javascript", "string", {
    hashbang: {
      pattern: /^#!.*/,
      greedy: !0,
      alias: "comment"
    },
    "template-string": {
      pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
      greedy: !0,
      inside: {
        "template-punctuation": {
          pattern: /^`|`$/,
          alias: "string"
        },
        interpolation: {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
          lookbehind: !0,
          inside: {
            "interpolation-punctuation": {
              pattern: /^\$\{|\}$/,
              alias: "punctuation"
            },
            rest: r.languages.javascript
          }
        },
        string: /[\s\S]+/
      }
    },
    "string-property": {
      pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
      lookbehind: !0,
      greedy: !0,
      alias: "property"
    }
  }), r.languages.insertBefore("javascript", "operator", {
    "literal-property": {
      pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
      lookbehind: !0,
      alias: "property"
    }
  }), r.languages.markup && (r.languages.markup.tag.addInlined("script", "javascript"), r.languages.markup.tag.addAttribute(
    /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
    "javascript"
  )), r.languages.js = r.languages.javascript, function() {
    if (typeof r > "u" || typeof document > "u")
      return;
    Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector);
    var n = "Loadingâ€¦", i = function(g, m) {
      return "âœ– Error " + g + " while fetching file: " + m;
    }, s = "âœ– Error: File does not exist or is empty", o = {
      js: "javascript",
      py: "python",
      rb: "ruby",
      ps1: "powershell",
      psm1: "powershell",
      sh: "bash",
      bat: "batch",
      h: "c",
      tex: "latex"
    }, a = "data-src-status", l = "loading", c = "loaded", u = "failed", d = "pre[data-src]:not([" + a + '="' + c + '"]):not([' + a + '="' + l + '"])';
    function f(g, m, y) {
      var O = new XMLHttpRequest();
      O.open("GET", g, !0), O.onreadystatechange = function() {
        O.readyState == 4 && (O.status < 400 && O.responseText ? m(O.responseText) : O.status >= 400 ? y(i(O.status, O.statusText)) : y(s));
      }, O.send(null);
    }
    function h(g) {
      var m = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(g || "");
      if (m) {
        var y = Number(m[1]), O = m[2], b = m[3];
        return O ? b ? [y, Number(b)] : [y, void 0] : [y, y];
      }
    }
    r.hooks.add("before-highlightall", function(g) {
      g.selector += ", " + d;
    }), r.hooks.add("before-sanity-check", function(g) {
      var m = (
        /** @type {HTMLPreElement} */
        g.element
      );
      if (m.matches(d)) {
        g.code = "", m.setAttribute(a, l);
        var y = m.appendChild(document.createElement("CODE"));
        y.textContent = n;
        var O = m.getAttribute("data-src"), b = g.language;
        if (b === "none") {
          var w = (/\.(\w+)$/.exec(O) || [, "none"])[1];
          b = o[w] || w;
        }
        r.util.setLanguage(y, b), r.util.setLanguage(m, b);
        var S = r.plugins.autoloader;
        S && S.loadLanguages(b), f(
          O,
          function($) {
            m.setAttribute(a, c);
            var _ = h(m.getAttribute("data-range"));
            if (_) {
              var Q = $.split(/\r\n?|\n/g), N = _[0], B = _[1] == null ? Q.length : _[1];
              N < 0 && (N += Q.length), N = Math.max(0, Math.min(N - 1, Q.length)), B < 0 && (B += Q.length), B = Math.max(0, Math.min(B, Q.length)), $ = Q.slice(N, B).join(`
`), m.hasAttribute("data-start") || m.setAttribute("data-start", String(N + 1));
            }
            y.textContent = $, r.highlightElement(y);
          },
          function($) {
            m.setAttribute(a, u), y.textContent = $;
          }
        );
      }
    }), r.plugins.fileHighlight = {
      /**
       * Executes the File Highlight plugin for all matching `pre` elements under the given container.
       *
       * Note: Elements which are already loaded or currently loading will not be touched by this method.
       *
       * @param {ParentNode} [container=document]
       */
      highlight: function(m) {
        for (var y = (m || document).querySelectorAll(d), O = 0, b; b = y[O++]; )
          r.highlightElement(b);
      }
    };
    var p = !1;
    r.fileHighlight = function() {
      p || (console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead."), p = !0), r.plugins.fileHighlight.highlight.apply(this, arguments);
    };
  }();
})(U$);
var u9 = U$.exports;
const Y1 = /* @__PURE__ */ X$(u9);
(function() {
  try {
    if (typeof document < "u") {
      var t = document.createElement("style");
      t.appendChild(document.createTextNode(`.loader-wrapper:where(.scalar-component[data-v-42a08e16]),:where(.scalar-component) .loader-wrapper[data-v-42a08e16]{position:relative;height:var(--8d3a1414);width:var(--8d3a1414);display:flex;align-items:center;justify-content:center;--default-loader-size: 50%}.svg-loader:where(.scalar-component[data-v-42a08e16]),:where(.scalar-component) .svg-loader[data-v-42a08e16]{width:var(--loader-size, var(--default-loader-size));height:var(--loader-size, var(--default-loader-size));top:1rem;right:.9rem;overflow:visible;fill:none;background-color:transparent;stroke:currentColor}.svg-path:where(.scalar-component[data-v-42a08e16]),:where(.scalar-component) .svg-path[data-v-42a08e16]{stroke-width:14;fill:none;transition:.3s}.svg-x-mark:where(.scalar-component[data-v-42a08e16]),:where(.scalar-component) .svg-x-mark[data-v-42a08e16]{stroke-dasharray:57;stroke-dashoffset:57;transition-delay:0s}.svg-check-mark:where(.scalar-component[data-v-42a08e16]),:where(.scalar-component) .svg-check-mark[data-v-42a08e16]{stroke-dasharray:149;stroke-dashoffset:149;transition-delay:0s}.icon-is-invalid .svg-x-mark:where(.scalar-component[data-v-42a08e16]),:where(.scalar-component) .icon-is-invalid .svg-x-mark[data-v-42a08e16]{stroke-dashoffset:0;transition-delay:.3s}.icon-is-valid .svg-check-mark:where(.scalar-component[data-v-42a08e16]),:where(.scalar-component) .icon-is-valid .svg-check-mark[data-v-42a08e16]{stroke-dashoffset:0;transition-delay:.3s}.circular-loader:where(.scalar-component[data-v-42a08e16]),:where(.scalar-component) .circular-loader[data-v-42a08e16]{animation:rotate-42a08e16 .7s linear infinite,fade-in-42a08e16 .4s;transform-origin:center center;transform:scale(5);background:transparent}.loader-path:where(.scalar-component[data-v-42a08e16]),:where(.scalar-component) .loader-path[data-v-42a08e16]{stroke-dasharray:50,200;stroke-dashoffset:-100;stroke-linecap:round}.loader-path-off:where(.scalar-component[data-v-42a08e16]),:where(.scalar-component) .loader-path-off[data-v-42a08e16]{stroke-dasharray:50,200;stroke-dashoffset:-100;transition:opacity .3s;opacity:0}@keyframes fade-in-42a08e16{0%{opacity:0}70%{opacity:0}to{opacity:1}}@keyframes rotate-42a08e16{0%{transform:scale(5) rotate(0)}to{transform:scale(5) rotate(360deg)}}.scalar-codeblock-code[class*=language-]:where(.scalar-component),:where(.scalar-component) .scalar-codeblock-code[class*=language-],.scalar-codeblock-pre[class*=language-]:where(.scalar-component),:where(.scalar-component) .scalar-codeblock-pre[class*=language-]{color:var(--theme-color-3, var(--default-theme-color-2));background:none;font-family:var(--theme-font-code, var(--default-theme-font-code));font-size:var(--theme-small, var(--default-theme-small));text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.4;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;hyphens:none}.scalar-codeblock-pre[class*=language-]:where(.scalar-component),:where(.scalar-component) .scalar-codeblock-pre[class*=language-]{margin:0;padding:.5rem;overflow:auto}:not(pre)>code[class*=language-]:where(.scalar-component),:where(.scalar-component) :not(pre)>code[class*=language-],.scalar-codeblock-pre[class*=language-]:where(.scalar-component),:where(.scalar-component) .scalar-codeblock-pre[class*=language-]{background:var(--theme-background-2, var(--default-theme-background-2))}.line-numbers.scalar-codeblock-pre[class*=language-]{position:relative;padding-left:2em;counter-reset:linenumber}.line-numbers>code{position:relative;white-space:inherit}.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:0;font-size:100%;left:-3em;width:3em;letter-spacing:-1px;-webkit-user-select:none;-moz-user-select:none;user-select:none}.line-numbers-rows>span{display:block;counter-increment:linenumber}.line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}:not(pre)>code[class*=language-]:where(.scalar-component),:where(.scalar-component) :not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.comment:where(.scalar-component),:where(.scalar-component) .token.comment,.token.block-comment:where(.scalar-component),:where(.scalar-component) .token.block-comment,.token.prolog:where(.scalar-component),:where(.scalar-component) .token.prolog,.token.doctype:where(.scalar-component),:where(.scalar-component) .token.doctype,.token.cdata:where(.scalar-component),:where(.scalar-component) .token.cdata{color:var(--theme-color-2, var(--default-theme-color-2))}.token.punctuation:where(.scalar-component),:where(.scalar-component) .token.punctuation{color:var(--theme-color-3, var(--default-theme-color-3))}.token.tag:where(.scalar-component),:where(.scalar-component) .token.tag,.token.attr-name:where(.scalar-component),:where(.scalar-component) .token.attr-name,.token.namespace:where(.scalar-component),:where(.scalar-component) .token.namespace,.token.deleted:where(.scalar-component),:where(.scalar-component) .token.deleted{color:var(--theme-color-red, var(--default-theme-color-red))}.token.function-name:where(.scalar-component),:where(.scalar-component) .token.function-name{color:var(--theme-color-green, var(--default-theme-color-green))}.token.boolean:where(.scalar-component),:where(.scalar-component) .token.boolean,.token.number:where(.scalar-component),:where(.scalar-component) .token.number,.token.function:where(.scalar-component),:where(.scalar-component) .token.function{color:var(--theme-color-orange, var(--default-theme-color-orange))}.token.property:where(.scalar-component),:where(.scalar-component) .token.property,.token.class-name:where(.scalar-component),:where(.scalar-component) .token.class-name,.token.constant:where(.scalar-component),:where(.scalar-component) .token.constant,.token.symbol:where(.scalar-component),:where(.scalar-component) .token.symbol{color:var(--theme-color-1, var(--default-theme-color-1))}.token.selector:where(.scalar-component),:where(.scalar-component) .token.selector,.token.important:where(.scalar-component),:where(.scalar-component) .token.important,.token.atrule:where(.scalar-component),:where(.scalar-component) .token.atrule,.token.keyword:where(.scalar-component),:where(.scalar-component) .token.keyword,.token.builtin:where(.scalar-component),:where(.scalar-component) .token.builtin{color:var(--theme-color-purple, var(--default-theme-color-purple))}.token.string:where(.scalar-component),:where(.scalar-component) .token.string,.token.char:where(.scalar-component),:where(.scalar-component) .token.char,.token.attr-value:where(.scalar-component),:where(.scalar-component) .token.attr-value,.token.regex:where(.scalar-component),:where(.scalar-component) .token.regex,.token.variable:where(.scalar-component),:where(.scalar-component) .token.variable{color:var(--theme-color-blue, var(--default-theme-color-blue))}.light-mode .dark-mode .language-shell .token.variable:where(.scalar-component),:where(.scalar-component) .light-mode .dark-mode .language-shell .token.variable{color:var(--theme-color-1, var(--default-theme-color-1))}.light-mode .dark-mode .language-shell .token.string:where(.scalar-component),:where(.scalar-component) .light-mode .dark-mode .language-shell .token.string{color:var(--theme-color-blue, var(--default-theme-color-blue))}.language-shell .token.string:where(.scalar-component),:where(.scalar-component) .language-shell .token.string{color:var(--theme-color-1, var(--default-theme-color-1))}.token.operator:where(.scalar-component),:where(.scalar-component) .token.operator,.token.entity:where(.scalar-component),:where(.scalar-component) .token.entity,.token.url:where(.scalar-component),:where(.scalar-component) .token.url{color:var(--theme-color-3, var(--default-theme-color-3))}.token.important:where(.scalar-component),:where(.scalar-component) .token.important,.token.bold:where(.scalar-component),:where(.scalar-component) .token.bold{font-weight:700}.token.italic:where(.scalar-component),:where(.scalar-component) .token.italic{font-style:italic}.token.entity:where(.scalar-component),:where(.scalar-component) .token.entity{cursor:help}.token.inserted:where(.scalar-component),:where(.scalar-component) .token.inserted{color:var(--theme-color-green, var(--default-theme-color-green))}.credentials:where(.scalar-component),:where(.scalar-component) .credentials{font-size:0;color:transparent}.credentials:after:where(.scalar-component),:where(.scalar-component) .credentials:after{content:"Â·Â·Â·Â·Â·";font-size:var(--theme-small, var(--default-theme-small));color:var(--theme-color-3, var(--default-theme-color-3))}.scalar-modal-layout:where(.scalar-component[data-v-ff85ced0]),:where(.scalar-component) .scalar-modal-layout[data-v-ff85ced0]{animation:modal-fade-ff85ced0 .2s forwards}.scalar-modal:where(.scalar-component[data-v-ff85ced0]),:where(.scalar-component) .scalar-modal[data-v-ff85ced0]{transform:scale(.98);animation:modal-pop-ff85ced0 .15s .15s forwards}@keyframes modal-fade-ff85ced0{0%{opacity:0}to{opacity:1}}@keyframes modal-pop-ff85ced0{0%{opacity:0}to{opacity:1;transform:scale(1)}}.scalar-input-wrapper-focus .scalar-input-label:where(.scalar-component[data-v-4717ec50]),:where(.scalar-component) .scalar-input-wrapper-focus .scalar-input-label[data-v-4717ec50]{color:var(--theme-color-1, var(--default-theme-color-1))}.scalar-input-wrapper-error .scalar-input-label:where(.scalar-component[data-v-4717ec50]),:where(.scalar-component) .scalar-input-wrapper-error .scalar-input-label[data-v-4717ec50]{color:var(--theme-color-error-color, var(--default-theme-color-red))}.scalar-input::-moz-selection:where(.scalar-component[data-v-4717ec50]),:where(.scalar-component) .scalar-input[data-v-4717ec50]::-moz-selection{color:var(--theme-color-1, var(--default-theme-color-1));background:#ffa55859}.scalar-input::selection:where(.scalar-component[data-v-4717ec50]),:where(.scalar-component) .scalar-input[data-v-4717ec50]::selection{color:var(--theme-color-1, var(--default-theme-color-1));background:#ffa55859}.scalar-input:has(+.scalar-input-label):where(.scalar-component[data-v-4717ec50]),:where(.scalar-component) .scalar-input[data-v-4717ec50]:has(+.scalar-input-label){opacity:0}.scalar-input:not(:-moz-placeholder-shown):where(.scalar-component[data-v-4717ec50]),:where(.scalar-component) .scalar-input[data-v-4717ec50]:not(:-moz-placeholder-shown){opacity:1;-moz-transition:opacity .2s ease-in-out .15s;transition:opacity .2s ease-in-out .15s}.scalar-input:not(:placeholder-shown):where(.scalar-component[data-v-4717ec50]),:where(.scalar-component) .scalar-input[data-v-4717ec50]:not(:placeholder-shown),.scalar-input-wrapper-focus .scalar-input:where(.scalar-component[data-v-4717ec50]),:where(.scalar-component) .scalar-input-wrapper-focus .scalar-input[data-v-4717ec50]{opacity:1;transition:opacity .2s ease-in-out .15s}.scalar-input:-webkit-autofill:where(.scalar-component[data-v-4717ec50]),:where(.scalar-component) .scalar-input[data-v-4717ec50]:-webkit-autofill,.scalar-input:-webkit-autofill:hover:where(.scalar-component[data-v-4717ec50]),:where(.scalar-component) .scalar-input[data-v-4717ec50]:-webkit-autofill:hover,.scalar-input:-webkit-autofill:focus:where(.scalar-component[data-v-4717ec50]),:where(.scalar-component) .scalar-input[data-v-4717ec50]:-webkit-autofill:focus,.scalar-input:-webkit-autofill:active:where(.scalar-component[data-v-4717ec50]),:where(.scalar-component) .scalar-input[data-v-4717ec50]:-webkit-autofill:active,.scalar-input:focus-within:-webkit-autofill:where(.scalar-component[data-v-4717ec50]),:where(.scalar-component) .scalar-input[data-v-4717ec50]:focus-within:-webkit-autofill,.scalar-input:focus-within:-webkit-autofill:hover:where(.scalar-component[data-v-4717ec50]),:where(.scalar-component) .scalar-input[data-v-4717ec50]:focus-within:-webkit-autofill:hover,.scalar-input:focus-within:-webkit-autofill:focus:where(.scalar-component[data-v-4717ec50]),:where(.scalar-component) .scalar-input[data-v-4717ec50]:focus-within:-webkit-autofill:focus,.scalar-input:focus-within:-webkit-autofill:active:where(.scalar-component[data-v-4717ec50]),:where(.scalar-component) .scalar-input[data-v-4717ec50]:focus-within:-webkit-autofill:active{-webkit-box-shadow:0 0 0px 1000px var(--theme-background-1, var(--default-theme-background-1)) inset!important;-webkit-text-fill-color:var(--theme-color-1, var(--default-theme-color-1));color:var(--theme-color-1, var(--default-theme-color-1));border-radius:var(--theme-radius, var(--default-theme-radius))}.scalar-input:not(:-moz-placeholder-shown)+.scalar-input-label:where(.scalar-component[data-v-4717ec50]),:where(.scalar-component) .scalar-input:not(:-moz-placeholder-shown)+.scalar-input-label[data-v-4717ec50]{transform:translate3d(0,-20px,0) scale(.8);transform-origin:top left}.scalar-input-wrapper-focus .scalar-input-label:where(.scalar-component[data-v-4717ec50]),:where(.scalar-component) .scalar-input-wrapper-focus .scalar-input-label[data-v-4717ec50],.scalar-input:not(:placeholder-shown)+.scalar-input-label:where(.scalar-component[data-v-4717ec50]),:where(.scalar-component) .scalar-input:not(:placeholder-shown)+.scalar-input-label[data-v-4717ec50]{transform:translate3d(0,-20px,0) scale(.8);transform-origin:top left}.scalar-input-wrapper-focus:has(button:active) .scalar-input-label:where(.scalar-component[data-v-4717ec50]),:where(.scalar-component) .scalar-input-wrapper-focus:has(button:active) .scalar-input-label[data-v-4717ec50]{color:var(--theme-color-3, var(--default-theme-color-3))!important}:where(.scalar-component),:where(.scalar-component) *{box-sizing:border-box;border-width:unset;border-style:unset;border-color:currentColor;font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:unset;font-weight:inherit;line-height:inherit;color:inherit;margin:unset;padding:unset}:where(.scalar-component),:where(.scalar-component) *,:before:where(.scalar-component),:where(.scalar-component) :before,:after:where(.scalar-component),:where(.scalar-component) :after{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::backdrop:where(.scalar-component),:where(.scalar-component) ::backdrop{--tw-border-spacing-x: 0;--tw-border-spacing-y: 0;--tw-translate-x: 0;--tw-translate-y: 0;--tw-rotate: 0;--tw-skew-x: 0;--tw-skew-y: 0;--tw-scale-x: 1;--tw-scale-y: 1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness: proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width: 0px;--tw-ring-offset-color: #fff;--tw-ring-color: rgb(59 130 246 / .5);--tw-ring-offset-shadow: 0 0 #0000;--tw-ring-shadow: 0 0 #0000;--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }.sr-only:where(.scalar-component),:where(.scalar-component) .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0}.pointer-events-none:where(.scalar-component),:where(.scalar-component) .pointer-events-none{pointer-events:none}.visible:where(.scalar-component),:where(.scalar-component) .visible{visibility:visible}.fixed:where(.scalar-component),:where(.scalar-component) .fixed{position:fixed}.absolute:where(.scalar-component),:where(.scalar-component) .absolute{position:absolute}.relative:where(.scalar-component),:where(.scalar-component) .relative{position:relative}.left-0:where(.scalar-component),:where(.scalar-component) .left-0{left:0}.top-0:where(.scalar-component),:where(.scalar-component) .top-0{top:0}.z-10:where(.scalar-component),:where(.scalar-component) .z-10{z-index:10}.z-\\[1001\\]:where(.scalar-component),:where(.scalar-component) .z-\\[1001\\]{z-index:1001}.m-0:where(.scalar-component),:where(.scalar-component) .m-0{margin:0}.mx-2:where(.scalar-component),:where(.scalar-component) .mx-2{margin-left:8px;margin-right:8px}.mx-auto:where(.scalar-component),:where(.scalar-component) .mx-auto{margin-left:auto;margin-right:auto}.my-3:where(.scalar-component),:where(.scalar-component) .my-3{margin-top:12px;margin-bottom:12px}.mb-0:where(.scalar-component),:where(.scalar-component) .mb-0{margin-bottom:0}.ml-2:where(.scalar-component),:where(.scalar-component) .ml-2{margin-left:8px}.mr-2:where(.scalar-component),:where(.scalar-component) .mr-2{margin-right:8px}.mt-1:where(.scalar-component),:where(.scalar-component) .mt-1{margin-top:4px}.mt-1\\.5:where(.scalar-component),:where(.scalar-component) .mt-1\\.5{margin-top:6px}.mt-20:where(.scalar-component),:where(.scalar-component) .mt-20{margin-top:80px}.block:where(.scalar-component),:where(.scalar-component) .block{display:block}.flex:where(.scalar-component),:where(.scalar-component) .flex{display:flex}.grid:where(.scalar-component),:where(.scalar-component) .grid{display:grid}.hidden:where(.scalar-component),:where(.scalar-component) .hidden{display:none}.aspect-square:where(.scalar-component),:where(.scalar-component) .aspect-square{aspect-ratio:1 / 1}.h-10:where(.scalar-component),:where(.scalar-component) .h-10{height:40px}.h-3:where(.scalar-component),:where(.scalar-component) .h-3{height:12px}.h-3\\.5:where(.scalar-component),:where(.scalar-component) .h-3\\.5{height:14px}.h-4:where(.scalar-component),:where(.scalar-component) .h-4{height:16px}.h-5:where(.scalar-component),:where(.scalar-component) .h-5{height:20px}.h-6:where(.scalar-component),:where(.scalar-component) .h-6{height:24px}.h-\\[100dvh\\]:where(.scalar-component),:where(.scalar-component) .h-\\[100dvh\\]{height:100dvh}.h-full:where(.scalar-component),:where(.scalar-component) .h-full{height:100%}.max-h-\\[440px\\]:where(.scalar-component),:where(.scalar-component) .max-h-\\[440px\\]{max-height:440px}.max-h-\\[calc\\(100dvh-240px\\)\\]:where(.scalar-component),:where(.scalar-component) .max-h-\\[calc\\(100dvh-240px\\)\\]{max-height:calc(100dvh - 240px)}.min-h-\\[77px\\]:where(.scalar-component),:where(.scalar-component) .min-h-\\[77px\\]{min-height:77px}.w-10:where(.scalar-component),:where(.scalar-component) .w-10{width:40px}.w-3:where(.scalar-component),:where(.scalar-component) .w-3{width:12px}.w-3\\.5:where(.scalar-component),:where(.scalar-component) .w-3\\.5{width:14px}.w-4:where(.scalar-component),:where(.scalar-component) .w-4{width:16px}.w-5:where(.scalar-component),:where(.scalar-component) .w-5{width:20px}.w-6:where(.scalar-component),:where(.scalar-component) .w-6{width:24px}.w-\\[100dvw\\]:where(.scalar-component),:where(.scalar-component) .w-\\[100dvw\\]{width:100dvw}.w-full:where(.scalar-component),:where(.scalar-component) .w-full{width:100%}.max-w-screen-lg:where(.scalar-component),:where(.scalar-component) .max-w-screen-lg{max-width:800px}.max-w-screen-md:where(.scalar-component),:where(.scalar-component) .max-w-screen-md{max-width:640px}.max-w-screen-sm:where(.scalar-component),:where(.scalar-component) .max-w-screen-sm{max-width:540px}.max-w-screen-xs:where(.scalar-component),:where(.scalar-component) .max-w-screen-xs{max-width:480px}.origin-top-left:where(.scalar-component),:where(.scalar-component) .origin-top-left{transform-origin:top left}.transform:where(.scalar-component),:where(.scalar-component) .transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.cursor-not-allowed:where(.scalar-component),:where(.scalar-component) .cursor-not-allowed{cursor:not-allowed}.cursor-pointer:where(.scalar-component),:where(.scalar-component) .cursor-pointer{cursor:pointer}.resize-none:where(.scalar-component),:where(.scalar-component) .resize-none{resize:none}.appearance-none:where(.scalar-component),:where(.scalar-component) .appearance-none{-webkit-appearance:none;-moz-appearance:none;appearance:none}.items-start:where(.scalar-component),:where(.scalar-component) .items-start{align-items:flex-start}.items-center:where(.scalar-component),:where(.scalar-component) .items-center{align-items:center}.justify-center:where(.scalar-component),:where(.scalar-component) .justify-center{justify-content:center}.gap-1:where(.scalar-component),:where(.scalar-component) .gap-1{gap:4px}.gap-4:where(.scalar-component),:where(.scalar-component) .gap-4{gap:16px}.overflow-hidden:where(.scalar-component),:where(.scalar-component) .overflow-hidden{overflow:hidden}.overflow-y-auto:where(.scalar-component),:where(.scalar-component) .overflow-y-auto{overflow-y:auto}.rounded:where(.scalar-component),:where(.scalar-component) .rounded{border-radius:var(--theme-radius, var(--default-theme-radius))}.rounded-lg:where(.scalar-component),:where(.scalar-component) .rounded-lg{border-radius:var(--theme-radius-lg, var(--default-theme-radius-lg))}.border:where(.scalar-component),:where(.scalar-component) .border{border-width:1px}.border-0:where(.scalar-component),:where(.scalar-component) .border-0{border-width:0px}.border-solid:where(.scalar-component),:where(.scalar-component) .border-solid{border-style:solid}.border-border:where(.scalar-component),:where(.scalar-component) .border-border{border-color:var(--theme-border-color, var(--default-theme-border-color))}.border-error:where(.scalar-component),:where(.scalar-component) .border-error{border-color:var(--theme-error-color, var(--default-theme-color-red))}.border-fore-3:where(.scalar-component),:where(.scalar-component) .border-fore-3{border-color:var(--theme-color-3, var(--default-theme-color-3))}.bg-back-1:where(.scalar-component),:where(.scalar-component) .bg-back-1{background-color:var(--theme-background-1, var(--default-theme-background-1))}.bg-back-2:where(.scalar-component),:where(.scalar-component) .bg-back-2{background-color:var(--theme-background-2, var(--default-theme-background-2))}.bg-back-btn-1:where(.scalar-component),:where(.scalar-component) .bg-back-btn-1{background-color:var(--theme-button-1, var(--default-theme-button-1))}.bg-backdrop:where(.scalar-component),:where(.scalar-component) .bg-backdrop{background-color:#00000070}.bg-error:where(.scalar-component),:where(.scalar-component) .bg-error{background-color:var(--theme-error-color, var(--default-theme-color-red))}.bg-transparent:where(.scalar-component),:where(.scalar-component) .bg-transparent{background-color:transparent}.p-0:where(.scalar-component),:where(.scalar-component) .p-0{padding:0}.p-0\\.5:where(.scalar-component),:where(.scalar-component) .p-0\\.5{padding:2px}.p-1:where(.scalar-component),:where(.scalar-component) .p-1{padding:4px}.p-3:where(.scalar-component),:where(.scalar-component) .p-3{padding:12px}.p-5:where(.scalar-component),:where(.scalar-component) .p-5{padding:20px}.px-1:where(.scalar-component),:where(.scalar-component) .px-1{padding-left:4px;padding-right:4px}.px-4:where(.scalar-component),:where(.scalar-component) .px-4{padding-left:16px;padding-right:16px}.px-6:where(.scalar-component),:where(.scalar-component) .px-6{padding-left:24px;padding-right:24px}.px-9:where(.scalar-component),:where(.scalar-component) .px-9{padding-left:36px;padding-right:36px}.py-1:where(.scalar-component),:where(.scalar-component) .py-1{padding-top:4px;padding-bottom:4px}.py-3:where(.scalar-component),:where(.scalar-component) .py-3{padding-top:12px;padding-bottom:12px}.pb-0:where(.scalar-component),:where(.scalar-component) .pb-0{padding-bottom:0}.pb-4:where(.scalar-component),:where(.scalar-component) .pb-4{padding-bottom:16px}.pl-9:where(.scalar-component),:where(.scalar-component) .pl-9{padding-left:36px}.pr-3:where(.scalar-component),:where(.scalar-component) .pr-3{padding-right:12px}.pt-3:where(.scalar-component),:where(.scalar-component) .pt-3{padding-top:12px}.pt-6:where(.scalar-component),:where(.scalar-component) .pt-6{padding-top:24px}.text-left:where(.scalar-component),:where(.scalar-component) .text-left{text-align:left}.text-sm:where(.scalar-component),:where(.scalar-component) .text-sm{font-size:var(--theme-small, var(--default-theme-small, var(--theme-font-size-3, var(--default-theme-font-size-3))))}.text-xs:where(.scalar-component),:where(.scalar-component) .text-xs{font-size:var(--theme-mini, var(--default-theme-mini, var(--theme-font-size-4, var(--default-theme-font-size-4))))}.font-medium:where(.scalar-component),:where(.scalar-component) .font-medium{font-weight:var(--theme-font-medium, var(--default-theme-font-medium))}.font-normal:where(.scalar-component),:where(.scalar-component) .font-normal{font-weight:400}.italic:where(.scalar-component),:where(.scalar-component) .italic{font-style:italic}.text-error:where(.scalar-component),:where(.scalar-component) .text-error{color:var(--theme-error-color, var(--default-theme-color-red))}.text-fore-1:where(.scalar-component),:where(.scalar-component) .text-fore-1{color:var(--theme-color-1, var(--default-theme-color-1))}.text-fore-3:where(.scalar-component),:where(.scalar-component) .text-fore-3{color:var(--theme-color-3, var(--default-theme-color-3))}.text-fore-btn-1:where(.scalar-component),:where(.scalar-component) .text-fore-btn-1{color:var(--theme-button-1-color, var(--default-theme-button-1-color))}.text-ghost:where(.scalar-component),:where(.scalar-component) .text-ghost{color:var(--theme-color-ghost, var(--default-theme-color-ghost))}.text-white:where(.scalar-component),:where(.scalar-component) .text-white{--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}.opacity-0:where(.scalar-component),:where(.scalar-component) .opacity-0{opacity:0}.shadow-none:where(.scalar-component),:where(.scalar-component) .shadow-none{--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.shadow-sm:where(.scalar-component),:where(.scalar-component) .shadow-sm{--tw-shadow: rgba(0, 0, 0, .09) 0px 1px 4px;--tw-shadow-colored: 0px 1px 4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.outline-none:where(.scalar-component),:where(.scalar-component) .outline-none{outline:2px solid transparent;outline-offset:2px}.outline:where(.scalar-component),:where(.scalar-component) .outline{outline-style:solid}.blur:where(.scalar-component),:where(.scalar-component) .blur{--tw-blur: blur(8px);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.filter:where(.scalar-component),:where(.scalar-component) .filter{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.transition:where(.scalar-component),:where(.scalar-component) .transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,-webkit-backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter,-webkit-backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-opacity:where(.scalar-component),:where(.scalar-component) .transition-opacity{transition-property:opacity;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.transition-transform:where(.scalar-component),:where(.scalar-component) .transition-transform{transition-property:transform;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.ease-in-out:where(.scalar-component),:where(.scalar-component) .ease-in-out{transition-timing-function:cubic-bezier(.4,0,.2,1)}.row:where(.scalar-component),:where(.scalar-component) .row{display:flex;flex-direction:row}.col:where(.scalar-component),:where(.scalar-component) .col{display:flex;flex-direction:column}.before\\:mr-1:before:where(.scalar-component),:where(.scalar-component) .before\\:mr-1:before{content:var(--tw-content);margin-right:4px}.before\\:mr-1\\.5:before:where(.scalar-component),:where(.scalar-component) .before\\:mr-1\\.5:before{content:var(--tw-content);margin-right:6px}.before\\:block:before:where(.scalar-component),:where(.scalar-component) .before\\:block:before{content:var(--tw-content);display:block}.before\\:h-4:before:where(.scalar-component),:where(.scalar-component) .before\\:h-4:before{content:var(--tw-content);height:16px}.before\\:w-4:before:where(.scalar-component),:where(.scalar-component) .before\\:w-4:before{content:var(--tw-content);width:16px}.before\\:bg-error:before:where(.scalar-component),:where(.scalar-component) .before\\:bg-error:before{content:var(--tw-content);background-color:var(--theme-error-color, var(--default-theme-color-red))}.before\\:text-center:before:where(.scalar-component),:where(.scalar-component) .before\\:text-center:before{content:var(--tw-content);text-align:center}.before\\:text-xxs:before:where(.scalar-component),:where(.scalar-component) .before\\:text-xxs:before{content:var(--tw-content);font-size:var(--theme-micro, var(--default-theme-micro, var(--theme-font-size-5, var(--default-theme-font-size-5))))}.before\\:font-black:before:where(.scalar-component),:where(.scalar-component) .before\\:font-black:before{content:var(--tw-content);font-weight:900}.before\\:leading-4:before:where(.scalar-component),:where(.scalar-component) .before\\:leading-4:before{content:var(--tw-content);line-height:16px}.before\\:text-white:before:where(.scalar-component),:where(.scalar-component) .before\\:text-white:before{content:var(--tw-content);--tw-text-opacity: 1;color:rgb(255 255 255 / var(--tw-text-opacity))}.before\\:content-\\[\\'\\!\\'\\]:before:where(.scalar-component),:where(.scalar-component) .before\\:content-\\[\\'\\!\\'\\]:before{--tw-content: "!";content:var(--tw-content)}.empty\\:hidden:empty:where(.scalar-component),:where(.scalar-component) .empty\\:hidden:empty{display:none}.hover\\:text-fore-1:hover:where(.scalar-component),:where(.scalar-component) .hover\\:text-fore-1:hover{color:var(--theme-color-1, var(--default-theme-color-1))}.active\\:bg-back-btn-1:active:where(.scalar-component),:where(.scalar-component) .active\\:bg-back-btn-1:active{background-color:var(--theme-button-1, var(--default-theme-button-1))}.active\\:text-fore-2:active:where(.scalar-component),:where(.scalar-component) .active\\:text-fore-2:active{color:var(--theme-color-2, var(--default-theme-color-2))}.active\\:shadow-none:active:where(.scalar-component),:where(.scalar-component) .active\\:shadow-none:active{--tw-shadow: 0 0 #0000;--tw-shadow-colored: 0 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}.active\\:brightness-90:active:where(.scalar-component),:where(.scalar-component) .active\\:brightness-90:active{--tw-brightness: brightness(.9);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.has-actv-btn\\:border:has(button:active):where(.scalar-component),:where(.scalar-component) .has-actv-btn\\:border:has(button:active){border-width:1px}.has-actv-btn\\:border-border:has(button:active):where(.scalar-component),:where(.scalar-component) .has-actv-btn\\:border-border:has(button:active){border-color:var(--theme-border-color, var(--default-theme-border-color))}.\\!empty\\:flex:not(:empty):where(.scalar-component),:where(.scalar-component) .\\!empty\\:flex:not(:empty){display:flex}.\\!empty\\:w-7:not(:empty):where(.scalar-component),:where(.scalar-component) .\\!empty\\:w-7:not(:empty){width:28px}.\\!empty\\:items-center:not(:empty):where(.scalar-component),:where(.scalar-component) .\\!empty\\:items-center:not(:empty){align-items:center}.\\!empty\\:pr-3:not(:empty):where(.scalar-component),:where(.scalar-component) .\\!empty\\:pr-3:not(:empty){padding-right:12px}.hocus\\:bg-back-2:hover:where(.scalar-component),:where(.scalar-component) .hocus\\:bg-back-2:hover{background-color:var(--theme-background-2, var(--default-theme-background-2))}.hocus\\:bg-hover-btn-1:hover:where(.scalar-component),:where(.scalar-component) .hocus\\:bg-hover-btn-1:hover{background-color:var(--theme-button-1-hover, var(--default-theme-button-1-hover))}.hocus\\:text-fore-2:hover:where(.scalar-component),:where(.scalar-component) .hocus\\:text-fore-2:hover{color:var(--theme-color-2, var(--default-theme-color-2))}.hocus\\:brightness-90:hover:where(.scalar-component),:where(.scalar-component) .hocus\\:brightness-90:hover{--tw-brightness: brightness(.9);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.hocus\\:bg-back-2:focus-visible:where(.scalar-component),:where(.scalar-component) .hocus\\:bg-back-2:focus-visible{background-color:var(--theme-background-2, var(--default-theme-background-2))}.hocus\\:bg-hover-btn-1:focus-visible:where(.scalar-component),:where(.scalar-component) .hocus\\:bg-hover-btn-1:focus-visible{background-color:var(--theme-button-1-hover, var(--default-theme-button-1-hover))}.hocus\\:text-fore-2:focus-visible:where(.scalar-component),:where(.scalar-component) .hocus\\:text-fore-2:focus-visible{color:var(--theme-color-2, var(--default-theme-color-2))}.hocus\\:brightness-90:focus-visible:where(.scalar-component),:where(.scalar-component) .hocus\\:brightness-90:focus-visible{--tw-brightness: brightness(.9);filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}@media (min-width: 768px){.md\\:row:where(.scalar-component),:where(.scalar-component) .md\\:row{display:flex;flex-direction:row}}`)), document.head.appendChild(t);
    }
  } catch (e) {
    console.error("vite-plugin-css-injected-by-js", e);
  }
})();
const ep = "scalar-component", d9 = c9({
  extend: {
    classGroups: {
      // Add the scalar class prefix as a custom class to be deduped by tailwind-merge
      [ep]: [ep]
    }
  }
}), { cva: Um, cx: ld, compose: qre } = QA({
  hooks: {
    onComplete: (t) => `${d9(t, ep)}`
  }
}), f9 = /* @__PURE__ */ gs('<path class="svg-path svg-check-mark" d="m 0 60 l 30 30 l 70 -80" data-v-42a08e16></path><path class="svg-path svg-x-mark" d="m 50 50 l 40 -40" data-v-42a08e16></path><path class="svg-path svg-x-mark" d="m 50 50 l 40 40" data-v-42a08e16></path><path class="svg-path svg-x-mark" d="m 50 50 l -40 -40" data-v-42a08e16></path><path class="svg-path svg-x-mark" d="m 50 50 l -40 40" data-v-42a08e16></path>', 5), h9 = {
  key: 0,
  class: "circular-loader"
}, p9 = /* @__PURE__ */ G({
  __name: "ScalarLoading",
  props: {
    loadingState: {},
    size: { default: "24px" }
  },
  setup(t) {
    return J5((e) => ({
      "8d3a1414": e.size
    })), (e, r) => e.loadingState ? (k(), C("div", {
      key: 0,
      class: $e(v(ld)("loader-wrapper"))
    }, [
      (k(), C("svg", {
        class: $e(["svg-loader", {
          "icon-is-valid": e.loadingState.isValid,
          "icon-is-invalid": e.loadingState.isInvalid
        }]),
        viewBox: "0 0 100 100",
        xmlns: "http://www.w3.org/2000/svg",
        "xmlns:xlink": "http://www.w3.org/1999/xlink"
      }, [
        f9,
        e.loadingState.isLoading ? (k(), C("g", h9, [
          x("circle", {
            class: $e(["loader-path", {
              "loader-path-off": e.loadingState.isValid || e.loadingState.isInvalid
            }]),
            cx: "50",
            cy: "50",
            fill: "none",
            r: "20",
            "stroke-width": "2"
          }, null, 2)
        ])) : H("", !0)
      ], 2))
    ], 2)) : H("", !0);
  }
}), m9 = (t, e) => {
  const r = t.__vccOpts || t;
  for (const [n, i] of e)
    r[n] = i;
  return r;
}, g9 = /* @__PURE__ */ m9(p9, [["__scopeId", "data-v-42a08e16"]]), V$ = {
  solid: [
    "scalar-button-solid",
    "bg-back-btn-1 text-fore-btn-1 shadow-sm active:bg-back-btn-1 active:shadow-none hocus:bg-hover-btn-1"
  ],
  outlined: [
    "scalar-button-outlined",
    "active:bg-btn-1 border border-solid border-border bg-transparent text-fore-1 hocus:bg-back-2"
  ],
  ghost: [
    "scalar-button-ghost",
    "bg-transparent text-fore-3 active:text-fore-2 hocus:text-fore-2"
  ],
  danger: [
    "scalar-button-danger",
    "bg-error text-white active:brightness-90 hocus:brightness-90"
  ]
}, O9 = Um({
  base: "scalar-button row cursor-pointer items-center justify-center rounded font-medium",
  variants: {
    disabled: {
      true: "bg-background-2 text-color-3 cursor-not-allowed shadow-none"
    },
    fullWidth: { true: "w-full" },
    size: { md: "h-10 px-6 text-sm" },
    variant: V$
  },
  compoundVariants: [
    {
      disabled: !0,
      variant: "ghost",
      class: "bg-transparent text-ghost"
    }
  ]
}), y9 = ["ariaDisabled"], b9 = {
  key: 0,
  class: "mr-2 h-4 w-4"
}, v9 = {
  key: 1,
  class: "ml-2"
}, B1 = /* @__PURE__ */ G({
  inheritAttrs: !1,
  __name: "ScalarButton",
  props: {
    disabled: { type: Boolean },
    fullWidth: { type: Boolean, default: !1 },
    loading: {},
    size: { default: "md" },
    variant: { default: "solid" }
  },
  setup(t) {
    const e = fe(() => {
      const { class: r, ...n } = K5();
      return { className: r || "", rest: n };
    });
    return (r, n) => (k(), C("button", Bp(e.value.rest, {
      ariaDisabled: r.disabled || void 0,
      class: v(ld)(
        v(O9)({ fullWidth: r.fullWidth, disabled: r.disabled, size: r.size, variant: r.variant }),
        { "pl-9 pr-3": r.loading },
        `${e.value.className}`
      ),
      type: "button"
    }), [
      r.$slots.icon ? (k(), C("div", b9, [
        se(r.$slots, "icon")
      ])) : H("", !0),
      se(r.$slots, "default"),
      r.loading ? (k(), C("div", v9, [
        Z(v(g9), {
          loadingState: r.loading,
          size: "20px"
        }, null, 8, ["loadingState"])
      ])) : H("", !0)
    ], 16, y9));
  }
});
(function(t) {
  var e = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b", r = {
    pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
    lookbehind: !0,
    alias: "punctuation",
    // this looks reasonably well in all themes
    inside: null
    // see below
  }, n = {
    bash: r,
    environment: {
      pattern: RegExp("\\$" + e),
      alias: "constant"
    },
    variable: [
      // [0]: Arithmetic Environment
      {
        pattern: /\$?\(\([\s\S]+?\)\)/,
        greedy: !0,
        inside: {
          // If there is a $ sign at the beginning highlight $(( and )) as variable
          variable: [
            {
              pattern: /(^\$\(\([\s\S]+)\)\)/,
              lookbehind: !0
            },
            /^\$\(\(/
          ],
          number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
          // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
          operator: /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
          // If there is no $ sign at the beginning highlight (( and )) as punctuation
          punctuation: /\(\(?|\)\)?|,|;/
        }
      },
      // [1]: Command Substitution
      {
        pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
        greedy: !0,
        inside: {
          variable: /^\$\(|^`|\)$|`$/
        }
      },
      // [2]: Brace expansion
      {
        pattern: /\$\{[^}]+\}/,
        greedy: !0,
        inside: {
          operator: /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
          punctuation: /[\[\]]/,
          environment: {
            pattern: RegExp("(\\{)" + e),
            lookbehind: !0,
            alias: "constant"
          }
        }
      },
      /\$(?:\w+|[#?*!@$])/
    ],
    // Escape sequences from echo and printf's manuals, and escaped quotes.
    entity: /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
  };
  t.languages.bash = {
    shebang: {
      pattern: /^#!\s*\/.*/,
      alias: "important"
    },
    comment: {
      pattern: /(^|[^"{\\$])#.*/,
      lookbehind: !0
    },
    "function-name": [
      // a) function foo {
      // b) foo() {
      // c) function foo() {
      // but not â€œfoo {â€
      {
        // a) and c)
        pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
        lookbehind: !0,
        alias: "function"
      },
      {
        // b)
        pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
        alias: "function"
      }
    ],
    // Highlight variable names as variables in for and select beginnings.
    "for-or-select": {
      pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
      alias: "variable",
      lookbehind: !0
    },
    // Highlight variable names as variables in the left-hand part
    // of assignments (â€œ=â€ and â€œ+=â€).
    "assign-left": {
      pattern: /(^|[\s;|&]|[<>]\()\w+(?:\.\w+)*(?=\+?=)/,
      inside: {
        environment: {
          pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + e),
          lookbehind: !0,
          alias: "constant"
        }
      },
      alias: "variable",
      lookbehind: !0
    },
    // Highlight parameter names as variables
    parameter: {
      pattern: /(^|\s)-{1,2}(?:\w+:[+-]?)?\w+(?:\.\w+)*(?=[=\s]|$)/,
      alias: "variable",
      lookbehind: !0
    },
    string: [
      // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
      {
        pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
        lookbehind: !0,
        greedy: !0,
        inside: n
      },
      // Here-document with quotes around the tag
      // â†’ No expansion (so no â€œinsideâ€).
      {
        pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
        lookbehind: !0,
        greedy: !0,
        inside: {
          bash: r
        }
      },
      // â€œNormalâ€ string
      {
        // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
        pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
        lookbehind: !0,
        greedy: !0,
        inside: n
      },
      {
        // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
        pattern: /(^|[^$\\])'[^']*'/,
        lookbehind: !0,
        greedy: !0
      },
      {
        // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
        pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
        greedy: !0,
        inside: {
          entity: n.entity
        }
      }
    ],
    environment: {
      pattern: RegExp("\\$?" + e),
      alias: "constant"
    },
    variable: n.variable,
    function: {
      pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
      lookbehind: !0
    },
    keyword: {
      pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
      lookbehind: !0
    },
    // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
    builtin: {
      pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
      lookbehind: !0,
      // Alias added to make those easier to distinguish from strings.
      alias: "class-name"
    },
    boolean: {
      pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
      lookbehind: !0
    },
    "file-descriptor": {
      pattern: /\B&\d\b/,
      alias: "important"
    },
    operator: {
      // Lots of redirections here, but not just that.
      pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
      inside: {
        "file-descriptor": {
          pattern: /^\d/,
          alias: "important"
        }
      }
    },
    punctuation: /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
    number: {
      pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
      lookbehind: !0
    }
  }, r.inside = t.languages.bash;
  for (var i = [
    "comment",
    "function-name",
    "for-or-select",
    "assign-left",
    "parameter",
    "string",
    "environment",
    "function",
    "keyword",
    "builtin",
    "boolean",
    "file-descriptor",
    "operator",
    "punctuation",
    "number"
  ], s = n.variable[1].inside, o = 0; o < i.length; o++)
    s[i[o]] = t.languages.bash[i[o]];
  t.languages.sh = t.languages.bash, t.languages.shell = t.languages.bash;
})(Prism);
Prism.languages.json = {
  property: {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
    lookbehind: !0,
    greedy: !0
  },
  string: {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
    lookbehind: !0,
    greedy: !0
  },
  comment: {
    pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: !0
  },
  number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
  punctuation: /[{}[\],]/,
  operator: /:/,
  boolean: /\b(?:false|true)\b/,
  null: {
    pattern: /\bnull\b/,
    alias: "keyword"
  }
};
Prism.languages.webmanifest = Prism.languages.json;
(function() {
  if (typeof Prism > "u" || typeof document > "u")
    return;
  var t = (
    /*dependencies_placeholder[*/
    {
      javascript: "clike",
      actionscript: "javascript",
      apex: [
        "clike",
        "sql"
      ],
      arduino: "cpp",
      aspnet: [
        "markup",
        "csharp"
      ],
      birb: "clike",
      bison: "c",
      c: "clike",
      csharp: "clike",
      cpp: "c",
      cfscript: "clike",
      chaiscript: [
        "clike",
        "cpp"
      ],
      cilkc: "c",
      cilkcpp: "cpp",
      coffeescript: "javascript",
      crystal: "ruby",
      "css-extras": "css",
      d: "clike",
      dart: "clike",
      django: "markup-templating",
      ejs: [
        "javascript",
        "markup-templating"
      ],
      etlua: [
        "lua",
        "markup-templating"
      ],
      erb: [
        "ruby",
        "markup-templating"
      ],
      fsharp: "clike",
      "firestore-security-rules": "clike",
      flow: "javascript",
      ftl: "markup-templating",
      gml: "clike",
      glsl: "c",
      go: "clike",
      gradle: "clike",
      groovy: "clike",
      haml: "ruby",
      handlebars: "markup-templating",
      haxe: "clike",
      hlsl: "c",
      idris: "haskell",
      java: "clike",
      javadoc: [
        "markup",
        "java",
        "javadoclike"
      ],
      jolie: "clike",
      jsdoc: [
        "javascript",
        "javadoclike",
        "typescript"
      ],
      "js-extras": "javascript",
      json5: "json",
      jsonp: "json",
      "js-templates": "javascript",
      kotlin: "clike",
      latte: [
        "clike",
        "markup-templating",
        "php"
      ],
      less: "css",
      lilypond: "scheme",
      liquid: "markup-templating",
      markdown: "markup",
      "markup-templating": "markup",
      mongodb: "javascript",
      n4js: "javascript",
      objectivec: "c",
      opencl: "c",
      parser: "markup",
      php: "markup-templating",
      phpdoc: [
        "php",
        "javadoclike"
      ],
      "php-extras": "php",
      plsql: "sql",
      processing: "clike",
      protobuf: "clike",
      pug: [
        "markup",
        "javascript"
      ],
      purebasic: "clike",
      purescript: "haskell",
      qsharp: "clike",
      qml: "javascript",
      qore: "clike",
      racket: "scheme",
      cshtml: [
        "markup",
        "csharp"
      ],
      jsx: [
        "markup",
        "javascript"
      ],
      tsx: [
        "jsx",
        "typescript"
      ],
      reason: "clike",
      ruby: "clike",
      sass: "css",
      scss: "css",
      scala: "java",
      "shell-session": "bash",
      smarty: "markup-templating",
      solidity: "clike",
      soy: "markup-templating",
      sparql: "turtle",
      sqf: "clike",
      squirrel: "clike",
      stata: [
        "mata",
        "java",
        "python"
      ],
      "t4-cs": [
        "t4-templating",
        "csharp"
      ],
      "t4-vb": [
        "t4-templating",
        "vbnet"
      ],
      tap: "yaml",
      tt2: [
        "clike",
        "markup-templating"
      ],
      textile: "markup",
      twig: "markup-templating",
      typescript: "javascript",
      v: "clike",
      vala: "clike",
      vbnet: "basic",
      velocity: "markup",
      wiki: "markup",
      xeora: "markup",
      "xml-doc": "markup",
      xquery: "markup"
    }
  ), e = (
    /*aliases_placeholder[*/
    {
      html: "markup",
      xml: "markup",
      svg: "markup",
      mathml: "markup",
      ssml: "markup",
      atom: "markup",
      rss: "markup",
      js: "javascript",
      g4: "antlr4",
      ino: "arduino",
      "arm-asm": "armasm",
      art: "arturo",
      adoc: "asciidoc",
      avs: "avisynth",
      avdl: "avro-idl",
      gawk: "awk",
      sh: "bash",
      shell: "bash",
      shortcode: "bbcode",
      rbnf: "bnf",
      oscript: "bsl",
      cs: "csharp",
      dotnet: "csharp",
      cfc: "cfscript",
      "cilk-c": "cilkc",
      "cilk-cpp": "cilkcpp",
      cilk: "cilkcpp",
      coffee: "coffeescript",
      conc: "concurnas",
      jinja2: "django",
      "dns-zone": "dns-zone-file",
      dockerfile: "docker",
      gv: "dot",
      eta: "ejs",
      xlsx: "excel-formula",
      xls: "excel-formula",
      gamemakerlanguage: "gml",
      po: "gettext",
      gni: "gn",
      ld: "linker-script",
      "go-mod": "go-module",
      hbs: "handlebars",
      mustache: "handlebars",
      hs: "haskell",
      idr: "idris",
      gitignore: "ignore",
      hgignore: "ignore",
      npmignore: "ignore",
      webmanifest: "json",
      kt: "kotlin",
      kts: "kotlin",
      kum: "kumir",
      tex: "latex",
      context: "latex",
      ly: "lilypond",
      emacs: "lisp",
      elisp: "lisp",
      "emacs-lisp": "lisp",
      md: "markdown",
      moon: "moonscript",
      n4jsd: "n4js",
      nani: "naniscript",
      objc: "objectivec",
      qasm: "openqasm",
      objectpascal: "pascal",
      px: "pcaxis",
      pcode: "peoplecode",
      plantuml: "plant-uml",
      pq: "powerquery",
      mscript: "powerquery",
      pbfasm: "purebasic",
      purs: "purescript",
      py: "python",
      qs: "qsharp",
      rkt: "racket",
      razor: "cshtml",
      rpy: "renpy",
      res: "rescript",
      robot: "robotframework",
      rb: "ruby",
      "sh-session": "shell-session",
      shellsession: "shell-session",
      smlnj: "sml",
      sol: "solidity",
      sln: "solution-file",
      rq: "sparql",
      sclang: "supercollider",
      t4: "t4-cs",
      trickle: "tremor",
      troy: "tremor",
      trig: "turtle",
      ts: "typescript",
      tsconfig: "typoscript",
      uscript: "unrealscript",
      uc: "unrealscript",
      url: "uri",
      vb: "visual-basic",
      vba: "visual-basic",
      webidl: "web-idl",
      mathematica: "wolfram",
      nb: "wolfram",
      wl: "wolfram",
      xeoracube: "xeora",
      yml: "yaml"
    }
  ), r = {}, n = "none", i = "components/", s = Prism.util.currentScript();
  if (s) {
    var o = /\bplugins\/autoloader\/prism-autoloader\.(?:min\.)?js(?:\?[^\r\n/]*)?$/i, a = /(^|\/)[\w-]+\.(?:min\.)?js(?:\?[^\r\n/]*)?$/i, l = s.getAttribute("data-autoloader-path");
    if (l != null)
      i = l.trim().replace(/\/?$/, "/");
    else {
      var c = s.src;
      o.test(c) ? i = c.replace(o, "components/") : a.test(c) && (i = c.replace(a, "$1components/"));
    }
  }
  var u = Prism.plugins.autoloader = {
    languages_path: i,
    use_minified: !0,
    loadLanguages: g
  };
  function d(O, b, w) {
    var S = document.createElement("script");
    S.src = O, S.async = !0, S.onload = function() {
      document.body.removeChild(S), b && b();
    }, S.onerror = function() {
      document.body.removeChild(S), w && w();
    }, document.body.appendChild(S);
  }
  function f(O) {
    var b = (O.getAttribute("data-dependencies") || "").trim();
    if (!b) {
      var w = O.parentElement;
      w && w.tagName.toLowerCase() === "pre" && (b = (w.getAttribute("data-dependencies") || "").trim());
    }
    return b ? b.split(/\s*,\s*/g) : [];
  }
  function h(O) {
    if (O.indexOf("!") >= 0)
      return !1;
    if (O = e[O] || O, O in Prism.languages)
      return !0;
    var b = r[O];
    return b && !b.error && b.loading === !1;
  }
  function p(O) {
    return u.languages_path + "prism-" + O + (u.use_minified ? ".min" : "") + ".js";
  }
  function g(O, b, w) {
    typeof O == "string" && (O = [O]);
    var S = O.length, $ = 0, _ = !1;
    if (S === 0) {
      b && setTimeout(b, 0);
      return;
    }
    function Q() {
      _ || ($++, $ === S && b && b(O));
    }
    O.forEach(function(N) {
      m(N, Q, function() {
        _ || (_ = !0, w && w(N));
      });
    });
  }
  function m(O, b, w) {
    var S = O.indexOf("!") >= 0;
    O = O.replace("!", ""), O = e[O] || O;
    function $() {
      var Q = r[O];
      Q || (Q = r[O] = {
        callbacks: []
      }), Q.callbacks.push({
        success: b,
        error: w
      }), !S && h(O) ? y(O, "success") : !S && Q.error ? y(O, "error") : (S || !Q.loading) && (Q.loading = !0, Q.error = !1, d(p(O), function() {
        Q.loading = !1, y(O, "success");
      }, function() {
        Q.loading = !1, Q.error = !0, y(O, "error");
      }));
    }
    var _ = t[O];
    _ && _.length ? g(_, $, w) : $();
  }
  function y(O, b) {
    if (r[O]) {
      for (var w = r[O].callbacks, S = 0, $ = w.length; S < $; S++) {
        var _ = w[S][b];
        _ && setTimeout(_, 0);
      }
      w.length = 0;
    }
  }
  Prism.hooks.add("complete", function(O) {
    var b = O.element, w = O.language;
    if (!(!b || !w || w === n)) {
      var S = f(b);
      /^diff-./i.test(w) ? (S.push("diff"), S.push(w.substr(5))) : S.push(w), S.every(h) || g(S, function() {
        Prism.highlightElement(b);
      });
    }
  });
})();
(function() {
  if (typeof Prism > "u" || typeof document > "u")
    return;
  var t = "line-numbers", e = /\n(?!$)/g, r = Prism.plugins.lineNumbers = {
    /**
     * Get node for provided line number
     *
     * @param {Element} element pre element
     * @param {number} number line number
     * @returns {Element|undefined}
     */
    getLine: function(o, a) {
      if (!(o.tagName !== "PRE" || !o.classList.contains(t))) {
        var l = o.querySelector(".line-numbers-rows");
        if (l) {
          var c = parseInt(o.getAttribute("data-start"), 10) || 1, u = c + (l.children.length - 1);
          a < c && (a = c), a > u && (a = u);
          var d = a - c;
          return l.children[d];
        }
      }
    },
    /**
     * Resizes the line numbers of the given element.
     *
     * This function will not add line numbers. It will only resize existing ones.
     *
     * @param {HTMLElement} element A `<pre>` element with line numbers.
     * @returns {void}
     */
    resize: function(o) {
      n([o]);
    },
    /**
     * Whether the plugin can assume that the units font sizes and margins are not depended on the size of
     * the current viewport.
     *
     * Setting this to `true` will allow the plugin to do certain optimizations for better performance.
     *
     * Set this to `false` if you use any of the following CSS units: `vh`, `vw`, `vmin`, `vmax`.
     *
     * @type {boolean}
     */
    assumeViewportIndependence: !0
  };
  function n(o) {
    if (o = o.filter(function(l) {
      var c = i(l), u = c["white-space"];
      return u === "pre-wrap" || u === "pre-line";
    }), o.length != 0) {
      var a = o.map(function(l) {
        var c = l.querySelector("code"), u = l.querySelector(".line-numbers-rows");
        if (!(!c || !u)) {
          var d = l.querySelector(".line-numbers-sizer"), f = c.textContent.split(e);
          d || (d = document.createElement("span"), d.className = "line-numbers-sizer", c.appendChild(d)), d.innerHTML = "0", d.style.display = "block";
          var h = d.getBoundingClientRect().height;
          return d.innerHTML = "", {
            element: l,
            lines: f,
            lineHeights: [],
            oneLinerHeight: h,
            sizer: d
          };
        }
      }).filter(Boolean);
      a.forEach(function(l) {
        var c = l.sizer, u = l.lines, d = l.lineHeights, f = l.oneLinerHeight;
        d[u.length - 1] = void 0, u.forEach(function(h, p) {
          if (h && h.length > 1) {
            var g = c.appendChild(document.createElement("span"));
            g.style.display = "block", g.textContent = h;
          } else
            d[p] = f;
        });
      }), a.forEach(function(l) {
        for (var c = l.sizer, u = l.lineHeights, d = 0, f = 0; f < u.length; f++)
          u[f] === void 0 && (u[f] = c.children[d++].getBoundingClientRect().height);
      }), a.forEach(function(l) {
        var c = l.sizer, u = l.element.querySelector(".line-numbers-rows");
        c.style.display = "none", c.innerHTML = "", l.lineHeights.forEach(function(d, f) {
          u.children[f].style.height = d + "px";
        });
      });
    }
  }
  function i(o) {
    return o ? window.getComputedStyle ? getComputedStyle(o) : o.currentStyle || null : null;
  }
  var s = void 0;
  window.addEventListener("resize", function() {
    r.assumeViewportIndependence && s === window.innerWidth || (s = window.innerWidth, n(Array.prototype.slice.call(document.querySelectorAll("pre." + t))));
  }), Prism.hooks.add("complete", function(o) {
    if (o.code) {
      var a = (
        /** @type {Element} */
        o.element
      ), l = (
        /** @type {HTMLElement} */
        a.parentNode
      );
      if (!(!l || !/pre/i.test(l.nodeName)) && !a.querySelector(".line-numbers-rows") && Prism.util.isActive(a, t)) {
        a.classList.remove(t), l.classList.add(t);
        var c = o.code.match(e), u = c ? c.length + 1 : 1, d, f = new Array(u + 1).join("<span></span>");
        d = document.createElement("span"), d.setAttribute("aria-hidden", "true"), d.className = "line-numbers-rows", d.innerHTML = f, l.hasAttribute("data-start") && (l.style.counterReset = "linenumber " + (parseInt(l.getAttribute("data-start"), 10) - 1)), o.element.appendChild(d), n([l]), Prism.hooks.run("line-numbers", o);
      }
    }
  }), Prism.hooks.add("line-numbers", function(o) {
    o.plugins = o.plugins || {}, o.plugins.lineNumbers = !0;
  });
})();
const Qn = /* @__PURE__ */ G({
  __name: "ScalarCodeBlock",
  props: {
    content: {},
    lang: { default: "js" },
    lineNumbers: { type: Boolean, default: !1 },
    hideCredentials: {}
  },
  setup(t) {
    const e = t, { plugins: r, highlightElement: n } = Y1;
    e.hideCredentials && Y1.hooks.add("wrap", function(o) {
      if (!e.hideCredentials)
        return;
      let a = !1;
      typeof e.hideCredentials == "string" ? o.content.includes(e.hideCredentials) && (a = !0) : Array.isArray(e.hideCredentials) && (a = e.hideCredentials.some(
        (l) => o.content.includes(l)
      )), a && (o.content = o.content.replace(
        /<span class="credentials">.*?<\/span>/g,
        (l) => l.replace(/<span class="credentials">|<\/span>/g, "")
      ), o.content = o.content.replace(
        new RegExp(
          typeof e.hideCredentials == "string" ? e.hideCredentials : e.hideCredentials.join("|"),
          "g"
        ),
        (l) => `<span class="credentials">${l}</span>`
      ));
    });
    const i = ge(null), s = fe(() => e.lang === "node" ? "js" : e.lang);
    return r.autoloader.languages_path = "https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/", Ve(
      () => [e.lang, e.content],
      () => {
        i.value && _c(() => n(i.value));
      }
    ), Xn(() => {
      i.value && n(i.value);
    }), (o, a) => (k(), C("pre", {
      class: $e(["scalar-component scalar-codeblock-pre", {
        "line-numbers": o.lineNumbers
      }])
    }, [
      x("code", {
        ref_key: "el",
        ref: i,
        class: $e(`scalar-codeblock-code lang-${s.value}`)
      }, te(o.content), 3)
    ], 2));
  }
}), w9 = (t) => Object.fromEntries(Array.from(t).map((e) => [e.name, e.value])), $9 = (t) => ({ raw: e }) => {
  const r = new t().parseFromString(e, "image/svg+xml");
  if (r.getElementsByTagName("parsererror").length)
    return;
  const n = r.documentElement, i = w9(n.attributes), { width: s, height: o, ...a } = i;
  return Hb("svg", { ...a, innerHTML: n.innerHTML });
}, S9 = Fb(async () => {
  const t = typeof DOMParser > "u" ? (await import("@xmldom/xmldom")).DOMParser : DOMParser, e = $9(t);
  return e.props = {
    raw: {
      type: String,
      required: !0
    }
  }, e;
}), k9 = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48">
    <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="3.429"
        d="M24 1.714v44.572M1.714 24h44.572" />
</svg>`, _9 = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32.5 23.5" fill="currentColor">
    <path d="M11.2 23.5 0 12.3l2.15-2.15 9.05 9.05L30.4 0l2.15 2.15z" />
</svg>`, P9 = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4.5 8.25L12 15.75L19.5 8.25" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`, x9 = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M15.75 19.5L8.25 12L15.75 4.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`, T9 = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M8.25 19.5L15.75 12L8.25 4.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`, C9 = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M19.5 15.75L12 8.25L4.5 15.75" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
`, Q9 = `<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 16 16">
    <path d="M6,5h4c1.7,0,2-1.3,2-3c1.1,0,2,0.9,2,2v10c0,1.1-0.9,2-2,2H4c-1.1,0-2-0.9-2-2V4c0-1.1,0.9-2,2-2C4,3.7,4.3,5,6,5z M6,2V1
	c0-0.6,0.5-1,1-1h2c0.5,0,1,0.4,1,1v1.3C10,2.9,9.6,3,9,3H7C6.4,3,6,2.6,6,2z" />
</svg>`, A9 = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 14">
    <path stroke="currentColor" d="m12.5 1.5-11 11m0-11 11 11" />
</svg>`, E9 = `<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
    <path
        d="M9.557,7.243A.456.456,0,0,0,9.1,6.991C9.023,7,8.951,7,8.877,7A4,4,0,0,1,5.546.781.5.5,0,0,0,5.564.256.476.476,0,0,0,5.1,0,5,5,0,1,0,9.539,7.767.5.5,0,0,0,9.557,7.243Z"
        fill="currentColor" stroke="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="0"></path>
</svg>`, R9 = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
    <path
        d="M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z" />
</svg>`, I9 = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 9 9">
    <g fill="none" fill-rule="evenodd" transform="translate(.67 .67)">
        <rect transform="rotate(180 4 4)" />
        <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width=".5"
            d="M2.85 1.73h3.4v3.4m0-3.4L1.74 6.24" />
    </g>
</svg>`, j9 = `<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 1024 1024">
    <path
        d="M512 0a512 512 0 0 0-162 998c26 4 35-11 35-25l-1-95c-128 23-161-32-172-60-6-15-31-61-52-73-18-10-44-33-1-33 40-1 69 37 78 52 46 78 120 56 149 43 5-33 18-56 33-69-114-13-234-56-234-253 0-56 20-101 53-137-5-13-23-65 5-136 0 0 43-13 141 53a487 487 0 0 1 256 0c98-66 141-53 141-53 28 71 10 123 5 136 33 36 53 81 53 137 0 197-120 240-234 253 18 16 35 47 35 95l-1 140c0 14 9 30 35 25A512 512 0 0 0 512 0z" />
</svg>`, Z9 = `<svg
  height="24"
  viewBox="0 0 24 24"
  width="24"
  xmlns="http://www.w3.org/2000/svg">
  <path
    d="M24 12a1 1 0 0 0 -1 -1h-3.91a0.51 0.51 0 0 1 -0.49 -0.4 6.83 6.83 0 0 0 -0.94 -2.28 0.5 0.5 0 0 1 0.06 -0.63l2.77 -2.76a1 1 0 1 0 -1.42 -1.42l-2.76 2.77a0.5 0.5 0 0 1 -0.63 0.06 6.83 6.83 0 0 0 -2.28 -0.94 0.5 0.5 0 0 1 -0.4 -0.49V1a1 1 0 0 0 -2 0v3.91a0.51 0.51 0 0 1 -0.4 0.49 6.83 6.83 0 0 0 -2.28 0.94 0.5 0.5 0 0 1 -0.63 -0.06L4.93 3.51a1 1 0 0 0 -1.42 1.42l2.77 2.76a0.5 0.5 0 0 1 0.06 0.63 6.83 6.83 0 0 0 -0.94 2.28 0.5 0.5 0 0 1 -0.49 0.4H1a1 1 0 0 0 0 2h3.91a0.51 0.51 0 0 1 0.49 0.4 6.83 6.83 0 0 0 0.94 2.28 0.5 0.5 0 0 1 -0.06 0.63l-2.77 2.76a1 1 0 1 0 1.42 1.42l2.76 -2.77a0.5 0.5 0 0 1 0.63 -0.06 6.83 6.83 0 0 0 2.28 0.94 0.5 0.5 0 0 1 0.4 0.49V23a1 1 0 0 0 2 0v-3.91a0.51 0.51 0 0 1 0.4 -0.49 6.83 6.83 0 0 0 2.28 -0.94 0.5 0.5 0 0 1 0.63 0.06l2.76 2.77a1 1 0 1 0 1.42 -1.42l-2.77 -2.76a0.5 0.5 0 0 1 -0.06 -0.63 6.83 6.83 0 0 0 0.94 -2.28 0.5 0.5 0 0 1 0.49 -0.4H23a1 1 0 0 0 1 -1Zm-8.74 2.5A5.76 5.76 0 0 1 9.5 8.74a5.66 5.66 0 0 1 0.16 -1.31 0.49 0.49 0 0 1 0.34 -0.36 5.36 5.36 0 0 1 1.8 -0.31 5.47 5.47 0 0 1 5.46 5.46 5.36 5.36 0 0 1 -0.31 1.8 0.49 0.49 0 0 1 -0.35 0.32 5.53 5.53 0 0 1 -1.34 0.16Z"
    fill="currentColor"
    stroke-width="1"></path>
</svg>`, M9 = `<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
    <path d="M3.500 5.000 A1.500 1.500 0 1 0 6.500 5.000 A1.500 1.500 0 1 0 3.500 5.000 Z" fill="currentColor"
        stroke="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="0"></path>
    <path d="M5,2.25a.625.625,0,0,1-.625-.625v-1a.625.625,0,0,1,1.25,0v1A.625.625,0,0,1,5,2.25Z" fill="currentColor"
        stroke="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="0"></path>
    <path d="M6.945,3.055a.623.623,0,0,1,0-.883l.707-.708a.625.625,0,0,1,.884.884l-.708.707A.623.623,0,0,1,6.945,3.055Z"
        fill="currentColor" stroke="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="0"></path>
    <path d="M7.75,5a.625.625,0,0,1,.625-.625h1a.625.625,0,0,1,0,1.25h-1A.625.625,0,0,1,7.75,5Z" fill="currentColor"
        stroke="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="0"></path>
    <path d="M6.945,6.945a.623.623,0,0,1,.883,0l.708.707a.625.625,0,0,1-.884.884l-.707-.708A.623.623,0,0,1,6.945,6.945Z"
        fill="currentColor" stroke="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="0"></path>
    <path d="M5,7.75a.625.625,0,0,1,.625.625v1a.625.625,0,0,1-1.25,0v-1A.625.625,0,0,1,5,7.75Z" fill="currentColor"
        stroke="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="0"></path>
    <path
        d="M3.055,6.945a.623.623,0,0,1,0,.883l-.707.708a.625.625,0,0,1-.884-.884l.708-.707A.623.623,0,0,1,3.055,6.945Z"
        fill="currentColor" stroke="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="0"></path>
    <path d="M2.25,5a.625.625,0,0,1-.625.625h-1a.625.625,0,0,1,0-1.25h1A.625.625,0,0,1,2.25,5Z" fill="currentColor"
        stroke="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="0"></path>
    <path
        d="M3.055,3.055a.623.623,0,0,1-.883,0l-.708-.707a.625.625,0,0,1,.884-.884l.707.708A.623.623,0,0,1,3.055,3.055Z"
        fill="currentColor" stroke="none" stroke-linecap="round" stroke-linejoin="round" stroke-width="0"></path>
</svg>`, q9 = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 593 593">
    <path fill="currentColor" fill-rule="evenodd"
        d="M347 0c6 0 12 5 12 12v134l94-95c5-5 13-5 17 0l72 72c4 4 5 12 0 16v1l-95 94h134c7 0 12 5 12 12v101c0 7-5 12-12 12H447l95 94c4 5 5 13 0 17l-72 72c-4 4-12 5-16 0h-1l-94-95v134c0 7-5 12-12 12H246c-7 0-12-5-12-12v-70c0-22 9-43 24-59l130-130c14-14 14-37 0-51L259 142a84 84 0 0 1-25-59V12c0-7 5-12 12-12h101ZM138 52h1l219 219c14 14 14 37 0 51L139 542c-4 5-12 5-17 0l-71-70c-4-5-5-12 0-17l95-96H12c-7 0-12-5-12-12V246c0-7 5-12 12-12h134l-95-94c-4-5-4-12 0-17l71-71c4-5 12-5 16 0Z" />
</svg>`, N9 = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 662 662">
    <path fill-rule="evenodd" fill="currentColor"
        d="M331 0a331 331 0 1 1 0 662 331 331 0 0 1 0-662Zm148.5 109 .6.9a187 187 0 1 1-297.6-.9 267 267 0 1 0 297 0Z" />
</svg>`, D9 = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 620 620">
    <path fill="currentColor"
        d="M-.653 309.29c-.078 82.272 31.848 159.735 89.739 218.178l.283.283c122.379 121.247 319.824 121.184 440.16-.283 119.967-121.1 119.409-316.933-.998-437.339l-.99-.99C468.681 30.845 390.716-1.017 307.893-.67c-82.83.354-160.443 32.994-218.814 91.79C31.209 149.555-.724 227.025-.653 309.29Zm469.271-160.789.778.778c87.9 87.9 88.325 231.005.707 319.33-77.753 78.46-199.786 87.412-288.959 26.862l198.513-198.513-.007 166.361 83.68-.07v-306.22H157.11l-.008 83.6h160.584L121.994 436.323c-59.347-87.689-50.536-208.59 26.51-286.343C236.34 61.294 379.94 60.67 468.61 148.494Z" />
</svg>`, z9 = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 642 642" fill="currentColor">
    <path
        d="M321 0a321 321 0 1 1 0 642 321 321 0 0 1 0-642Zm51.3 63L321 189.5 269.7 63l1 136.5-95.8-97.2L228 228l-125.7-53.1 97.2 95.8-136.5-1L189.5 321 63 372.3l136.5-1-97.2 95.8 125.7-53-53.1 125.6 95.8-97.2-1 136.5L321 452.5 372.3 579l-1-136.5 95.8 97.2-53-125.7 125.6 53.1-97.2-95.8 136.5 1L452.5 321 579 269.7l-136.5 1 97.2-95.8L414 228l53.1-125.7-95.8 97.2 1-136.5Z" />
</svg>`, X9 = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 620 620" fill="currentColor">
    <path
        d="M529.2 90.8A310 310 0 1 0 90.8 529.2 310 310 0 0 0 529.2 90.8M122.4 498.2c-54.9-55-15.4-183.5 88.2-287 103.6-103.7 232.1-143.2 287-88.3 54.9 54.8 15.4 183.4-88.3 287-103.5 103.6-232 143.1-286.9 88.3m261.8-262.7A104.7 104.7 0 1 1 236 383.7a104.7 104.7 0 0 1 148.2-148.2" />
</svg>`, W9 = `<svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 14 14">
    <path fill="none" stroke="currentColor" d="M14 3.4H0m14 7.2H0" />
</svg>`, U9 = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 14">
    <path fill="currentColor" fill-rule="evenodd"
        d="M11.8214 0.0977942C12.1097 -0.00745677 12.4219 -0.0286524 12.7219 0.0367783C13.0248 0.102864 13.3024 0.254542 13.5216 0.47378C13.7408 0.693018 13.8925 0.970598 13.9586 1.27352C14.024 1.57344 14.0028 1.88572 13.8976 2.17395L10.3236 12.8859L10.3234 12.8866C10.2363 13.1501 10.083 13.3868 9.8781 13.574C9.6738 13.7606 9.42509 13.8918 9.15572 13.9549C8.8863 14.0206 8.60441 14.0151 8.33774 13.9389C8.07131 13.8628 7.82926 13.7187 7.63529 13.5209L5.71795 11.6124L3.70389 12.6538C3.54684 12.7351 3.35857 12.7273 3.20874 12.6334C3.05892 12.5395 2.96981 12.3735 2.9744 12.1967L3.05697 9.013L10.1019 3.8956C10.3812 3.69273 10.4432 3.30188 10.2403 3.02261C10.0374 2.74333 9.64659 2.68139 9.36731 2.88425L2.20283 8.08846L0.473125 6.35875L0.473067 6.3587L0.472941 6.35857C0.285618 6.17138 0.147716 5.9406 0.0716193 5.68694C-0.00393616 5.43509 -0.0162115 5.16853 0.0358379 4.91085C0.0879545 4.62934 0.213796 4.36664 0.400577 4.14957C0.588637 3.93101 0.83165 3.76664 1.1045 3.67345L1.10787 3.6723L1.10787 3.67231L11.8214 0.0977942Z"
        clip-rule="evenodd"></path>
</svg>`, V9 = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor">
    <path fill-rule="evenodd"
        d="M12.6 11.2h.1l3 3a1 1 0 1 1-1.4 1.5l-3-3a1 1 0 0 1-.1-.1 7 7 0 1 1 1.4-1.4zM7 12A5 5 0 1 0 7 2a5 5 0 0 0 0 10z" />
</svg>`, F1 = /* @__PURE__ */ Object.assign({ "./Add.svg": k9, "./CheckMark.svg": _9, "./ChevronDown.svg": P9, "./ChevronLeft.svg": x9, "./ChevronRight.svg": T9, "./ChevronUp.svg": C9, "./Clipboard.svg": Q9, "./Close.svg": A9, "./DarkMode.svg": E9, "./Ellipses.svg": R9, "./ExternalLink.svg": I9, "./GitHub.svg": j9, "./LightDarkModeToggle.svg": Z9, "./LightMode.svg": M9, "./Logo.svg": q9, "./LogoAPI.svg": N9, "./LogoClient.svg": D9, "./LogoMarket.svg": z9, "./LogoSwagger.svg": X9, "./Menu.svg": W9, "./PaperAirplane.svg": U9, "./Search.svg": V9 }), L9 = (t) => {
  const e = `./${t}.svg`;
  return F1[e] === void 0 ? (console.warn(`Could not find icon: ${t}`), "") : F1[e];
}, $t = /* @__PURE__ */ G({
  __name: "ScalarIcon",
  props: {
    icon: {},
    size: {}
  },
  setup(t) {
    const e = t, r = Um({
      variants: {
        size: {
          xs: "h-3 w-3",
          sm: "h-3.5 w-3.5",
          md: "h-4 w-4",
          lg: "h-5 w-5",
          xl: "h-6 w-6",
          full: "h-full w-full"
        }
      },
      defaultVariants: {
        size: "full"
      }
    }), n = fe(() => L9(e.icon));
    return (i, s) => n.value ? (k(), Y(v(S9), {
      key: 0,
      class: $e(v(ld)("scalar-icon", v(r)({ size: i.size }))),
      raw: n.value
    }, null, 8, ["class", "raw"])) : H("", !0);
  }
}), Y9 = ["ariaDisabled"], B9 = { class: "sr-only" }, Vm = /* @__PURE__ */ G({
  __name: "ScalarIconButton",
  props: {
    label: {},
    icon: {},
    disabled: { type: Boolean },
    variant: { default: "ghost" },
    size: { default: "md" }
  },
  setup(t) {
    const e = Um({
      base: "scalar-icon-button grid aspect-square cursor-pointer rounded",
      variants: {
        size: {
          xs: "h-3.5 w-3.5 p-0.5",
          sm: "h-5 w-5 p-1",
          md: "h-10 w-10 p-3",
          full: "h-full w-full"
        },
        disabled: {
          true: "cursor-not-allowed shadow-none"
        },
        variant: V$
      }
    });
    return (r, n) => (k(), C("button", {
      ariaDisabled: r.disabled || void 0,
      class: $e(v(ld)(v(e)({ size: r.size, variant: r.variant, disabled: r.disabled }))),
      type: "button"
    }, [
      Z(v($t), { icon: r.icon }, null, 8, ["icon"]),
      x("span", B9, te(r.label), 1)
    ], 10, Y9));
  }
}), F9 = { class: "table" }, H9 = { class: "table-row" }, G9 = /* @__PURE__ */ x("div", { class: "table-row-item" }, [
  /* @__PURE__ */ x("label", null, "Key")
], -1), K9 = /* @__PURE__ */ x("div", { class: "table-row-item" }, [
  /* @__PURE__ */ x("label", null, "Value")
], -1), J9 = { class: "table-row-item" }, eE = /* @__PURE__ */ x("label", null, "Description", -1), tE = [
  eE
], rE = /* @__PURE__ */ x("svg", {
  fill: "currentColor",
  height: "12",
  viewBox: "0 0 18 12",
  width: "18",
  xmlns: "http://www.w3.org/2000/svg"
}, [
  /* @__PURE__ */ x("path", {
    d: "M0 12h12v-2H0v2zM0 0v2h18V0H0zm0 7h18V5H0v2z",
    "fill-rule": "nonzero"
  })
], -1), nE = [
  rE
], iE = { class: "table-row-item" }, sE = ["onUpdate:modelValue"], oE = { class: "table-row-item" }, aE = ["onUpdate:modelValue"], lE = { class: "table-row-item" }, cE = ["onUpdate:modelValue"], uE = { class: "table-row-meta" }, dE = { class: "meta-check" }, fE = ["onUpdate:modelValue"], hE = /* @__PURE__ */ x("span", { class: "meta-checkmark" }, null, -1), pE = ["onClick"], mE = /* @__PURE__ */ x("svg", {
  fill: "none",
  height: "10",
  viewBox: "-0.5 -0.5 10 10",
  width: "10",
  xmlns: "http://www.w3.org/2000/svg"
}, [
  /* @__PURE__ */ x("path", {
    d: "m8.55 0.45 -8.1 8.1",
    stroke: "currentColor",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "1.5"
  }),
  /* @__PURE__ */ x("path", {
    d: "m0.45 0.45 8.1 8.1",
    stroke: "currentColor",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "1.5"
  })
], -1), gE = [
  mE
], OE = { class: "meta-actions" }, yE = { class: "meta-actions-item-icon" }, bE = { class: "meta-actions-item-icon" }, Pl = /* @__PURE__ */ G({
  __name: "Grid",
  props: {
    items: {},
    addLabel: {},
    showMoreFilter: { type: Boolean }
  },
  emits: ["deleteIndex", "addAnother"],
  setup(t, { emit: e }) {
    const r = e, n = ge(!1), i = ge(!1);
    function s() {
      r("addAnother"), i.value = !0;
    }
    return (o, a) => (k(), C("div", F9, [
      x("div", H9, [
        G9,
        K9,
        Ne(x("div", J9, tE, 512), [
          [mn, n.value]
        ]),
        x("div", {
          class: "table-row-meta",
          onClick: a[0] || (a[0] = (l) => n.value = !n.value)
        }, nE)
      ]),
      (k(!0), C(ee, null, _e(o.items, (l, c) => Ne((k(), C("div", {
        key: l.id,
        class: $e(["table-row", {
          "required-parameter": l.required
        }])
      }, [
        x("div", iE, [
          Ne(x("input", {
            "onUpdate:modelValue": (u) => l.name = u,
            placeholder: "key"
          }, null, 8, sE), [
            [xt, l.name]
          ])
        ]),
        x("div", oE, [
          Ne(x("input", {
            "onUpdate:modelValue": (u) => l.value = u,
            placeholder: "value"
          }, null, 8, aE), [
            [xt, l.value]
          ])
        ]),
        Ne(x("div", lE, [
          Ne(x("input", {
            "onUpdate:modelValue": (u) => l.description = u,
            placeholder: "value"
          }, null, 8, cE), [
            [xt, l.description]
          ])
        ], 512), [
          [mn, n.value]
        ]),
        x("div", uE, [
          x("label", dE, [
            Ne(x("input", {
              "onUpdate:modelValue": (u) => l.enabled = u,
              checked: "",
              type: "checkbox"
            }, null, 8, fE), [
              [Ca, l.enabled]
            ]),
            hE
          ]),
          x("button", {
            class: "meta-delete",
            type: "button",
            onClick: (u) => o.$emit("deleteIndex", c)
          }, gE, 8, pE)
        ])
      ], 2)), [
        [mn, !o.showMoreFilter || o.showMoreFilter && c < 5 || i.value]
      ])), 128)),
      x("div", OE, [
        o.addLabel ? (k(), C("button", {
          key: 0,
          class: "meta-actions-item",
          type: "button",
          onClick: s
        }, [
          x("i", yE, [
            Z(v($t), { icon: "Add" })
          ]),
          re(" " + te(o.addLabel), 1)
        ])) : H("", !0),
        o.showMoreFilter && o.items.length > 5 && !i.value ? (k(), C("button", {
          key: 1,
          class: "meta-actions-item",
          type: "button",
          onClick: a[1] || (a[1] = (l) => i.value = !0)
        }, [
          re(" Show More "),
          x("i", bE, [
            Z(v($t), { icon: "ChevronDown" })
          ])
        ])) : H("", !0)
      ])
    ]));
  }
}), vE = { class: "navtable simpletable" }, wE = { class: "navtable-table" }, $E = /* @__PURE__ */ gs('<div class="navtable-item navtable-item__top"><div class="navtable-item-33"><label for="">Name</label></div><div class="navtable-item-66"><label for="">Value</label></div></div>', 1), SE = { class: "navtable-item-33" }, kE = { class: "navtable-item-66" }, _E = /* @__PURE__ */ G({
  __name: "SimpleGrid",
  props: {
    items: {}
  },
  setup(t) {
    return (e, r) => (k(), C("div", vE, [
      x("div", wE, [
        $E,
        (k(!0), C(ee, null, _e(e.items, (n) => (k(), C("div", {
          key: n.id,
          class: "navtable-item"
        }, [
          x("div", SE, [
            x("p", null, te(n.name), 1)
          ]),
          x("div", kE, [
            x("p", null, te(n.value), 1)
          ])
        ]))), 128))
      ])
    ]));
  }
}), PE = { key: 0 }, xE = /* @__PURE__ */ G({
  __name: "RequestBody",
  props: {
    body: {},
    formData: {}
  },
  setup(t) {
    const { activeRequest: e, setActiveRequest: r } = pr(), n = (i) => {
      e.body !== i && r({
        ...e,
        body: i
      });
    };
    return (i, s) => (k(), Y(v(Wn), { title: "Body" }, {
      default: I(() => [
        i.body && i.body.length === 0 && i.formData && i.formData.length === 0 ? (k(), C("span", PE, "No Body")) : i.formData && i.formData.length > 0 ? (k(), Y(v(Pl), {
          key: 1,
          items: i.formData
        }, null, 8, ["items"])) : (k(), Y(v(F2), {
          key: 2,
          content: v(e).body,
          language: "json",
          lineNumbers: "",
          onChange: n
        }, null, 8, ["content"]))
      ]),
      _: 1
    }));
  }
}), TE = {
  key: 0,
  class: "scalar-api-client__empty-state"
}, CE = /* @__PURE__ */ x("svg", {
  class: "flow-icon",
  "data-v-aa4fbd2d": "",
  height: "100%",
  viewBox: "0 0 48 48",
  xmlns: "http://www.w3.org/2000/svg"
}, [
  /* @__PURE__ */ x("path", {
    d: "M24 1.714v44.572M1.714 24h44.572",
    fill: "none",
    stroke: "currentColor",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "3.429",
    xmlns: "http://www.w3.org/2000/svg"
  })
], -1), QE = /* @__PURE__ */ G({
  __name: "RequestCookies",
  props: {
    cookies: {}
  },
  setup(t) {
    const { activeRequest: e } = pr();
    function r(i) {
      var s;
      (s = e.cookies) == null || s.splice(i, 1);
    }
    function n() {
      var i;
      e.cookies === void 0 && (e.cookies = []), (i = e.cookies) == null || i.push({ name: "", value: "", enabled: !0 });
    }
    return (i, s) => (k(), Y(v(Wn), {
      defaultOpen: v(e).cookies && v(e).cookies.length > 0,
      title: "Cookies"
    }, {
      default: I(() => [
        !i.cookies || i.cookies.length === 0 ? (k(), C("div", TE, [
          x("button", {
            class: "scalar-api-client-add",
            type: "button",
            onClick: n
          }, [
            CE,
            re(" Cookies ")
          ])
        ])) : (k(), Y(v(Pl), {
          key: 1,
          addLabel: "Cookie",
          items: i.cookies,
          onAddAnother: n,
          onDeleteIndex: r
        }, null, 8, ["items"]))
      ]),
      _: 1
    }, 8, ["defaultOpen"]));
  }
}), AE = {
  key: 0,
  class: "scalar-api-client__empty-state"
}, EE = /* @__PURE__ */ x("svg", {
  class: "flow-icon",
  "data-v-aa4fbd2d": "",
  height: "100%",
  viewBox: "0 0 48 48",
  xmlns: "http://www.w3.org/2000/svg"
}, [
  /* @__PURE__ */ x("path", {
    d: "M24 1.714v44.572M1.714 24h44.572",
    fill: "none",
    stroke: "currentColor",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "3.429",
    xmlns: "http://www.w3.org/2000/svg"
  })
], -1), RE = /* @__PURE__ */ G({
  __name: "RequestHeaders",
  props: {
    headers: {}
  },
  setup(t) {
    const { activeRequest: e } = pr();
    function r(i) {
      var s;
      (s = e.headers) == null || s.splice(i, 1);
    }
    function n() {
      var i;
      e.headers === void 0 && (e.headers = []), (i = e.headers) == null || i.push({ name: "", value: "", enabled: !0 });
    }
    return (i, s) => (k(), Y(v(Wn), {
      defaultOpen: v(e).headers && v(e).headers.length > 0,
      title: "Headers"
    }, {
      default: I(() => [
        !i.headers || i.headers.length === 0 ? (k(), C("div", AE, [
          x("button", {
            class: "scalar-api-client-add",
            type: "button",
            onClick: n
          }, [
            EE,
            re(" Headers ")
          ])
        ])) : (k(), Y(v(Pl), {
          key: 1,
          addLabel: "Header",
          items: i.headers,
          onAddAnother: n,
          onDeleteIndex: r
        }, null, 8, ["items"]))
      ]),
      _: 1
    }, 8, ["defaultOpen"]));
  }
}), IE = {
  key: 0,
  class: "scalar-api-client__empty-state"
}, jE = /* @__PURE__ */ x("svg", {
  class: "flow-icon",
  "data-v-aa4fbd2d": "",
  height: "100%",
  viewBox: "0 0 48 48",
  xmlns: "http://www.w3.org/2000/svg"
}, [
  /* @__PURE__ */ x("path", {
    d: "M24 1.714v44.572M1.714 24h44.572",
    fill: "none",
    stroke: "currentColor",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "3.429",
    xmlns: "http://www.w3.org/2000/svg"
  })
], -1), ZE = /* @__PURE__ */ G({
  __name: "RequestQuery",
  props: {
    queries: {}
  },
  setup(t) {
    const { activeRequest: e } = pr();
    function r(i) {
      var s;
      (s = e.query) == null || s.splice(i, 1);
    }
    function n() {
      var i;
      e.query === void 0 && (e.query = []), (i = e.query) == null || i.push({ name: "", value: "", enabled: !0 });
    }
    return (i, s) => (k(), Y(v(Wn), {
      defaultOpen: v(e).query && v(e).query.length > 0,
      title: "Query Parameters"
    }, {
      default: I(() => [
        !i.queries || i.queries.length === 0 ? (k(), C("div", IE, [
          x("button", {
            class: "scalar-api-client-add",
            type: "button",
            onClick: n
          }, [
            jE,
            re(" Query Parameter ")
          ])
        ])) : (k(), Y(v(Pl), {
          key: 1,
          addLabel: "Query Parameter",
          items: i.queries,
          showMoreFilter: !0,
          onAddAnother: n,
          onDeleteIndex: r
        }, null, 8, ["items"]))
      ]),
      _: 1
    }, 8, ["defaultOpen"]));
  }
}), ME = {
  key: 0,
  class: "scalar-api-client__empty-state"
}, qE = /* @__PURE__ */ x("svg", {
  class: "flow-icon",
  "data-v-aa4fbd2d": "",
  height: "100%",
  viewBox: "0 0 48 48",
  xmlns: "http://www.w3.org/2000/svg"
}, [
  /* @__PURE__ */ x("path", {
    d: "M24 1.714v44.572M1.714 24h44.572",
    fill: "none",
    stroke: "currentColor",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "3.429",
    xmlns: "http://www.w3.org/2000/svg"
  })
], -1), NE = /* @__PURE__ */ G({
  __name: "RequestVariables",
  props: {
    variables: {}
  },
  setup(t) {
    const { activeRequest: e } = pr();
    function r(i) {
      var s;
      (s = e.variables) == null || s.splice(i, 1);
    }
    function n() {
      var i;
      e.variables === void 0 && (e.variables = []), (i = e.variables) == null || i.push({ name: "", value: "", enabled: !0 });
    }
    return (i, s) => (k(), Y(v(Wn), {
      defaultOpen: v(e).variables && v(e).variables.length > 0,
      title: "Variables"
    }, {
      default: I(() => [
        !i.variables || i.variables.length === 0 ? (k(), C("div", ME, [
          x("button", {
            class: "scalar-api-client-add",
            type: "button",
            onClick: n
          }, [
            qE,
            re(" Variable ")
          ])
        ])) : (k(), Y(v(Pl), {
          key: 1,
          addLabel: "Variable",
          items: i.variables,
          showMoreFilter: !0,
          onAddAnother: n,
          onDeleteIndex: r
        }, null, 8, ["items"]))
      ]),
      _: 1
    }, 8, ["defaultOpen"]));
  }
}), DE = { class: "scalar-api-client__main__left custom-scroll" }, zE = { class: "scalar-api-client__main__content" }, XE = /* @__PURE__ */ x("label", null, "Request", -1), WE = { class: "meta" }, UE = { class: "meta-item meta-item__input" }, VE = ["disabled"], LE = /* @__PURE__ */ x("div", { class: "scalar-api-client__main__scroll-container" }, null, -1), H1 = /* @__PURE__ */ G({
  __name: "Request",
  setup(t) {
    const { activeRequest: e, readOnly: r } = pr();
    return (n, i) => (k(), C("div", DE, [
      x("div", zE, [
        XE,
        x("div", WE, [
          x("div", UE, [
            Ne(x("input", {
              "onUpdate:modelValue": i[0] || (i[0] = (s) => v(e).name = s),
              class: "scalar-api-client__request-name",
              disabled: v(r),
              placeholder: "Request Name",
              type: "text"
            }, null, 8, VE), [
              [xt, v(e).name]
            ])
          ])
        ])
      ]),
      x("div", null, [
        Z(NE, {
          variables: v(e).variables
        }, null, 8, ["variables"]),
        Z(CA),
        Z(QE, {
          cookies: v(e).cookies
        }, null, 8, ["cookies"]),
        Z(RE, {
          headers: v(e).headers
        }, null, 8, ["headers"]),
        Z(ZE, {
          queries: v(e).query
        }, null, 8, ["queries"]),
        Z(xE, {
          body: v(e).body,
          formData: v(e).formData,
          requestBody: v(e).body
        }, null, 8, ["body", "formData", "requestBody"]),
        LE
      ])
    ]));
  }
});
var Lm = {};
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var G1 = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g, YE = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/, L$ = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/, BE = /\\([\u000b\u0020-\u00ff])/g, FE = /([\\"])/g, Y$ = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
Lm.format = HE;
Lm.parse = GE;
function HE(t) {
  if (!t || typeof t != "object")
    throw new TypeError("argument obj is required");
  var e = t.parameters, r = t.type;
  if (!r || !Y$.test(r))
    throw new TypeError("invalid type");
  var n = r;
  if (e && typeof e == "object")
    for (var i, s = Object.keys(e).sort(), o = 0; o < s.length; o++) {
      if (i = s[o], !L$.test(i))
        throw new TypeError("invalid parameter name");
      n += "; " + i + "=" + JE(e[i]);
    }
  return n;
}
function GE(t) {
  if (!t)
    throw new TypeError("argument string is required");
  var e = typeof t == "object" ? KE(t) : t;
  if (typeof e != "string")
    throw new TypeError("argument string is required to be a string");
  var r = e.indexOf(";"), n = r !== -1 ? e.slice(0, r).trim() : e.trim();
  if (!Y$.test(n))
    throw new TypeError("invalid media type");
  var i = new eR(n.toLowerCase());
  if (r !== -1) {
    var s, o, a;
    for (G1.lastIndex = r; o = G1.exec(e); ) {
      if (o.index !== r)
        throw new TypeError("invalid parameter format");
      r += o[0].length, s = o[1].toLowerCase(), a = o[2], a.charCodeAt(0) === 34 && (a = a.slice(1, -1), a.indexOf("\\") !== -1 && (a = a.replace(BE, "$1"))), i.parameters[s] = a;
    }
    if (r !== e.length)
      throw new TypeError("invalid parameter format");
  }
  return i;
}
function KE(t) {
  var e;
  if (typeof t.getHeader == "function" ? e = t.getHeader("content-type") : typeof t.headers == "object" && (e = t.headers && t.headers["content-type"]), typeof e != "string")
    throw new TypeError("content-type header is missing from object");
  return e;
}
function JE(t) {
  var e = String(t);
  if (L$.test(e))
    return e;
  if (e.length > 0 && !YE.test(e))
    throw new TypeError("invalid parameter value");
  return '"' + e.replace(FE, "\\$1") + '"';
}
function eR(t) {
  this.parameters = /* @__PURE__ */ Object.create(null), this.type = t;
}
const tR = {
  key: 1,
  class: "scalar-api-client__empty-state"
}, rR = {
  key: 1,
  class: "scalar-api-client__empty-state"
}, nR = /* @__PURE__ */ G({
  __name: "ResponseBody",
  props: {
    active: { type: Boolean, default: !1 },
    data: { default: null },
    headers: {}
  },
  setup(t) {
    const e = t, r = fe(() => {
      const i = e.headers.find(
        (s) => s.name.toLowerCase() === "content-type"
      );
      if (!i)
        return null;
      try {
        return Lm.parse(i.value).type;
      } catch {
        return null;
      }
    }), n = fe(() => r.value === "application/json" || r.value === "application/problem+json" ? "json" : r.value === "text/html" || r.value === "text/plain" ? "html" : null);
    return (i, s) => (k(), Y(v(Wn), { title: "Body" }, {
      default: I(() => [
        i.active ? (k(), C(ee, { key: 0 }, [
          n.value ? (k(), Y(v(Qn), {
            key: 0,
            class: "custom-scroll",
            content: i.data,
            lang: n.value
          }, null, 8, ["content", "lang"])) : (k(), C("div", tR, [
            r.value ? (k(), C(ee, { key: 0 }, [
              re(" No Preview Available (" + te(r.value) + ") ", 1)
            ], 64)) : (k(), C(ee, { key: 1 }, [
              re(" Canâ€™t render a preview. The Content-Type header is missing or unknown. ")
            ], 64))
          ]))
        ], 64)) : (k(), C("div", rR, " No Response "))
      ]),
      _: 1
    }));
  }
}), iR = ["href"], sR = /* @__PURE__ */ G({
  __name: "HelpfulLink",
  props: {
    href: {}
  },
  setup(t) {
    return (e, r) => (k(), C("a", {
      href: e.href,
      rel: "noopener noreferrer",
      target: "_blank"
    }, [
      se(e.$slots, "default", {}, void 0, !0)
    ], 8, iR));
  }
}), B$ = /* @__PURE__ */ oe(sR, [["__scopeId", "data-v-d11ff062"]]), oR = /* @__PURE__ */ G({
  __name: "SimpleCell",
  props: {
    wrap: { type: Boolean, default: !0 },
    strong: { type: Boolean, default: !1 },
    href: { default: null }
  },
  setup(t) {
    return (e, r) => (k(), C("td", {
      class: $e(["simple-cell", { wrap: e.wrap, strong: e.strong }])
    }, [
      e.href ? (k(), Y(B$, {
        key: 0,
        href: e.href
      }, {
        default: I(() => [
          se(e.$slots, "default", {}, void 0, !0)
        ]),
        _: 3
      }, 8, ["href"])) : se(e.$slots, "default", { key: 1 }, void 0, !0)
    ], 2));
  }
}), tp = /* @__PURE__ */ oe(oR, [["__scopeId", "data-v-01fffd78"]]), aR = /* @__PURE__ */ G({
  __name: "SimpleHeader",
  setup(t) {
    return (e, r) => (k(), Y(tp, {
      as: "th",
      class: "simple-header"
    }, {
      default: I(() => [
        se(e.$slots, "default", {}, void 0, !0)
      ]),
      _: 3
    }));
  }
}), K1 = /* @__PURE__ */ oe(aR, [["__scopeId", "data-v-b2232089"]]), lR = {}, cR = { class: "simple-row" };
function uR(t, e) {
  return k(), C("tr", cR, [
    se(t.$slots, "default", {}, void 0, !0)
  ]);
}
const J1 = /* @__PURE__ */ oe(lR, [["render", uR], ["__scopeId", "data-v-0982ade4"]]), dR = {}, fR = { class: "simple-table" };
function hR(t, e) {
  return k(), C("table", fR, [
    se(t.$slots, "default", {}, void 0, !0)
  ]);
}
const pR = /* @__PURE__ */ oe(dR, [["render", hR], ["__scopeId", "data-v-28fcbcb6"]]), mR = {
  key: 1,
  class: "scalar-api-client__empty-state"
}, gR = /* @__PURE__ */ G({
  __name: "ResponseHeaders",
  props: {
    headers: {}
  },
  setup(t) {
    const e = (n) => {
      var i;
      return (i = w_.find((s) => s.name.toLowerCase() === n.toLowerCase())) == null ? void 0 : i.url;
    }, r = (n) => n.split("-").map((i) => i.charAt(0).toUpperCase() + i.slice(1)).join("-");
    return (n, i) => (k(), Y(v(Wn), { title: "Headers" }, {
      default: I(() => [
        n.headers.length > 0 ? (k(), Y(v(pR), { key: 0 }, {
          default: I(() => [
            Z(v(J1), null, {
              default: I(() => [
                Z(v(K1), null, {
                  default: I(() => [
                    re("Key")
                  ]),
                  _: 1
                }),
                Z(v(K1), null, {
                  default: I(() => [
                    re("Value")
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }),
            (k(!0), C(ee, null, _e(n.headers, (s) => (k(), Y(v(J1), {
              key: s.name
            }, {
              default: I(() => [
                Z(v(tp), {
                  href: e(s.name),
                  strong: !0,
                  wrap: !1
                }, {
                  default: I(() => [
                    re(te(r(s.name)), 1)
                  ]),
                  _: 2
                }, 1032, ["href"]),
                Z(v(tp), null, {
                  default: I(() => [
                    re(te(s.value), 1)
                  ]),
                  _: 2
                }, 1024)
              ]),
              _: 2
            }, 1024))), 128))
          ]),
          _: 1
        })) : (k(), C("div", mR, "No Headers"))
      ]),
      _: 1
    }));
  }
}), OR = { class: "meta-item" }, yR = { class: "meta-item" }, bR = { class: "meta-item" }, vR = /* @__PURE__ */ G({
  __name: "ResponseMetaInformation",
  props: {
    response: {}
  },
  setup(t) {
    const e = t, r = (i) => {
      var s;
      return (s = i == null ? void 0 : i.headers) != null && s["X-API-Client-Content-Length"] ? bu(
        parseFloat(i.headers["X-API-Client-Content-Length"])
      ) : bu(0);
    }, n = fe(() => {
      const i = e.response.statusCode;
      if (i)
        return __[i] ?? void 0;
    });
    return (i, s) => {
      var o, a;
      return k(), C(ee, null, [
        x("div", OR, [
          x("span", null, te(v(j$)(i.response.duration)), 1)
        ]),
        x("div", yR, [
          x("span", null, te(r(i.response)), 1)
        ]),
        x("div", bR, [
          x("span", {
            class: $e(`scalar-api-client__status scalar-api-client__status--${String(
              i.response.statusCode
            ).charAt(0)}xx`)
          }, [
            (o = n.value) != null && o.url ? (k(), Y(B$, {
              key: 0,
              href: n.value.url
            }, {
              default: I(() => [
                re(te(i.response.statusCode) + " " + te(n.value.name), 1)
              ]),
              _: 1
            }, 8, ["href"])) : (k(), C(ee, { key: 1 }, [
              re(te(i.response.statusCode) + " " + te((a = n.value) == null ? void 0 : a.name), 1)
            ], 64))
          ], 2)
        ])
      ], 64);
    };
  }
}), wR = { class: "scalar-api-client__main__right custom-scroll" }, $R = { class: "scalar-api-client__main__content" }, SR = /* @__PURE__ */ x("label", null, "Response", -1), kR = { class: "meta" }, _R = {
  key: 1,
  class: "meta-item"
}, PR = /* @__PURE__ */ x("span", null, "Send your first request to start", -1), xR = [
  PR
], TR = {
  key: 0,
  class: "scalar-api-client__empty-state"
}, CR = /* @__PURE__ */ x("div", { class: "scalar-api-client__main__scroll-container" }, null, -1), ey = /* @__PURE__ */ G({
  __name: "Response",
  setup(t) {
    const { activeResponse: e, activeRequestId: r } = pr(), n = fe(() => {
      var a;
      const o = (a = e.value) == null ? void 0 : a.headers;
      return o ? Object.keys(o).map((l) => ({ name: l, value: o[l] })).filter(
        (l) => ![
          "rest-api-client-content-length",
          "X-API-Client-Content-Length"
        ].includes(l.name)
      ) : [];
    }), i = fe(() => {
      var a;
      const o = (a = e.value) == null ? void 0 : a.cookies;
      return o ? Object.keys(o).map((l) => ({ name: l, value: o[l] })) : [];
    }), s = fe(() => {
      var a;
      const o = (a = e.value) == null ? void 0 : a.data;
      return o && yu(o) ? JSON.stringify(JSON.parse(o), null, 2) : o && typeof e3(o) == "object" || o && !yu(o) ? JSON.stringify(o, null, 2) : o;
    });
    return (o, a) => (k(), C("div", wR, [
      x("div", $R, [
        SR,
        x("div", kR, [
          v(r) && v(e) ? (k(), Y(vR, {
            key: 0,
            response: v(e)
          }, null, 8, ["response"])) : (k(), C("div", _R, xR))
        ])
      ]),
      x("div", null, [
        Z(nR, {
          active: !!v(e),
          data: s.value,
          headers: n.value
        }, null, 8, ["active", "data", "headers"]),
        Z(gR, { headers: n.value }, null, 8, ["headers"]),
        Z(v(Wn), { title: "Cookies" }, {
          default: I(() => [
            Ne(Z(v(_E), { items: i.value }, null, 8, ["items"]), [
              [mn, i.value.length > 0]
            ]),
            i.value.length === 0 ? (k(), C("div", TR, "No Cookies")) : H("", !0)
          ]),
          _: 1
        }),
        CR
      ])
    ]));
  }
}), QR = { class: "scalar-api-client__main" }, AR = /* @__PURE__ */ G({
  __name: "ApiClient",
  props: {
    proxyUrl: {},
    readOnly: { type: Boolean, default: !1 },
    theme: {}
  },
  emits: ["escapeKeyPress"],
  setup(t, { emit: e }) {
    const r = t, n = e, i = Uu();
    Hs(i.escape, () => n("escapeKeyPress"));
    const { activeRequest: s, readOnly: o } = pr(), a = Vu("(max-width: 820px)"), l = ge(0), c = {
      Request: 0,
      Response: 1
    };
    function u(d) {
      l.value = d;
    }
    return Ve(
      () => r.readOnly,
      () => {
        o.value = r.readOnly;
      },
      { immediate: !0 }
    ), (d, f) => (k(), C(ee, null, [
      Z(v(iv), { id: d.theme }, null, 8, ["id"]),
      Z(xi, {
        class: "scalar-api-client",
        method: v(s).type ?? "get",
        property: "--default-scalar-api-client-color",
        onKeydown: f[1] || (f[1] = t3((h) => n("escapeKeyPress"), ["esc"]))
      }, {
        default: I(() => [
          Z(DQ, {
            proxyUrl: d.proxyUrl,
            onOnSend: f[0] || (f[0] = (h) => u(c.Response))
          }, null, 8, ["proxyUrl"]),
          x("div", QR, [
            v(a) ? (k(), Y(v(Gb), {
              key: 1,
              selectedIndex: l.value,
              onChange: u
            }, {
              default: I(() => [
                Z(v(Kb), { class: "scalar-api-client__mobile-navigation" }, {
                  default: I(() => [
                    Z(v(Gf), { class: "scalar-api-client__mobile-navigation__toggle" }, {
                      default: I(({ selected: h }) => [
                        x("span", {
                          class: $e({
                            "scalar-api-client__mobile-navigation--active": h
                          })
                        }, " Request ", 2)
                      ]),
                      _: 1
                    }),
                    Z(v(Gf), { class: "scalar-api-client__mobile-navigation__toggle" }, {
                      default: I(({ selected: h }) => [
                        x("span", {
                          class: $e({
                            "scalar-api-client__mobile-navigation--active": h
                          })
                        }, " Response ", 2)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }),
                Z(v(a3), { as: "template" }, {
                  default: I(() => [
                    Z(v(k0), { as: "template" }, {
                      default: I(() => [
                        Z(v(H1))
                      ]),
                      _: 1
                    }),
                    Z(v(k0), { as: "template" }, {
                      default: I(() => [
                        Z(v(ey))
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["selectedIndex"])) : (k(), C(ee, { key: 0 }, [
              Z(v(H1)),
              Z(v(ey))
            ], 64))
          ])
        ]),
        _: 1
      }, 8, ["method"])
    ], 64));
  }
});
function ER(t, e) {
  for (const [r, n] of Object.entries(t))
    n !== null && typeof n == "object" ? (e[r] ?? (e[r] = new n.__proto__.constructor()), ER(n, e[r])) : typeof n < "u" && (e[r] = n);
  return e;
}
function F$({
  serverState: t,
  authenticationState: e,
  operation: r
}) {
  var o, a;
  const n = H$(
    {
      url: np(t)
    },
    rp(r, { requiredOnly: !1 }),
    K$(
      e,
      (o = r.information) == null ? void 0 : o.security
    )
  ), i = rp(r, {
    requiredOnly: !1
  }), s = oo(r, "path", !1);
  return {
    id: r.operationId,
    name: r.name,
    type: n.method,
    path: i.path ?? "",
    variables: s,
    cookies: n.cookies.map((l) => ({ ...l, enabled: !0 })),
    query: n.queryString.map((l) => ({ ...l, enabled: l.required ?? !0 })),
    headers: n.headers.map((l) => ({ ...l, enabled: !0 })),
    url: np(t) ?? "",
    body: (a = n.postData) == null ? void 0 : a.text
  };
}
const Yt = (t, e, r = 0) => {
  var i, s, o, a;
  if (r > 5)
    return null;
  if ((e == null ? void 0 : e.mode) === "write" && t.readOnly || (e == null ? void 0 : e.mode) === "read" && t.writeOnly)
    return;
  if (Array.isArray(t.examples) && t.examples.length > 0)
    return t.examples[0];
  if (t.example !== void 0)
    return t.example;
  if (t.default !== void 0)
    return t.default;
  if (t.enum !== void 0)
    return t.enum[0];
  if (t.type === "object" || t.properties !== void 0) {
    const l = {};
    if (t.properties !== void 0 && Object.keys(t.properties).forEach((c) => {
      var f;
      const u = t.properties[c], d = e != null && e.xml ? (f = u.xml) == null ? void 0 : f.name : void 0;
      l[d ?? c] = Yt(
        u,
        e,
        r + 1
      );
    }), t.additionalProperties !== void 0 && t.additionalProperties !== !1) {
      const c = Yt(
        t.additionalProperties,
        e,
        r + 1
      );
      return c && typeof c == "object" && !Array.isArray(c) ? {
        ...l,
        ...Yt(
          t.additionalProperties,
          e,
          r + 1
        )
      } : c === null ? null : {
        ...l,
        someKey: Yt(
          t.additionalProperties,
          e,
          r + 1
        )
      };
    }
    return l;
  }
  if (t.type === "array" || t.items !== void 0) {
    const l = (s = (i = t == null ? void 0 : t.items) == null ? void 0 : i.xml) == null ? void 0 : s.name, c = !!(e != null && e.xml && ((o = t.xml) != null && o.wrapped) && l);
    if (t.example !== void 0)
      return c ? { [l]: t.example } : t.example;
    if ((a = t.items) != null && a.type) {
      const u = Yt(
        t.items,
        e,
        r + 1
      );
      return c ? [{ [l]: u }] : [u];
    }
    return [];
  }
  const n = {
    string: (e == null ? void 0 : e.emptyString) ?? "",
    boolean: !0,
    integer: t.min ?? 1,
    number: t.min ?? 1,
    array: []
  };
  if (t.type !== void 0 && n[t.type] !== void 0)
    return n[t.type];
  if (Array.isArray(t.oneOf) && t.oneOf.length > 0) {
    const l = t.oneOf[0];
    return Yt(l, e, r + 1);
  }
  if (Array.isArray(t.allOf)) {
    let l = null;
    return t.allOf.forEach((c) => {
      const u = Yt(c, e, r + 1);
      l = typeof u == "object" && typeof l == "object" ? {
        ...l ?? {},
        ...u
      } : Array.isArray(u) && Array.isArray(l) ? [...l ?? {}, ...u] : u;
    }), l;
  }
  return console.warn(`[getExampleFromSchema] Unknown property type "${t.type}".`), null;
}, H$ = (...t) => {
  let e = {
    httpVersion: "1.1",
    method: "GET",
    url: "",
    path: "",
    headers: [],
    headersSize: -1,
    queryString: [],
    cookies: [],
    bodySize: -1
  };
  t.forEach((i) => {
    e = {
      ...e,
      ...i,
      headers: [...e.headers, ...i.headers ?? []],
      queryString: [
        ...e.queryString,
        ...i.queryString ?? []
      ],
      cookies: [...e.cookies, ...i.cookies ?? []]
    };
  }), e.headers = XR(
    O3.from(
      _a(e.headers, "name", "value")
    ).normalize(!0),
    "name"
  );
  const { path: r, ...n } = e;
  return r ? {
    ...n,
    url: `${e.url}${r}`
  } : n;
}, RR = rv().use(tv).use(v3).use(y3), vu = async (t) => {
  const e = new b3(), { headings: r } = (await RR.process(t)).data;
  return IR(r, e);
}, IR = (t, e) => t.map((r) => ({
  ...r,
  slug: e.slug(r.value)
})), G$ = (t) => {
  const e = Math.min(...t.map((r) => r.depth));
  return e >= 1 && e <= 6 ? e : 1;
};
function oo(t, e, r = !0) {
  var s;
  return [
    ...t.pathParameters || [],
    ...((s = t.information) == null ? void 0 : s.parameters) || []
  ].filter((o) => o.in === e).filter(
    (o) => r && o.required || !r
  ).map((o) => ({
    name: o.name,
    description: o.description ?? null,
    value: o.example ? o.example : o.schema ? Yt(o.schema, { mode: "write" }) : "",
    required: o.required ?? !1,
    enabled: o.required ?? !1
  })).sort((o, a) => o.required && !a.required ? -1 : !o.required && a.required ? 1 : 0);
}
function jR(t, e) {
  var d, f, h, p, g, m, y, O;
  const n = [
    "application/json",
    "application/octet-stream",
    "application/x-www-form-urlencoded",
    "application/xml",
    "multipart/form-data",
    "text/plain"
  ].find(
    (b) => {
      var w, S, $;
      return !!(($ = (S = (w = t.information) == null ? void 0 : w.requestBody) == null ? void 0 : S.content) != null && $[b]);
    }
  ), i = (p = (h = (f = (d = t.information) == null ? void 0 : d.requestBody) == null ? void 0 : f.content) == null ? void 0 : h["application/json"]) == null ? void 0 : p.examples, s = (g = i ?? {}) == null ? void 0 : g[e ?? Object.keys(i ?? {})[0]];
  if (s)
    return {
      postData: {
        mimeType: "application/json",
        text: wu(s == null ? void 0 : s.value)
      }
    };
  const o = oo(t, "body", !1);
  if (o.length > 0)
    return {
      postData: {
        mimeType: "application/json",
        text: wu(o[0].value)
      }
    };
  const a = oo(
    t,
    "formData",
    !1
  );
  if (a.length > 0)
    return {
      postData: {
        mimeType: "application/x-www-form-urlencoded",
        params: a.map((b) => ({
          name: b.name,
          value: b.value
        }))
      }
    };
  if (!n)
    return {
      postData: void 0
    };
  const l = (O = (y = (m = t.information) == null ? void 0 : m.requestBody) == null ? void 0 : y.content) == null ? void 0 : O[n], c = [
    {
      name: "Content-Type",
      value: n
    }
  ], u = l != null && l.example ? l == null ? void 0 : l.example : void 0;
  if (n === "application/json") {
    const b = l != null && l.schema ? Yt(l == null ? void 0 : l.schema, { mode: "write" }) : null;
    return {
      headers: c,
      postData: {
        mimeType: n,
        text: u ?? JSON.stringify(b, null, 2)
      }
    };
  }
  if (n === "application/xml") {
    const b = l != null && l.schema ? Yt(l == null ? void 0 : l.schema, {
      xml: !0,
      mode: "write"
    }) : null;
    return {
      headers: c,
      postData: {
        mimeType: n,
        text: u ?? zR(b, "  ")
      }
    };
  }
  if (n === "application/octet-stream")
    return {
      headers: c,
      postData: {
        mimeType: n,
        text: "BINARY"
      }
    };
  if (n === "text/plain") {
    const b = l != null && l.schema ? Yt(l == null ? void 0 : l.schema, {
      xml: !0,
      mode: "write"
    }) : null;
    return {
      headers: c,
      postData: {
        mimeType: n,
        text: u ?? b ?? ""
      }
    };
  }
  if (n === "application/x-www-form-urlencoded")
    return {
      headers: c,
      postData: {
        mimeType: n
        // TODO: We have an object, but how do we get that kind of array from the object?
        // Donâ€™t forget to include nested properties â€¦ :|
        // params: [
        //   {
        //     name: 'foo',
        //     value: 'bar',
        //   },
        // ],
      }
    };
  if (n === "multipart/form-data")
    return {
      headers: c,
      postData: {
        mimeType: n
        // TODO: We have an object, but how do we get that kind of array from the object?
        // Donâ€™t forget to include nested properties â€¦ :|
        // params: [
        //   {
        //     name: 'foo',
        //     value: 'bar',
        //   },
        // ],
      }
    };
}
function ZR(t) {
  return !(!t || Array.isArray(t) && !t.length || (t ?? []).some(
    (e) => !Object.keys(e).length
  ));
}
function K$(t, e) {
  var l;
  const r = [], n = [], i = [];
  if (!t.securitySchemeKey || !ZR(e))
    return { headers: r, queryString: n, cookies: i };
  const o = (e == null ? void 0 : e.some(
    (c) => t.securitySchemeKey && Object.keys(c).includes(
      t.securitySchemeKey
    )
  )) ? t.securitySchemeKey : Object.keys((e == null ? void 0 : e[0]) ?? {}).pop(), a = (l = t.securitySchemes) == null ? void 0 : l[o ?? ""];
  if (a) {
    if ("type" in a && a.type === "apiKey") {
      if ("in" in a && a.in === "header") {
        const c = t.apiKey.token.length ? t.apiKey.token : "YOUR_TOKEN";
        r.push({
          name: "name" in a ? a.name : "",
          value: c
        });
      } else if ("in" in a && a.in === "cookie") {
        const c = t.apiKey.token.length ? t.apiKey.token : "YOUR_TOKEN";
        i.push({
          name: a.name,
          value: c
        });
      } else if ("in" in a && a.in === "query") {
        const c = t.apiKey.token.length ? t.apiKey.token : "YOUR_TOKEN";
        n.push({
          name: a.name,
          value: c
        });
      }
    } else if ("type" in a && // @ts-ignore
    (a.type === "http" || a.type === "basic")) {
      if ("type" in a && // @ts-ignore
      (a.type === "basic" || a.type === "http" && a.scheme === "basic")) {
        const { username: c, password: u } = t.http.basic, d = J$(c, u);
        r.push({
          name: "Authorization",
          value: `Basic ${d}`.trim()
        });
      } else if ("type" in a && a.type === "http" && a.scheme === "bearer") {
        const c = t.http.bearer.token.length ? t.http.bearer.token : "YOUR_SECRET_TOKEN";
        r.push({
          name: "Authorization",
          value: `Bearer ${c}`
        });
      }
    } else if ("type" in a && // @ts-ignore
    a.type.toLowerCase() === "oauth2") {
      const c = t.oAuth2.clientId.length ? t.oAuth2.clientId : "YOUR_SECRET_TOKEN";
      r.push({
        name: "Authorization",
        value: `Bearer ${c}`
      });
    }
  }
  return { headers: r, queryString: n, cookies: i };
}
function J$(t, e) {
  return t != null && t.length || e != null && e.length ? Buffer.from(`${t}:${e}`).toString("base64") : "";
}
function MR(t) {
  return [
    t.apiKey.token,
    t.http.bearer.token,
    t.oAuth2.clientId,
    // The basic auth token is the base64 encoded username and password
    J$(
      t.http.basic.username,
      t.http.basic.password
    ),
    // The plain text password shouldnâ€™t appear anyway, but just in case
    t.http.basic.password
  ].filter(Boolean);
}
const rp = (t, e, r) => {
  let n = t.path;
  if ((e == null ? void 0 : e.replaceVariables) === !0) {
    const s = n.match(/{(.*?)}/g);
    s && s.forEach((o) => {
      const a = o.replace(/{|}/g, "");
      n = n.replace(o, `__${a.toUpperCase()}__`);
    });
  }
  const i = jR(t, r);
  return {
    method: t.httpVerb.toUpperCase(),
    path: n,
    headers: [
      ...oo(t, "header", e == null ? void 0 : e.requiredOnly),
      ...(i == null ? void 0 : i.headers) ?? []
    ],
    // TODO: Sorry, something is off here and I donâ€™t get it.
    // @ts-ignore
    postData: i == null ? void 0 : i.postData,
    queryString: oo(
      t,
      "query",
      e == null ? void 0 : e.requiredOnly
    ),
    cookies: oo(
      t,
      "cookie",
      e == null ? void 0 : e.requiredOnly
    )
  };
};
function eS(t, e) {
  const r = /{{\s*([\w.-]+)\s*}}/g, n = /{\s*([\w.-]+)\s*}/g, i = (s, o) => {
    if (typeof e == "function")
      return e(o);
    {
      const a = e == null ? void 0 : e.find(
        (l) => l.name === o
      );
      return ((a == null ? void 0 : a.value) ?? "").toString();
    }
  };
  return t.replace(r, i).replace(n, i);
}
function np(t) {
  var n, i;
  const e = t.selectedServer === null ? (n = t == null ? void 0 : t.servers) == null ? void 0 : n[0] : (i = t == null ? void 0 : t.servers) == null ? void 0 : i[t.selectedServer];
  let r = typeof (e == null ? void 0 : e.url) == "string" ? eS(e == null ? void 0 : e.url, t.variables) : e == null ? void 0 : e.url;
  return r != null && r.startsWith("/") ? r = `${ty()}${r}` : r && !(r != null && r.startsWith("http://")) && !(r != null && r.startsWith("https://")) && (r = `${ty()}/${r}`), r;
}
const ty = () => {
  const t = window.location.origin;
  return t.endsWith("/") ? t.slice(0, -1) : t;
};
function Nre(t) {
  const e = /{{?\s*([\w.-]+)\s*}}?/g, r = t == null ? void 0 : t.matchAll(e);
  return Array.from(r ?? [], (n) => n[1]);
}
const tS = (t) => {
  var e;
  return t ? !!Object.keys(((e = t == null ? void 0 : t.components) == null ? void 0 : e.schemas) ?? {}).length : !1;
}, qR = (t) => {
  var e;
  return !!Object.keys(((e = t == null ? void 0 : t.components) == null ? void 0 : e.securitySchemes) ?? {}).length;
}, NR = (t) => t ? !!Object.keys((t == null ? void 0 : t.webhooks) ?? {}).length : !1;
function DR(t) {
  try {
    return !!new URL(t);
  } catch {
    return !1;
  }
}
function zR(t, e) {
  const r = function(i, s, o) {
    let a = "";
    if (i instanceof Array)
      for (let l = 0, c = i.length; l < c; l++)
        a += o + r(i[l], s, o + "	") + `
`;
    else if (typeof i == "object") {
      let l = !1;
      a += o + "<" + s;
      for (const c in i)
        c.charAt(0) == "@" ? a += " " + c.substr(1) + '="' + i[c].toString() + '"' : l = !0;
      if (a += l ? ">" : "/>", l) {
        for (const c in i)
          c == "#text" ? a += i[c] : c == "#cdata" ? a += "<![CDATA[" + i[c] + "]]>" : c.charAt(0) != "@" && (a += r(i[c], c, o + "	"));
        a += (a.charAt(a.length - 1) == `
` ? o : "") + "</" + s + ">";
      }
    } else
      a += o + "<" + s + ">" + i.toString() + "</" + s + ">";
    return a;
  };
  let n = "";
  for (const i in t)
    n += r(t[i], i, "");
  return e ? n.replace(/\t/g, e) : n.replace(/\t|\n/g, "");
}
const XR = (t, e) => Object.keys(t).map((r) => ({
  [e ?? r]: r,
  value: t[r]
})), Dre = (t) => t.reduce((e, r) => ({
  ...e,
  ...r
}), {});
function WR(t, e) {
  return Object.keys(t).forEach((r) => {
    Object.hasOwn(e, r) || delete t[r];
  }), Object.assign(t, e), t;
}
const UR = () => ({
  securitySchemeKey: null,
  http: {
    basic: {
      username: "",
      password: ""
    },
    bearer: {
      token: ""
    }
  },
  apiKey: {
    token: ""
  },
  oAuth2: {
    clientId: "",
    scopes: []
  }
}), ip = vn(
  UR()
), VR = (t) => {
  Object.assign(ip, {
    ...ip,
    ...t
  });
}, LR = () => ({
  selectedServer: null,
  servers: [],
  variables: []
}), sp = vn(LR()), YR = (t) => {
  Object.assign(sp, {
    ...sp,
    ...t
  });
}, Ti = () => ({
  authentication: ip,
  setAuthentication: VR,
  server: sp,
  setServer: YR
}), { server: BR, authentication: FR } = Ti(), { toggleApiClient: HR } = Gp(), { setActiveRequest: GR, resetActiveResponse: KR } = pr();
function op(t) {
  const e = F$({
    serverState: BR,
    authenticationState: FR,
    operation: t
  });
  KR(), GR(e), HR(e, !0);
}
const wu = (t) => {
  try {
    return JSON.stringify(typeof t == "string" ? JSON.parse(t) : t, null, 2);
  } catch {
    return console.log("[prettyPrintJson] Error parsing JSON", t), t;
  }
}, rS = async (t) => {
  var e;
  (e = document.getElementById(t)) == null || e.scrollIntoView();
}, nS = (t) => new Promise((e) => setTimeout(e, t)), JR = Symbol("downloadSpec"), iS = Jb(JR);
function eI(t) {
  const e = yu(t), r = e ? new Blob([t], { type: "application/json" }) : new Blob([t], { type: "application/x-yaml" }), n = URL.createObjectURL(r), i = document.createElement("a");
  i.href = n, i.download = e ? "spec.json" : "spec.yaml", i.dispatchEvent(
    new MouseEvent("click", {
      bubbles: !0,
      cancelable: !0,
      view: window
    })
  ), setTimeout(() => {
    window.URL.revokeObjectURL(n), i.remove();
  }, 100);
}
function tI(t, e = 1) {
  const r = new RegExp(`^(?=#{${e}} )`, "m");
  return t.split(r).map((n) => n.trim()).filter(Boolean);
}
const sS = {
  toast: (t) => null
};
function rI(t) {
  sS.toast = t;
}
function oS() {
  return {
    initializeToasts: rI,
    toast: sS.toast
  };
}
const Xo = () => {
  const { toast: t } = oS();
  return {
    copyToClipboard: (r) => {
      navigator.clipboard.writeText(r).then(() => {
        t("Copied to the clipboard.", "info");
      });
    }
  };
}, Fn = ge(!1);
function nI() {
  const t = () => {
    var i, s;
    const n = typeof window < "u" ? (i = window.localStorage) == null ? void 0 : i.getItem("isDark") : null;
    return typeof n == "string" ? !!JSON.parse(n) : !!(typeof window < "u" && ((s = window == null ? void 0 : window.matchMedia("(prefers-color-scheme: dark)")) != null && s.matches));
  }, e = () => {
    var n;
    Fn.value = !Fn.value, typeof window < "u" && ((n = window == null ? void 0 : window.localStorage) == null || n.setItem("isDark", JSON.stringify(Fn.value)));
  };
  function r(n) {
    var i;
    Fn.value = n, typeof window < "u" && ((i = window == null ? void 0 : window.localStorage) == null || i.setItem("isDark", JSON.stringify(Fn.value)));
  }
  return Fn.value = t(), Ve(
    Fn,
    (n) => {
      typeof document > "u" || (document.body.classList.toggle("dark-mode", n), document.body.classList.toggle("light-mode", !n));
    },
    { immediate: !0 }
  ), {
    isDark: Fn,
    toggleDarkMode: e,
    setDarkMode: r
  };
}
const Ym = ge(""), ap = ge(!1), iI = (t) => t.slug ? `description/${t.slug}` : "", sI = (t, e) => {
  if (!t)
    return "webhooks";
  const r = Hp(t), n = encodeURIComponent(r);
  return `webhook/${e}/${n}`;
}, oI = (t) => {
  if (!t)
    return "models";
  const e = Hp(t);
  return `model/${encodeURIComponent(e)}`;
}, aI = (t, e) => `${aS(e)}/${t.httpVerb}${t.path}`, aS = ({ name: t }) => {
  const e = Hp(t);
  return `tag/${encodeURIComponent(e)}`;
}, lI = (t = Ym.value) => {
  var n;
  const e = (n = t.match(/(tag\/[^/]+)/)) == null ? void 0 : n[0], r = t.startsWith("model") ? "models" : "";
  return e ?? r;
}, ry = () => Ym.value = window.location.hash.replace(/^#/, ""), cI = () => Xn(async () => {
  ry(), window.onhashchange = async () => {
    ap.value = !1, ry(), rS(window.location.hash.replace(/^#/, "")), await nS(100), ap.value = !0;
  };
}), Jt = () => ({
  hash: Ym,
  getWebhookId: sI,
  getModelId: oI,
  getHeadingId: iI,
  getOperationId: aI,
  getSectionId: lI,
  getTagId: aS,
  isIntersectionEnabled: ap,
  enableHashListener: cI
});
function Bm(t) {
  return {
    parameterMap: fe(() => {
      var i;
      const r = ((i = t.operation.information) == null ? void 0 : i.parameters) ?? [], n = {
        path: [],
        query: [],
        header: [],
        body: [],
        formData: []
      };
      return t.operation.pathParameters && t.operation.pathParameters.forEach((s) => {
        s.in === "path" ? n.path.push(s) : s.in === "query" ? n.query.push(s) : s.in === "header" ? n.header.push(s) : s.in === "body" ? n.body.push(s) : s.in === "formData" && n.formData.push(s);
      }), r && r.forEach((s) => {
        s.in === "path" ? n.path.push(s) : s.in === "query" ? n.query.push(s) : s.in === "header" ? n.header.push(s) : s.in === "body" ? n.body.push(s) : s.in === "formData" && n.formData.push(s);
      }), n;
    })
  };
}
function uI(t) {
  const e = ge(null);
  return Xn(() => {
    e.value = t();
  }), e;
}
function Fm(t) {
  return { responses: fe(() => {
    if (!t.information)
      return [];
    const { responses: r } = t.information, n = [];
    return r && Object.keys(r).forEach((i) => {
      n.push({
        name: i,
        description: r[i].description
      });
    }), n;
  }) };
}
const {
  getHeadingId: dI,
  getModelId: ny,
  getOperationId: iy,
  getSectionId: fI,
  getTagId: lS,
  getWebhookId: Sf,
  hash: hI
} = Jt(), Tt = ge(void 0), $u = vn({});
function pI(t) {
  $u[t] = !$u[t];
}
function kf(t, e) {
  $u[t] = e;
}
const cS = ge([]), mI = async (t) => {
  const e = await vu(t), r = G$(e);
  return e.filter((n) => n.depth === r);
}, uS = fe(() => {
  var l, c, u, d, f, h, p, g, m, y;
  const { state: t } = Gp(), e = {}, r = cS.value.map((O) => ({
    id: dI(O),
    title: O.value.toUpperCase(),
    show: !t.showApiClient
  })), n = (c = (l = Tt.value) == null ? void 0 : l.tags) == null ? void 0 : c[0], s = n && ((O) => (O == null ? void 0 : O.length) !== 1 || O[0].name !== "default" || O[0].description !== "")((u = Tt.value) == null ? void 0 : u.tags) && ((d = n.operations) == null ? void 0 : d.length) > 0 ? (h = (f = Tt.value) == null ? void 0 : f.tags) == null ? void 0 : h.map((O) => {
    var b;
    return {
      id: lS(O),
      title: O.name.toUpperCase(),
      show: !0,
      children: (b = O.operations) == null ? void 0 : b.map((w) => {
        var _;
        const S = iy(w, O), $ = w.name ?? w.path;
        return e[S] = $, {
          id: S,
          title: $,
          httpVerb: w.httpVerb,
          deprecated: ((_ = w.information) == null ? void 0 : _.deprecated) ?? !1,
          show: !0,
          select: () => {
            t.showApiClient && op(w);
          }
        };
      })
    };
  }) : (p = n == null ? void 0 : n.operations) == null ? void 0 : p.map((O) => {
    var S;
    const b = iy(O, n), w = O.name ?? O.path;
    return e[b] = w, {
      id: b,
      title: w,
      httpVerb: O.httpVerb,
      deprecated: ((S = O.information) == null ? void 0 : S.deprecated) ?? !1,
      show: !0,
      select: () => {
        t.showApiClient && op(O);
      }
    };
  }), o = NR(Tt.value) ? [
    {
      id: Sf(),
      title: "WEBHOOKS",
      show: !t.showApiClient,
      children: Object.keys(((g = Tt.value) == null ? void 0 : g.webhooks) ?? {}).map((O) => {
        var w, S;
        const b = Sf(O);
        return e[b] = O, Object.keys(
          ((S = (w = Tt.value) == null ? void 0 : w.webhooks) == null ? void 0 : S[O]) ?? {}
        ).map(($) => {
          var _, Q, N;
          return {
            id: Sf(O, $),
            title: (N = (Q = (_ = Tt.value) == null ? void 0 : _.webhooks) == null ? void 0 : Q[O][$]) == null ? void 0 : N.name,
            httpVerb: $,
            show: !t.showApiClient
          };
        });
      }).flat()
    }
  ] : [], a = tS(Tt.value) ? [
    {
      id: ny(),
      title: "MODELS",
      show: !t.showApiClient,
      children: Object.keys(
        ((y = (m = Tt.value) == null ? void 0 : m.components) == null ? void 0 : y.schemas) ?? {}
      ).map((O) => {
        var w, S, $;
        const b = ny(O);
        return e[b] = O, {
          id: b,
          title: (($ = (S = (w = Tt == null ? void 0 : Tt.value) == null ? void 0 : w.components) == null ? void 0 : S.schemas) == null ? void 0 : $[O]).title ?? O,
          show: !t.showApiClient
        };
      })
    }
  ] : [];
  return {
    entries: [
      ...r,
      ...s ?? [],
      ...o,
      ...a
    ],
    titles: e
  };
}), gI = fe(() => {
  var t, e;
  return ((e = (t = uS.value) == null ? void 0 : t.titles) == null ? void 0 : e[hI.value]) ?? "";
});
function Un(t) {
  return t != null && t.parsedSpec && (Tt.value = t.parsedSpec, Ve(
    () => {
      var e, r;
      return (r = (e = Tt.value) == null ? void 0 : e.tags) == null ? void 0 : r.length;
    },
    () => {
      var e, r;
      if (window != null && window.location.hash) {
        const n = fI(window.location.hash);
        n || kf(n, !0);
      } else {
        const n = (r = (e = Tt.value) == null ? void 0 : e.tags) == null ? void 0 : r[0];
        n && kf(lS(n), !0);
      }
    }
  ), Ve(
    () => {
      var e, r;
      return (r = (e = Tt.value) == null ? void 0 : e.info) == null ? void 0 : r.description;
    },
    async () => {
      var r, n;
      const e = (n = (r = Tt.value) == null ? void 0 : r.info) == null ? void 0 : n.description;
      return e ? cS.value = await mI(e) : [];
    }
  )), {
    breadcrumb: gI,
    items: uS,
    collapsedSidebarItems: $u,
    toggleCollapsedSidebarItem: pI,
    setCollapsedSidebarItem: kf
  };
}
const OI = ["unirest"], lp = ge([...OI]), yI = w3().map((t) => (t.key === "node" && (t.default = "undici", t.clients.unshift({
  description: "An HTTP/1.1 client, written from scratch for Node.js.",
  key: "undici",
  link: "https://github.com/nodejs/undici",
  title: "undici"
})), t.clients = t.clients.filter(
  (e) => !lp.value.includes(e.key)
), t)).filter((t) => t.clients.length);
function xl() {
  return {
    availableTargets: fe(() => yI),
    excludedClients: Yp(lp),
    setExcludedClients: (e) => lp.value = e
  };
}
typeof window < "u" && (window.process = window.process || {
  platform: "browser",
  browser: !0
});
var ys = {}, Hm = {}, bI = function(e) {
  return e && typeof e == "object" && typeof e.copy == "function" && typeof e.fill == "function" && typeof e.readUInt8 == "function";
}, cp = { exports: {} };
typeof Object.create == "function" ? cp.exports = function(e, r) {
  e.super_ = r, e.prototype = Object.create(r.prototype, {
    constructor: {
      value: e,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  });
} : cp.exports = function(e, r) {
  e.super_ = r;
  var n = function() {
  };
  n.prototype = r.prototype, e.prototype = new n(), e.prototype.constructor = e;
};
var vI = cp.exports;
(function(t) {
  var e = /%[sdj%]/g;
  t.format = function(X) {
    if (!b(X)) {
      for (var F = [], K = 0; K < arguments.length; K++)
        F.push(i(arguments[K]));
      return F.join(" ");
    }
    for (var K = 1, z = arguments, R = z.length, D = String(X).replace(e, function(P) {
      if (P === "%%")
        return "%";
      if (K >= R)
        return P;
      switch (P) {
        case "%s":
          return String(z[K++]);
        case "%d":
          return Number(z[K++]);
        case "%j":
          try {
            return JSON.stringify(z[K++]);
          } catch {
            return "[Circular]";
          }
        default:
          return P;
      }
    }), M = z[K]; K < R; M = z[++K])
      m(M) || !_(M) ? D += " " + M : D += " " + i(M);
    return D;
  }, t.deprecate = function(X, F) {
    if (S(pi.process))
      return function() {
        return t.deprecate(X, F).apply(this, arguments);
      };
    if (process.noDeprecation === !0)
      return X;
    var K = !1;
    function z() {
      if (!K) {
        if (process.throwDeprecation)
          throw new Error(F);
        process.traceDeprecation ? console.trace(F) : console.error(F), K = !0;
      }
      return X.apply(this, arguments);
    }
    return z;
  };
  var r = {}, n;
  t.debuglog = function(X) {
    if (S(n) && (n = process.env.NODE_DEBUG || ""), X = X.toUpperCase(), !r[X])
      if (new RegExp("\\b" + X + "\\b", "i").test(n)) {
        var F = process.pid;
        r[X] = function() {
          var K = t.format.apply(t, arguments);
          console.error("%s %d: %s", X, F, K);
        };
      } else
        r[X] = function() {
        };
    return r[X];
  };
  function i(X, F) {
    var K = {
      seen: [],
      stylize: o
    };
    return arguments.length >= 3 && (K.depth = arguments[2]), arguments.length >= 4 && (K.colors = arguments[3]), g(F) ? K.showHidden = F : F && t._extend(K, F), S(K.showHidden) && (K.showHidden = !1), S(K.depth) && (K.depth = 2), S(K.colors) && (K.colors = !1), S(K.customInspect) && (K.customInspect = !0), K.colors && (K.stylize = s), l(K, X, K.depth);
  }
  t.inspect = i, i.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, i.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function s(X, F) {
    var K = i.styles[F];
    return K ? "\x1B[" + i.colors[K][0] + "m" + X + "\x1B[" + i.colors[K][1] + "m" : X;
  }
  function o(X, F) {
    return X;
  }
  function a(X) {
    var F = {};
    return X.forEach(function(K, z) {
      F[K] = !0;
    }), F;
  }
  function l(X, F, K) {
    if (X.customInspect && F && B(F.inspect) && // Filter out the util module, it's inspect function is special
    F.inspect !== t.inspect && // Also filter out any prototype objects using the circular check.
    !(F.constructor && F.constructor.prototype === F)) {
      var z = F.inspect(K, X);
      return b(z) || (z = l(X, z, K)), z;
    }
    var R = c(X, F);
    if (R)
      return R;
    var D = Object.keys(F), M = a(D);
    if (X.showHidden && (D = Object.getOwnPropertyNames(F)), N(F) && (D.indexOf("message") >= 0 || D.indexOf("description") >= 0))
      return u(F);
    if (D.length === 0) {
      if (B(F)) {
        var P = F.name ? ": " + F.name : "";
        return X.stylize("[Function" + P + "]", "special");
      }
      if ($(F))
        return X.stylize(RegExp.prototype.toString.call(F), "regexp");
      if (Q(F))
        return X.stylize(Date.prototype.toString.call(F), "date");
      if (N(F))
        return u(F);
    }
    var A = "", W = !1, ne = ["{", "}"];
    if (p(F) && (W = !0, ne = ["[", "]"]), B(F)) {
      var ie = F.name ? ": " + F.name : "";
      A = " [Function" + ie + "]";
    }
    if ($(F) && (A = " " + RegExp.prototype.toString.call(F)), Q(F) && (A = " " + Date.prototype.toUTCString.call(F)), N(F) && (A = " " + u(F)), D.length === 0 && (!W || F.length == 0))
      return ne[0] + A + ne[1];
    if (K < 0)
      return $(F) ? X.stylize(RegExp.prototype.toString.call(F), "regexp") : X.stylize("[Object]", "special");
    X.seen.push(F);
    var Oe;
    return W ? Oe = d(X, F, K, M, D) : Oe = D.map(function(ve) {
      return f(X, F, K, M, ve, W);
    }), X.seen.pop(), h(Oe, A, ne);
  }
  function c(X, F) {
    if (S(F))
      return X.stylize("undefined", "undefined");
    if (b(F)) {
      var K = "'" + JSON.stringify(F).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return X.stylize(K, "string");
    }
    if (O(F))
      return X.stylize("" + F, "number");
    if (g(F))
      return X.stylize("" + F, "boolean");
    if (m(F))
      return X.stylize("null", "null");
  }
  function u(X) {
    return "[" + Error.prototype.toString.call(X) + "]";
  }
  function d(X, F, K, z, R) {
    for (var D = [], M = 0, P = F.length; M < P; ++M)
      Ce(F, String(M)) ? D.push(f(
        X,
        F,
        K,
        z,
        String(M),
        !0
      )) : D.push("");
    return R.forEach(function(A) {
      A.match(/^\d+$/) || D.push(f(
        X,
        F,
        K,
        z,
        A,
        !0
      ));
    }), D;
  }
  function f(X, F, K, z, R, D) {
    var M, P, A;
    if (A = Object.getOwnPropertyDescriptor(F, R) || { value: F[R] }, A.get ? A.set ? P = X.stylize("[Getter/Setter]", "special") : P = X.stylize("[Getter]", "special") : A.set && (P = X.stylize("[Setter]", "special")), Ce(z, R) || (M = "[" + R + "]"), P || (X.seen.indexOf(A.value) < 0 ? (m(K) ? P = l(X, A.value, null) : P = l(X, A.value, K - 1), P.indexOf(`
`) > -1 && (D ? P = P.split(`
`).map(function(W) {
      return "  " + W;
    }).join(`
`).substr(2) : P = `
` + P.split(`
`).map(function(W) {
      return "   " + W;
    }).join(`
`))) : P = X.stylize("[Circular]", "special")), S(M)) {
      if (D && R.match(/^\d+$/))
        return P;
      M = JSON.stringify("" + R), M.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (M = M.substr(1, M.length - 2), M = X.stylize(M, "name")) : (M = M.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), M = X.stylize(M, "string"));
    }
    return M + ": " + P;
  }
  function h(X, F, K) {
    var z = X.reduce(function(R, D) {
      return D.indexOf(`
`) >= 0, R + D.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return z > 60 ? K[0] + (F === "" ? "" : F + `
 `) + " " + X.join(`,
  `) + " " + K[1] : K[0] + F + " " + X.join(", ") + " " + K[1];
  }
  function p(X) {
    return Array.isArray(X);
  }
  t.isArray = p;
  function g(X) {
    return typeof X == "boolean";
  }
  t.isBoolean = g;
  function m(X) {
    return X === null;
  }
  t.isNull = m;
  function y(X) {
    return X == null;
  }
  t.isNullOrUndefined = y;
  function O(X) {
    return typeof X == "number";
  }
  t.isNumber = O;
  function b(X) {
    return typeof X == "string";
  }
  t.isString = b;
  function w(X) {
    return typeof X == "symbol";
  }
  t.isSymbol = w;
  function S(X) {
    return X === void 0;
  }
  t.isUndefined = S;
  function $(X) {
    return _(X) && U(X) === "[object RegExp]";
  }
  t.isRegExp = $;
  function _(X) {
    return typeof X == "object" && X !== null;
  }
  t.isObject = _;
  function Q(X) {
    return _(X) && U(X) === "[object Date]";
  }
  t.isDate = Q;
  function N(X) {
    return _(X) && (U(X) === "[object Error]" || X instanceof Error);
  }
  t.isError = N;
  function B(X) {
    return typeof X == "function";
  }
  t.isFunction = B;
  function J(X) {
    return X === null || typeof X == "boolean" || typeof X == "number" || typeof X == "string" || typeof X == "symbol" || // ES6 symbol
    typeof X > "u";
  }
  t.isPrimitive = J, t.isBuffer = bI;
  function U(X) {
    return Object.prototype.toString.call(X);
  }
  function ue(X) {
    return X < 10 ? "0" + X.toString(10) : X.toString(10);
  }
  var le = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function Pe() {
    var X = /* @__PURE__ */ new Date(), F = [
      ue(X.getHours()),
      ue(X.getMinutes()),
      ue(X.getSeconds())
    ].join(":");
    return [X.getDate(), le[X.getMonth()], F].join(" ");
  }
  t.log = function() {
    console.log("%s - %s", Pe(), t.format.apply(t, arguments));
  }, t.inherits = vI, t._extend = function(X, F) {
    if (!F || !_(F))
      return X;
    for (var K = Object.keys(F), z = K.length; z--; )
      X[K[z]] = F[K[z]];
    return X;
  };
  function Ce(X, F) {
    return Object.prototype.hasOwnProperty.call(X, F);
  }
})(Hm);
var up = { exports: {} }, hs = {}, Su = { exports: {} };
/*! https://mths.be/punycode v1.4.1 by @mathias */
Su.exports;
(function(t, e) {
  (function(r) {
    var n = e && !e.nodeType && e, i = t && !t.nodeType && t, s = typeof pi == "object" && pi;
    (s.global === s || s.window === s || s.self === s) && (r = s);
    var o, a = 2147483647, l = 36, c = 1, u = 26, d = 38, f = 700, h = 72, p = 128, g = "-", m = /^xn--/, y = /[^\x20-\x7E]/, O = /[\x2E\u3002\uFF0E\uFF61]/g, b = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, w = l - c, S = Math.floor, $ = String.fromCharCode, _;
    function Q(z) {
      throw new RangeError(b[z]);
    }
    function N(z, R) {
      for (var D = z.length, M = []; D--; )
        M[D] = R(z[D]);
      return M;
    }
    function B(z, R) {
      var D = z.split("@"), M = "";
      D.length > 1 && (M = D[0] + "@", z = D[1]), z = z.replace(O, ".");
      var P = z.split("."), A = N(P, R).join(".");
      return M + A;
    }
    function J(z) {
      for (var R = [], D = 0, M = z.length, P, A; D < M; )
        P = z.charCodeAt(D++), P >= 55296 && P <= 56319 && D < M ? (A = z.charCodeAt(D++), (A & 64512) == 56320 ? R.push(((P & 1023) << 10) + (A & 1023) + 65536) : (R.push(P), D--)) : R.push(P);
      return R;
    }
    function U(z) {
      return N(z, function(R) {
        var D = "";
        return R > 65535 && (R -= 65536, D += $(R >>> 10 & 1023 | 55296), R = 56320 | R & 1023), D += $(R), D;
      }).join("");
    }
    function ue(z) {
      return z - 48 < 10 ? z - 22 : z - 65 < 26 ? z - 65 : z - 97 < 26 ? z - 97 : l;
    }
    function le(z, R) {
      return z + 22 + 75 * (z < 26) - ((R != 0) << 5);
    }
    function Pe(z, R, D) {
      var M = 0;
      for (z = D ? S(z / f) : z >> 1, z += S(z / R); z > w * u >> 1; M += l)
        z = S(z / w);
      return S(M + (w + 1) * z / (z + d));
    }
    function Ce(z) {
      var R = [], D = z.length, M, P = 0, A = p, W = h, ne, ie, Oe, ve, xe, Fe, st, er, or;
      for (ne = z.lastIndexOf(g), ne < 0 && (ne = 0), ie = 0; ie < ne; ++ie)
        z.charCodeAt(ie) >= 128 && Q("not-basic"), R.push(z.charCodeAt(ie));
      for (Oe = ne > 0 ? ne + 1 : 0; Oe < D; ) {
        for (ve = P, xe = 1, Fe = l; Oe >= D && Q("invalid-input"), st = ue(z.charCodeAt(Oe++)), (st >= l || st > S((a - P) / xe)) && Q("overflow"), P += st * xe, er = Fe <= W ? c : Fe >= W + u ? u : Fe - W, !(st < er); Fe += l)
          or = l - er, xe > S(a / or) && Q("overflow"), xe *= or;
        M = R.length + 1, W = Pe(P - ve, M, ve == 0), S(P / M) > a - A && Q("overflow"), A += S(P / M), P %= M, R.splice(P++, 0, A);
      }
      return U(R);
    }
    function X(z) {
      var R, D, M, P, A, W, ne, ie, Oe, ve, xe, Fe = [], st, er, or, kt;
      for (z = J(z), st = z.length, R = p, D = 0, A = h, W = 0; W < st; ++W)
        xe = z[W], xe < 128 && Fe.push($(xe));
      for (M = P = Fe.length, P && Fe.push(g); M < st; ) {
        for (ne = a, W = 0; W < st; ++W)
          xe = z[W], xe >= R && xe < ne && (ne = xe);
        for (er = M + 1, ne - R > S((a - D) / er) && Q("overflow"), D += (ne - R) * er, R = ne, W = 0; W < st; ++W)
          if (xe = z[W], xe < R && ++D > a && Q("overflow"), xe == R) {
            for (ie = D, Oe = l; ve = Oe <= A ? c : Oe >= A + u ? u : Oe - A, !(ie < ve); Oe += l)
              kt = ie - ve, or = l - ve, Fe.push(
                $(le(ve + kt % or, 0))
              ), ie = S(kt / or);
            Fe.push($(le(ie, 0))), A = Pe(D, er, M == P), D = 0, ++M;
          }
        ++D, ++R;
      }
      return Fe.join("");
    }
    function F(z) {
      return B(z, function(R) {
        return m.test(R) ? Ce(R.slice(4).toLowerCase()) : R;
      });
    }
    function K(z) {
      return B(z, function(R) {
        return y.test(R) ? "xn--" + X(R) : R;
      });
    }
    if (o = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      version: "1.4.1",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      ucs2: {
        decode: J,
        encode: U
      },
      decode: Ce,
      encode: X,
      toASCII: K,
      toUnicode: F
    }, n && i)
      if (t.exports == n)
        i.exports = o;
      else
        for (_ in o)
          o.hasOwnProperty(_) && (n[_] = o[_]);
    else
      r.punycode = o;
  })(pi);
})(Su, Su.exports);
var wI = Su.exports, $I = Error, SI = EvalError, kI = RangeError, _I = ReferenceError, dS = SyntaxError, Tl = TypeError, PI = URIError, xI = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var e = {}, r = Symbol("test"), n = Object(r);
  if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(n) !== "[object Symbol]")
    return !1;
  var i = 42;
  e[r] = i;
  for (r in e)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0)
    return !1;
  var s = Object.getOwnPropertySymbols(e);
  if (s.length !== 1 || s[0] !== r || !Object.prototype.propertyIsEnumerable.call(e, r))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var o = Object.getOwnPropertyDescriptor(e, r);
    if (o.value !== i || o.enumerable !== !0)
      return !1;
  }
  return !0;
}, sy = typeof Symbol < "u" && Symbol, TI = xI, CI = function() {
  return typeof sy != "function" || typeof Symbol != "function" || typeof sy("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : TI();
}, _f = {
  __proto__: null,
  foo: {}
}, QI = Object, AI = function() {
  return { __proto__: _f }.foo === _f.foo && !(_f instanceof QI);
}, EI = "Function.prototype.bind called on incompatible ", RI = Object.prototype.toString, II = Math.max, jI = "[object Function]", oy = function(e, r) {
  for (var n = [], i = 0; i < e.length; i += 1)
    n[i] = e[i];
  for (var s = 0; s < r.length; s += 1)
    n[s + e.length] = r[s];
  return n;
}, ZI = function(e, r) {
  for (var n = [], i = r || 0, s = 0; i < e.length; i += 1, s += 1)
    n[s] = e[i];
  return n;
}, MI = function(t, e) {
  for (var r = "", n = 0; n < t.length; n += 1)
    r += t[n], n + 1 < t.length && (r += e);
  return r;
}, qI = function(e) {
  var r = this;
  if (typeof r != "function" || RI.apply(r) !== jI)
    throw new TypeError(EI + r);
  for (var n = ZI(arguments, 1), i, s = function() {
    if (this instanceof i) {
      var u = r.apply(
        this,
        oy(n, arguments)
      );
      return Object(u) === u ? u : this;
    }
    return r.apply(
      e,
      oy(n, arguments)
    );
  }, o = II(0, r.length - n.length), a = [], l = 0; l < o; l++)
    a[l] = "$" + l;
  if (i = Function("binder", "return function (" + MI(a, ",") + "){ return binder.apply(this,arguments); }")(s), r.prototype) {
    var c = function() {
    };
    c.prototype = r.prototype, i.prototype = new c(), c.prototype = null;
  }
  return i;
}, NI = qI, Gm = Function.prototype.bind || NI, DI = Function.prototype.call, zI = Object.prototype.hasOwnProperty, XI = Gm, WI = XI.call(DI, zI), Me, UI = $I, VI = SI, LI = kI, YI = _I, So = dS, ao = Tl, BI = PI, fS = Function, Pf = function(t) {
  try {
    return fS('"use strict"; return (' + t + ").constructor;")();
  } catch {
  }
}, is = Object.getOwnPropertyDescriptor;
if (is)
  try {
    is({}, "");
  } catch {
    is = null;
  }
var xf = function() {
  throw new ao();
}, FI = is ? function() {
  try {
    return arguments.callee, xf;
  } catch {
    try {
      return is(arguments, "callee").get;
    } catch {
      return xf;
    }
  }
}() : xf, Es = CI(), HI = AI(), vt = Object.getPrototypeOf || (HI ? function(t) {
  return t.__proto__;
} : null), Ns = {}, GI = typeof Uint8Array > "u" || !vt ? Me : vt(Uint8Array), ss = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? Me : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? Me : ArrayBuffer,
  "%ArrayIteratorPrototype%": Es && vt ? vt([][Symbol.iterator]()) : Me,
  "%AsyncFromSyncIteratorPrototype%": Me,
  "%AsyncFunction%": Ns,
  "%AsyncGenerator%": Ns,
  "%AsyncGeneratorFunction%": Ns,
  "%AsyncIteratorPrototype%": Ns,
  "%Atomics%": typeof Atomics > "u" ? Me : Atomics,
  "%BigInt%": typeof BigInt > "u" ? Me : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? Me : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? Me : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? Me : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": UI,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": VI,
  "%Float32Array%": typeof Float32Array > "u" ? Me : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? Me : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? Me : FinalizationRegistry,
  "%Function%": fS,
  "%GeneratorFunction%": Ns,
  "%Int8Array%": typeof Int8Array > "u" ? Me : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? Me : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? Me : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": Es && vt ? vt(vt([][Symbol.iterator]())) : Me,
  "%JSON%": typeof JSON == "object" ? JSON : Me,
  "%Map%": typeof Map > "u" ? Me : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !Es || !vt ? Me : vt((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? Me : Promise,
  "%Proxy%": typeof Proxy > "u" ? Me : Proxy,
  "%RangeError%": LI,
  "%ReferenceError%": YI,
  "%Reflect%": typeof Reflect > "u" ? Me : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? Me : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !Es || !vt ? Me : vt((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? Me : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": Es && vt ? vt(""[Symbol.iterator]()) : Me,
  "%Symbol%": Es ? Symbol : Me,
  "%SyntaxError%": So,
  "%ThrowTypeError%": FI,
  "%TypedArray%": GI,
  "%TypeError%": ao,
  "%Uint8Array%": typeof Uint8Array > "u" ? Me : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? Me : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? Me : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? Me : Uint32Array,
  "%URIError%": BI,
  "%WeakMap%": typeof WeakMap > "u" ? Me : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? Me : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? Me : WeakSet
};
if (vt)
  try {
    null.error;
  } catch (t) {
    var KI = vt(vt(t));
    ss["%Error.prototype%"] = KI;
  }
var JI = function t(e) {
  var r;
  if (e === "%AsyncFunction%")
    r = Pf("async function () {}");
  else if (e === "%GeneratorFunction%")
    r = Pf("function* () {}");
  else if (e === "%AsyncGeneratorFunction%")
    r = Pf("async function* () {}");
  else if (e === "%AsyncGenerator%") {
    var n = t("%AsyncGeneratorFunction%");
    n && (r = n.prototype);
  } else if (e === "%AsyncIteratorPrototype%") {
    var i = t("%AsyncGenerator%");
    i && vt && (r = vt(i.prototype));
  }
  return ss[e] = r, r;
}, ay = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, Cl = Gm, ku = WI, ej = Cl.call(Function.call, Array.prototype.concat), tj = Cl.call(Function.apply, Array.prototype.splice), ly = Cl.call(Function.call, String.prototype.replace), _u = Cl.call(Function.call, String.prototype.slice), rj = Cl.call(Function.call, RegExp.prototype.exec), nj = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, ij = /\\(\\)?/g, sj = function(e) {
  var r = _u(e, 0, 1), n = _u(e, -1);
  if (r === "%" && n !== "%")
    throw new So("invalid intrinsic syntax, expected closing `%`");
  if (n === "%" && r !== "%")
    throw new So("invalid intrinsic syntax, expected opening `%`");
  var i = [];
  return ly(e, nj, function(s, o, a, l) {
    i[i.length] = a ? ly(l, ij, "$1") : o || s;
  }), i;
}, oj = function(e, r) {
  var n = e, i;
  if (ku(ay, n) && (i = ay[n], n = "%" + i[0] + "%"), ku(ss, n)) {
    var s = ss[n];
    if (s === Ns && (s = JI(n)), typeof s > "u" && !r)
      throw new ao("intrinsic " + e + " exists, but is not available. Please file an issue!");
    return {
      alias: i,
      name: n,
      value: s
    };
  }
  throw new So("intrinsic " + e + " does not exist!");
}, Wo = function(e, r) {
  if (typeof e != "string" || e.length === 0)
    throw new ao("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof r != "boolean")
    throw new ao('"allowMissing" argument must be a boolean');
  if (rj(/^%?[^%]*%?$/, e) === null)
    throw new So("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var n = sj(e), i = n.length > 0 ? n[0] : "", s = oj("%" + i + "%", r), o = s.name, a = s.value, l = !1, c = s.alias;
  c && (i = c[0], tj(n, ej([0, 1], c)));
  for (var u = 1, d = !0; u < n.length; u += 1) {
    var f = n[u], h = _u(f, 0, 1), p = _u(f, -1);
    if ((h === '"' || h === "'" || h === "`" || p === '"' || p === "'" || p === "`") && h !== p)
      throw new So("property names with quotes must have matching quotes");
    if ((f === "constructor" || !d) && (l = !0), i += "." + f, o = "%" + i + "%", ku(ss, o))
      a = ss[o];
    else if (a != null) {
      if (!(f in a)) {
        if (!r)
          throw new ao("base intrinsic for " + e + " exists, but the property is not available.");
        return;
      }
      if (is && u + 1 >= n.length) {
        var g = is(a, f);
        d = !!g, d && "get" in g && !("originalValue" in g.get) ? a = g.get : a = a[f];
      } else
        d = ku(a, f), a = a[f];
      d && !l && (ss[o] = a);
    }
  }
  return a;
}, hS = { exports: {} }, Tf, cy;
function Km() {
  if (cy)
    return Tf;
  cy = 1;
  var t = Wo, e = t("%Object.defineProperty%", !0) || !1;
  if (e)
    try {
      e({}, "a", { value: 1 });
    } catch {
      e = !1;
    }
  return Tf = e, Tf;
}
var aj = Wo, zc = aj("%Object.getOwnPropertyDescriptor%", !0);
if (zc)
  try {
    zc([], "length");
  } catch {
    zc = null;
  }
var pS = zc, uy = Km(), lj = dS, Rs = Tl, dy = pS, cj = function(e, r, n) {
  if (!e || typeof e != "object" && typeof e != "function")
    throw new Rs("`obj` must be an object or a function`");
  if (typeof r != "string" && typeof r != "symbol")
    throw new Rs("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new Rs("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new Rs("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new Rs("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new Rs("`loose`, if provided, must be a boolean");
  var i = arguments.length > 3 ? arguments[3] : null, s = arguments.length > 4 ? arguments[4] : null, o = arguments.length > 5 ? arguments[5] : null, a = arguments.length > 6 ? arguments[6] : !1, l = !!dy && dy(e, r);
  if (uy)
    uy(e, r, {
      configurable: o === null && l ? l.configurable : !o,
      enumerable: i === null && l ? l.enumerable : !i,
      value: n,
      writable: s === null && l ? l.writable : !s
    });
  else if (a || !i && !s && !o)
    e[r] = n;
  else
    throw new lj("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, dp = Km(), mS = function() {
  return !!dp;
};
mS.hasArrayLengthDefineBug = function() {
  if (!dp)
    return null;
  try {
    return dp([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var uj = mS, dj = Wo, fy = cj, fj = uj(), hy = pS, py = Tl, hj = dj("%Math.floor%"), pj = function(e, r) {
  if (typeof e != "function")
    throw new py("`fn` is not a function");
  if (typeof r != "number" || r < 0 || r > 4294967295 || hj(r) !== r)
    throw new py("`length` must be a positive 32-bit integer");
  var n = arguments.length > 2 && !!arguments[2], i = !0, s = !0;
  if ("length" in e && hy) {
    var o = hy(e, "length");
    o && !o.configurable && (i = !1), o && !o.writable && (s = !1);
  }
  return (i || s || !n) && (fj ? fy(
    /** @type {Parameters<define>[0]} */
    e,
    "length",
    r,
    !0,
    !0
  ) : fy(
    /** @type {Parameters<define>[0]} */
    e,
    "length",
    r
  )), e;
};
(function(t) {
  var e = Gm, r = Wo, n = pj, i = Tl, s = r("%Function.prototype.apply%"), o = r("%Function.prototype.call%"), a = r("%Reflect.apply%", !0) || e.call(o, s), l = Km(), c = r("%Math.max%");
  t.exports = function(f) {
    if (typeof f != "function")
      throw new i("a function is required");
    var h = a(e, o, arguments);
    return n(
      h,
      1 + c(0, f.length - (arguments.length - 1)),
      !0
    );
  };
  var u = function() {
    return a(e, s, arguments);
  };
  l ? l(t.exports, "apply", { value: u }) : t.exports.apply = u;
})(hS);
var mj = hS.exports, gS = Wo, OS = mj, gj = OS(gS("String.prototype.indexOf")), Oj = function(e, r) {
  var n = gS(e, !!r);
  return typeof n == "function" && gj(e, ".prototype.") > -1 ? OS(n) : n;
};
const yj = {}, bj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: yj
}, Symbol.toStringTag, { value: "Module" })), cd = /* @__PURE__ */ W$(bj);
var Jm = typeof Map == "function" && Map.prototype, Cf = Object.getOwnPropertyDescriptor && Jm ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, Pu = Jm && Cf && typeof Cf.get == "function" ? Cf.get : null, my = Jm && Map.prototype.forEach, eg = typeof Set == "function" && Set.prototype, Qf = Object.getOwnPropertyDescriptor && eg ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, xu = eg && Qf && typeof Qf.get == "function" ? Qf.get : null, gy = eg && Set.prototype.forEach, vj = typeof WeakMap == "function" && WeakMap.prototype, Ma = vj ? WeakMap.prototype.has : null, wj = typeof WeakSet == "function" && WeakSet.prototype, qa = wj ? WeakSet.prototype.has : null, $j = typeof WeakRef == "function" && WeakRef.prototype, Oy = $j ? WeakRef.prototype.deref : null, Sj = Boolean.prototype.valueOf, kj = Object.prototype.toString, _j = Function.prototype.toString, Pj = String.prototype.match, tg = String.prototype.slice, li = String.prototype.replace, xj = String.prototype.toUpperCase, yy = String.prototype.toLowerCase, yS = RegExp.prototype.test, by = Array.prototype.concat, ln = Array.prototype.join, Tj = Array.prototype.slice, vy = Math.floor, fp = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, Af = Object.getOwnPropertySymbols, hp = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, ko = typeof Symbol == "function" && typeof Symbol.iterator == "object", Wt = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === ko || !0) ? Symbol.toStringTag : null, bS = Object.prototype.propertyIsEnumerable, wy = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(t) {
  return t.__proto__;
} : null);
function $y(t, e) {
  if (t === 1 / 0 || t === -1 / 0 || t !== t || t && t > -1e3 && t < 1e3 || yS.call(/e/, e))
    return e;
  var r = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof t == "number") {
    var n = t < 0 ? -vy(-t) : vy(t);
    if (n !== t) {
      var i = String(n), s = tg.call(e, i.length + 1);
      return li.call(i, r, "$&_") + "." + li.call(li.call(s, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return li.call(e, r, "$&_");
}
var pp = cd, Sy = pp.custom, ky = wS(Sy) ? Sy : null, Cj = function t(e, r, n, i) {
  var s = r || {};
  if (ni(s, "quoteStyle") && s.quoteStyle !== "single" && s.quoteStyle !== "double")
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  if (ni(s, "maxStringLength") && (typeof s.maxStringLength == "number" ? s.maxStringLength < 0 && s.maxStringLength !== 1 / 0 : s.maxStringLength !== null))
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  var o = ni(s, "customInspect") ? s.customInspect : !0;
  if (typeof o != "boolean" && o !== "symbol")
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  if (ni(s, "indent") && s.indent !== null && s.indent !== "	" && !(parseInt(s.indent, 10) === s.indent && s.indent > 0))
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  if (ni(s, "numericSeparator") && typeof s.numericSeparator != "boolean")
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  var a = s.numericSeparator;
  if (typeof e > "u")
    return "undefined";
  if (e === null)
    return "null";
  if (typeof e == "boolean")
    return e ? "true" : "false";
  if (typeof e == "string")
    return SS(e, s);
  if (typeof e == "number") {
    if (e === 0)
      return 1 / 0 / e > 0 ? "0" : "-0";
    var l = String(e);
    return a ? $y(e, l) : l;
  }
  if (typeof e == "bigint") {
    var c = String(e) + "n";
    return a ? $y(e, c) : c;
  }
  var u = typeof s.depth > "u" ? 5 : s.depth;
  if (typeof n > "u" && (n = 0), n >= u && u > 0 && typeof e == "object")
    return mp(e) ? "[Array]" : "[Object]";
  var d = Yj(s, n);
  if (typeof i > "u")
    i = [];
  else if ($S(i, e) >= 0)
    return "[Circular]";
  function f(ue, le, Pe) {
    if (le && (i = Tj.call(i), i.push(le)), Pe) {
      var Ce = {
        depth: s.depth
      };
      return ni(s, "quoteStyle") && (Ce.quoteStyle = s.quoteStyle), t(ue, Ce, n + 1, i);
    }
    return t(ue, s, n + 1, i);
  }
  if (typeof e == "function" && !_y(e)) {
    var h = qj(e), p = gc(e, f);
    return "[Function" + (h ? ": " + h : " (anonymous)") + "]" + (p.length > 0 ? " { " + ln.call(p, ", ") + " }" : "");
  }
  if (wS(e)) {
    var g = ko ? li.call(String(e), /^(Symbol\(.*\))_[^)]*$/, "$1") : hp.call(e);
    return typeof e == "object" && !ko ? ma(g) : g;
  }
  if (Uj(e)) {
    for (var m = "<" + yy.call(String(e.nodeName)), y = e.attributes || [], O = 0; O < y.length; O++)
      m += " " + y[O].name + "=" + vS(Qj(y[O].value), "double", s);
    return m += ">", e.childNodes && e.childNodes.length && (m += "..."), m += "</" + yy.call(String(e.nodeName)) + ">", m;
  }
  if (mp(e)) {
    if (e.length === 0)
      return "[]";
    var b = gc(e, f);
    return d && !Lj(b) ? "[" + gp(b, d) + "]" : "[ " + ln.call(b, ", ") + " ]";
  }
  if (Ej(e)) {
    var w = gc(e, f);
    return !("cause" in Error.prototype) && "cause" in e && !bS.call(e, "cause") ? "{ [" + String(e) + "] " + ln.call(by.call("[cause]: " + f(e.cause), w), ", ") + " }" : w.length === 0 ? "[" + String(e) + "]" : "{ [" + String(e) + "] " + ln.call(w, ", ") + " }";
  }
  if (typeof e == "object" && o) {
    if (ky && typeof e[ky] == "function" && pp)
      return pp(e, { depth: u - n });
    if (o !== "symbol" && typeof e.inspect == "function")
      return e.inspect();
  }
  if (Nj(e)) {
    var S = [];
    return my && my.call(e, function(ue, le) {
      S.push(f(le, e, !0) + " => " + f(ue, e));
    }), Py("Map", Pu.call(e), S, d);
  }
  if (Xj(e)) {
    var $ = [];
    return gy && gy.call(e, function(ue) {
      $.push(f(ue, e));
    }), Py("Set", xu.call(e), $, d);
  }
  if (Dj(e))
    return Ef("WeakMap");
  if (Wj(e))
    return Ef("WeakSet");
  if (zj(e))
    return Ef("WeakRef");
  if (Ij(e))
    return ma(f(Number(e)));
  if (Zj(e))
    return ma(f(fp.call(e)));
  if (jj(e))
    return ma(Sj.call(e));
  if (Rj(e))
    return ma(f(String(e)));
  if (typeof window < "u" && e === window)
    return "{ [object Window] }";
  if (e === pi)
    return "{ [object globalThis] }";
  if (!Aj(e) && !_y(e)) {
    var _ = gc(e, f), Q = wy ? wy(e) === Object.prototype : e instanceof Object || e.constructor === Object, N = e instanceof Object ? "" : "null prototype", B = !Q && Wt && Object(e) === e && Wt in e ? tg.call(Ci(e), 8, -1) : N ? "Object" : "", J = Q || typeof e.constructor != "function" ? "" : e.constructor.name ? e.constructor.name + " " : "", U = J + (B || N ? "[" + ln.call(by.call([], B || [], N || []), ": ") + "] " : "");
    return _.length === 0 ? U + "{}" : d ? U + "{" + gp(_, d) + "}" : U + "{ " + ln.call(_, ", ") + " }";
  }
  return String(e);
};
function vS(t, e, r) {
  var n = (r.quoteStyle || e) === "double" ? '"' : "'";
  return n + t + n;
}
function Qj(t) {
  return li.call(String(t), /"/g, "&quot;");
}
function mp(t) {
  return Ci(t) === "[object Array]" && (!Wt || !(typeof t == "object" && Wt in t));
}
function Aj(t) {
  return Ci(t) === "[object Date]" && (!Wt || !(typeof t == "object" && Wt in t));
}
function _y(t) {
  return Ci(t) === "[object RegExp]" && (!Wt || !(typeof t == "object" && Wt in t));
}
function Ej(t) {
  return Ci(t) === "[object Error]" && (!Wt || !(typeof t == "object" && Wt in t));
}
function Rj(t) {
  return Ci(t) === "[object String]" && (!Wt || !(typeof t == "object" && Wt in t));
}
function Ij(t) {
  return Ci(t) === "[object Number]" && (!Wt || !(typeof t == "object" && Wt in t));
}
function jj(t) {
  return Ci(t) === "[object Boolean]" && (!Wt || !(typeof t == "object" && Wt in t));
}
function wS(t) {
  if (ko)
    return t && typeof t == "object" && t instanceof Symbol;
  if (typeof t == "symbol")
    return !0;
  if (!t || typeof t != "object" || !hp)
    return !1;
  try {
    return hp.call(t), !0;
  } catch {
  }
  return !1;
}
function Zj(t) {
  if (!t || typeof t != "object" || !fp)
    return !1;
  try {
    return fp.call(t), !0;
  } catch {
  }
  return !1;
}
var Mj = Object.prototype.hasOwnProperty || function(t) {
  return t in this;
};
function ni(t, e) {
  return Mj.call(t, e);
}
function Ci(t) {
  return kj.call(t);
}
function qj(t) {
  if (t.name)
    return t.name;
  var e = Pj.call(_j.call(t), /^function\s*([\w$]+)/);
  return e ? e[1] : null;
}
function $S(t, e) {
  if (t.indexOf)
    return t.indexOf(e);
  for (var r = 0, n = t.length; r < n; r++)
    if (t[r] === e)
      return r;
  return -1;
}
function Nj(t) {
  if (!Pu || !t || typeof t != "object")
    return !1;
  try {
    Pu.call(t);
    try {
      xu.call(t);
    } catch {
      return !0;
    }
    return t instanceof Map;
  } catch {
  }
  return !1;
}
function Dj(t) {
  if (!Ma || !t || typeof t != "object")
    return !1;
  try {
    Ma.call(t, Ma);
    try {
      qa.call(t, qa);
    } catch {
      return !0;
    }
    return t instanceof WeakMap;
  } catch {
  }
  return !1;
}
function zj(t) {
  if (!Oy || !t || typeof t != "object")
    return !1;
  try {
    return Oy.call(t), !0;
  } catch {
  }
  return !1;
}
function Xj(t) {
  if (!xu || !t || typeof t != "object")
    return !1;
  try {
    xu.call(t);
    try {
      Pu.call(t);
    } catch {
      return !0;
    }
    return t instanceof Set;
  } catch {
  }
  return !1;
}
function Wj(t) {
  if (!qa || !t || typeof t != "object")
    return !1;
  try {
    qa.call(t, qa);
    try {
      Ma.call(t, Ma);
    } catch {
      return !0;
    }
    return t instanceof WeakSet;
  } catch {
  }
  return !1;
}
function Uj(t) {
  return !t || typeof t != "object" ? !1 : typeof HTMLElement < "u" && t instanceof HTMLElement ? !0 : typeof t.nodeName == "string" && typeof t.getAttribute == "function";
}
function SS(t, e) {
  if (t.length > e.maxStringLength) {
    var r = t.length - e.maxStringLength, n = "... " + r + " more character" + (r > 1 ? "s" : "");
    return SS(tg.call(t, 0, e.maxStringLength), e) + n;
  }
  var i = li.call(li.call(t, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, Vj);
  return vS(i, "single", e);
}
function Vj(t) {
  var e = t.charCodeAt(0), r = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[e];
  return r ? "\\" + r : "\\x" + (e < 16 ? "0" : "") + xj.call(e.toString(16));
}
function ma(t) {
  return "Object(" + t + ")";
}
function Ef(t) {
  return t + " { ? }";
}
function Py(t, e, r, n) {
  var i = n ? gp(r, n) : ln.call(r, ", ");
  return t + " (" + e + ") {" + i + "}";
}
function Lj(t) {
  for (var e = 0; e < t.length; e++)
    if ($S(t[e], `
`) >= 0)
      return !1;
  return !0;
}
function Yj(t, e) {
  var r;
  if (t.indent === "	")
    r = "	";
  else if (typeof t.indent == "number" && t.indent > 0)
    r = ln.call(Array(t.indent + 1), " ");
  else
    return null;
  return {
    base: r,
    prev: ln.call(Array(e + 1), r)
  };
}
function gp(t, e) {
  if (t.length === 0)
    return "";
  var r = `
` + e.prev + e.base;
  return r + ln.call(t, "," + r) + `
` + e.prev;
}
function gc(t, e) {
  var r = mp(t), n = [];
  if (r) {
    n.length = t.length;
    for (var i = 0; i < t.length; i++)
      n[i] = ni(t, i) ? e(t[i], t) : "";
  }
  var s = typeof Af == "function" ? Af(t) : [], o;
  if (ko) {
    o = {};
    for (var a = 0; a < s.length; a++)
      o["$" + s[a]] = s[a];
  }
  for (var l in t)
    ni(t, l) && (r && String(Number(l)) === l && l < t.length || ko && o["$" + l] instanceof Symbol || (yS.call(/[^\w$]/, l) ? n.push(e(l, t) + ": " + e(t[l], t)) : n.push(l + ": " + e(t[l], t))));
  if (typeof Af == "function")
    for (var c = 0; c < s.length; c++)
      bS.call(t, s[c]) && n.push("[" + e(s[c]) + "]: " + e(t[s[c]], t));
  return n;
}
var kS = Wo, Uo = Oj, Bj = Cj, Fj = Tl, Oc = kS("%WeakMap%", !0), yc = kS("%Map%", !0), Hj = Uo("WeakMap.prototype.get", !0), Gj = Uo("WeakMap.prototype.set", !0), Kj = Uo("WeakMap.prototype.has", !0), Jj = Uo("Map.prototype.get", !0), eZ = Uo("Map.prototype.set", !0), tZ = Uo("Map.prototype.has", !0), rg = function(t, e) {
  for (var r = t, n; (n = r.next) !== null; r = n)
    if (n.key === e)
      return r.next = n.next, n.next = t.next, t.next = n, n;
}, rZ = function(t, e) {
  var r = rg(t, e);
  return r && r.value;
}, nZ = function(t, e, r) {
  var n = rg(t, e);
  n ? n.value = r : t.next = {
    // eslint-disable-line no-param-reassign
    key: e,
    next: t.next,
    value: r
  };
}, iZ = function(t, e) {
  return !!rg(t, e);
}, sZ = function() {
  var e, r, n, i = {
    assert: function(s) {
      if (!i.has(s))
        throw new Fj("Side channel does not contain " + Bj(s));
    },
    get: function(s) {
      if (Oc && s && (typeof s == "object" || typeof s == "function")) {
        if (e)
          return Hj(e, s);
      } else if (yc) {
        if (r)
          return Jj(r, s);
      } else if (n)
        return rZ(n, s);
    },
    has: function(s) {
      if (Oc && s && (typeof s == "object" || typeof s == "function")) {
        if (e)
          return Kj(e, s);
      } else if (yc) {
        if (r)
          return tZ(r, s);
      } else if (n)
        return iZ(n, s);
      return !1;
    },
    set: function(s, o) {
      Oc && s && (typeof s == "object" || typeof s == "function") ? (e || (e = new Oc()), Gj(e, s, o)) : yc ? (r || (r = new yc()), eZ(r, s, o)) : (n || (n = { key: {}, next: null }), nZ(n, s, o));
    }
  };
  return i;
}, oZ = String.prototype.replace, aZ = /%20/g, Rf = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
}, ng = {
  default: Rf.RFC3986,
  formatters: {
    RFC1738: function(t) {
      return oZ.call(t, aZ, "+");
    },
    RFC3986: function(t) {
      return String(t);
    }
  },
  RFC1738: Rf.RFC1738,
  RFC3986: Rf.RFC3986
}, lZ = ng, If = Object.prototype.hasOwnProperty, Ui = Array.isArray, sn = function() {
  for (var t = [], e = 0; e < 256; ++e)
    t.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
  return t;
}(), cZ = function(e) {
  for (; e.length > 1; ) {
    var r = e.pop(), n = r.obj[r.prop];
    if (Ui(n)) {
      for (var i = [], s = 0; s < n.length; ++s)
        typeof n[s] < "u" && i.push(n[s]);
      r.obj[r.prop] = i;
    }
  }
}, _S = function(e, r) {
  for (var n = r && r.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, i = 0; i < e.length; ++i)
    typeof e[i] < "u" && (n[i] = e[i]);
  return n;
}, uZ = function t(e, r, n) {
  if (!r)
    return e;
  if (typeof r != "object") {
    if (Ui(e))
      e.push(r);
    else if (e && typeof e == "object")
      (n && (n.plainObjects || n.allowPrototypes) || !If.call(Object.prototype, r)) && (e[r] = !0);
    else
      return [e, r];
    return e;
  }
  if (!e || typeof e != "object")
    return [e].concat(r);
  var i = e;
  return Ui(e) && !Ui(r) && (i = _S(e, n)), Ui(e) && Ui(r) ? (r.forEach(function(s, o) {
    if (If.call(e, o)) {
      var a = e[o];
      a && typeof a == "object" && s && typeof s == "object" ? e[o] = t(a, s, n) : e.push(s);
    } else
      e[o] = s;
  }), e) : Object.keys(r).reduce(function(s, o) {
    var a = r[o];
    return If.call(s, o) ? s[o] = t(s[o], a, n) : s[o] = a, s;
  }, i);
}, dZ = function(e, r) {
  return Object.keys(r).reduce(function(n, i) {
    return n[i] = r[i], n;
  }, e);
}, fZ = function(t, e, r) {
  var n = t.replace(/\+/g, " ");
  if (r === "iso-8859-1")
    return n.replace(/%[0-9a-f]{2}/gi, unescape);
  try {
    return decodeURIComponent(n);
  } catch {
    return n;
  }
}, hZ = function(e, r, n, i, s) {
  if (e.length === 0)
    return e;
  var o = e;
  if (typeof e == "symbol" ? o = Symbol.prototype.toString.call(e) : typeof e != "string" && (o = String(e)), n === "iso-8859-1")
    return escape(o).replace(/%u[0-9a-f]{4}/gi, function(u) {
      return "%26%23" + parseInt(u.slice(2), 16) + "%3B";
    });
  for (var a = "", l = 0; l < o.length; ++l) {
    var c = o.charCodeAt(l);
    if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || s === lZ.RFC1738 && (c === 40 || c === 41)) {
      a += o.charAt(l);
      continue;
    }
    if (c < 128) {
      a = a + sn[c];
      continue;
    }
    if (c < 2048) {
      a = a + (sn[192 | c >> 6] + sn[128 | c & 63]);
      continue;
    }
    if (c < 55296 || c >= 57344) {
      a = a + (sn[224 | c >> 12] + sn[128 | c >> 6 & 63] + sn[128 | c & 63]);
      continue;
    }
    l += 1, c = 65536 + ((c & 1023) << 10 | o.charCodeAt(l) & 1023), a += sn[240 | c >> 18] + sn[128 | c >> 12 & 63] + sn[128 | c >> 6 & 63] + sn[128 | c & 63];
  }
  return a;
}, pZ = function(e) {
  for (var r = [{ obj: { o: e }, prop: "o" }], n = [], i = 0; i < r.length; ++i)
    for (var s = r[i], o = s.obj[s.prop], a = Object.keys(o), l = 0; l < a.length; ++l) {
      var c = a[l], u = o[c];
      typeof u == "object" && u !== null && n.indexOf(u) === -1 && (r.push({ obj: o, prop: c }), n.push(u));
    }
  return cZ(r), e;
}, mZ = function(e) {
  return Object.prototype.toString.call(e) === "[object RegExp]";
}, gZ = function(e) {
  return !e || typeof e != "object" ? !1 : !!(e.constructor && e.constructor.isBuffer && e.constructor.isBuffer(e));
}, OZ = function(e, r) {
  return [].concat(e, r);
}, yZ = function(e, r) {
  if (Ui(e)) {
    for (var n = [], i = 0; i < e.length; i += 1)
      n.push(r(e[i]));
    return n;
  }
  return r(e);
}, PS = {
  arrayToObject: _S,
  assign: dZ,
  combine: OZ,
  compact: pZ,
  decode: fZ,
  encode: hZ,
  isBuffer: gZ,
  isRegExp: mZ,
  maybeMap: yZ,
  merge: uZ
}, xS = sZ, Xc = PS, Na = ng, bZ = Object.prototype.hasOwnProperty, xy = {
  brackets: function(e) {
    return e + "[]";
  },
  comma: "comma",
  indices: function(e, r) {
    return e + "[" + r + "]";
  },
  repeat: function(e) {
    return e;
  }
}, Cn = Array.isArray, vZ = Array.prototype.push, TS = function(t, e) {
  vZ.apply(t, Cn(e) ? e : [e]);
}, wZ = Date.prototype.toISOString, Ty = Na.default, jt = {
  addQueryPrefix: !1,
  allowDots: !1,
  charset: "utf-8",
  charsetSentinel: !1,
  delimiter: "&",
  encode: !0,
  encoder: Xc.encode,
  encodeValuesOnly: !1,
  format: Ty,
  formatter: Na.formatters[Ty],
  // deprecated
  indices: !1,
  serializeDate: function(e) {
    return wZ.call(e);
  },
  skipNulls: !1,
  strictNullHandling: !1
}, $Z = function(e) {
  return typeof e == "string" || typeof e == "number" || typeof e == "boolean" || typeof e == "symbol" || typeof e == "bigint";
}, jf = {}, SZ = function t(e, r, n, i, s, o, a, l, c, u, d, f, h, p, g, m) {
  for (var y = e, O = m, b = 0, w = !1; (O = O.get(jf)) !== void 0 && !w; ) {
    var S = O.get(e);
    if (b += 1, typeof S < "u") {
      if (S === b)
        throw new RangeError("Cyclic object value");
      w = !0;
    }
    typeof O.get(jf) > "u" && (b = 0);
  }
  if (typeof l == "function" ? y = l(r, y) : y instanceof Date ? y = d(y) : n === "comma" && Cn(y) && (y = Xc.maybeMap(y, function(Ce) {
    return Ce instanceof Date ? d(Ce) : Ce;
  })), y === null) {
    if (s)
      return a && !p ? a(r, jt.encoder, g, "key", f) : r;
    y = "";
  }
  if ($Z(y) || Xc.isBuffer(y)) {
    if (a) {
      var $ = p ? r : a(r, jt.encoder, g, "key", f);
      return [h($) + "=" + h(a(y, jt.encoder, g, "value", f))];
    }
    return [h(r) + "=" + h(String(y))];
  }
  var _ = [];
  if (typeof y > "u")
    return _;
  var Q;
  if (n === "comma" && Cn(y))
    p && a && (y = Xc.maybeMap(y, a)), Q = [{ value: y.length > 0 ? y.join(",") || null : void 0 }];
  else if (Cn(l))
    Q = l;
  else {
    var N = Object.keys(y);
    Q = c ? N.sort(c) : N;
  }
  for (var B = i && Cn(y) && y.length === 1 ? r + "[]" : r, J = 0; J < Q.length; ++J) {
    var U = Q[J], ue = typeof U == "object" && typeof U.value < "u" ? U.value : y[U];
    if (!(o && ue === null)) {
      var le = Cn(y) ? typeof n == "function" ? n(B, U) : B : B + (u ? "." + U : "[" + U + "]");
      m.set(e, b);
      var Pe = xS();
      Pe.set(jf, m), TS(_, t(
        ue,
        le,
        n,
        i,
        s,
        o,
        n === "comma" && p && Cn(y) ? null : a,
        l,
        c,
        u,
        d,
        f,
        h,
        p,
        g,
        Pe
      ));
    }
  }
  return _;
}, kZ = function(e) {
  if (!e)
    return jt;
  if (e.encoder !== null && typeof e.encoder < "u" && typeof e.encoder != "function")
    throw new TypeError("Encoder has to be a function.");
  var r = e.charset || jt.charset;
  if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  var n = Na.default;
  if (typeof e.format < "u") {
    if (!bZ.call(Na.formatters, e.format))
      throw new TypeError("Unknown format option provided.");
    n = e.format;
  }
  var i = Na.formatters[n], s = jt.filter;
  return (typeof e.filter == "function" || Cn(e.filter)) && (s = e.filter), {
    addQueryPrefix: typeof e.addQueryPrefix == "boolean" ? e.addQueryPrefix : jt.addQueryPrefix,
    allowDots: typeof e.allowDots > "u" ? jt.allowDots : !!e.allowDots,
    charset: r,
    charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : jt.charsetSentinel,
    delimiter: typeof e.delimiter > "u" ? jt.delimiter : e.delimiter,
    encode: typeof e.encode == "boolean" ? e.encode : jt.encode,
    encoder: typeof e.encoder == "function" ? e.encoder : jt.encoder,
    encodeValuesOnly: typeof e.encodeValuesOnly == "boolean" ? e.encodeValuesOnly : jt.encodeValuesOnly,
    filter: s,
    format: n,
    formatter: i,
    serializeDate: typeof e.serializeDate == "function" ? e.serializeDate : jt.serializeDate,
    skipNulls: typeof e.skipNulls == "boolean" ? e.skipNulls : jt.skipNulls,
    sort: typeof e.sort == "function" ? e.sort : null,
    strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : jt.strictNullHandling
  };
}, _Z = function(t, e) {
  var r = t, n = kZ(e), i, s;
  typeof n.filter == "function" ? (s = n.filter, r = s("", r)) : Cn(n.filter) && (s = n.filter, i = s);
  var o = [];
  if (typeof r != "object" || r === null)
    return "";
  var a;
  e && e.arrayFormat in xy ? a = e.arrayFormat : e && "indices" in e ? a = e.indices ? "indices" : "repeat" : a = "indices";
  var l = xy[a];
  if (e && "commaRoundTrip" in e && typeof e.commaRoundTrip != "boolean")
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  var c = l === "comma" && e && e.commaRoundTrip;
  i || (i = Object.keys(r)), n.sort && i.sort(n.sort);
  for (var u = xS(), d = 0; d < i.length; ++d) {
    var f = i[d];
    n.skipNulls && r[f] === null || TS(o, SZ(
      r[f],
      f,
      l,
      c,
      n.strictNullHandling,
      n.skipNulls,
      n.encode ? n.encoder : null,
      n.filter,
      n.sort,
      n.allowDots,
      n.serializeDate,
      n.format,
      n.formatter,
      n.encodeValuesOnly,
      n.charset,
      u
    ));
  }
  var h = o.join(n.delimiter), p = n.addQueryPrefix === !0 ? "?" : "";
  return n.charsetSentinel && (n.charset === "iso-8859-1" ? p += "utf8=%26%2310003%3B&" : p += "utf8=%E2%9C%93&"), h.length > 0 ? p + h : "";
}, _o = PS, Op = Object.prototype.hasOwnProperty, PZ = Array.isArray, bt = {
  allowDots: !1,
  allowPrototypes: !1,
  allowSparse: !1,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: !1,
  comma: !1,
  decoder: _o.decode,
  delimiter: "&",
  depth: 5,
  ignoreQueryPrefix: !1,
  interpretNumericEntities: !1,
  parameterLimit: 1e3,
  parseArrays: !0,
  plainObjects: !1,
  strictNullHandling: !1
}, xZ = function(t) {
  return t.replace(/&#(\d+);/g, function(e, r) {
    return String.fromCharCode(parseInt(r, 10));
  });
}, CS = function(t, e) {
  return t && typeof t == "string" && e.comma && t.indexOf(",") > -1 ? t.split(",") : t;
}, TZ = "utf8=%26%2310003%3B", CZ = "utf8=%E2%9C%93", QZ = function(e, r) {
  var n = { __proto__: null }, i = r.ignoreQueryPrefix ? e.replace(/^\?/, "") : e, s = r.parameterLimit === 1 / 0 ? void 0 : r.parameterLimit, o = i.split(r.delimiter, s), a = -1, l, c = r.charset;
  if (r.charsetSentinel)
    for (l = 0; l < o.length; ++l)
      o[l].indexOf("utf8=") === 0 && (o[l] === CZ ? c = "utf-8" : o[l] === TZ && (c = "iso-8859-1"), a = l, l = o.length);
  for (l = 0; l < o.length; ++l)
    if (l !== a) {
      var u = o[l], d = u.indexOf("]="), f = d === -1 ? u.indexOf("=") : d + 1, h, p;
      f === -1 ? (h = r.decoder(u, bt.decoder, c, "key"), p = r.strictNullHandling ? null : "") : (h = r.decoder(u.slice(0, f), bt.decoder, c, "key"), p = _o.maybeMap(
        CS(u.slice(f + 1), r),
        function(g) {
          return r.decoder(g, bt.decoder, c, "value");
        }
      )), p && r.interpretNumericEntities && c === "iso-8859-1" && (p = xZ(p)), u.indexOf("[]=") > -1 && (p = PZ(p) ? [p] : p), Op.call(n, h) ? n[h] = _o.combine(n[h], p) : n[h] = p;
    }
  return n;
}, AZ = function(t, e, r, n) {
  for (var i = n ? e : CS(e, r), s = t.length - 1; s >= 0; --s) {
    var o, a = t[s];
    if (a === "[]" && r.parseArrays)
      o = [].concat(i);
    else {
      o = r.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var l = a.charAt(0) === "[" && a.charAt(a.length - 1) === "]" ? a.slice(1, -1) : a, c = parseInt(l, 10);
      !r.parseArrays && l === "" ? o = { 0: i } : !isNaN(c) && a !== l && String(c) === l && c >= 0 && r.parseArrays && c <= r.arrayLimit ? (o = [], o[c] = i) : l !== "__proto__" && (o[l] = i);
    }
    i = o;
  }
  return i;
}, EZ = function(e, r, n, i) {
  if (e) {
    var s = n.allowDots ? e.replace(/\.([^.[]+)/g, "[$1]") : e, o = /(\[[^[\]]*])/, a = /(\[[^[\]]*])/g, l = n.depth > 0 && o.exec(s), c = l ? s.slice(0, l.index) : s, u = [];
    if (c) {
      if (!n.plainObjects && Op.call(Object.prototype, c) && !n.allowPrototypes)
        return;
      u.push(c);
    }
    for (var d = 0; n.depth > 0 && (l = a.exec(s)) !== null && d < n.depth; ) {
      if (d += 1, !n.plainObjects && Op.call(Object.prototype, l[1].slice(1, -1)) && !n.allowPrototypes)
        return;
      u.push(l[1]);
    }
    return l && u.push("[" + s.slice(l.index) + "]"), AZ(u, r, n, i);
  }
}, RZ = function(e) {
  if (!e)
    return bt;
  if (e.decoder !== null && e.decoder !== void 0 && typeof e.decoder != "function")
    throw new TypeError("Decoder has to be a function.");
  if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  var r = typeof e.charset > "u" ? bt.charset : e.charset;
  return {
    allowDots: typeof e.allowDots > "u" ? bt.allowDots : !!e.allowDots,
    allowPrototypes: typeof e.allowPrototypes == "boolean" ? e.allowPrototypes : bt.allowPrototypes,
    allowSparse: typeof e.allowSparse == "boolean" ? e.allowSparse : bt.allowSparse,
    arrayLimit: typeof e.arrayLimit == "number" ? e.arrayLimit : bt.arrayLimit,
    charset: r,
    charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : bt.charsetSentinel,
    comma: typeof e.comma == "boolean" ? e.comma : bt.comma,
    decoder: typeof e.decoder == "function" ? e.decoder : bt.decoder,
    delimiter: typeof e.delimiter == "string" || _o.isRegExp(e.delimiter) ? e.delimiter : bt.delimiter,
    // eslint-disable-next-line no-implicit-coercion, no-extra-parens
    depth: typeof e.depth == "number" || e.depth === !1 ? +e.depth : bt.depth,
    ignoreQueryPrefix: e.ignoreQueryPrefix === !0,
    interpretNumericEntities: typeof e.interpretNumericEntities == "boolean" ? e.interpretNumericEntities : bt.interpretNumericEntities,
    parameterLimit: typeof e.parameterLimit == "number" ? e.parameterLimit : bt.parameterLimit,
    parseArrays: e.parseArrays !== !1,
    plainObjects: typeof e.plainObjects == "boolean" ? e.plainObjects : bt.plainObjects,
    strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : bt.strictNullHandling
  };
}, IZ = function(t, e) {
  var r = RZ(e);
  if (t === "" || t === null || typeof t > "u")
    return r.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  for (var n = typeof t == "string" ? QZ(t, r) : t, i = r.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, s = Object.keys(n), o = 0; o < s.length; ++o) {
    var a = s[o], l = EZ(a, n[a], r, typeof t == "string");
    i = _o.merge(i, l, r);
  }
  return r.allowSparse === !0 ? i : _o.compact(i);
}, jZ = _Z, ZZ = IZ, MZ = ng, qZ = {
  formats: MZ,
  parse: ZZ,
  stringify: jZ
}, NZ = wI;
function _r() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
var DZ = /^([a-z0-9.+-]+:)/i, zZ = /:[0-9]*$/, XZ = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/, WZ = [
  "<",
  ">",
  '"',
  "`",
  " ",
  "\r",
  `
`,
  "	"
], UZ = [
  "{",
  "}",
  "|",
  "\\",
  "^",
  "`"
].concat(WZ), yp = ["'"].concat(UZ), Cy = [
  "%",
  "/",
  "?",
  ";",
  "#"
].concat(yp), Qy = [
  "/",
  "?",
  "#"
], VZ = 255, Ay = /^[+a-z0-9A-Z_-]{0,63}$/, LZ = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, YZ = {
  javascript: !0,
  "javascript:": !0
}, bp = {
  javascript: !0,
  "javascript:": !0
}, lo = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
}, vp = qZ;
function Ql(t, e, r) {
  if (t && typeof t == "object" && t instanceof _r)
    return t;
  var n = new _r();
  return n.parse(t, e, r), n;
}
_r.prototype.parse = function(t, e, r) {
  if (typeof t != "string")
    throw new TypeError("Parameter 'url' must be a string, not " + typeof t);
  var n = t.indexOf("?"), i = n !== -1 && n < t.indexOf("#") ? "?" : "#", s = t.split(i), o = /\\/g;
  s[0] = s[0].replace(o, "/"), t = s.join(i);
  var a = t;
  if (a = a.trim(), !r && t.split("#").length === 1) {
    var l = XZ.exec(a);
    if (l)
      return this.path = a, this.href = a, this.pathname = l[1], l[2] ? (this.search = l[2], e ? this.query = vp.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : e && (this.search = "", this.query = {}), this;
  }
  var c = DZ.exec(a);
  if (c) {
    c = c[0];
    var u = c.toLowerCase();
    this.protocol = u, a = a.substr(c.length);
  }
  if (r || c || a.match(/^\/\/[^@/]+@[^@/]+/)) {
    var d = a.substr(0, 2) === "//";
    d && !(c && bp[c]) && (a = a.substr(2), this.slashes = !0);
  }
  if (!bp[c] && (d || c && !lo[c])) {
    for (var f = -1, h = 0; h < Qy.length; h++) {
      var p = a.indexOf(Qy[h]);
      p !== -1 && (f === -1 || p < f) && (f = p);
    }
    var g, m;
    f === -1 ? m = a.lastIndexOf("@") : m = a.lastIndexOf("@", f), m !== -1 && (g = a.slice(0, m), a = a.slice(m + 1), this.auth = decodeURIComponent(g)), f = -1;
    for (var h = 0; h < Cy.length; h++) {
      var p = a.indexOf(Cy[h]);
      p !== -1 && (f === -1 || p < f) && (f = p);
    }
    f === -1 && (f = a.length), this.host = a.slice(0, f), a = a.slice(f), this.parseHost(), this.hostname = this.hostname || "";
    var y = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!y)
      for (var O = this.hostname.split(/\./), h = 0, b = O.length; h < b; h++) {
        var w = O[h];
        if (w && !w.match(Ay)) {
          for (var S = "", $ = 0, _ = w.length; $ < _; $++)
            w.charCodeAt($) > 127 ? S += "x" : S += w[$];
          if (!S.match(Ay)) {
            var Q = O.slice(0, h), N = O.slice(h + 1), B = w.match(LZ);
            B && (Q.push(B[1]), N.unshift(B[2])), N.length && (a = "/" + N.join(".") + a), this.hostname = Q.join(".");
            break;
          }
        }
      }
    this.hostname.length > VZ ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), y || (this.hostname = NZ.toASCII(this.hostname));
    var J = this.port ? ":" + this.port : "", U = this.hostname || "";
    this.host = U + J, this.href += this.host, y && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), a[0] !== "/" && (a = "/" + a));
  }
  if (!YZ[u])
    for (var h = 0, b = yp.length; h < b; h++) {
      var ue = yp[h];
      if (a.indexOf(ue) !== -1) {
        var le = encodeURIComponent(ue);
        le === ue && (le = escape(ue)), a = a.split(ue).join(le);
      }
    }
  var Pe = a.indexOf("#");
  Pe !== -1 && (this.hash = a.substr(Pe), a = a.slice(0, Pe));
  var Ce = a.indexOf("?");
  if (Ce !== -1 ? (this.search = a.substr(Ce), this.query = a.substr(Ce + 1), e && (this.query = vp.parse(this.query)), a = a.slice(0, Ce)) : e && (this.search = "", this.query = {}), a && (this.pathname = a), lo[u] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
    var J = this.pathname || "", X = this.search || "";
    this.path = J + X;
  }
  return this.href = this.format(), this;
};
function BZ(t) {
  return typeof t == "string" && (t = Ql(t)), t instanceof _r ? t.format() : _r.prototype.format.call(t);
}
_r.prototype.format = function() {
  var t = this.auth || "";
  t && (t = encodeURIComponent(t), t = t.replace(/%3A/i, ":"), t += "@");
  var e = this.protocol || "", r = this.pathname || "", n = this.hash || "", i = !1, s = "";
  this.host ? i = t + this.host : this.hostname && (i = t + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (i += ":" + this.port)), this.query && typeof this.query == "object" && Object.keys(this.query).length && (s = vp.stringify(this.query, {
    arrayFormat: "repeat",
    addQueryPrefix: !1
  }));
  var o = this.search || s && "?" + s || "";
  return e && e.substr(-1) !== ":" && (e += ":"), this.slashes || (!e || lo[e]) && i !== !1 ? (i = "//" + (i || ""), r && r.charAt(0) !== "/" && (r = "/" + r)) : i || (i = ""), n && n.charAt(0) !== "#" && (n = "#" + n), o && o.charAt(0) !== "?" && (o = "?" + o), r = r.replace(/[?#]/g, function(a) {
    return encodeURIComponent(a);
  }), o = o.replace("#", "%23"), e + i + r + o + n;
};
function FZ(t, e) {
  return Ql(t, !1, !0).resolve(e);
}
_r.prototype.resolve = function(t) {
  return this.resolveObject(Ql(t, !1, !0)).format();
};
function HZ(t, e) {
  return t ? Ql(t, !1, !0).resolveObject(e) : e;
}
_r.prototype.resolveObject = function(t) {
  if (typeof t == "string") {
    var e = new _r();
    e.parse(t, !1, !0), t = e;
  }
  for (var r = new _r(), n = Object.keys(this), i = 0; i < n.length; i++) {
    var s = n[i];
    r[s] = this[s];
  }
  if (r.hash = t.hash, t.href === "")
    return r.href = r.format(), r;
  if (t.slashes && !t.protocol) {
    for (var o = Object.keys(t), a = 0; a < o.length; a++) {
      var l = o[a];
      l !== "protocol" && (r[l] = t[l]);
    }
    return lo[r.protocol] && r.hostname && !r.pathname && (r.pathname = "/", r.path = r.pathname), r.href = r.format(), r;
  }
  if (t.protocol && t.protocol !== r.protocol) {
    if (!lo[t.protocol]) {
      for (var c = Object.keys(t), u = 0; u < c.length; u++) {
        var d = c[u];
        r[d] = t[d];
      }
      return r.href = r.format(), r;
    }
    if (r.protocol = t.protocol, !t.host && !bp[t.protocol]) {
      for (var b = (t.pathname || "").split("/"); b.length && !(t.host = b.shift()); )
        ;
      t.host || (t.host = ""), t.hostname || (t.hostname = ""), b[0] !== "" && b.unshift(""), b.length < 2 && b.unshift(""), r.pathname = b.join("/");
    } else
      r.pathname = t.pathname;
    if (r.search = t.search, r.query = t.query, r.host = t.host || "", r.auth = t.auth, r.hostname = t.hostname || t.host, r.port = t.port, r.pathname || r.search) {
      var f = r.pathname || "", h = r.search || "";
      r.path = f + h;
    }
    return r.slashes = r.slashes || t.slashes, r.href = r.format(), r;
  }
  var p = r.pathname && r.pathname.charAt(0) === "/", g = t.host || t.pathname && t.pathname.charAt(0) === "/", m = g || p || r.host && t.pathname, y = m, O = r.pathname && r.pathname.split("/") || [], b = t.pathname && t.pathname.split("/") || [], w = r.protocol && !lo[r.protocol];
  if (w && (r.hostname = "", r.port = null, r.host && (O[0] === "" ? O[0] = r.host : O.unshift(r.host)), r.host = "", t.protocol && (t.hostname = null, t.port = null, t.host && (b[0] === "" ? b[0] = t.host : b.unshift(t.host)), t.host = null), m = m && (b[0] === "" || O[0] === "")), g)
    r.host = t.host || t.host === "" ? t.host : r.host, r.hostname = t.hostname || t.hostname === "" ? t.hostname : r.hostname, r.search = t.search, r.query = t.query, O = b;
  else if (b.length)
    O || (O = []), O.pop(), O = O.concat(b), r.search = t.search, r.query = t.query;
  else if (t.search != null) {
    if (w) {
      r.host = O.shift(), r.hostname = r.host;
      var S = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : !1;
      S && (r.auth = S.shift(), r.hostname = S.shift(), r.host = r.hostname);
    }
    return r.search = t.search, r.query = t.query, (r.pathname !== null || r.search !== null) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.href = r.format(), r;
  }
  if (!O.length)
    return r.pathname = null, r.search ? r.path = "/" + r.search : r.path = null, r.href = r.format(), r;
  for (var $ = O.slice(-1)[0], _ = (r.host || t.host || O.length > 1) && ($ === "." || $ === "..") || $ === "", Q = 0, N = O.length; N >= 0; N--)
    $ = O[N], $ === "." ? O.splice(N, 1) : $ === ".." ? (O.splice(N, 1), Q++) : Q && (O.splice(N, 1), Q--);
  if (!m && !y)
    for (; Q--; Q)
      O.unshift("..");
  m && O[0] !== "" && (!O[0] || O[0].charAt(0) !== "/") && O.unshift(""), _ && O.join("/").substr(-1) !== "/" && O.push("");
  var B = O[0] === "" || O[0] && O[0].charAt(0) === "/";
  if (w) {
    r.hostname = B ? "" : O.length ? O.shift() : "", r.host = r.hostname;
    var S = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : !1;
    S && (r.auth = S.shift(), r.hostname = S.shift(), r.host = r.hostname);
  }
  return m = m || r.host && O.length, m && !B && O.unshift(""), O.length > 0 ? r.pathname = O.join("/") : (r.pathname = null, r.path = null), (r.pathname !== null || r.search !== null) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.auth = t.auth || r.auth, r.slashes = r.slashes || t.slashes, r.href = r.format(), r;
};
_r.prototype.parseHost = function() {
  var t = this.host, e = zZ.exec(t);
  e && (e = e[0], e !== ":" && (this.port = e.substr(1)), t = t.substr(0, t.length - e.length)), t && (this.hostname = t);
};
hs.parse = Ql;
hs.resolve = FZ;
hs.resolveObject = HZ;
hs.format = BZ;
hs.Url = _r;
(function(t, e) {
  let r = /^win/.test(process.platform), n = /\//g, i = /^(\w{2,}):\/\//i, s = t.exports, o = /~1/g, a = /~0/g, l = [
    /\?/g,
    "%3F",
    /\#/g,
    "%23"
  ], c = [
    /\%23/g,
    "#",
    /\%24/g,
    "$",
    /\%26/g,
    "&",
    /\%2C/g,
    ",",
    /\%40/g,
    "@"
  ];
  e.parse = hs.parse, e.resolve = hs.resolve, e.cwd = function() {
    if (process.browser)
      return location.href;
    let d = process.cwd(), f = d.slice(-1);
    return f === "/" || f === "\\" ? d : d + "/";
  }, e.getProtocol = function(d) {
    let f = i.exec(d);
    if (f)
      return f[1].toLowerCase();
  }, e.getExtension = function(d) {
    let f = d.lastIndexOf(".");
    return f >= 0 ? d.substr(f).toLowerCase() : "";
  }, e.getHash = function(d) {
    let f = d.indexOf("#");
    return f >= 0 ? d.substr(f) : "#";
  }, e.stripHash = function(d) {
    let f = d.indexOf("#");
    return f >= 0 && (d = d.substr(0, f)), d;
  }, e.isHttp = function(d) {
    let f = s.getProtocol(d);
    return f === "http" || f === "https" ? !0 : f === void 0 ? process.browser : !1;
  }, e.isFileSystemPath = function(d) {
    if (process.browser)
      return !1;
    let f = s.getProtocol(d);
    return f === void 0 || f === "file";
  }, e.fromFileSystemPath = function(d) {
    r && (d = d.replace(/\\/g, "/")), d = encodeURI(d);
    for (let f = 0; f < l.length; f += 2)
      d = d.replace(l[f], l[f + 1]);
    return d;
  }, e.toFileSystemPath = function(d, f) {
    d = decodeURI(d);
    for (let p = 0; p < c.length; p += 2)
      d = d.replace(c[p], c[p + 1]);
    let h = d.substr(0, 7).toLowerCase() === "file://";
    return h && (d = d[7] === "/" ? d.substr(8) : d.substr(7), r && d[1] === "/" && (d = d[0] + ":" + d.substr(1)), f ? d = "file:///" + d : (h = !1, d = r ? d : "/" + d)), r && !h && (d = d.replace(n, "\\"), d.substr(1, 2) === ":\\" && (d = d[0].toUpperCase() + d.substr(1))), d;
  }, e.safePointerToPath = function(d) {
    return d.length <= 1 || d[0] !== "#" || d[1] !== "/" ? [] : d.slice(2).split("/").map((f) => decodeURIComponent(f).replace(o, "/").replace(a, "~"));
  };
})(up, up.exports);
var Cr = up.exports;
const QS = Hm, GZ = Cr;
ys.format = QS.format;
ys.inherits = QS.inherits;
ys.swaggerParamRegExp = /\{([^/}]+)}/g;
const KZ = ["get", "post", "put", "delete", "patch", "options", "head", "trace"];
function Zf(t, e) {
  if (t.url && t.url.startsWith("/")) {
    const r = GZ.parse(e), n = r.protocol + "//" + r.hostname + t.url;
    return t.url = n, t;
  }
}
function JZ(t, e) {
  t.openapi && e && (e.startsWith("http:") || e.startsWith("https:")) && (t.servers && t.servers.map((r) => Zf(r, e)), ["paths", "webhooks"].forEach((r) => {
    Object.keys(t[r] || []).forEach((n) => {
      const i = t[r][n];
      Object.keys(i).forEach((s) => {
        s === "servers" ? i[s].map((o) => Zf(o, e)) : KZ.includes(s) && i[s].servers && i[s].servers.map((o) => Zf(o, e));
      });
    });
  }));
}
ys.fixOasRelativeServers = JZ;
const eM = !1, tM = /\r?\n/, rM = /\bono[ @]/;
function nM(t) {
  return !!(t && t.configurable && typeof t.get == "function");
}
function iM(t) {
  return !!// If there is no stack property, then it's writable, since assigning it will create it
  (!t || t.writable || typeof t.set == "function");
}
function AS(t, e) {
  let r = ES(t.stack), n = e ? e.stack : void 0;
  return r && n ? r + `

` + n : r || n;
}
function sM(t, e, r) {
  r ? Object.defineProperty(e, "stack", {
    get: () => {
      let n = t.get.apply(e);
      return AS({ stack: n }, r);
    },
    enumerable: !1,
    configurable: !0
  }) : oM(e, t);
}
function ES(t) {
  if (t) {
    let e = t.split(tM), r;
    for (let n = 0; n < e.length; n++) {
      let i = e[n];
      if (rM.test(i))
        r === void 0 && (r = n);
      else if (r !== void 0) {
        e.splice(r, n - r);
        break;
      }
    }
    if (e.length > 0)
      return e.join(`
`);
  }
  return t;
}
function oM(t, e) {
  Object.defineProperty(t, "stack", {
    get: () => ES(e.get.apply(t)),
    enumerable: !1,
    configurable: !0
  });
}
const aM = ["function", "symbol", "undefined"], lM = ["constructor", "prototype", "__proto__"], cM = Object.getPrototypeOf({});
function RS() {
  let t = {}, e = this;
  for (let r of IS(e))
    if (typeof r == "string") {
      let n = e[r], i = typeof n;
      aM.includes(i) || (t[r] = n);
    }
  return t;
}
function IS(t, e = []) {
  let r = [];
  for (; t && t !== cM; )
    r = r.concat(Object.getOwnPropertyNames(t), Object.getOwnPropertySymbols(t)), t = Object.getPrototypeOf(t);
  let n = new Set(r);
  for (let i of e.concat(lM))
    n.delete(i);
  return n;
}
const uM = ["name", "message", "stack"];
function Wc(t, e, r) {
  let n = t;
  return dM(n, e), e && typeof e == "object" && fM(n, e), n.toJSON = RS, r && typeof r == "object" && Object.assign(n, r), n;
}
function dM(t, e) {
  let r = Object.getOwnPropertyDescriptor(t, "stack");
  nM(r) ? sM(r, t, e) : iM(r) && (t.stack = AS(t, e));
}
function fM(t, e) {
  let r = IS(e, uM), n = t, i = e;
  for (let s of r)
    if (n[s] === void 0)
      try {
        n[s] = i[s];
      } catch {
      }
}
function hM(t) {
  return t = t || {}, {
    concatMessages: t.concatMessages === void 0 ? !0 : !!t.concatMessages,
    format: t.format === void 0 ? eM : typeof t.format == "function" ? t.format : !1
  };
}
function pM(t, e) {
  let r, n, i, s = "";
  return typeof t[0] == "string" ? i = t : typeof t[1] == "string" ? (t[0] instanceof Error ? r = t[0] : n = t[0], i = t.slice(1)) : (r = t[0], n = t[1], i = t.slice(2)), i.length > 0 && (e.format ? s = e.format.apply(void 0, i) : s = i.join(" ")), e.concatMessages && r && r.message && (s += (s ? ` 
` : "") + r.message), { originalError: r, props: n, message: s };
}
const Qi = ig;
function ig(t, e) {
  e = hM(e);
  function r(...n) {
    let { originalError: i, props: s, message: o } = pM(n, e), a = new t(o);
    return Wc(a, i, s);
  }
  return r[Symbol.species] = t, r;
}
ig.toJSON = function(e) {
  return RS.call(e);
};
ig.extend = function(e, r, n) {
  return n || r instanceof Error ? Wc(e, r, n) : r ? Wc(e, void 0, r) : Wc(e);
};
const Ey = wn;
wn.error = new Qi(Error);
wn.eval = new Qi(EvalError);
wn.range = new Qi(RangeError);
wn.reference = new Qi(ReferenceError);
wn.syntax = new Qi(SyntaxError);
wn.type = new Qi(TypeError);
wn.uri = new Qi(URIError);
const mM = wn;
function wn(...t) {
  let e = t[0];
  if (typeof e == "object" && typeof e.name == "string") {
    for (let r of Object.values(mM))
      if (typeof r == "function" && r.name === "ono") {
        let n = r[Symbol.species];
        if (n && n !== Error && (e instanceof n || e.name === n.name))
          return r.apply(void 0, t);
      }
  }
  return wn.error.apply(void 0, t);
}
typeof module == "object" && typeof module.exports == "object" && (module.exports.default = module.exports.default || {}, module.exports = Object.assign(module.exports.default, module.exports));
const gM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Ono: Qi,
  default: Ey,
  ono: Ey
}, Symbol.toStringTag, { value: "Module" })), $n = /* @__PURE__ */ W$(gM);
var wp = { exports: {} }, co = {}, Ur = {}, Po = {}, Al = {}, Qe = {}, ll = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.regexpCode = t.getEsmExportName = t.getProperty = t.safeStringify = t.stringify = t.strConcat = t.addCodeArg = t.str = t._ = t.nil = t._Code = t.Name = t.IDENTIFIER = t._CodeOrName = void 0;
  class e {
  }
  t._CodeOrName = e, t.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class r extends e {
    constructor(O) {
      if (super(), !t.IDENTIFIER.test(O))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = O;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return !1;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  t.Name = r;
  class n extends e {
    constructor(O) {
      super(), this._items = typeof O == "string" ? [O] : O;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return !1;
      const O = this._items[0];
      return O === "" || O === '""';
    }
    get str() {
      var O;
      return (O = this._str) !== null && O !== void 0 ? O : this._str = this._items.reduce((b, w) => `${b}${w}`, "");
    }
    get names() {
      var O;
      return (O = this._names) !== null && O !== void 0 ? O : this._names = this._items.reduce((b, w) => (w instanceof r && (b[w.str] = (b[w.str] || 0) + 1), b), {});
    }
  }
  t._Code = n, t.nil = new n("");
  function i(y, ...O) {
    const b = [y[0]];
    let w = 0;
    for (; w < O.length; )
      a(b, O[w]), b.push(y[++w]);
    return new n(b);
  }
  t._ = i;
  const s = new n("+");
  function o(y, ...O) {
    const b = [h(y[0])];
    let w = 0;
    for (; w < O.length; )
      b.push(s), a(b, O[w]), b.push(s, h(y[++w]));
    return l(b), new n(b);
  }
  t.str = o;
  function a(y, O) {
    O instanceof n ? y.push(...O._items) : O instanceof r ? y.push(O) : y.push(d(O));
  }
  t.addCodeArg = a;
  function l(y) {
    let O = 1;
    for (; O < y.length - 1; ) {
      if (y[O] === s) {
        const b = c(y[O - 1], y[O + 1]);
        if (b !== void 0) {
          y.splice(O - 1, 3, b);
          continue;
        }
        y[O++] = "+";
      }
      O++;
    }
  }
  function c(y, O) {
    if (O === '""')
      return y;
    if (y === '""')
      return O;
    if (typeof y == "string")
      return O instanceof r || y[y.length - 1] !== '"' ? void 0 : typeof O != "string" ? `${y.slice(0, -1)}${O}"` : O[0] === '"' ? y.slice(0, -1) + O.slice(1) : void 0;
    if (typeof O == "string" && O[0] === '"' && !(y instanceof r))
      return `"${y}${O.slice(1)}`;
  }
  function u(y, O) {
    return O.emptyStr() ? y : y.emptyStr() ? O : o`${y}${O}`;
  }
  t.strConcat = u;
  function d(y) {
    return typeof y == "number" || typeof y == "boolean" || y === null ? y : h(Array.isArray(y) ? y.join(",") : y);
  }
  function f(y) {
    return new n(h(y));
  }
  t.stringify = f;
  function h(y) {
    return JSON.stringify(y).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  t.safeStringify = h;
  function p(y) {
    return typeof y == "string" && t.IDENTIFIER.test(y) ? new n(`.${y}`) : i`[${y}]`;
  }
  t.getProperty = p;
  function g(y) {
    if (typeof y == "string" && t.IDENTIFIER.test(y))
      return new n(`${y}`);
    throw new Error(`CodeGen: invalid export name: ${y}, use explicit $id name mapping`);
  }
  t.getEsmExportName = g;
  function m(y) {
    return new n(y.toString());
  }
  t.regexpCode = m;
})(ll);
var $p = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.ValueScope = t.ValueScopeName = t.Scope = t.varKinds = t.UsedValueState = void 0;
  const e = ll;
  class r extends Error {
    constructor(c) {
      super(`CodeGen: "code" for ${c} not defined`), this.value = c.value;
    }
  }
  var n;
  (function(l) {
    l[l.Started = 0] = "Started", l[l.Completed = 1] = "Completed";
  })(n = t.UsedValueState || (t.UsedValueState = {})), t.varKinds = {
    const: new e.Name("const"),
    let: new e.Name("let"),
    var: new e.Name("var")
  };
  class i {
    constructor({ prefixes: c, parent: u } = {}) {
      this._names = {}, this._prefixes = c, this._parent = u;
    }
    toName(c) {
      return c instanceof e.Name ? c : this.name(c);
    }
    name(c) {
      return new e.Name(this._newName(c));
    }
    _newName(c) {
      const u = this._names[c] || this._nameGroup(c);
      return `${c}${u.index++}`;
    }
    _nameGroup(c) {
      var u, d;
      if (!((d = (u = this._parent) === null || u === void 0 ? void 0 : u._prefixes) === null || d === void 0) && d.has(c) || this._prefixes && !this._prefixes.has(c))
        throw new Error(`CodeGen: prefix "${c}" is not allowed in this scope`);
      return this._names[c] = { prefix: c, index: 0 };
    }
  }
  t.Scope = i;
  class s extends e.Name {
    constructor(c, u) {
      super(u), this.prefix = c;
    }
    setValue(c, { property: u, itemIndex: d }) {
      this.value = c, this.scopePath = (0, e._)`.${new e.Name(u)}[${d}]`;
    }
  }
  t.ValueScopeName = s;
  const o = (0, e._)`\n`;
  class a extends i {
    constructor(c) {
      super(c), this._values = {}, this._scope = c.scope, this.opts = { ...c, _n: c.lines ? o : e.nil };
    }
    get() {
      return this._scope;
    }
    name(c) {
      return new s(c, this._newName(c));
    }
    value(c, u) {
      var d;
      if (u.ref === void 0)
        throw new Error("CodeGen: ref must be passed in value");
      const f = this.toName(c), { prefix: h } = f, p = (d = u.key) !== null && d !== void 0 ? d : u.ref;
      let g = this._values[h];
      if (g) {
        const O = g.get(p);
        if (O)
          return O;
      } else
        g = this._values[h] = /* @__PURE__ */ new Map();
      g.set(p, f);
      const m = this._scope[h] || (this._scope[h] = []), y = m.length;
      return m[y] = u.ref, f.setValue(u, { property: h, itemIndex: y }), f;
    }
    getValue(c, u) {
      const d = this._values[c];
      if (d)
        return d.get(u);
    }
    scopeRefs(c, u = this._values) {
      return this._reduceValues(u, (d) => {
        if (d.scopePath === void 0)
          throw new Error(`CodeGen: name "${d}" has no value`);
        return (0, e._)`${c}${d.scopePath}`;
      });
    }
    scopeCode(c = this._values, u, d) {
      return this._reduceValues(c, (f) => {
        if (f.value === void 0)
          throw new Error(`CodeGen: name "${f}" has no value`);
        return f.value.code;
      }, u, d);
    }
    _reduceValues(c, u, d = {}, f) {
      let h = e.nil;
      for (const p in c) {
        const g = c[p];
        if (!g)
          continue;
        const m = d[p] = d[p] || /* @__PURE__ */ new Map();
        g.forEach((y) => {
          if (m.has(y))
            return;
          m.set(y, n.Started);
          let O = u(y);
          if (O) {
            const b = this.opts.es5 ? t.varKinds.var : t.varKinds.const;
            h = (0, e._)`${h}${b} ${y} = ${O};${this.opts._n}`;
          } else if (O = f == null ? void 0 : f(y))
            h = (0, e._)`${h}${O}${this.opts._n}`;
          else
            throw new r(y);
          m.set(y, n.Completed);
        });
      }
      return h;
    }
  }
  t.ValueScope = a;
})($p);
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.or = t.and = t.not = t.CodeGen = t.operators = t.varKinds = t.ValueScopeName = t.ValueScope = t.Scope = t.Name = t.regexpCode = t.stringify = t.getProperty = t.nil = t.strConcat = t.str = t._ = void 0;
  const e = ll, r = $p;
  var n = ll;
  Object.defineProperty(t, "_", { enumerable: !0, get: function() {
    return n._;
  } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
    return n.str;
  } }), Object.defineProperty(t, "strConcat", { enumerable: !0, get: function() {
    return n.strConcat;
  } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
    return n.nil;
  } }), Object.defineProperty(t, "getProperty", { enumerable: !0, get: function() {
    return n.getProperty;
  } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
    return n.stringify;
  } }), Object.defineProperty(t, "regexpCode", { enumerable: !0, get: function() {
    return n.regexpCode;
  } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
    return n.Name;
  } });
  var i = $p;
  Object.defineProperty(t, "Scope", { enumerable: !0, get: function() {
    return i.Scope;
  } }), Object.defineProperty(t, "ValueScope", { enumerable: !0, get: function() {
    return i.ValueScope;
  } }), Object.defineProperty(t, "ValueScopeName", { enumerable: !0, get: function() {
    return i.ValueScopeName;
  } }), Object.defineProperty(t, "varKinds", { enumerable: !0, get: function() {
    return i.varKinds;
  } }), t.operators = {
    GT: new e._Code(">"),
    GTE: new e._Code(">="),
    LT: new e._Code("<"),
    LTE: new e._Code("<="),
    EQ: new e._Code("==="),
    NEQ: new e._Code("!=="),
    NOT: new e._Code("!"),
    OR: new e._Code("||"),
    AND: new e._Code("&&"),
    ADD: new e._Code("+")
  };
  class s {
    optimizeNodes() {
      return this;
    }
    optimizeNames(P, A) {
      return this;
    }
  }
  class o extends s {
    constructor(P, A, W) {
      super(), this.varKind = P, this.name = A, this.rhs = W;
    }
    render({ es5: P, _n: A }) {
      const W = P ? r.varKinds.var : this.varKind, ne = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${W} ${this.name}${ne};` + A;
    }
    optimizeNames(P, A) {
      if (P[this.name.str])
        return this.rhs && (this.rhs = le(this.rhs, P, A)), this;
    }
    get names() {
      return this.rhs instanceof e._CodeOrName ? this.rhs.names : {};
    }
  }
  class a extends s {
    constructor(P, A, W) {
      super(), this.lhs = P, this.rhs = A, this.sideEffects = W;
    }
    render({ _n: P }) {
      return `${this.lhs} = ${this.rhs};` + P;
    }
    optimizeNames(P, A) {
      if (!(this.lhs instanceof e.Name && !P[this.lhs.str] && !this.sideEffects))
        return this.rhs = le(this.rhs, P, A), this;
    }
    get names() {
      const P = this.lhs instanceof e.Name ? {} : { ...this.lhs.names };
      return ue(P, this.rhs);
    }
  }
  class l extends a {
    constructor(P, A, W, ne) {
      super(P, W, ne), this.op = A;
    }
    render({ _n: P }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + P;
    }
  }
  class c extends s {
    constructor(P) {
      super(), this.label = P, this.names = {};
    }
    render({ _n: P }) {
      return `${this.label}:` + P;
    }
  }
  class u extends s {
    constructor(P) {
      super(), this.label = P, this.names = {};
    }
    render({ _n: P }) {
      return `break${this.label ? ` ${this.label}` : ""};` + P;
    }
  }
  class d extends s {
    constructor(P) {
      super(), this.error = P;
    }
    render({ _n: P }) {
      return `throw ${this.error};` + P;
    }
    get names() {
      return this.error.names;
    }
  }
  class f extends s {
    constructor(P) {
      super(), this.code = P;
    }
    render({ _n: P }) {
      return `${this.code};` + P;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(P, A) {
      return this.code = le(this.code, P, A), this;
    }
    get names() {
      return this.code instanceof e._CodeOrName ? this.code.names : {};
    }
  }
  class h extends s {
    constructor(P = []) {
      super(), this.nodes = P;
    }
    render(P) {
      return this.nodes.reduce((A, W) => A + W.render(P), "");
    }
    optimizeNodes() {
      const { nodes: P } = this;
      let A = P.length;
      for (; A--; ) {
        const W = P[A].optimizeNodes();
        Array.isArray(W) ? P.splice(A, 1, ...W) : W ? P[A] = W : P.splice(A, 1);
      }
      return P.length > 0 ? this : void 0;
    }
    optimizeNames(P, A) {
      const { nodes: W } = this;
      let ne = W.length;
      for (; ne--; ) {
        const ie = W[ne];
        ie.optimizeNames(P, A) || (Pe(P, ie.names), W.splice(ne, 1));
      }
      return W.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((P, A) => U(P, A.names), {});
    }
  }
  class p extends h {
    render(P) {
      return "{" + P._n + super.render(P) + "}" + P._n;
    }
  }
  class g extends h {
  }
  class m extends p {
  }
  m.kind = "else";
  class y extends p {
    constructor(P, A) {
      super(A), this.condition = P;
    }
    render(P) {
      let A = `if(${this.condition})` + super.render(P);
      return this.else && (A += "else " + this.else.render(P)), A;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const P = this.condition;
      if (P === !0)
        return this.nodes;
      let A = this.else;
      if (A) {
        const W = A.optimizeNodes();
        A = this.else = Array.isArray(W) ? new m(W) : W;
      }
      if (A)
        return P === !1 ? A instanceof y ? A : A.nodes : this.nodes.length ? this : new y(Ce(P), A instanceof y ? [A] : A.nodes);
      if (!(P === !1 || !this.nodes.length))
        return this;
    }
    optimizeNames(P, A) {
      var W;
      if (this.else = (W = this.else) === null || W === void 0 ? void 0 : W.optimizeNames(P, A), !!(super.optimizeNames(P, A) || this.else))
        return this.condition = le(this.condition, P, A), this;
    }
    get names() {
      const P = super.names;
      return ue(P, this.condition), this.else && U(P, this.else.names), P;
    }
  }
  y.kind = "if";
  class O extends p {
  }
  O.kind = "for";
  class b extends O {
    constructor(P) {
      super(), this.iteration = P;
    }
    render(P) {
      return `for(${this.iteration})` + super.render(P);
    }
    optimizeNames(P, A) {
      if (super.optimizeNames(P, A))
        return this.iteration = le(this.iteration, P, A), this;
    }
    get names() {
      return U(super.names, this.iteration.names);
    }
  }
  class w extends O {
    constructor(P, A, W, ne) {
      super(), this.varKind = P, this.name = A, this.from = W, this.to = ne;
    }
    render(P) {
      const A = P.es5 ? r.varKinds.var : this.varKind, { name: W, from: ne, to: ie } = this;
      return `for(${A} ${W}=${ne}; ${W}<${ie}; ${W}++)` + super.render(P);
    }
    get names() {
      const P = ue(super.names, this.from);
      return ue(P, this.to);
    }
  }
  class S extends O {
    constructor(P, A, W, ne) {
      super(), this.loop = P, this.varKind = A, this.name = W, this.iterable = ne;
    }
    render(P) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(P);
    }
    optimizeNames(P, A) {
      if (super.optimizeNames(P, A))
        return this.iterable = le(this.iterable, P, A), this;
    }
    get names() {
      return U(super.names, this.iterable.names);
    }
  }
  class $ extends p {
    constructor(P, A, W) {
      super(), this.name = P, this.args = A, this.async = W;
    }
    render(P) {
      return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(P);
    }
  }
  $.kind = "func";
  class _ extends h {
    render(P) {
      return "return " + super.render(P);
    }
  }
  _.kind = "return";
  class Q extends p {
    render(P) {
      let A = "try" + super.render(P);
      return this.catch && (A += this.catch.render(P)), this.finally && (A += this.finally.render(P)), A;
    }
    optimizeNodes() {
      var P, A;
      return super.optimizeNodes(), (P = this.catch) === null || P === void 0 || P.optimizeNodes(), (A = this.finally) === null || A === void 0 || A.optimizeNodes(), this;
    }
    optimizeNames(P, A) {
      var W, ne;
      return super.optimizeNames(P, A), (W = this.catch) === null || W === void 0 || W.optimizeNames(P, A), (ne = this.finally) === null || ne === void 0 || ne.optimizeNames(P, A), this;
    }
    get names() {
      const P = super.names;
      return this.catch && U(P, this.catch.names), this.finally && U(P, this.finally.names), P;
    }
  }
  class N extends p {
    constructor(P) {
      super(), this.error = P;
    }
    render(P) {
      return `catch(${this.error})` + super.render(P);
    }
  }
  N.kind = "catch";
  class B extends p {
    render(P) {
      return "finally" + super.render(P);
    }
  }
  B.kind = "finally";
  class J {
    constructor(P, A = {}) {
      this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...A, _n: A.lines ? `
` : "" }, this._extScope = P, this._scope = new r.Scope({ parent: P }), this._nodes = [new g()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    // returns unique name in the internal scope
    name(P) {
      return this._scope.name(P);
    }
    // reserves unique name in the external scope
    scopeName(P) {
      return this._extScope.name(P);
    }
    // reserves unique name in the external scope and assigns value to it
    scopeValue(P, A) {
      const W = this._extScope.value(P, A);
      return (this._values[W.prefix] || (this._values[W.prefix] = /* @__PURE__ */ new Set())).add(W), W;
    }
    getScopeValue(P, A) {
      return this._extScope.getValue(P, A);
    }
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(P) {
      return this._extScope.scopeRefs(P, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(P, A, W, ne) {
      const ie = this._scope.toName(A);
      return W !== void 0 && ne && (this._constants[ie.str] = W), this._leafNode(new o(P, ie, W)), ie;
    }
    // `const` declaration (`var` in es5 mode)
    const(P, A, W) {
      return this._def(r.varKinds.const, P, A, W);
    }
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(P, A, W) {
      return this._def(r.varKinds.let, P, A, W);
    }
    // `var` declaration with optional assignment
    var(P, A, W) {
      return this._def(r.varKinds.var, P, A, W);
    }
    // assignment code
    assign(P, A, W) {
      return this._leafNode(new a(P, A, W));
    }
    // `+=` code
    add(P, A) {
      return this._leafNode(new l(P, t.operators.ADD, A));
    }
    // appends passed SafeExpr to code or executes Block
    code(P) {
      return typeof P == "function" ? P() : P !== e.nil && this._leafNode(new f(P)), this;
    }
    // returns code for object literal for the passed argument list of key-value pairs
    object(...P) {
      const A = ["{"];
      for (const [W, ne] of P)
        A.length > 1 && A.push(","), A.push(W), (W !== ne || this.opts.es5) && (A.push(":"), (0, e.addCodeArg)(A, ne));
      return A.push("}"), new e._Code(A);
    }
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(P, A, W) {
      if (this._blockNode(new y(P)), A && W)
        this.code(A).else().code(W).endIf();
      else if (A)
        this.code(A).endIf();
      else if (W)
        throw new Error('CodeGen: "else" body without "then" body');
      return this;
    }
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf(P) {
      return this._elseNode(new y(P));
    }
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
      return this._elseNode(new m());
    }
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
      return this._endBlockNode(y, m);
    }
    _for(P, A) {
      return this._blockNode(P), A && this.code(A).endFor(), this;
    }
    // a generic `for` clause (or statement if `forBody` is passed)
    for(P, A) {
      return this._for(new b(P), A);
    }
    // `for` statement for a range of values
    forRange(P, A, W, ne, ie = this.opts.es5 ? r.varKinds.var : r.varKinds.let) {
      const Oe = this._scope.toName(P);
      return this._for(new w(ie, Oe, A, W), () => ne(Oe));
    }
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(P, A, W, ne = r.varKinds.const) {
      const ie = this._scope.toName(P);
      if (this.opts.es5) {
        const Oe = A instanceof e.Name ? A : this.var("_arr", A);
        return this.forRange("_i", 0, (0, e._)`${Oe}.length`, (ve) => {
          this.var(ie, (0, e._)`${Oe}[${ve}]`), W(ie);
        });
      }
      return this._for(new S("of", ne, ie, A), () => W(ie));
    }
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(P, A, W, ne = this.opts.es5 ? r.varKinds.var : r.varKinds.const) {
      if (this.opts.ownProperties)
        return this.forOf(P, (0, e._)`Object.keys(${A})`, W);
      const ie = this._scope.toName(P);
      return this._for(new S("in", ne, ie, A), () => W(ie));
    }
    // end `for` loop
    endFor() {
      return this._endBlockNode(O);
    }
    // `label` statement
    label(P) {
      return this._leafNode(new c(P));
    }
    // `break` statement
    break(P) {
      return this._leafNode(new u(P));
    }
    // `return` statement
    return(P) {
      const A = new _();
      if (this._blockNode(A), this.code(P), A.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(_);
    }
    // `try` statement
    try(P, A, W) {
      if (!A && !W)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const ne = new Q();
      if (this._blockNode(ne), this.code(P), A) {
        const ie = this.name("e");
        this._currNode = ne.catch = new N(ie), A(ie);
      }
      return W && (this._currNode = ne.finally = new B(), this.code(W)), this._endBlockNode(N, B);
    }
    // `throw` statement
    throw(P) {
      return this._leafNode(new d(P));
    }
    // start self-balancing block
    block(P, A) {
      return this._blockStarts.push(this._nodes.length), P && this.code(P).endBlock(A), this;
    }
    // end the current self-balancing block
    endBlock(P) {
      const A = this._blockStarts.pop();
      if (A === void 0)
        throw new Error("CodeGen: not in self-balancing block");
      const W = this._nodes.length - A;
      if (W < 0 || P !== void 0 && W !== P)
        throw new Error(`CodeGen: wrong number of nodes: ${W} vs ${P} expected`);
      return this._nodes.length = A, this;
    }
    // `function` heading (or definition if funcBody is passed)
    func(P, A = e.nil, W, ne) {
      return this._blockNode(new $(P, A, W)), ne && this.code(ne).endFunc(), this;
    }
    // end function definition
    endFunc() {
      return this._endBlockNode($);
    }
    optimize(P = 1) {
      for (; P-- > 0; )
        this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
    }
    _leafNode(P) {
      return this._currNode.nodes.push(P), this;
    }
    _blockNode(P) {
      this._currNode.nodes.push(P), this._nodes.push(P);
    }
    _endBlockNode(P, A) {
      const W = this._currNode;
      if (W instanceof P || A && W instanceof A)
        return this._nodes.pop(), this;
      throw new Error(`CodeGen: not in block "${A ? `${P.kind}/${A.kind}` : P.kind}"`);
    }
    _elseNode(P) {
      const A = this._currNode;
      if (!(A instanceof y))
        throw new Error('CodeGen: "else" without "if"');
      return this._currNode = A.else = P, this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const P = this._nodes;
      return P[P.length - 1];
    }
    set _currNode(P) {
      const A = this._nodes;
      A[A.length - 1] = P;
    }
  }
  t.CodeGen = J;
  function U(M, P) {
    for (const A in P)
      M[A] = (M[A] || 0) + (P[A] || 0);
    return M;
  }
  function ue(M, P) {
    return P instanceof e._CodeOrName ? U(M, P.names) : M;
  }
  function le(M, P, A) {
    if (M instanceof e.Name)
      return W(M);
    if (!ne(M))
      return M;
    return new e._Code(M._items.reduce((ie, Oe) => (Oe instanceof e.Name && (Oe = W(Oe)), Oe instanceof e._Code ? ie.push(...Oe._items) : ie.push(Oe), ie), []));
    function W(ie) {
      const Oe = A[ie.str];
      return Oe === void 0 || P[ie.str] !== 1 ? ie : (delete P[ie.str], Oe);
    }
    function ne(ie) {
      return ie instanceof e._Code && ie._items.some((Oe) => Oe instanceof e.Name && P[Oe.str] === 1 && A[Oe.str] !== void 0);
    }
  }
  function Pe(M, P) {
    for (const A in P)
      M[A] = (M[A] || 0) - (P[A] || 0);
  }
  function Ce(M) {
    return typeof M == "boolean" || typeof M == "number" || M === null ? !M : (0, e._)`!${D(M)}`;
  }
  t.not = Ce;
  const X = R(t.operators.AND);
  function F(...M) {
    return M.reduce(X);
  }
  t.and = F;
  const K = R(t.operators.OR);
  function z(...M) {
    return M.reduce(K);
  }
  t.or = z;
  function R(M) {
    return (P, A) => P === e.nil ? A : A === e.nil ? P : (0, e._)`${D(P)} ${M} ${D(A)}`;
  }
  function D(M) {
    return M instanceof e.Name ? M : (0, e._)`(${M})`;
  }
})(Qe);
var je = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.checkStrictMode = t.getErrorPath = t.Type = t.useFunc = t.setEvaluated = t.evaluatedPropsToName = t.mergeEvaluated = t.eachItem = t.unescapeJsonPointer = t.escapeJsonPointer = t.escapeFragment = t.unescapeFragment = t.schemaRefOrVal = t.schemaHasRulesButRef = t.schemaHasRules = t.checkUnknownRules = t.alwaysValidSchema = t.toHash = void 0;
  const e = Qe, r = ll;
  function n($) {
    const _ = {};
    for (const Q of $)
      _[Q] = !0;
    return _;
  }
  t.toHash = n;
  function i($, _) {
    return typeof _ == "boolean" ? _ : Object.keys(_).length === 0 ? !0 : (s($, _), !o(_, $.self.RULES.all));
  }
  t.alwaysValidSchema = i;
  function s($, _ = $.schema) {
    const { opts: Q, self: N } = $;
    if (!Q.strictSchema || typeof _ == "boolean")
      return;
    const B = N.RULES.keywords;
    for (const J in _)
      B[J] || S($, `unknown keyword: "${J}"`);
  }
  t.checkUnknownRules = s;
  function o($, _) {
    if (typeof $ == "boolean")
      return !$;
    for (const Q in $)
      if (_[Q])
        return !0;
    return !1;
  }
  t.schemaHasRules = o;
  function a($, _) {
    if (typeof $ == "boolean")
      return !$;
    for (const Q in $)
      if (Q !== "$ref" && _.all[Q])
        return !0;
    return !1;
  }
  t.schemaHasRulesButRef = a;
  function l({ topSchemaRef: $, schemaPath: _ }, Q, N, B) {
    if (!B) {
      if (typeof Q == "number" || typeof Q == "boolean")
        return Q;
      if (typeof Q == "string")
        return (0, e._)`${Q}`;
    }
    return (0, e._)`${$}${_}${(0, e.getProperty)(N)}`;
  }
  t.schemaRefOrVal = l;
  function c($) {
    return f(decodeURIComponent($));
  }
  t.unescapeFragment = c;
  function u($) {
    return encodeURIComponent(d($));
  }
  t.escapeFragment = u;
  function d($) {
    return typeof $ == "number" ? `${$}` : $.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  t.escapeJsonPointer = d;
  function f($) {
    return $.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  t.unescapeJsonPointer = f;
  function h($, _) {
    if (Array.isArray($))
      for (const Q of $)
        _(Q);
    else
      _($);
  }
  t.eachItem = h;
  function p({ mergeNames: $, mergeToName: _, mergeValues: Q, resultToName: N }) {
    return (B, J, U, ue) => {
      const le = U === void 0 ? J : U instanceof e.Name ? (J instanceof e.Name ? $(B, J, U) : _(B, J, U), U) : J instanceof e.Name ? (_(B, U, J), J) : Q(J, U);
      return ue === e.Name && !(le instanceof e.Name) ? N(B, le) : le;
    };
  }
  t.mergeEvaluated = {
    props: p({
      mergeNames: ($, _, Q) => $.if((0, e._)`${Q} !== true && ${_} !== undefined`, () => {
        $.if((0, e._)`${_} === true`, () => $.assign(Q, !0), () => $.assign(Q, (0, e._)`${Q} || {}`).code((0, e._)`Object.assign(${Q}, ${_})`));
      }),
      mergeToName: ($, _, Q) => $.if((0, e._)`${Q} !== true`, () => {
        _ === !0 ? $.assign(Q, !0) : ($.assign(Q, (0, e._)`${Q} || {}`), m($, Q, _));
      }),
      mergeValues: ($, _) => $ === !0 ? !0 : { ...$, ..._ },
      resultToName: g
    }),
    items: p({
      mergeNames: ($, _, Q) => $.if((0, e._)`${Q} !== true && ${_} !== undefined`, () => $.assign(Q, (0, e._)`${_} === true ? true : ${Q} > ${_} ? ${Q} : ${_}`)),
      mergeToName: ($, _, Q) => $.if((0, e._)`${Q} !== true`, () => $.assign(Q, _ === !0 ? !0 : (0, e._)`${Q} > ${_} ? ${Q} : ${_}`)),
      mergeValues: ($, _) => $ === !0 ? !0 : Math.max($, _),
      resultToName: ($, _) => $.var("items", _)
    })
  };
  function g($, _) {
    if (_ === !0)
      return $.var("props", !0);
    const Q = $.var("props", (0, e._)`{}`);
    return _ !== void 0 && m($, Q, _), Q;
  }
  t.evaluatedPropsToName = g;
  function m($, _, Q) {
    Object.keys(Q).forEach((N) => $.assign((0, e._)`${_}${(0, e.getProperty)(N)}`, !0));
  }
  t.setEvaluated = m;
  const y = {};
  function O($, _) {
    return $.scopeValue("func", {
      ref: _,
      code: y[_.code] || (y[_.code] = new r._Code(_.code))
    });
  }
  t.useFunc = O;
  var b;
  (function($) {
    $[$.Num = 0] = "Num", $[$.Str = 1] = "Str";
  })(b = t.Type || (t.Type = {}));
  function w($, _, Q) {
    if ($ instanceof e.Name) {
      const N = _ === b.Num;
      return Q ? N ? (0, e._)`"[" + ${$} + "]"` : (0, e._)`"['" + ${$} + "']"` : N ? (0, e._)`"/" + ${$}` : (0, e._)`"/" + ${$}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return Q ? (0, e.getProperty)($).toString() : "/" + d($);
  }
  t.getErrorPath = w;
  function S($, _, Q = $.opts.strictSchema) {
    if (Q) {
      if (_ = `strict mode: ${_}`, Q === !0)
        throw new Error(_);
      $.self.logger.warn(_);
    }
  }
  t.checkStrictMode = S;
})(je);
var mr = {};
Object.defineProperty(mr, "__esModule", { value: !0 });
const It = Qe, OM = {
  // validation function arguments
  data: new It.Name("data"),
  // args passed from referencing schema
  valCxt: new It.Name("valCxt"),
  instancePath: new It.Name("instancePath"),
  parentData: new It.Name("parentData"),
  parentDataProperty: new It.Name("parentDataProperty"),
  rootData: new It.Name("rootData"),
  dynamicAnchors: new It.Name("dynamicAnchors"),
  // function scoped variables
  vErrors: new It.Name("vErrors"),
  errors: new It.Name("errors"),
  this: new It.Name("this"),
  // "globals"
  self: new It.Name("self"),
  scope: new It.Name("scope"),
  // JTD serialize/parse name for JSON string and position
  json: new It.Name("json"),
  jsonPos: new It.Name("jsonPos"),
  jsonLen: new It.Name("jsonLen"),
  jsonPart: new It.Name("jsonPart")
};
mr.default = OM;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.extendErrors = t.resetErrorsCount = t.reportExtraError = t.reportError = t.keyword$DataError = t.keywordError = void 0;
  const e = Qe, r = je, n = mr;
  t.keywordError = {
    message: ({ keyword: m }) => (0, e.str)`must pass "${m}" keyword validation`
  }, t.keyword$DataError = {
    message: ({ keyword: m, schemaType: y }) => y ? (0, e.str)`"${m}" keyword must be ${y} ($data)` : (0, e.str)`"${m}" keyword is invalid ($data)`
  };
  function i(m, y = t.keywordError, O, b) {
    const { it: w } = m, { gen: S, compositeRule: $, allErrors: _ } = w, Q = d(m, y, O);
    b ?? ($ || _) ? l(S, Q) : c(w, (0, e._)`[${Q}]`);
  }
  t.reportError = i;
  function s(m, y = t.keywordError, O) {
    const { it: b } = m, { gen: w, compositeRule: S, allErrors: $ } = b, _ = d(m, y, O);
    l(w, _), S || $ || c(b, n.default.vErrors);
  }
  t.reportExtraError = s;
  function o(m, y) {
    m.assign(n.default.errors, y), m.if((0, e._)`${n.default.vErrors} !== null`, () => m.if(y, () => m.assign((0, e._)`${n.default.vErrors}.length`, y), () => m.assign(n.default.vErrors, null)));
  }
  t.resetErrorsCount = o;
  function a({ gen: m, keyword: y, schemaValue: O, data: b, errsCount: w, it: S }) {
    if (w === void 0)
      throw new Error("ajv implementation error");
    const $ = m.name("err");
    m.forRange("i", w, n.default.errors, (_) => {
      m.const($, (0, e._)`${n.default.vErrors}[${_}]`), m.if((0, e._)`${$}.instancePath === undefined`, () => m.assign((0, e._)`${$}.instancePath`, (0, e.strConcat)(n.default.instancePath, S.errorPath))), m.assign((0, e._)`${$}.schemaPath`, (0, e.str)`${S.errSchemaPath}/${y}`), S.opts.verbose && (m.assign((0, e._)`${$}.schema`, O), m.assign((0, e._)`${$}.data`, b));
    });
  }
  t.extendErrors = a;
  function l(m, y) {
    const O = m.const("err", y);
    m.if((0, e._)`${n.default.vErrors} === null`, () => m.assign(n.default.vErrors, (0, e._)`[${O}]`), (0, e._)`${n.default.vErrors}.push(${O})`), m.code((0, e._)`${n.default.errors}++`);
  }
  function c(m, y) {
    const { gen: O, validateName: b, schemaEnv: w } = m;
    w.$async ? O.throw((0, e._)`new ${m.ValidationError}(${y})`) : (O.assign((0, e._)`${b}.errors`, y), O.return(!1));
  }
  const u = {
    keyword: new e.Name("keyword"),
    schemaPath: new e.Name("schemaPath"),
    params: new e.Name("params"),
    propertyName: new e.Name("propertyName"),
    message: new e.Name("message"),
    schema: new e.Name("schema"),
    parentSchema: new e.Name("parentSchema")
  };
  function d(m, y, O) {
    const { createErrors: b } = m.it;
    return b === !1 ? (0, e._)`{}` : f(m, y, O);
  }
  function f(m, y, O = {}) {
    const { gen: b, it: w } = m, S = [
      h(w, O),
      p(m, O)
    ];
    return g(m, y, S), b.object(...S);
  }
  function h({ errorPath: m }, { instancePath: y }) {
    const O = y ? (0, e.str)`${m}${(0, r.getErrorPath)(y, r.Type.Str)}` : m;
    return [n.default.instancePath, (0, e.strConcat)(n.default.instancePath, O)];
  }
  function p({ keyword: m, it: { errSchemaPath: y } }, { schemaPath: O, parentSchema: b }) {
    let w = b ? y : (0, e.str)`${y}/${m}`;
    return O && (w = (0, e.str)`${w}${(0, r.getErrorPath)(O, r.Type.Str)}`), [u.schemaPath, w];
  }
  function g(m, { params: y, message: O }, b) {
    const { keyword: w, data: S, schemaValue: $, it: _ } = m, { opts: Q, propertyName: N, topSchemaRef: B, schemaPath: J } = _;
    b.push([u.keyword, w], [u.params, typeof y == "function" ? y(m) : y || (0, e._)`{}`]), Q.messages && b.push([u.message, typeof O == "function" ? O(m) : O]), Q.verbose && b.push([u.schema, $], [u.parentSchema, (0, e._)`${B}${J}`], [n.default.data, S]), N && b.push([u.propertyName, N]);
  }
})(Al);
Object.defineProperty(Po, "__esModule", { value: !0 });
Po.boolOrEmptySchema = Po.topBoolOrEmptySchema = void 0;
const yM = Al, bM = Qe, vM = mr, wM = {
  message: "boolean schema is false"
};
function $M(t) {
  const { gen: e, schema: r, validateName: n } = t;
  r === !1 ? jS(t, !1) : typeof r == "object" && r.$async === !0 ? e.return(vM.default.data) : (e.assign((0, bM._)`${n}.errors`, null), e.return(!0));
}
Po.topBoolOrEmptySchema = $M;
function SM(t, e) {
  const { gen: r, schema: n } = t;
  n === !1 ? (r.var(e, !1), jS(t)) : r.var(e, !0);
}
Po.boolOrEmptySchema = SM;
function jS(t, e) {
  const { gen: r, data: n } = t, i = {
    gen: r,
    keyword: "false schema",
    data: n,
    schema: !1,
    schemaCode: !1,
    schemaValue: !1,
    params: {},
    it: t
  };
  (0, yM.reportError)(i, wM, void 0, e);
}
var El = {}, ps = {};
Object.defineProperty(ps, "__esModule", { value: !0 });
ps.getRules = ps.isJSONType = void 0;
const kM = ["string", "number", "integer", "boolean", "null", "object", "array"], _M = new Set(kM);
function PM(t) {
  return typeof t == "string" && _M.has(t);
}
ps.isJSONType = PM;
function xM() {
  const t = {
    number: { type: "number", rules: [] },
    string: { type: "string", rules: [] },
    array: { type: "array", rules: [] },
    object: { type: "object", rules: [] }
  };
  return {
    types: { ...t, integer: !0, boolean: !0, null: !0 },
    rules: [{ rules: [] }, t.number, t.string, t.array, t.object],
    post: { rules: [] },
    all: {},
    keywords: {}
  };
}
ps.getRules = xM;
var jn = {};
Object.defineProperty(jn, "__esModule", { value: !0 });
jn.shouldUseRule = jn.shouldUseGroup = jn.schemaHasRulesForType = void 0;
function TM({ schema: t, self: e }, r) {
  const n = e.RULES.types[r];
  return n && n !== !0 && ZS(t, n);
}
jn.schemaHasRulesForType = TM;
function ZS(t, e) {
  return e.rules.some((r) => MS(t, r));
}
jn.shouldUseGroup = ZS;
function MS(t, e) {
  var r;
  return t[e.keyword] !== void 0 || ((r = e.definition.implements) === null || r === void 0 ? void 0 : r.some((n) => t[n] !== void 0));
}
jn.shouldUseRule = MS;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.reportTypeError = t.checkDataTypes = t.checkDataType = t.coerceAndCheckDataType = t.getJSONTypes = t.getSchemaTypes = t.DataType = void 0;
  const e = ps, r = jn, n = Al, i = Qe, s = je;
  var o;
  (function(b) {
    b[b.Correct = 0] = "Correct", b[b.Wrong = 1] = "Wrong";
  })(o = t.DataType || (t.DataType = {}));
  function a(b) {
    const w = l(b.type);
    if (w.includes("null")) {
      if (b.nullable === !1)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!w.length && b.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      b.nullable === !0 && w.push("null");
    }
    return w;
  }
  t.getSchemaTypes = a;
  function l(b) {
    const w = Array.isArray(b) ? b : b ? [b] : [];
    if (w.every(e.isJSONType))
      return w;
    throw new Error("type must be JSONType or JSONType[]: " + w.join(","));
  }
  t.getJSONTypes = l;
  function c(b, w) {
    const { gen: S, data: $, opts: _ } = b, Q = d(w, _.coerceTypes), N = w.length > 0 && !(Q.length === 0 && w.length === 1 && (0, r.schemaHasRulesForType)(b, w[0]));
    if (N) {
      const B = g(w, $, _.strictNumbers, o.Wrong);
      S.if(B, () => {
        Q.length ? f(b, w, Q) : y(b);
      });
    }
    return N;
  }
  t.coerceAndCheckDataType = c;
  const u = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function d(b, w) {
    return w ? b.filter((S) => u.has(S) || w === "array" && S === "array") : [];
  }
  function f(b, w, S) {
    const { gen: $, data: _, opts: Q } = b, N = $.let("dataType", (0, i._)`typeof ${_}`), B = $.let("coerced", (0, i._)`undefined`);
    Q.coerceTypes === "array" && $.if((0, i._)`${N} == 'object' && Array.isArray(${_}) && ${_}.length == 1`, () => $.assign(_, (0, i._)`${_}[0]`).assign(N, (0, i._)`typeof ${_}`).if(g(w, _, Q.strictNumbers), () => $.assign(B, _))), $.if((0, i._)`${B} !== undefined`);
    for (const U of S)
      (u.has(U) || U === "array" && Q.coerceTypes === "array") && J(U);
    $.else(), y(b), $.endIf(), $.if((0, i._)`${B} !== undefined`, () => {
      $.assign(_, B), h(b, B);
    });
    function J(U) {
      switch (U) {
        case "string":
          $.elseIf((0, i._)`${N} == "number" || ${N} == "boolean"`).assign(B, (0, i._)`"" + ${_}`).elseIf((0, i._)`${_} === null`).assign(B, (0, i._)`""`);
          return;
        case "number":
          $.elseIf((0, i._)`${N} == "boolean" || ${_} === null
              || (${N} == "string" && ${_} && ${_} == +${_})`).assign(B, (0, i._)`+${_}`);
          return;
        case "integer":
          $.elseIf((0, i._)`${N} === "boolean" || ${_} === null
              || (${N} === "string" && ${_} && ${_} == +${_} && !(${_} % 1))`).assign(B, (0, i._)`+${_}`);
          return;
        case "boolean":
          $.elseIf((0, i._)`${_} === "false" || ${_} === 0 || ${_} === null`).assign(B, !1).elseIf((0, i._)`${_} === "true" || ${_} === 1`).assign(B, !0);
          return;
        case "null":
          $.elseIf((0, i._)`${_} === "" || ${_} === 0 || ${_} === false`), $.assign(B, null);
          return;
        case "array":
          $.elseIf((0, i._)`${N} === "string" || ${N} === "number"
              || ${N} === "boolean" || ${_} === null`).assign(B, (0, i._)`[${_}]`);
      }
    }
  }
  function h({ gen: b, parentData: w, parentDataProperty: S }, $) {
    b.if((0, i._)`${w} !== undefined`, () => b.assign((0, i._)`${w}[${S}]`, $));
  }
  function p(b, w, S, $ = o.Correct) {
    const _ = $ === o.Correct ? i.operators.EQ : i.operators.NEQ;
    let Q;
    switch (b) {
      case "null":
        return (0, i._)`${w} ${_} null`;
      case "array":
        Q = (0, i._)`Array.isArray(${w})`;
        break;
      case "object":
        Q = (0, i._)`${w} && typeof ${w} == "object" && !Array.isArray(${w})`;
        break;
      case "integer":
        Q = N((0, i._)`!(${w} % 1) && !isNaN(${w})`);
        break;
      case "number":
        Q = N();
        break;
      default:
        return (0, i._)`typeof ${w} ${_} ${b}`;
    }
    return $ === o.Correct ? Q : (0, i.not)(Q);
    function N(B = i.nil) {
      return (0, i.and)((0, i._)`typeof ${w} == "number"`, B, S ? (0, i._)`isFinite(${w})` : i.nil);
    }
  }
  t.checkDataType = p;
  function g(b, w, S, $) {
    if (b.length === 1)
      return p(b[0], w, S, $);
    let _;
    const Q = (0, s.toHash)(b);
    if (Q.array && Q.object) {
      const N = (0, i._)`typeof ${w} != "object"`;
      _ = Q.null ? N : (0, i._)`!${w} || ${N}`, delete Q.null, delete Q.array, delete Q.object;
    } else
      _ = i.nil;
    Q.number && delete Q.integer;
    for (const N in Q)
      _ = (0, i.and)(_, p(N, w, S, $));
    return _;
  }
  t.checkDataTypes = g;
  const m = {
    message: ({ schema: b }) => `must be ${b}`,
    params: ({ schema: b, schemaValue: w }) => typeof b == "string" ? (0, i._)`{type: ${b}}` : (0, i._)`{type: ${w}}`
  };
  function y(b) {
    const w = O(b);
    (0, n.reportError)(w, m);
  }
  t.reportTypeError = y;
  function O(b) {
    const { gen: w, data: S, schema: $ } = b, _ = (0, s.schemaRefOrVal)(b, $, "type");
    return {
      gen: w,
      keyword: "type",
      data: S,
      schema: $.type,
      schemaCode: _,
      schemaValue: _,
      parentSchema: $,
      params: {},
      it: b
    };
  }
})(El);
var ud = {};
Object.defineProperty(ud, "__esModule", { value: !0 });
ud.assignDefaults = void 0;
const Is = Qe, CM = je;
function QM(t, e) {
  const { properties: r, items: n } = t.schema;
  if (e === "object" && r)
    for (const i in r)
      Ry(t, i, r[i].default);
  else
    e === "array" && Array.isArray(n) && n.forEach((i, s) => Ry(t, s, i.default));
}
ud.assignDefaults = QM;
function Ry(t, e, r) {
  const { gen: n, compositeRule: i, data: s, opts: o } = t;
  if (r === void 0)
    return;
  const a = (0, Is._)`${s}${(0, Is.getProperty)(e)}`;
  if (i) {
    (0, CM.checkStrictMode)(t, `default is ignored for: ${a}`);
    return;
  }
  let l = (0, Is._)`${a} === undefined`;
  o.useDefaults === "empty" && (l = (0, Is._)`${l} || ${a} === null || ${a} === ""`), n.if(l, (0, Is._)`${a} = ${(0, Is.stringify)(r)}`);
}
var pn = {}, Re = {};
Object.defineProperty(Re, "__esModule", { value: !0 });
Re.validateUnion = Re.validateArray = Re.usePattern = Re.callValidateCode = Re.schemaProperties = Re.allSchemaProperties = Re.noPropertyInData = Re.propertyInData = Re.isOwnProperty = Re.hasPropFunc = Re.reportMissingProp = Re.checkMissingProp = Re.checkReportMissingProp = void 0;
const Je = Qe, sg = je, Hn = mr, AM = je;
function EM(t, e) {
  const { gen: r, data: n, it: i } = t;
  r.if(ag(r, n, e, i.opts.ownProperties), () => {
    t.setParams({ missingProperty: (0, Je._)`${e}` }, !0), t.error();
  });
}
Re.checkReportMissingProp = EM;
function RM({ gen: t, data: e, it: { opts: r } }, n, i) {
  return (0, Je.or)(...n.map((s) => (0, Je.and)(ag(t, e, s, r.ownProperties), (0, Je._)`${i} = ${s}`)));
}
Re.checkMissingProp = RM;
function IM(t, e) {
  t.setParams({ missingProperty: e }, !0), t.error();
}
Re.reportMissingProp = IM;
function qS(t) {
  return t.scopeValue("func", {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ref: Object.prototype.hasOwnProperty,
    code: (0, Je._)`Object.prototype.hasOwnProperty`
  });
}
Re.hasPropFunc = qS;
function og(t, e, r) {
  return (0, Je._)`${qS(t)}.call(${e}, ${r})`;
}
Re.isOwnProperty = og;
function jM(t, e, r, n) {
  const i = (0, Je._)`${e}${(0, Je.getProperty)(r)} !== undefined`;
  return n ? (0, Je._)`${i} && ${og(t, e, r)}` : i;
}
Re.propertyInData = jM;
function ag(t, e, r, n) {
  const i = (0, Je._)`${e}${(0, Je.getProperty)(r)} === undefined`;
  return n ? (0, Je.or)(i, (0, Je.not)(og(t, e, r))) : i;
}
Re.noPropertyInData = ag;
function NS(t) {
  return t ? Object.keys(t).filter((e) => e !== "__proto__") : [];
}
Re.allSchemaProperties = NS;
function ZM(t, e) {
  return NS(e).filter((r) => !(0, sg.alwaysValidSchema)(t, e[r]));
}
Re.schemaProperties = ZM;
function MM({ schemaCode: t, data: e, it: { gen: r, topSchemaRef: n, schemaPath: i, errorPath: s }, it: o }, a, l, c) {
  const u = c ? (0, Je._)`${t}, ${e}, ${n}${i}` : e, d = [
    [Hn.default.instancePath, (0, Je.strConcat)(Hn.default.instancePath, s)],
    [Hn.default.parentData, o.parentData],
    [Hn.default.parentDataProperty, o.parentDataProperty],
    [Hn.default.rootData, Hn.default.rootData]
  ];
  o.opts.dynamicRef && d.push([Hn.default.dynamicAnchors, Hn.default.dynamicAnchors]);
  const f = (0, Je._)`${u}, ${r.object(...d)}`;
  return l !== Je.nil ? (0, Je._)`${a}.call(${l}, ${f})` : (0, Je._)`${a}(${f})`;
}
Re.callValidateCode = MM;
const qM = (0, Je._)`new RegExp`;
function NM({ gen: t, it: { opts: e } }, r) {
  const n = e.unicodeRegExp ? "u" : "", { regExp: i } = e.code, s = i(r, n);
  return t.scopeValue("pattern", {
    key: s.toString(),
    ref: s,
    code: (0, Je._)`${i.code === "new RegExp" ? qM : (0, AM.useFunc)(t, i)}(${r}, ${n})`
  });
}
Re.usePattern = NM;
function DM(t) {
  const { gen: e, data: r, keyword: n, it: i } = t, s = e.name("valid");
  if (i.allErrors) {
    const a = e.let("valid", !0);
    return o(() => e.assign(a, !1)), a;
  }
  return e.var(s, !0), o(() => e.break()), s;
  function o(a) {
    const l = e.const("len", (0, Je._)`${r}.length`);
    e.forRange("i", 0, l, (c) => {
      t.subschema({
        keyword: n,
        dataProp: c,
        dataPropType: sg.Type.Num
      }, s), e.if((0, Je.not)(s), a);
    });
  }
}
Re.validateArray = DM;
function zM(t) {
  const { gen: e, schema: r, keyword: n, it: i } = t;
  if (!Array.isArray(r))
    throw new Error("ajv implementation error");
  if (r.some((l) => (0, sg.alwaysValidSchema)(i, l)) && !i.opts.unevaluated)
    return;
  const o = e.let("valid", !1), a = e.name("_valid");
  e.block(() => r.forEach((l, c) => {
    const u = t.subschema({
      keyword: n,
      schemaProp: c,
      compositeRule: !0
    }, a);
    e.assign(o, (0, Je._)`${o} || ${a}`), t.mergeValidEvaluated(u, a) || e.if((0, Je.not)(o));
  })), t.result(o, () => t.reset(), () => t.error(!0));
}
Re.validateUnion = zM;
Object.defineProperty(pn, "__esModule", { value: !0 });
pn.validateKeywordUsage = pn.validSchemaType = pn.funcKeywordCode = pn.macroKeywordCode = void 0;
const Vt = Qe, Vi = mr, XM = Re, WM = Al;
function UM(t, e) {
  const { gen: r, keyword: n, schema: i, parentSchema: s, it: o } = t, a = e.macro.call(o.self, i, s, o), l = DS(r, n, a);
  o.opts.validateSchema !== !1 && o.self.validateSchema(a, !0);
  const c = r.name("valid");
  t.subschema({
    schema: a,
    schemaPath: Vt.nil,
    errSchemaPath: `${o.errSchemaPath}/${n}`,
    topSchemaRef: l,
    compositeRule: !0
  }, c), t.pass(c, () => t.error(!0));
}
pn.macroKeywordCode = UM;
function VM(t, e) {
  var r;
  const { gen: n, keyword: i, schema: s, parentSchema: o, $data: a, it: l } = t;
  YM(l, e);
  const c = !a && e.compile ? e.compile.call(l.self, s, o, l) : e.validate, u = DS(n, i, c), d = n.let("valid");
  t.block$data(d, f), t.ok((r = e.valid) !== null && r !== void 0 ? r : d);
  function f() {
    if (e.errors === !1)
      g(), e.modifying && Iy(t), m(() => t.error());
    else {
      const y = e.async ? h() : p();
      e.modifying && Iy(t), m(() => LM(t, y));
    }
  }
  function h() {
    const y = n.let("ruleErrs", null);
    return n.try(() => g((0, Vt._)`await `), (O) => n.assign(d, !1).if((0, Vt._)`${O} instanceof ${l.ValidationError}`, () => n.assign(y, (0, Vt._)`${O}.errors`), () => n.throw(O))), y;
  }
  function p() {
    const y = (0, Vt._)`${u}.errors`;
    return n.assign(y, null), g(Vt.nil), y;
  }
  function g(y = e.async ? (0, Vt._)`await ` : Vt.nil) {
    const O = l.opts.passContext ? Vi.default.this : Vi.default.self, b = !("compile" in e && !a || e.schema === !1);
    n.assign(d, (0, Vt._)`${y}${(0, XM.callValidateCode)(t, u, O, b)}`, e.modifying);
  }
  function m(y) {
    var O;
    n.if((0, Vt.not)((O = e.valid) !== null && O !== void 0 ? O : d), y);
  }
}
pn.funcKeywordCode = VM;
function Iy(t) {
  const { gen: e, data: r, it: n } = t;
  e.if(n.parentData, () => e.assign(r, (0, Vt._)`${n.parentData}[${n.parentDataProperty}]`));
}
function LM(t, e) {
  const { gen: r } = t;
  r.if((0, Vt._)`Array.isArray(${e})`, () => {
    r.assign(Vi.default.vErrors, (0, Vt._)`${Vi.default.vErrors} === null ? ${e} : ${Vi.default.vErrors}.concat(${e})`).assign(Vi.default.errors, (0, Vt._)`${Vi.default.vErrors}.length`), (0, WM.extendErrors)(t);
  }, () => t.error());
}
function YM({ schemaEnv: t }, e) {
  if (e.async && !t.$async)
    throw new Error("async keyword in sync schema");
}
function DS(t, e, r) {
  if (r === void 0)
    throw new Error(`keyword "${e}" failed to compile`);
  return t.scopeValue("keyword", typeof r == "function" ? { ref: r } : { ref: r, code: (0, Vt.stringify)(r) });
}
function BM(t, e, r = !1) {
  return !e.length || e.some((n) => n === "array" ? Array.isArray(t) : n === "object" ? t && typeof t == "object" && !Array.isArray(t) : typeof t == n || r && typeof t > "u");
}
pn.validSchemaType = BM;
function FM({ schema: t, opts: e, self: r, errSchemaPath: n }, i, s) {
  if (Array.isArray(i.keyword) ? !i.keyword.includes(s) : i.keyword !== s)
    throw new Error("ajv implementation error");
  const o = i.dependencies;
  if (o != null && o.some((a) => !Object.prototype.hasOwnProperty.call(t, a)))
    throw new Error(`parent schema must have dependencies of ${s}: ${o.join(",")}`);
  if (i.validateSchema && !i.validateSchema(t[s])) {
    const l = `keyword "${s}" value is invalid at path "${n}": ` + r.errorsText(i.validateSchema.errors);
    if (e.validateSchema === "log")
      r.logger.error(l);
    else
      throw new Error(l);
  }
}
pn.validateKeywordUsage = FM;
var mi = {};
Object.defineProperty(mi, "__esModule", { value: !0 });
mi.extendSubschemaMode = mi.extendSubschemaData = mi.getSubschema = void 0;
const dn = Qe, zS = je;
function HM(t, { keyword: e, schemaProp: r, schema: n, schemaPath: i, errSchemaPath: s, topSchemaRef: o }) {
  if (e !== void 0 && n !== void 0)
    throw new Error('both "keyword" and "schema" passed, only one allowed');
  if (e !== void 0) {
    const a = t.schema[e];
    return r === void 0 ? {
      schema: a,
      schemaPath: (0, dn._)`${t.schemaPath}${(0, dn.getProperty)(e)}`,
      errSchemaPath: `${t.errSchemaPath}/${e}`
    } : {
      schema: a[r],
      schemaPath: (0, dn._)`${t.schemaPath}${(0, dn.getProperty)(e)}${(0, dn.getProperty)(r)}`,
      errSchemaPath: `${t.errSchemaPath}/${e}/${(0, zS.escapeFragment)(r)}`
    };
  }
  if (n !== void 0) {
    if (i === void 0 || s === void 0 || o === void 0)
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
    return {
      schema: n,
      schemaPath: i,
      topSchemaRef: o,
      errSchemaPath: s
    };
  }
  throw new Error('either "keyword" or "schema" must be passed');
}
mi.getSubschema = HM;
function GM(t, e, { dataProp: r, dataPropType: n, data: i, dataTypes: s, propertyName: o }) {
  if (i !== void 0 && r !== void 0)
    throw new Error('both "data" and "dataProp" passed, only one allowed');
  const { gen: a } = e;
  if (r !== void 0) {
    const { errorPath: c, dataPathArr: u, opts: d } = e, f = a.let("data", (0, dn._)`${e.data}${(0, dn.getProperty)(r)}`, !0);
    l(f), t.errorPath = (0, dn.str)`${c}${(0, zS.getErrorPath)(r, n, d.jsPropertySyntax)}`, t.parentDataProperty = (0, dn._)`${r}`, t.dataPathArr = [...u, t.parentDataProperty];
  }
  if (i !== void 0) {
    const c = i instanceof dn.Name ? i : a.let("data", i, !0);
    l(c), o !== void 0 && (t.propertyName = o);
  }
  s && (t.dataTypes = s);
  function l(c) {
    t.data = c, t.dataLevel = e.dataLevel + 1, t.dataTypes = [], e.definedProperties = /* @__PURE__ */ new Set(), t.parentData = e.data, t.dataNames = [...e.dataNames, c];
  }
}
mi.extendSubschemaData = GM;
function KM(t, { jtdDiscriminator: e, jtdMetadata: r, compositeRule: n, createErrors: i, allErrors: s }) {
  n !== void 0 && (t.compositeRule = n), i !== void 0 && (t.createErrors = i), s !== void 0 && (t.allErrors = s), t.jtdDiscriminator = e, t.jtdMetadata = r;
}
mi.extendSubschemaMode = KM;
var At = {}, XS = function t(e, r) {
  if (e === r)
    return !0;
  if (e && r && typeof e == "object" && typeof r == "object") {
    if (e.constructor !== r.constructor)
      return !1;
    var n, i, s;
    if (Array.isArray(e)) {
      if (n = e.length, n != r.length)
        return !1;
      for (i = n; i-- !== 0; )
        if (!t(e[i], r[i]))
          return !1;
      return !0;
    }
    if (e.constructor === RegExp)
      return e.source === r.source && e.flags === r.flags;
    if (e.valueOf !== Object.prototype.valueOf)
      return e.valueOf() === r.valueOf();
    if (e.toString !== Object.prototype.toString)
      return e.toString() === r.toString();
    if (s = Object.keys(e), n = s.length, n !== Object.keys(r).length)
      return !1;
    for (i = n; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(r, s[i]))
        return !1;
    for (i = n; i-- !== 0; ) {
      var o = s[i];
      if (!t(e[o], r[o]))
        return !1;
    }
    return !0;
  }
  return e !== e && r !== r;
}, WS = { exports: {} }, ci = WS.exports = function(t, e, r) {
  typeof e == "function" && (r = e, e = {}), r = e.cb || r;
  var n = typeof r == "function" ? r : r.pre || function() {
  }, i = r.post || function() {
  };
  Uc(e, n, i, t, "", t);
};
ci.keywords = {
  additionalItems: !0,
  items: !0,
  contains: !0,
  additionalProperties: !0,
  propertyNames: !0,
  not: !0,
  if: !0,
  then: !0,
  else: !0
};
ci.arrayKeywords = {
  items: !0,
  allOf: !0,
  anyOf: !0,
  oneOf: !0
};
ci.propsKeywords = {
  $defs: !0,
  definitions: !0,
  properties: !0,
  patternProperties: !0,
  dependencies: !0
};
ci.skipKeywords = {
  default: !0,
  enum: !0,
  const: !0,
  required: !0,
  maximum: !0,
  minimum: !0,
  exclusiveMaximum: !0,
  exclusiveMinimum: !0,
  multipleOf: !0,
  maxLength: !0,
  minLength: !0,
  pattern: !0,
  format: !0,
  maxItems: !0,
  minItems: !0,
  uniqueItems: !0,
  maxProperties: !0,
  minProperties: !0
};
function Uc(t, e, r, n, i, s, o, a, l, c) {
  if (n && typeof n == "object" && !Array.isArray(n)) {
    e(n, i, s, o, a, l, c);
    for (var u in n) {
      var d = n[u];
      if (Array.isArray(d)) {
        if (u in ci.arrayKeywords)
          for (var f = 0; f < d.length; f++)
            Uc(t, e, r, d[f], i + "/" + u + "/" + f, s, i, u, n, f);
      } else if (u in ci.propsKeywords) {
        if (d && typeof d == "object")
          for (var h in d)
            Uc(t, e, r, d[h], i + "/" + u + "/" + JM(h), s, i, u, n, h);
      } else
        (u in ci.keywords || t.allKeys && !(u in ci.skipKeywords)) && Uc(t, e, r, d, i + "/" + u, s, i, u, n);
    }
    r(n, i, s, o, a, l, c);
  }
}
function JM(t) {
  return t.replace(/~/g, "~0").replace(/\//g, "~1");
}
var eq = WS.exports;
Object.defineProperty(At, "__esModule", { value: !0 });
At.getSchemaRefs = At.resolveUrl = At.normalizeId = At._getFullPath = At.getFullPath = At.inlineRef = void 0;
const tq = je, rq = XS, nq = eq, iq = /* @__PURE__ */ new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const"
]);
function sq(t, e = !0) {
  return typeof t == "boolean" ? !0 : e === !0 ? !Sp(t) : e ? US(t) <= e : !1;
}
At.inlineRef = sq;
const oq = /* @__PURE__ */ new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor"
]);
function Sp(t) {
  for (const e in t) {
    if (oq.has(e))
      return !0;
    const r = t[e];
    if (Array.isArray(r) && r.some(Sp) || typeof r == "object" && Sp(r))
      return !0;
  }
  return !1;
}
function US(t) {
  let e = 0;
  for (const r in t) {
    if (r === "$ref")
      return 1 / 0;
    if (e++, !iq.has(r) && (typeof t[r] == "object" && (0, tq.eachItem)(t[r], (n) => e += US(n)), e === 1 / 0))
      return 1 / 0;
  }
  return e;
}
function VS(t, e = "", r) {
  r !== !1 && (e = uo(e));
  const n = t.parse(e);
  return LS(t, n);
}
At.getFullPath = VS;
function LS(t, e) {
  return t.serialize(e).split("#")[0] + "#";
}
At._getFullPath = LS;
const aq = /#\/?$/;
function uo(t) {
  return t ? t.replace(aq, "") : "";
}
At.normalizeId = uo;
function lq(t, e, r) {
  return r = uo(r), t.resolve(e, r);
}
At.resolveUrl = lq;
const cq = /^[a-z_][-a-z0-9._]*$/i;
function uq(t, e) {
  if (typeof t == "boolean")
    return {};
  const { schemaId: r, uriResolver: n } = this.opts, i = uo(t[r] || e), s = { "": i }, o = VS(n, i, !1), a = {}, l = /* @__PURE__ */ new Set();
  return nq(t, { allKeys: !0 }, (d, f, h, p) => {
    if (p === void 0)
      return;
    const g = o + f;
    let m = s[p];
    typeof d[r] == "string" && (m = y.call(this, d[r])), O.call(this, d.$anchor), O.call(this, d.$dynamicAnchor), s[f] = m;
    function y(b) {
      const w = this.opts.uriResolver.resolve;
      if (b = uo(m ? w(m, b) : b), l.has(b))
        throw u(b);
      l.add(b);
      let S = this.refs[b];
      return typeof S == "string" && (S = this.refs[S]), typeof S == "object" ? c(d, S.schema, b) : b !== uo(g) && (b[0] === "#" ? (c(d, a[b], b), a[b] = d) : this.refs[b] = g), b;
    }
    function O(b) {
      if (typeof b == "string") {
        if (!cq.test(b))
          throw new Error(`invalid anchor "${b}"`);
        y.call(this, `#${b}`);
      }
    }
  }), a;
  function c(d, f, h) {
    if (f !== void 0 && !rq(d, f))
      throw u(h);
  }
  function u(d) {
    return new Error(`reference "${d}" resolves to more than one schema`);
  }
}
At.getSchemaRefs = uq;
Object.defineProperty(Ur, "__esModule", { value: !0 });
Ur.getData = Ur.KeywordCxt = Ur.validateFunctionCode = void 0;
const YS = Po, jy = El, lg = jn, Tu = El, dq = ud, Da = pn, Mf = mi, pe = Qe, ke = mr, fq = At, Zn = je, ga = Al;
function hq(t) {
  if (HS(t) && (GS(t), FS(t))) {
    gq(t);
    return;
  }
  BS(t, () => (0, YS.topBoolOrEmptySchema)(t));
}
Ur.validateFunctionCode = hq;
function BS({ gen: t, validateName: e, schema: r, schemaEnv: n, opts: i }, s) {
  i.code.es5 ? t.func(e, (0, pe._)`${ke.default.data}, ${ke.default.valCxt}`, n.$async, () => {
    t.code((0, pe._)`"use strict"; ${Zy(r, i)}`), mq(t, i), t.code(s);
  }) : t.func(e, (0, pe._)`${ke.default.data}, ${pq(i)}`, n.$async, () => t.code(Zy(r, i)).code(s));
}
function pq(t) {
  return (0, pe._)`{${ke.default.instancePath}="", ${ke.default.parentData}, ${ke.default.parentDataProperty}, ${ke.default.rootData}=${ke.default.data}${t.dynamicRef ? (0, pe._)`, ${ke.default.dynamicAnchors}={}` : pe.nil}}={}`;
}
function mq(t, e) {
  t.if(ke.default.valCxt, () => {
    t.var(ke.default.instancePath, (0, pe._)`${ke.default.valCxt}.${ke.default.instancePath}`), t.var(ke.default.parentData, (0, pe._)`${ke.default.valCxt}.${ke.default.parentData}`), t.var(ke.default.parentDataProperty, (0, pe._)`${ke.default.valCxt}.${ke.default.parentDataProperty}`), t.var(ke.default.rootData, (0, pe._)`${ke.default.valCxt}.${ke.default.rootData}`), e.dynamicRef && t.var(ke.default.dynamicAnchors, (0, pe._)`${ke.default.valCxt}.${ke.default.dynamicAnchors}`);
  }, () => {
    t.var(ke.default.instancePath, (0, pe._)`""`), t.var(ke.default.parentData, (0, pe._)`undefined`), t.var(ke.default.parentDataProperty, (0, pe._)`undefined`), t.var(ke.default.rootData, ke.default.data), e.dynamicRef && t.var(ke.default.dynamicAnchors, (0, pe._)`{}`);
  });
}
function gq(t) {
  const { schema: e, opts: r, gen: n } = t;
  BS(t, () => {
    r.$comment && e.$comment && JS(t), wq(t), n.let(ke.default.vErrors, null), n.let(ke.default.errors, 0), r.unevaluated && Oq(t), KS(t), kq(t);
  });
}
function Oq(t) {
  const { gen: e, validateName: r } = t;
  t.evaluated = e.const("evaluated", (0, pe._)`${r}.evaluated`), e.if((0, pe._)`${t.evaluated}.dynamicProps`, () => e.assign((0, pe._)`${t.evaluated}.props`, (0, pe._)`undefined`)), e.if((0, pe._)`${t.evaluated}.dynamicItems`, () => e.assign((0, pe._)`${t.evaluated}.items`, (0, pe._)`undefined`));
}
function Zy(t, e) {
  const r = typeof t == "object" && t[e.schemaId];
  return r && (e.code.source || e.code.process) ? (0, pe._)`/*# sourceURL=${r} */` : pe.nil;
}
function yq(t, e) {
  if (HS(t) && (GS(t), FS(t))) {
    bq(t, e);
    return;
  }
  (0, YS.boolOrEmptySchema)(t, e);
}
function FS({ schema: t, self: e }) {
  if (typeof t == "boolean")
    return !t;
  for (const r in t)
    if (e.RULES.all[r])
      return !0;
  return !1;
}
function HS(t) {
  return typeof t.schema != "boolean";
}
function bq(t, e) {
  const { schema: r, gen: n, opts: i } = t;
  i.$comment && r.$comment && JS(t), $q(t), Sq(t);
  const s = n.const("_errs", ke.default.errors);
  KS(t, s), n.var(e, (0, pe._)`${s} === ${ke.default.errors}`);
}
function GS(t) {
  (0, Zn.checkUnknownRules)(t), vq(t);
}
function KS(t, e) {
  if (t.opts.jtd)
    return My(t, [], !1, e);
  const r = (0, jy.getSchemaTypes)(t.schema), n = (0, jy.coerceAndCheckDataType)(t, r);
  My(t, r, !n, e);
}
function vq(t) {
  const { schema: e, errSchemaPath: r, opts: n, self: i } = t;
  e.$ref && n.ignoreKeywordsWithRef && (0, Zn.schemaHasRulesButRef)(e, i.RULES) && i.logger.warn(`$ref: keywords ignored in schema at path "${r}"`);
}
function wq(t) {
  const { schema: e, opts: r } = t;
  e.default !== void 0 && r.useDefaults && r.strictSchema && (0, Zn.checkStrictMode)(t, "default is ignored in the schema root");
}
function $q(t) {
  const e = t.schema[t.opts.schemaId];
  e && (t.baseId = (0, fq.resolveUrl)(t.opts.uriResolver, t.baseId, e));
}
function Sq(t) {
  if (t.schema.$async && !t.schemaEnv.$async)
    throw new Error("async schema in sync schema");
}
function JS({ gen: t, schemaEnv: e, schema: r, errSchemaPath: n, opts: i }) {
  const s = r.$comment;
  if (i.$comment === !0)
    t.code((0, pe._)`${ke.default.self}.logger.log(${s})`);
  else if (typeof i.$comment == "function") {
    const o = (0, pe.str)`${n}/$comment`, a = t.scopeValue("root", { ref: e.root });
    t.code((0, pe._)`${ke.default.self}.opts.$comment(${s}, ${o}, ${a}.schema)`);
  }
}
function kq(t) {
  const { gen: e, schemaEnv: r, validateName: n, ValidationError: i, opts: s } = t;
  r.$async ? e.if((0, pe._)`${ke.default.errors} === 0`, () => e.return(ke.default.data), () => e.throw((0, pe._)`new ${i}(${ke.default.vErrors})`)) : (e.assign((0, pe._)`${n}.errors`, ke.default.vErrors), s.unevaluated && _q(t), e.return((0, pe._)`${ke.default.errors} === 0`));
}
function _q({ gen: t, evaluated: e, props: r, items: n }) {
  r instanceof pe.Name && t.assign((0, pe._)`${e}.props`, r), n instanceof pe.Name && t.assign((0, pe._)`${e}.items`, n);
}
function My(t, e, r, n) {
  const { gen: i, schema: s, data: o, allErrors: a, opts: l, self: c } = t, { RULES: u } = c;
  if (s.$ref && (l.ignoreKeywordsWithRef || !(0, Zn.schemaHasRulesButRef)(s, u))) {
    i.block(() => rk(t, "$ref", u.all.$ref.definition));
    return;
  }
  l.jtd || Pq(t, e), i.block(() => {
    for (const f of u.rules)
      d(f);
    d(u.post);
  });
  function d(f) {
    (0, lg.shouldUseGroup)(s, f) && (f.type ? (i.if((0, Tu.checkDataType)(f.type, o, l.strictNumbers)), qy(t, f), e.length === 1 && e[0] === f.type && r && (i.else(), (0, Tu.reportTypeError)(t)), i.endIf()) : qy(t, f), a || i.if((0, pe._)`${ke.default.errors} === ${n || 0}`));
  }
}
function qy(t, e) {
  const { gen: r, schema: n, opts: { useDefaults: i } } = t;
  i && (0, dq.assignDefaults)(t, e.type), r.block(() => {
    for (const s of e.rules)
      (0, lg.shouldUseRule)(n, s) && rk(t, s.keyword, s.definition, e.type);
  });
}
function Pq(t, e) {
  t.schemaEnv.meta || !t.opts.strictTypes || (xq(t, e), t.opts.allowUnionTypes || Tq(t, e), Cq(t, t.dataTypes));
}
function xq(t, e) {
  if (e.length) {
    if (!t.dataTypes.length) {
      t.dataTypes = e;
      return;
    }
    e.forEach((r) => {
      ek(t.dataTypes, r) || cg(t, `type "${r}" not allowed by context "${t.dataTypes.join(",")}"`);
    }), Aq(t, e);
  }
}
function Tq(t, e) {
  e.length > 1 && !(e.length === 2 && e.includes("null")) && cg(t, "use allowUnionTypes to allow union type keyword");
}
function Cq(t, e) {
  const r = t.self.RULES.all;
  for (const n in r) {
    const i = r[n];
    if (typeof i == "object" && (0, lg.shouldUseRule)(t.schema, i)) {
      const { type: s } = i.definition;
      s.length && !s.some((o) => Qq(e, o)) && cg(t, `missing type "${s.join(",")}" for keyword "${n}"`);
    }
  }
}
function Qq(t, e) {
  return t.includes(e) || e === "number" && t.includes("integer");
}
function ek(t, e) {
  return t.includes(e) || e === "integer" && t.includes("number");
}
function Aq(t, e) {
  const r = [];
  for (const n of t.dataTypes)
    ek(e, n) ? r.push(n) : e.includes("integer") && n === "number" && r.push("integer");
  t.dataTypes = r;
}
function cg(t, e) {
  const r = t.schemaEnv.baseId + t.errSchemaPath;
  e += ` at "${r}" (strictTypes)`, (0, Zn.checkStrictMode)(t, e, t.opts.strictTypes);
}
class tk {
  constructor(e, r, n) {
    if ((0, Da.validateKeywordUsage)(e, r, n), this.gen = e.gen, this.allErrors = e.allErrors, this.keyword = n, this.data = e.data, this.schema = e.schema[n], this.$data = r.$data && e.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, Zn.schemaRefOrVal)(e, this.schema, n, this.$data), this.schemaType = r.schemaType, this.parentSchema = e.schema, this.params = {}, this.it = e, this.def = r, this.$data)
      this.schemaCode = e.gen.const("vSchema", nk(this.$data, e));
    else if (this.schemaCode = this.schemaValue, !(0, Da.validSchemaType)(this.schema, r.schemaType, r.allowUndefined))
      throw new Error(`${n} value must be ${JSON.stringify(r.schemaType)}`);
    ("code" in r ? r.trackErrors : r.errors !== !1) && (this.errsCount = e.gen.const("_errs", ke.default.errors));
  }
  result(e, r, n) {
    this.failResult((0, pe.not)(e), r, n);
  }
  failResult(e, r, n) {
    this.gen.if(e), n ? n() : this.error(), r ? (this.gen.else(), r(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  pass(e, r) {
    this.failResult((0, pe.not)(e), void 0, r);
  }
  fail(e) {
    if (e === void 0) {
      this.error(), this.allErrors || this.gen.if(!1);
      return;
    }
    this.gen.if(e), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
  }
  fail$data(e) {
    if (!this.$data)
      return this.fail(e);
    const { schemaCode: r } = this;
    this.fail((0, pe._)`${r} !== undefined && (${(0, pe.or)(this.invalid$data(), e)})`);
  }
  error(e, r, n) {
    if (r) {
      this.setParams(r), this._error(e, n), this.setParams({});
      return;
    }
    this._error(e, n);
  }
  _error(e, r) {
    (e ? ga.reportExtraError : ga.reportError)(this, this.def.error, r);
  }
  $dataError() {
    (0, ga.reportError)(this, this.def.$dataError || ga.keyword$DataError);
  }
  reset() {
    if (this.errsCount === void 0)
      throw new Error('add "trackErrors" to keyword definition');
    (0, ga.resetErrorsCount)(this.gen, this.errsCount);
  }
  ok(e) {
    this.allErrors || this.gen.if(e);
  }
  setParams(e, r) {
    r ? Object.assign(this.params, e) : this.params = e;
  }
  block$data(e, r, n = pe.nil) {
    this.gen.block(() => {
      this.check$data(e, n), r();
    });
  }
  check$data(e = pe.nil, r = pe.nil) {
    if (!this.$data)
      return;
    const { gen: n, schemaCode: i, schemaType: s, def: o } = this;
    n.if((0, pe.or)((0, pe._)`${i} === undefined`, r)), e !== pe.nil && n.assign(e, !0), (s.length || o.validateSchema) && (n.elseIf(this.invalid$data()), this.$dataError(), e !== pe.nil && n.assign(e, !1)), n.else();
  }
  invalid$data() {
    const { gen: e, schemaCode: r, schemaType: n, def: i, it: s } = this;
    return (0, pe.or)(o(), a());
    function o() {
      if (n.length) {
        if (!(r instanceof pe.Name))
          throw new Error("ajv implementation error");
        const l = Array.isArray(n) ? n : [n];
        return (0, pe._)`${(0, Tu.checkDataTypes)(l, r, s.opts.strictNumbers, Tu.DataType.Wrong)}`;
      }
      return pe.nil;
    }
    function a() {
      if (i.validateSchema) {
        const l = e.scopeValue("validate$data", { ref: i.validateSchema });
        return (0, pe._)`!${l}(${r})`;
      }
      return pe.nil;
    }
  }
  subschema(e, r) {
    const n = (0, Mf.getSubschema)(this.it, e);
    (0, Mf.extendSubschemaData)(n, this.it, e), (0, Mf.extendSubschemaMode)(n, e);
    const i = { ...this.it, ...n, items: void 0, props: void 0 };
    return yq(i, r), i;
  }
  mergeEvaluated(e, r) {
    const { it: n, gen: i } = this;
    n.opts.unevaluated && (n.props !== !0 && e.props !== void 0 && (n.props = Zn.mergeEvaluated.props(i, e.props, n.props, r)), n.items !== !0 && e.items !== void 0 && (n.items = Zn.mergeEvaluated.items(i, e.items, n.items, r)));
  }
  mergeValidEvaluated(e, r) {
    const { it: n, gen: i } = this;
    if (n.opts.unevaluated && (n.props !== !0 || n.items !== !0))
      return i.if(r, () => this.mergeEvaluated(e, pe.Name)), !0;
  }
}
Ur.KeywordCxt = tk;
function rk(t, e, r, n) {
  const i = new tk(t, r, e);
  "code" in r ? r.code(i, n) : i.$data && r.validate ? (0, Da.funcKeywordCode)(i, r) : "macro" in r ? (0, Da.macroKeywordCode)(i, r) : (r.compile || r.validate) && (0, Da.funcKeywordCode)(i, r);
}
const Eq = /^\/(?:[^~]|~0|~1)*$/, Rq = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function nk(t, { dataLevel: e, dataNames: r, dataPathArr: n }) {
  let i, s;
  if (t === "")
    return ke.default.rootData;
  if (t[0] === "/") {
    if (!Eq.test(t))
      throw new Error(`Invalid JSON-pointer: ${t}`);
    i = t, s = ke.default.rootData;
  } else {
    const c = Rq.exec(t);
    if (!c)
      throw new Error(`Invalid JSON-pointer: ${t}`);
    const u = +c[1];
    if (i = c[2], i === "#") {
      if (u >= e)
        throw new Error(l("property/index", u));
      return n[e - u];
    }
    if (u > e)
      throw new Error(l("data", u));
    if (s = r[e - u], !i)
      return s;
  }
  let o = s;
  const a = i.split("/");
  for (const c of a)
    c && (s = (0, pe._)`${s}${(0, pe.getProperty)((0, Zn.unescapeJsonPointer)(c))}`, o = (0, pe._)`${o} && ${s}`);
  return o;
  function l(c, u) {
    return `Cannot access ${c} ${u} levels up, current level is ${e}`;
  }
}
Ur.getData = nk;
var Rl = {};
Object.defineProperty(Rl, "__esModule", { value: !0 });
class Iq extends Error {
  constructor(e) {
    super("validation failed"), this.errors = e, this.ajv = this.validation = !0;
  }
}
Rl.default = Iq;
var Il = {};
Object.defineProperty(Il, "__esModule", { value: !0 });
const qf = At;
class jq extends Error {
  constructor(e, r, n, i) {
    super(i || `can't resolve reference ${n} from id ${r}`), this.missingRef = (0, qf.resolveUrl)(e, r, n), this.missingSchema = (0, qf.normalizeId)((0, qf.getFullPath)(e, this.missingRef));
  }
}
Il.default = jq;
var Bt = {};
Object.defineProperty(Bt, "__esModule", { value: !0 });
Bt.resolveSchema = Bt.getCompilingSchema = Bt.resolveRef = Bt.compileSchema = Bt.SchemaEnv = void 0;
const Ar = Qe, Zq = Rl, Di = mr, Nr = At, Ny = je, Mq = Ur;
class dd {
  constructor(e) {
    var r;
    this.refs = {}, this.dynamicAnchors = {};
    let n;
    typeof e.schema == "object" && (n = e.schema), this.schema = e.schema, this.schemaId = e.schemaId, this.root = e.root || this, this.baseId = (r = e.baseId) !== null && r !== void 0 ? r : (0, Nr.normalizeId)(n == null ? void 0 : n[e.schemaId || "$id"]), this.schemaPath = e.schemaPath, this.localRefs = e.localRefs, this.meta = e.meta, this.$async = n == null ? void 0 : n.$async, this.refs = {};
  }
}
Bt.SchemaEnv = dd;
function ug(t) {
  const e = ik.call(this, t);
  if (e)
    return e;
  const r = (0, Nr.getFullPath)(this.opts.uriResolver, t.root.baseId), { es5: n, lines: i } = this.opts.code, { ownProperties: s } = this.opts, o = new Ar.CodeGen(this.scope, { es5: n, lines: i, ownProperties: s });
  let a;
  t.$async && (a = o.scopeValue("Error", {
    ref: Zq.default,
    code: (0, Ar._)`require("ajv/dist/runtime/validation_error").default`
  }));
  const l = o.scopeName("validate");
  t.validateName = l;
  const c = {
    gen: o,
    allErrors: this.opts.allErrors,
    data: Di.default.data,
    parentData: Di.default.parentData,
    parentDataProperty: Di.default.parentDataProperty,
    dataNames: [Di.default.data],
    dataPathArr: [Ar.nil],
    dataLevel: 0,
    dataTypes: [],
    definedProperties: /* @__PURE__ */ new Set(),
    topSchemaRef: o.scopeValue("schema", this.opts.code.source === !0 ? { ref: t.schema, code: (0, Ar.stringify)(t.schema) } : { ref: t.schema }),
    validateName: l,
    ValidationError: a,
    schema: t.schema,
    schemaEnv: t,
    rootId: r,
    baseId: t.baseId || r,
    schemaPath: Ar.nil,
    errSchemaPath: t.schemaPath || (this.opts.jtd ? "" : "#"),
    errorPath: (0, Ar._)`""`,
    opts: this.opts,
    self: this
  };
  let u;
  try {
    this._compilations.add(t), (0, Mq.validateFunctionCode)(c), o.optimize(this.opts.code.optimize);
    const d = o.toString();
    u = `${o.scopeRefs(Di.default.scope)}return ${d}`, this.opts.code.process && (u = this.opts.code.process(u, t));
    const h = new Function(`${Di.default.self}`, `${Di.default.scope}`, u)(this, this.scope.get());
    if (this.scope.value(l, { ref: h }), h.errors = null, h.schema = t.schema, h.schemaEnv = t, t.$async && (h.$async = !0), this.opts.code.source === !0 && (h.source = { validateName: l, validateCode: d, scopeValues: o._values }), this.opts.unevaluated) {
      const { props: p, items: g } = c;
      h.evaluated = {
        props: p instanceof Ar.Name ? void 0 : p,
        items: g instanceof Ar.Name ? void 0 : g,
        dynamicProps: p instanceof Ar.Name,
        dynamicItems: g instanceof Ar.Name
      }, h.source && (h.source.evaluated = (0, Ar.stringify)(h.evaluated));
    }
    return t.validate = h, t;
  } catch (d) {
    throw delete t.validate, delete t.validateName, u && this.logger.error("Error compiling schema, function code:", u), d;
  } finally {
    this._compilations.delete(t);
  }
}
Bt.compileSchema = ug;
function qq(t, e, r) {
  var n;
  r = (0, Nr.resolveUrl)(this.opts.uriResolver, e, r);
  const i = t.refs[r];
  if (i)
    return i;
  let s = zq.call(this, t, r);
  if (s === void 0) {
    const o = (n = t.localRefs) === null || n === void 0 ? void 0 : n[r], { schemaId: a } = this.opts;
    o && (s = new dd({ schema: o, schemaId: a, root: t, baseId: e }));
  }
  if (s !== void 0)
    return t.refs[r] = Nq.call(this, s);
}
Bt.resolveRef = qq;
function Nq(t) {
  return (0, Nr.inlineRef)(t.schema, this.opts.inlineRefs) ? t.schema : t.validate ? t : ug.call(this, t);
}
function ik(t) {
  for (const e of this._compilations)
    if (Dq(e, t))
      return e;
}
Bt.getCompilingSchema = ik;
function Dq(t, e) {
  return t.schema === e.schema && t.root === e.root && t.baseId === e.baseId;
}
function zq(t, e) {
  let r;
  for (; typeof (r = this.refs[e]) == "string"; )
    e = r;
  return r || this.schemas[e] || fd.call(this, t, e);
}
function fd(t, e) {
  const r = this.opts.uriResolver.parse(e), n = (0, Nr._getFullPath)(this.opts.uriResolver, r);
  let i = (0, Nr.getFullPath)(this.opts.uriResolver, t.baseId, void 0);
  if (Object.keys(t.schema).length > 0 && n === i)
    return Nf.call(this, r, t);
  const s = (0, Nr.normalizeId)(n), o = this.refs[s] || this.schemas[s];
  if (typeof o == "string") {
    const a = fd.call(this, t, o);
    return typeof (a == null ? void 0 : a.schema) != "object" ? void 0 : Nf.call(this, r, a);
  }
  if (typeof (o == null ? void 0 : o.schema) == "object") {
    if (o.validate || ug.call(this, o), s === (0, Nr.normalizeId)(e)) {
      const { schema: a } = o, { schemaId: l } = this.opts, c = a[l];
      return c && (i = (0, Nr.resolveUrl)(this.opts.uriResolver, i, c)), new dd({ schema: a, schemaId: l, root: t, baseId: i });
    }
    return Nf.call(this, r, o);
  }
}
Bt.resolveSchema = fd;
const Xq = /* @__PURE__ */ new Set([
  "properties",
  "patternProperties",
  "enum",
  "dependencies",
  "definitions"
]);
function Nf(t, { baseId: e, schema: r, root: n }) {
  var i;
  if (((i = t.fragment) === null || i === void 0 ? void 0 : i[0]) !== "/")
    return;
  for (const a of t.fragment.slice(1).split("/")) {
    if (typeof r == "boolean")
      return;
    const l = r[(0, Ny.unescapeFragment)(a)];
    if (l === void 0)
      return;
    r = l;
    const c = typeof r == "object" && r[this.opts.schemaId];
    !Xq.has(a) && c && (e = (0, Nr.resolveUrl)(this.opts.uriResolver, e, c));
  }
  let s;
  if (typeof r != "boolean" && r.$ref && !(0, Ny.schemaHasRulesButRef)(r, this.RULES)) {
    const a = (0, Nr.resolveUrl)(this.opts.uriResolver, e, r.$ref);
    s = fd.call(this, n, a);
  }
  const { schemaId: o } = this.opts;
  if (s = s || new dd({ schema: r, schemaId: o, root: n, baseId: e }), s.schema !== s.root.schema)
    return s;
}
const Wq = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", Uq = "Meta-schema for $data reference (JSON AnySchema extension proposal)", Vq = "object", Lq = [
  "$data"
], Yq = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
}, Bq = !1, Fq = {
  $id: Wq,
  description: Uq,
  type: Vq,
  required: Lq,
  properties: Yq,
  additionalProperties: Bq
};
var dg = {}, kp = { exports: {} };
/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function(t, e) {
  (function(r, n) {
    n(e);
  })(pi, function(r) {
    function n() {
      for (var j = arguments.length, T = Array(j), q = 0; q < j; q++)
        T[q] = arguments[q];
      if (T.length > 1) {
        T[0] = T[0].slice(0, -1);
        for (var L = T.length - 1, V = 1; V < L; ++V)
          T[V] = T[V].slice(1, -1);
        return T[L] = T[L].slice(1), T.join("");
      } else
        return T[0];
    }
    function i(j) {
      return "(?:" + j + ")";
    }
    function s(j) {
      return j === void 0 ? "undefined" : j === null ? "null" : Object.prototype.toString.call(j).split(" ").pop().split("]").shift().toLowerCase();
    }
    function o(j) {
      return j.toUpperCase();
    }
    function a(j) {
      return j != null ? j instanceof Array ? j : typeof j.length != "number" || j.split || j.setInterval || j.call ? [j] : Array.prototype.slice.call(j) : [];
    }
    function l(j, T) {
      var q = j;
      if (T)
        for (var L in T)
          q[L] = T[L];
      return q;
    }
    function c(j) {
      var T = "[A-Za-z]", q = "[0-9]", L = n(q, "[A-Fa-f]"), V = i(i("%[EFef]" + L + "%" + L + L + "%" + L + L) + "|" + i("%[89A-Fa-f]" + L + "%" + L + L) + "|" + i("%" + L + L)), me = "[\\:\\/\\?\\#\\[\\]\\@]", ye = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", qe = n(me, ye), He = j ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", at = j ? "[\\uE000-\\uF8FF]" : "[]", Ze = n(T, q, "[\\-\\.\\_\\~]", He);
      i(T + n(T, q, "[\\+\\-\\.]") + "*"), i(i(V + "|" + n(Ze, ye, "[\\:]")) + "*");
      var Ye = i(i("25[0-5]") + "|" + i("2[0-4]" + q) + "|" + i("1" + q + q) + "|" + i("0?[1-9]" + q) + "|0?0?" + q), lt = i(Ye + "\\." + Ye + "\\." + Ye + "\\." + Ye), Te = i(L + "{1,4}"), rt = i(i(Te + "\\:" + Te) + "|" + lt), ht = i(i(Te + "\\:") + "{6}" + rt), nt = i("\\:\\:" + i(Te + "\\:") + "{5}" + rt), Vn = i(i(Te) + "?\\:\\:" + i(Te + "\\:") + "{4}" + rt), Kr = i(i(i(Te + "\\:") + "{0,1}" + Te) + "?\\:\\:" + i(Te + "\\:") + "{3}" + rt), Jr = i(i(i(Te + "\\:") + "{0,2}" + Te) + "?\\:\\:" + i(Te + "\\:") + "{2}" + rt), xs = i(i(i(Te + "\\:") + "{0,3}" + Te) + "?\\:\\:" + Te + "\\:" + rt), Mi = i(i(i(Te + "\\:") + "{0,4}" + Te) + "?\\:\\:" + rt), Or = i(i(i(Te + "\\:") + "{0,5}" + Te) + "?\\:\\:" + Te), en = i(i(i(Te + "\\:") + "{0,6}" + Te) + "?\\:\\:"), qi = i([ht, nt, Vn, Kr, Jr, xs, Mi, Or, en].join("|")), Pn = i(i(Ze + "|" + V) + "+");
      i("[vV]" + L + "+\\." + n(Ze, ye, "[\\:]") + "+"), i(i(V + "|" + n(Ze, ye)) + "*");
      var na = i(V + "|" + n(Ze, ye, "[\\:\\@]"));
      return i(i(V + "|" + n(Ze, ye, "[\\@]")) + "+"), i(i(na + "|" + n("[\\/\\?]", at)) + "*"), {
        NOT_SCHEME: new RegExp(n("[^]", T, q, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(n("[^\\%\\:]", Ze, ye), "g"),
        NOT_HOST: new RegExp(n("[^\\%\\[\\]\\:]", Ze, ye), "g"),
        NOT_PATH: new RegExp(n("[^\\%\\/\\:\\@]", Ze, ye), "g"),
        NOT_PATH_NOSCHEME: new RegExp(n("[^\\%\\/\\@]", Ze, ye), "g"),
        NOT_QUERY: new RegExp(n("[^\\%]", Ze, ye, "[\\:\\@\\/\\?]", at), "g"),
        NOT_FRAGMENT: new RegExp(n("[^\\%]", Ze, ye, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(n("[^]", Ze, ye), "g"),
        UNRESERVED: new RegExp(Ze, "g"),
        OTHER_CHARS: new RegExp(n("[^\\%]", Ze, qe), "g"),
        PCT_ENCODED: new RegExp(V, "g"),
        IPV4ADDRESS: new RegExp("^(" + lt + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + qi + ")" + i(i("\\%25|\\%(?!" + L + "{2})") + "(" + Pn + ")") + "?\\]?$")
        //RFC 6874, with relaxed parsing rules
      };
    }
    var u = c(!1), d = c(!0), f = /* @__PURE__ */ function() {
      function j(T, q) {
        var L = [], V = !0, me = !1, ye = void 0;
        try {
          for (var qe = T[Symbol.iterator](), He; !(V = (He = qe.next()).done) && (L.push(He.value), !(q && L.length === q)); V = !0)
            ;
        } catch (at) {
          me = !0, ye = at;
        } finally {
          try {
            !V && qe.return && qe.return();
          } finally {
            if (me)
              throw ye;
          }
        }
        return L;
      }
      return function(T, q) {
        if (Array.isArray(T))
          return T;
        if (Symbol.iterator in Object(T))
          return j(T, q);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    }(), h = function(j) {
      if (Array.isArray(j)) {
        for (var T = 0, q = Array(j.length); T < j.length; T++)
          q[T] = j[T];
        return q;
      } else
        return Array.from(j);
    }, p = 2147483647, g = 36, m = 1, y = 26, O = 38, b = 700, w = 72, S = 128, $ = "-", _ = /^xn--/, Q = /[^\0-\x7E]/, N = /[\x2E\u3002\uFF0E\uFF61]/g, B = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, J = g - m, U = Math.floor, ue = String.fromCharCode;
    function le(j) {
      throw new RangeError(B[j]);
    }
    function Pe(j, T) {
      for (var q = [], L = j.length; L--; )
        q[L] = T(j[L]);
      return q;
    }
    function Ce(j, T) {
      var q = j.split("@"), L = "";
      q.length > 1 && (L = q[0] + "@", j = q[1]), j = j.replace(N, ".");
      var V = j.split("."), me = Pe(V, T).join(".");
      return L + me;
    }
    function X(j) {
      for (var T = [], q = 0, L = j.length; q < L; ) {
        var V = j.charCodeAt(q++);
        if (V >= 55296 && V <= 56319 && q < L) {
          var me = j.charCodeAt(q++);
          (me & 64512) == 56320 ? T.push(((V & 1023) << 10) + (me & 1023) + 65536) : (T.push(V), q--);
        } else
          T.push(V);
      }
      return T;
    }
    var F = function(T) {
      return String.fromCodePoint.apply(String, h(T));
    }, K = function(T) {
      return T - 48 < 10 ? T - 22 : T - 65 < 26 ? T - 65 : T - 97 < 26 ? T - 97 : g;
    }, z = function(T, q) {
      return T + 22 + 75 * (T < 26) - ((q != 0) << 5);
    }, R = function(T, q, L) {
      var V = 0;
      for (
        T = L ? U(T / b) : T >> 1, T += U(T / q);
        /* no initialization */
        T > J * y >> 1;
        V += g
      )
        T = U(T / J);
      return U(V + (J + 1) * T / (T + O));
    }, D = function(T) {
      var q = [], L = T.length, V = 0, me = S, ye = w, qe = T.lastIndexOf($);
      qe < 0 && (qe = 0);
      for (var He = 0; He < qe; ++He)
        T.charCodeAt(He) >= 128 && le("not-basic"), q.push(T.charCodeAt(He));
      for (var at = qe > 0 ? qe + 1 : 0; at < L; ) {
        for (
          var Ze = V, Ye = 1, lt = g;
          ;
          /* no condition */
          lt += g
        ) {
          at >= L && le("invalid-input");
          var Te = K(T.charCodeAt(at++));
          (Te >= g || Te > U((p - V) / Ye)) && le("overflow"), V += Te * Ye;
          var rt = lt <= ye ? m : lt >= ye + y ? y : lt - ye;
          if (Te < rt)
            break;
          var ht = g - rt;
          Ye > U(p / ht) && le("overflow"), Ye *= ht;
        }
        var nt = q.length + 1;
        ye = R(V - Ze, nt, Ze == 0), U(V / nt) > p - me && le("overflow"), me += U(V / nt), V %= nt, q.splice(V++, 0, me);
      }
      return String.fromCodePoint.apply(String, q);
    }, M = function(T) {
      var q = [];
      T = X(T);
      var L = T.length, V = S, me = 0, ye = w, qe = !0, He = !1, at = void 0;
      try {
        for (var Ze = T[Symbol.iterator](), Ye; !(qe = (Ye = Ze.next()).done); qe = !0) {
          var lt = Ye.value;
          lt < 128 && q.push(ue(lt));
        }
      } catch (ia) {
        He = !0, at = ia;
      } finally {
        try {
          !qe && Ze.return && Ze.return();
        } finally {
          if (He)
            throw at;
        }
      }
      var Te = q.length, rt = Te;
      for (Te && q.push($); rt < L; ) {
        var ht = p, nt = !0, Vn = !1, Kr = void 0;
        try {
          for (var Jr = T[Symbol.iterator](), xs; !(nt = (xs = Jr.next()).done); nt = !0) {
            var Mi = xs.value;
            Mi >= V && Mi < ht && (ht = Mi);
          }
        } catch (ia) {
          Vn = !0, Kr = ia;
        } finally {
          try {
            !nt && Jr.return && Jr.return();
          } finally {
            if (Vn)
              throw Kr;
          }
        }
        var Or = rt + 1;
        ht - V > U((p - me) / Or) && le("overflow"), me += (ht - V) * Or, V = ht;
        var en = !0, qi = !1, Pn = void 0;
        try {
          for (var na = T[Symbol.iterator](), v0; !(en = (v0 = na.next()).done); en = !0) {
            var w0 = v0.value;
            if (w0 < V && ++me > p && le("overflow"), w0 == V) {
              for (
                var Vl = me, Ll = g;
                ;
                /* no condition */
                Ll += g
              ) {
                var Yl = Ll <= ye ? m : Ll >= ye + y ? y : Ll - ye;
                if (Vl < Yl)
                  break;
                var $0 = Vl - Yl, S0 = g - Yl;
                q.push(ue(z(Yl + $0 % S0, 0))), Vl = U($0 / S0);
              }
              q.push(ue(z(Vl, 0))), ye = R(me, Or, rt == Te), me = 0, ++rt;
            }
          }
        } catch (ia) {
          qi = !0, Pn = ia;
        } finally {
          try {
            !en && na.return && na.return();
          } finally {
            if (qi)
              throw Pn;
          }
        }
        ++me, ++V;
      }
      return q.join("");
    }, P = function(T) {
      return Ce(T, function(q) {
        return _.test(q) ? D(q.slice(4).toLowerCase()) : q;
      });
    }, A = function(T) {
      return Ce(T, function(q) {
        return Q.test(q) ? "xn--" + M(q) : q;
      });
    }, W = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      version: "2.1.0",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      ucs2: {
        decode: X,
        encode: F
      },
      decode: D,
      encode: M,
      toASCII: A,
      toUnicode: P
    }, ne = {};
    function ie(j) {
      var T = j.charCodeAt(0), q = void 0;
      return T < 16 ? q = "%0" + T.toString(16).toUpperCase() : T < 128 ? q = "%" + T.toString(16).toUpperCase() : T < 2048 ? q = "%" + (T >> 6 | 192).toString(16).toUpperCase() + "%" + (T & 63 | 128).toString(16).toUpperCase() : q = "%" + (T >> 12 | 224).toString(16).toUpperCase() + "%" + (T >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (T & 63 | 128).toString(16).toUpperCase(), q;
    }
    function Oe(j) {
      for (var T = "", q = 0, L = j.length; q < L; ) {
        var V = parseInt(j.substr(q + 1, 2), 16);
        if (V < 128)
          T += String.fromCharCode(V), q += 3;
        else if (V >= 194 && V < 224) {
          if (L - q >= 6) {
            var me = parseInt(j.substr(q + 4, 2), 16);
            T += String.fromCharCode((V & 31) << 6 | me & 63);
          } else
            T += j.substr(q, 6);
          q += 6;
        } else if (V >= 224) {
          if (L - q >= 9) {
            var ye = parseInt(j.substr(q + 4, 2), 16), qe = parseInt(j.substr(q + 7, 2), 16);
            T += String.fromCharCode((V & 15) << 12 | (ye & 63) << 6 | qe & 63);
          } else
            T += j.substr(q, 9);
          q += 9;
        } else
          T += j.substr(q, 3), q += 3;
      }
      return T;
    }
    function ve(j, T) {
      function q(L) {
        var V = Oe(L);
        return V.match(T.UNRESERVED) ? V : L;
      }
      return j.scheme && (j.scheme = String(j.scheme).replace(T.PCT_ENCODED, q).toLowerCase().replace(T.NOT_SCHEME, "")), j.userinfo !== void 0 && (j.userinfo = String(j.userinfo).replace(T.PCT_ENCODED, q).replace(T.NOT_USERINFO, ie).replace(T.PCT_ENCODED, o)), j.host !== void 0 && (j.host = String(j.host).replace(T.PCT_ENCODED, q).toLowerCase().replace(T.NOT_HOST, ie).replace(T.PCT_ENCODED, o)), j.path !== void 0 && (j.path = String(j.path).replace(T.PCT_ENCODED, q).replace(j.scheme ? T.NOT_PATH : T.NOT_PATH_NOSCHEME, ie).replace(T.PCT_ENCODED, o)), j.query !== void 0 && (j.query = String(j.query).replace(T.PCT_ENCODED, q).replace(T.NOT_QUERY, ie).replace(T.PCT_ENCODED, o)), j.fragment !== void 0 && (j.fragment = String(j.fragment).replace(T.PCT_ENCODED, q).replace(T.NOT_FRAGMENT, ie).replace(T.PCT_ENCODED, o)), j;
    }
    function xe(j) {
      return j.replace(/^0*(.*)/, "$1") || "0";
    }
    function Fe(j, T) {
      var q = j.match(T.IPV4ADDRESS) || [], L = f(q, 2), V = L[1];
      return V ? V.split(".").map(xe).join(".") : j;
    }
    function st(j, T) {
      var q = j.match(T.IPV6ADDRESS) || [], L = f(q, 3), V = L[1], me = L[2];
      if (V) {
        for (var ye = V.toLowerCase().split("::").reverse(), qe = f(ye, 2), He = qe[0], at = qe[1], Ze = at ? at.split(":").map(xe) : [], Ye = He.split(":").map(xe), lt = T.IPV4ADDRESS.test(Ye[Ye.length - 1]), Te = lt ? 7 : 8, rt = Ye.length - Te, ht = Array(Te), nt = 0; nt < Te; ++nt)
          ht[nt] = Ze[nt] || Ye[rt + nt] || "";
        lt && (ht[Te - 1] = Fe(ht[Te - 1], T));
        var Vn = ht.reduce(function(Or, en, qi) {
          if (!en || en === "0") {
            var Pn = Or[Or.length - 1];
            Pn && Pn.index + Pn.length === qi ? Pn.length++ : Or.push({ index: qi, length: 1 });
          }
          return Or;
        }, []), Kr = Vn.sort(function(Or, en) {
          return en.length - Or.length;
        })[0], Jr = void 0;
        if (Kr && Kr.length > 1) {
          var xs = ht.slice(0, Kr.index), Mi = ht.slice(Kr.index + Kr.length);
          Jr = xs.join(":") + "::" + Mi.join(":");
        } else
          Jr = ht.join(":");
        return me && (Jr += "%" + me), Jr;
      } else
        return j;
    }
    var er = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i, or = "".match(/(){0}/)[1] === void 0;
    function kt(j) {
      var T = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, q = {}, L = T.iri !== !1 ? d : u;
      T.reference === "suffix" && (j = (T.scheme ? T.scheme + ":" : "") + "//" + j);
      var V = j.match(er);
      if (V) {
        or ? (q.scheme = V[1], q.userinfo = V[3], q.host = V[4], q.port = parseInt(V[5], 10), q.path = V[6] || "", q.query = V[7], q.fragment = V[8], isNaN(q.port) && (q.port = V[5])) : (q.scheme = V[1] || void 0, q.userinfo = j.indexOf("@") !== -1 ? V[3] : void 0, q.host = j.indexOf("//") !== -1 ? V[4] : void 0, q.port = parseInt(V[5], 10), q.path = V[6] || "", q.query = j.indexOf("?") !== -1 ? V[7] : void 0, q.fragment = j.indexOf("#") !== -1 ? V[8] : void 0, isNaN(q.port) && (q.port = j.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? V[4] : void 0)), q.host && (q.host = st(Fe(q.host, L), L)), q.scheme === void 0 && q.userinfo === void 0 && q.host === void 0 && q.port === void 0 && !q.path && q.query === void 0 ? q.reference = "same-document" : q.scheme === void 0 ? q.reference = "relative" : q.fragment === void 0 ? q.reference = "absolute" : q.reference = "uri", T.reference && T.reference !== "suffix" && T.reference !== q.reference && (q.error = q.error || "URI is not a " + T.reference + " reference.");
        var me = ne[(T.scheme || q.scheme || "").toLowerCase()];
        if (!T.unicodeSupport && (!me || !me.unicodeSupport)) {
          if (q.host && (T.domainHost || me && me.domainHost))
            try {
              q.host = W.toASCII(q.host.replace(L.PCT_ENCODED, Oe).toLowerCase());
            } catch (ye) {
              q.error = q.error || "Host's domain name can not be converted to ASCII via punycode: " + ye;
            }
          ve(q, u);
        } else
          ve(q, L);
        me && me.parse && me.parse(q, T);
      } else
        q.error = q.error || "URI can not be parsed.";
      return q;
    }
    function Ko(j, T) {
      var q = T.iri !== !1 ? d : u, L = [];
      return j.userinfo !== void 0 && (L.push(j.userinfo), L.push("@")), j.host !== void 0 && L.push(st(Fe(String(j.host), q), q).replace(q.IPV6ADDRESS, function(V, me, ye) {
        return "[" + me + (ye ? "%25" + ye : "") + "]";
      })), (typeof j.port == "number" || typeof j.port == "string") && (L.push(":"), L.push(String(j.port))), L.length ? L.join("") : void 0;
    }
    var $s = /^\.\.?\//, Ss = /^\/\.(\/|$)/, ks = /^\/\.\.(\/|$)/, Jo = /^\/?(?:.|\n)*?(?=\/|$)/;
    function Hr(j) {
      for (var T = []; j.length; )
        if (j.match($s))
          j = j.replace($s, "");
        else if (j.match(Ss))
          j = j.replace(Ss, "/");
        else if (j.match(ks))
          j = j.replace(ks, "/"), T.pop();
        else if (j === "." || j === "..")
          j = "";
        else {
          var q = j.match(Jo);
          if (q) {
            var L = q[0];
            j = j.slice(L.length), T.push(L);
          } else
            throw new Error("Unexpected dot segment condition");
        }
      return T.join("");
    }
    function tr(j) {
      var T = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, q = T.iri ? d : u, L = [], V = ne[(T.scheme || j.scheme || "").toLowerCase()];
      if (V && V.serialize && V.serialize(j, T), j.host && !q.IPV6ADDRESS.test(j.host)) {
        if (T.domainHost || V && V.domainHost)
          try {
            j.host = T.iri ? W.toUnicode(j.host) : W.toASCII(j.host.replace(q.PCT_ENCODED, Oe).toLowerCase());
          } catch (qe) {
            j.error = j.error || "Host's domain name can not be converted to " + (T.iri ? "Unicode" : "ASCII") + " via punycode: " + qe;
          }
      }
      ve(j, q), T.reference !== "suffix" && j.scheme && (L.push(j.scheme), L.push(":"));
      var me = Ko(j, T);
      if (me !== void 0 && (T.reference !== "suffix" && L.push("//"), L.push(me), j.path && j.path.charAt(0) !== "/" && L.push("/")), j.path !== void 0) {
        var ye = j.path;
        !T.absolutePath && (!V || !V.absolutePath) && (ye = Hr(ye)), me === void 0 && (ye = ye.replace(/^\/\//, "/%2F")), L.push(ye);
      }
      return j.query !== void 0 && (L.push("?"), L.push(j.query)), j.fragment !== void 0 && (L.push("#"), L.push(j.fragment)), L.join("");
    }
    function _s(j, T) {
      var q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, L = arguments[3], V = {};
      return L || (j = kt(tr(j, q), q), T = kt(tr(T, q), q)), q = q || {}, !q.tolerant && T.scheme ? (V.scheme = T.scheme, V.userinfo = T.userinfo, V.host = T.host, V.port = T.port, V.path = Hr(T.path || ""), V.query = T.query) : (T.userinfo !== void 0 || T.host !== void 0 || T.port !== void 0 ? (V.userinfo = T.userinfo, V.host = T.host, V.port = T.port, V.path = Hr(T.path || ""), V.query = T.query) : (T.path ? (T.path.charAt(0) === "/" ? V.path = Hr(T.path) : ((j.userinfo !== void 0 || j.host !== void 0 || j.port !== void 0) && !j.path ? V.path = "/" + T.path : j.path ? V.path = j.path.slice(0, j.path.lastIndexOf("/") + 1) + T.path : V.path = T.path, V.path = Hr(V.path)), V.query = T.query) : (V.path = j.path, T.query !== void 0 ? V.query = T.query : V.query = j.query), V.userinfo = j.userinfo, V.host = j.host, V.port = j.port), V.scheme = j.scheme), V.fragment = T.fragment, V;
    }
    function ea(j, T, q) {
      var L = l({ scheme: "null" }, q);
      return tr(_s(kt(j, L), kt(T, L), L, !0), L);
    }
    function ji(j, T) {
      return typeof j == "string" ? j = tr(kt(j, T), T) : s(j) === "object" && (j = kt(tr(j, T), T)), j;
    }
    function ta(j, T, q) {
      return typeof j == "string" ? j = tr(kt(j, q), q) : s(j) === "object" && (j = tr(j, q)), typeof T == "string" ? T = tr(kt(T, q), q) : s(T) === "object" && (T = tr(T, q)), j === T;
    }
    function Ul(j, T) {
      return j && j.toString().replace(!T || !T.iri ? u.ESCAPE : d.ESCAPE, ie);
    }
    function gr(j, T) {
      return j && j.toString().replace(!T || !T.iri ? u.PCT_ENCODED : d.PCT_ENCODED, Oe);
    }
    var Zi = {
      scheme: "http",
      domainHost: !0,
      parse: function(T, q) {
        return T.host || (T.error = T.error || "HTTP URIs must have a host."), T;
      },
      serialize: function(T, q) {
        var L = String(T.scheme).toLowerCase() === "https";
        return (T.port === (L ? 443 : 80) || T.port === "") && (T.port = void 0), T.path || (T.path = "/"), T;
      }
    }, f0 = {
      scheme: "https",
      domainHost: Zi.domainHost,
      parse: Zi.parse,
      serialize: Zi.serialize
    };
    function h0(j) {
      return typeof j.secure == "boolean" ? j.secure : String(j.scheme).toLowerCase() === "wss";
    }
    var ra = {
      scheme: "ws",
      domainHost: !0,
      parse: function(T, q) {
        var L = T;
        return L.secure = h0(L), L.resourceName = (L.path || "/") + (L.query ? "?" + L.query : ""), L.path = void 0, L.query = void 0, L;
      },
      serialize: function(T, q) {
        if ((T.port === (h0(T) ? 443 : 80) || T.port === "") && (T.port = void 0), typeof T.secure == "boolean" && (T.scheme = T.secure ? "wss" : "ws", T.secure = void 0), T.resourceName) {
          var L = T.resourceName.split("?"), V = f(L, 2), me = V[0], ye = V[1];
          T.path = me && me !== "/" ? me : void 0, T.query = ye, T.resourceName = void 0;
        }
        return T.fragment = void 0, T;
      }
    }, p0 = {
      scheme: "wss",
      domainHost: ra.domainHost,
      parse: ra.parse,
      serialize: ra.serialize
    }, q5 = {}, m0 = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]", Gr = "[0-9A-Fa-f]", N5 = i(i("%[EFef]" + Gr + "%" + Gr + Gr + "%" + Gr + Gr) + "|" + i("%[89A-Fa-f]" + Gr + "%" + Gr + Gr) + "|" + i("%" + Gr + Gr)), D5 = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]", z5 = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]", X5 = n(z5, '[\\"\\\\]'), W5 = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]", U5 = new RegExp(m0, "g"), Ps = new RegExp(N5, "g"), V5 = new RegExp(n("[^]", D5, "[\\.]", '[\\"]', X5), "g"), g0 = new RegExp(n("[^]", m0, W5), "g"), L5 = g0;
    function jd(j) {
      var T = Oe(j);
      return T.match(U5) ? T : j;
    }
    var O0 = {
      scheme: "mailto",
      parse: function(T, q) {
        var L = T, V = L.to = L.path ? L.path.split(",") : [];
        if (L.path = void 0, L.query) {
          for (var me = !1, ye = {}, qe = L.query.split("&"), He = 0, at = qe.length; He < at; ++He) {
            var Ze = qe[He].split("=");
            switch (Ze[0]) {
              case "to":
                for (var Ye = Ze[1].split(","), lt = 0, Te = Ye.length; lt < Te; ++lt)
                  V.push(Ye[lt]);
                break;
              case "subject":
                L.subject = gr(Ze[1], q);
                break;
              case "body":
                L.body = gr(Ze[1], q);
                break;
              default:
                me = !0, ye[gr(Ze[0], q)] = gr(Ze[1], q);
                break;
            }
          }
          me && (L.headers = ye);
        }
        L.query = void 0;
        for (var rt = 0, ht = V.length; rt < ht; ++rt) {
          var nt = V[rt].split("@");
          if (nt[0] = gr(nt[0]), q.unicodeSupport)
            nt[1] = gr(nt[1], q).toLowerCase();
          else
            try {
              nt[1] = W.toASCII(gr(nt[1], q).toLowerCase());
            } catch (Vn) {
              L.error = L.error || "Email address's domain name can not be converted to ASCII via punycode: " + Vn;
            }
          V[rt] = nt.join("@");
        }
        return L;
      },
      serialize: function(T, q) {
        var L = T, V = a(T.to);
        if (V) {
          for (var me = 0, ye = V.length; me < ye; ++me) {
            var qe = String(V[me]), He = qe.lastIndexOf("@"), at = qe.slice(0, He).replace(Ps, jd).replace(Ps, o).replace(V5, ie), Ze = qe.slice(He + 1);
            try {
              Ze = q.iri ? W.toUnicode(Ze) : W.toASCII(gr(Ze, q).toLowerCase());
            } catch (rt) {
              L.error = L.error || "Email address's domain name can not be converted to " + (q.iri ? "Unicode" : "ASCII") + " via punycode: " + rt;
            }
            V[me] = at + "@" + Ze;
          }
          L.path = V.join(",");
        }
        var Ye = T.headers = T.headers || {};
        T.subject && (Ye.subject = T.subject), T.body && (Ye.body = T.body);
        var lt = [];
        for (var Te in Ye)
          Ye[Te] !== q5[Te] && lt.push(Te.replace(Ps, jd).replace(Ps, o).replace(g0, ie) + "=" + Ye[Te].replace(Ps, jd).replace(Ps, o).replace(L5, ie));
        return lt.length && (L.query = lt.join("&")), L;
      }
    }, Y5 = /^([^\:]+)\:(.*)/, y0 = {
      scheme: "urn",
      parse: function(T, q) {
        var L = T.path && T.path.match(Y5), V = T;
        if (L) {
          var me = q.scheme || V.scheme || "urn", ye = L[1].toLowerCase(), qe = L[2], He = me + ":" + (q.nid || ye), at = ne[He];
          V.nid = ye, V.nss = qe, V.path = void 0, at && (V = at.parse(V, q));
        } else
          V.error = V.error || "URN can not be parsed.";
        return V;
      },
      serialize: function(T, q) {
        var L = q.scheme || T.scheme || "urn", V = T.nid, me = L + ":" + (q.nid || V), ye = ne[me];
        ye && (T = ye.serialize(T, q));
        var qe = T, He = T.nss;
        return qe.path = (V || q.nid) + ":" + He, qe;
      }
    }, B5 = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/, b0 = {
      scheme: "urn:uuid",
      parse: function(T, q) {
        var L = T;
        return L.uuid = L.nss, L.nss = void 0, !q.tolerant && (!L.uuid || !L.uuid.match(B5)) && (L.error = L.error || "UUID is not valid."), L;
      },
      serialize: function(T, q) {
        var L = T;
        return L.nss = (T.uuid || "").toLowerCase(), L;
      }
    };
    ne[Zi.scheme] = Zi, ne[f0.scheme] = f0, ne[ra.scheme] = ra, ne[p0.scheme] = p0, ne[O0.scheme] = O0, ne[y0.scheme] = y0, ne[b0.scheme] = b0, r.SCHEMES = ne, r.pctEncChar = ie, r.pctDecChars = Oe, r.parse = kt, r.removeDotSegments = Hr, r.serialize = tr, r.resolveComponents = _s, r.resolve = ea, r.normalize = ji, r.equal = ta, r.escapeComponent = Ul, r.unescapeComponent = gr, Object.defineProperty(r, "__esModule", { value: !0 });
  });
})(kp, kp.exports);
var Hq = kp.exports;
Object.defineProperty(dg, "__esModule", { value: !0 });
const sk = Hq;
sk.code = 'require("ajv/dist/runtime/uri").default';
dg.default = sk;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = void 0;
  var e = Ur;
  Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
    return e.KeywordCxt;
  } });
  var r = Qe;
  Object.defineProperty(t, "_", { enumerable: !0, get: function() {
    return r._;
  } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
    return r.str;
  } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
    return r.stringify;
  } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
    return r.nil;
  } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
    return r.Name;
  } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
    return r.CodeGen;
  } });
  const n = Rl, i = Il, s = ps, o = Bt, a = Qe, l = At, c = El, u = je, d = Fq, f = dg, h = (z, R) => new RegExp(z, R);
  h.code = "new RegExp";
  const p = ["removeAdditional", "useDefaults", "coerceTypes"], g = /* @__PURE__ */ new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]), m = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  }, y = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  }, O = 200;
  function b(z) {
    var R, D, M, P, A, W, ne, ie, Oe, ve, xe, Fe, st, er, or, kt, Ko, $s, Ss, ks, Jo, Hr, tr, _s, ea;
    const ji = z.strict, ta = (R = z.code) === null || R === void 0 ? void 0 : R.optimize, Ul = ta === !0 || ta === void 0 ? 1 : ta || 0, gr = (M = (D = z.code) === null || D === void 0 ? void 0 : D.regExp) !== null && M !== void 0 ? M : h, Zi = (P = z.uriResolver) !== null && P !== void 0 ? P : f.default;
    return {
      strictSchema: (W = (A = z.strictSchema) !== null && A !== void 0 ? A : ji) !== null && W !== void 0 ? W : !0,
      strictNumbers: (ie = (ne = z.strictNumbers) !== null && ne !== void 0 ? ne : ji) !== null && ie !== void 0 ? ie : !0,
      strictTypes: (ve = (Oe = z.strictTypes) !== null && Oe !== void 0 ? Oe : ji) !== null && ve !== void 0 ? ve : "log",
      strictTuples: (Fe = (xe = z.strictTuples) !== null && xe !== void 0 ? xe : ji) !== null && Fe !== void 0 ? Fe : "log",
      strictRequired: (er = (st = z.strictRequired) !== null && st !== void 0 ? st : ji) !== null && er !== void 0 ? er : !1,
      code: z.code ? { ...z.code, optimize: Ul, regExp: gr } : { optimize: Ul, regExp: gr },
      loopRequired: (or = z.loopRequired) !== null && or !== void 0 ? or : O,
      loopEnum: (kt = z.loopEnum) !== null && kt !== void 0 ? kt : O,
      meta: (Ko = z.meta) !== null && Ko !== void 0 ? Ko : !0,
      messages: ($s = z.messages) !== null && $s !== void 0 ? $s : !0,
      inlineRefs: (Ss = z.inlineRefs) !== null && Ss !== void 0 ? Ss : !0,
      schemaId: (ks = z.schemaId) !== null && ks !== void 0 ? ks : "$id",
      addUsedSchema: (Jo = z.addUsedSchema) !== null && Jo !== void 0 ? Jo : !0,
      validateSchema: (Hr = z.validateSchema) !== null && Hr !== void 0 ? Hr : !0,
      validateFormats: (tr = z.validateFormats) !== null && tr !== void 0 ? tr : !0,
      unicodeRegExp: (_s = z.unicodeRegExp) !== null && _s !== void 0 ? _s : !0,
      int32range: (ea = z.int32range) !== null && ea !== void 0 ? ea : !0,
      uriResolver: Zi
    };
  }
  class w {
    constructor(R = {}) {
      this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), R = this.opts = { ...R, ...b(R) };
      const { es5: D, lines: M } = this.opts.code;
      this.scope = new a.ValueScope({ scope: {}, prefixes: g, es5: D, lines: M }), this.logger = U(R.logger);
      const P = R.validateFormats;
      R.validateFormats = !1, this.RULES = (0, s.getRules)(), S.call(this, m, R, "NOT SUPPORTED"), S.call(this, y, R, "DEPRECATED", "warn"), this._metaOpts = B.call(this), R.formats && Q.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), R.keywords && N.call(this, R.keywords), typeof R.meta == "object" && this.addMetaSchema(R.meta), _.call(this), R.validateFormats = P;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data: R, meta: D, schemaId: M } = this.opts;
      let P = d;
      M === "id" && (P = { ...d }, P.id = P.$id, delete P.$id), D && R && this.addMetaSchema(P, P[M], !1);
    }
    defaultMeta() {
      const { meta: R, schemaId: D } = this.opts;
      return this.opts.defaultMeta = typeof R == "object" ? R[D] || R : void 0;
    }
    validate(R, D) {
      let M;
      if (typeof R == "string") {
        if (M = this.getSchema(R), !M)
          throw new Error(`no schema with key or ref "${R}"`);
      } else
        M = this.compile(R);
      const P = M(D);
      return "$async" in M || (this.errors = M.errors), P;
    }
    compile(R, D) {
      const M = this._addSchema(R, D);
      return M.validate || this._compileSchemaEnv(M);
    }
    compileAsync(R, D) {
      if (typeof this.opts.loadSchema != "function")
        throw new Error("options.loadSchema should be a function");
      const { loadSchema: M } = this.opts;
      return P.call(this, R, D);
      async function P(ve, xe) {
        await A.call(this, ve.$schema);
        const Fe = this._addSchema(ve, xe);
        return Fe.validate || W.call(this, Fe);
      }
      async function A(ve) {
        ve && !this.getSchema(ve) && await P.call(this, { $ref: ve }, !0);
      }
      async function W(ve) {
        try {
          return this._compileSchemaEnv(ve);
        } catch (xe) {
          if (!(xe instanceof i.default))
            throw xe;
          return ne.call(this, xe), await ie.call(this, xe.missingSchema), W.call(this, ve);
        }
      }
      function ne({ missingSchema: ve, missingRef: xe }) {
        if (this.refs[ve])
          throw new Error(`AnySchema ${ve} is loaded but ${xe} cannot be resolved`);
      }
      async function ie(ve) {
        const xe = await Oe.call(this, ve);
        this.refs[ve] || await A.call(this, xe.$schema), this.refs[ve] || this.addSchema(xe, ve, D);
      }
      async function Oe(ve) {
        const xe = this._loading[ve];
        if (xe)
          return xe;
        try {
          return await (this._loading[ve] = M(ve));
        } finally {
          delete this._loading[ve];
        }
      }
    }
    // Adds schema to the instance
    addSchema(R, D, M, P = this.opts.validateSchema) {
      if (Array.isArray(R)) {
        for (const W of R)
          this.addSchema(W, void 0, M, P);
        return this;
      }
      let A;
      if (typeof R == "object") {
        const { schemaId: W } = this.opts;
        if (A = R[W], A !== void 0 && typeof A != "string")
          throw new Error(`schema ${W} must be string`);
      }
      return D = (0, l.normalizeId)(D || A), this._checkUnique(D), this.schemas[D] = this._addSchema(R, M, D, P, !0), this;
    }
    // Add schema that will be used to validate other schemas
    // options in META_IGNORE_OPTIONS are alway set to false
    addMetaSchema(R, D, M = this.opts.validateSchema) {
      return this.addSchema(R, D, !0, M), this;
    }
    //  Validate schema against its meta-schema
    validateSchema(R, D) {
      if (typeof R == "boolean")
        return !0;
      let M;
      if (M = R.$schema, M !== void 0 && typeof M != "string")
        throw new Error("$schema must be a string");
      if (M = M || this.opts.defaultMeta || this.defaultMeta(), !M)
        return this.logger.warn("meta-schema not available"), this.errors = null, !0;
      const P = this.validate(M, R);
      if (!P && D) {
        const A = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(A);
        else
          throw new Error(A);
      }
      return P;
    }
    // Get compiled schema by `key` or `ref`.
    // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
    getSchema(R) {
      let D;
      for (; typeof (D = $.call(this, R)) == "string"; )
        R = D;
      if (D === void 0) {
        const { schemaId: M } = this.opts, P = new o.SchemaEnv({ schema: {}, schemaId: M });
        if (D = o.resolveSchema.call(this, P, R), !D)
          return;
        this.refs[R] = D;
      }
      return D.validate || this._compileSchemaEnv(D);
    }
    // Remove cached schema(s).
    // If no parameter is passed all schemas but meta-schemas are removed.
    // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
    // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
    removeSchema(R) {
      if (R instanceof RegExp)
        return this._removeAllSchemas(this.schemas, R), this._removeAllSchemas(this.refs, R), this;
      switch (typeof R) {
        case "undefined":
          return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
        case "string": {
          const D = $.call(this, R);
          return typeof D == "object" && this._cache.delete(D.schema), delete this.schemas[R], delete this.refs[R], this;
        }
        case "object": {
          const D = R;
          this._cache.delete(D);
          let M = R[this.opts.schemaId];
          return M && (M = (0, l.normalizeId)(M), delete this.schemas[M], delete this.refs[M]), this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    // add "vocabulary" - a collection of keywords
    addVocabulary(R) {
      for (const D of R)
        this.addKeyword(D);
      return this;
    }
    addKeyword(R, D) {
      let M;
      if (typeof R == "string")
        M = R, typeof D == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), D.keyword = M);
      else if (typeof R == "object" && D === void 0) {
        if (D = R, M = D.keyword, Array.isArray(M) && !M.length)
          throw new Error("addKeywords: keyword must be string or non-empty array");
      } else
        throw new Error("invalid addKeywords parameters");
      if (le.call(this, M, D), !D)
        return (0, u.eachItem)(M, (A) => Pe.call(this, A)), this;
      X.call(this, D);
      const P = {
        ...D,
        type: (0, c.getJSONTypes)(D.type),
        schemaType: (0, c.getJSONTypes)(D.schemaType)
      };
      return (0, u.eachItem)(M, P.type.length === 0 ? (A) => Pe.call(this, A, P) : (A) => P.type.forEach((W) => Pe.call(this, A, P, W))), this;
    }
    getKeyword(R) {
      const D = this.RULES.all[R];
      return typeof D == "object" ? D.definition : !!D;
    }
    // Remove keyword
    removeKeyword(R) {
      const { RULES: D } = this;
      delete D.keywords[R], delete D.all[R];
      for (const M of D.rules) {
        const P = M.rules.findIndex((A) => A.keyword === R);
        P >= 0 && M.rules.splice(P, 1);
      }
      return this;
    }
    // Add format
    addFormat(R, D) {
      return typeof D == "string" && (D = new RegExp(D)), this.formats[R] = D, this;
    }
    errorsText(R = this.errors, { separator: D = ", ", dataVar: M = "data" } = {}) {
      return !R || R.length === 0 ? "No errors" : R.map((P) => `${M}${P.instancePath} ${P.message}`).reduce((P, A) => P + D + A);
    }
    $dataMetaSchema(R, D) {
      const M = this.RULES.all;
      R = JSON.parse(JSON.stringify(R));
      for (const P of D) {
        const A = P.split("/").slice(1);
        let W = R;
        for (const ne of A)
          W = W[ne];
        for (const ne in M) {
          const ie = M[ne];
          if (typeof ie != "object")
            continue;
          const { $data: Oe } = ie.definition, ve = W[ne];
          Oe && ve && (W[ne] = K(ve));
        }
      }
      return R;
    }
    _removeAllSchemas(R, D) {
      for (const M in R) {
        const P = R[M];
        (!D || D.test(M)) && (typeof P == "string" ? delete R[M] : P && !P.meta && (this._cache.delete(P.schema), delete R[M]));
      }
    }
    _addSchema(R, D, M, P = this.opts.validateSchema, A = this.opts.addUsedSchema) {
      let W;
      const { schemaId: ne } = this.opts;
      if (typeof R == "object")
        W = R[ne];
      else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        if (typeof R != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let ie = this._cache.get(R);
      if (ie !== void 0)
        return ie;
      M = (0, l.normalizeId)(W || M);
      const Oe = l.getSchemaRefs.call(this, R, M);
      return ie = new o.SchemaEnv({ schema: R, schemaId: ne, meta: D, baseId: M, localRefs: Oe }), this._cache.set(ie.schema, ie), A && !M.startsWith("#") && (M && this._checkUnique(M), this.refs[M] = ie), P && this.validateSchema(R, !0), ie;
    }
    _checkUnique(R) {
      if (this.schemas[R] || this.refs[R])
        throw new Error(`schema with key or id "${R}" already exists`);
    }
    _compileSchemaEnv(R) {
      if (R.meta ? this._compileMetaSchema(R) : o.compileSchema.call(this, R), !R.validate)
        throw new Error("ajv implementation error");
      return R.validate;
    }
    _compileMetaSchema(R) {
      const D = this.opts;
      this.opts = this._metaOpts;
      try {
        o.compileSchema.call(this, R);
      } finally {
        this.opts = D;
      }
    }
  }
  t.default = w, w.ValidationError = n.default, w.MissingRefError = i.default;
  function S(z, R, D, M = "error") {
    for (const P in z) {
      const A = P;
      A in R && this.logger[M](`${D}: option ${P}. ${z[A]}`);
    }
  }
  function $(z) {
    return z = (0, l.normalizeId)(z), this.schemas[z] || this.refs[z];
  }
  function _() {
    const z = this.opts.schemas;
    if (z)
      if (Array.isArray(z))
        this.addSchema(z);
      else
        for (const R in z)
          this.addSchema(z[R], R);
  }
  function Q() {
    for (const z in this.opts.formats) {
      const R = this.opts.formats[z];
      R && this.addFormat(z, R);
    }
  }
  function N(z) {
    if (Array.isArray(z)) {
      this.addVocabulary(z);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const R in z) {
      const D = z[R];
      D.keyword || (D.keyword = R), this.addKeyword(D);
    }
  }
  function B() {
    const z = { ...this.opts };
    for (const R of p)
      delete z[R];
    return z;
  }
  const J = { log() {
  }, warn() {
  }, error() {
  } };
  function U(z) {
    if (z === !1)
      return J;
    if (z === void 0)
      return console;
    if (z.log && z.warn && z.error)
      return z;
    throw new Error("logger must implement log, warn and error methods");
  }
  const ue = /^[a-z_$][a-z0-9_$:-]*$/i;
  function le(z, R) {
    const { RULES: D } = this;
    if ((0, u.eachItem)(z, (M) => {
      if (D.keywords[M])
        throw new Error(`Keyword ${M} is already defined`);
      if (!ue.test(M))
        throw new Error(`Keyword ${M} has invalid name`);
    }), !!R && R.$data && !("code" in R || "validate" in R))
      throw new Error('$data keyword must have "code" or "validate" function');
  }
  function Pe(z, R, D) {
    var M;
    const P = R == null ? void 0 : R.post;
    if (D && P)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES: A } = this;
    let W = P ? A.post : A.rules.find(({ type: ie }) => ie === D);
    if (W || (W = { type: D, rules: [] }, A.rules.push(W)), A.keywords[z] = !0, !R)
      return;
    const ne = {
      keyword: z,
      definition: {
        ...R,
        type: (0, c.getJSONTypes)(R.type),
        schemaType: (0, c.getJSONTypes)(R.schemaType)
      }
    };
    R.before ? Ce.call(this, W, ne, R.before) : W.rules.push(ne), A.all[z] = ne, (M = R.implements) === null || M === void 0 || M.forEach((ie) => this.addKeyword(ie));
  }
  function Ce(z, R, D) {
    const M = z.rules.findIndex((P) => P.keyword === D);
    M >= 0 ? z.rules.splice(M, 0, R) : (z.rules.push(R), this.logger.warn(`rule ${D} is not defined`));
  }
  function X(z) {
    let { metaSchema: R } = z;
    R !== void 0 && (z.$data && this.opts.$data && (R = K(R)), z.validateSchema = this.compile(R, !0));
  }
  const F = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function K(z) {
    return { anyOf: [z, F] };
  }
})(co);
var fg = {}, hg = {}, yn = {};
Object.defineProperty(yn, "__esModule", { value: !0 });
yn.callRef = yn.getValidate = void 0;
const Gq = Il, Dy = Re, nr = Qe, js = mr, zy = Bt, bc = je, Kq = {
  keyword: "$ref",
  schemaType: "string",
  code(t) {
    const { gen: e, schema: r, it: n } = t, { baseId: i, schemaEnv: s, validateName: o, opts: a, self: l } = n, { root: c } = s;
    if ((r === "#" || r === "#/") && i === c.baseId)
      return d();
    const u = zy.resolveRef.call(l, c, i, r);
    if (u === void 0)
      throw new Gq.default(n.opts.uriResolver, i, r);
    if (u instanceof zy.SchemaEnv)
      return f(u);
    return h(u);
    function d() {
      if (s === c)
        return Vc(t, o, s, s.$async);
      const p = e.scopeValue("root", { ref: c });
      return Vc(t, (0, nr._)`${p}.validate`, c, c.$async);
    }
    function f(p) {
      const g = ok(t, p);
      Vc(t, g, p, p.$async);
    }
    function h(p) {
      const g = e.scopeValue("schema", a.code.source === !0 ? { ref: p, code: (0, nr.stringify)(p) } : { ref: p }), m = e.name("valid"), y = t.subschema({
        schema: p,
        dataTypes: [],
        schemaPath: nr.nil,
        topSchemaRef: g,
        errSchemaPath: r
      }, m);
      t.mergeEvaluated(y), t.ok(m);
    }
  }
};
function ok(t, e) {
  const { gen: r } = t;
  return e.validate ? r.scopeValue("validate", { ref: e.validate }) : (0, nr._)`${r.scopeValue("wrapper", { ref: e })}.validate`;
}
yn.getValidate = ok;
function Vc(t, e, r, n) {
  const { gen: i, it: s } = t, { allErrors: o, schemaEnv: a, opts: l } = s, c = l.passContext ? js.default.this : nr.nil;
  n ? u() : d();
  function u() {
    if (!a.$async)
      throw new Error("async schema referenced by sync schema");
    const p = i.let("valid");
    i.try(() => {
      i.code((0, nr._)`await ${(0, Dy.callValidateCode)(t, e, c)}`), h(e), o || i.assign(p, !0);
    }, (g) => {
      i.if((0, nr._)`!(${g} instanceof ${s.ValidationError})`, () => i.throw(g)), f(g), o || i.assign(p, !1);
    }), t.ok(p);
  }
  function d() {
    t.result((0, Dy.callValidateCode)(t, e, c), () => h(e), () => f(e));
  }
  function f(p) {
    const g = (0, nr._)`${p}.errors`;
    i.assign(js.default.vErrors, (0, nr._)`${js.default.vErrors} === null ? ${g} : ${js.default.vErrors}.concat(${g})`), i.assign(js.default.errors, (0, nr._)`${js.default.vErrors}.length`);
  }
  function h(p) {
    var g;
    if (!s.opts.unevaluated)
      return;
    const m = (g = r == null ? void 0 : r.validate) === null || g === void 0 ? void 0 : g.evaluated;
    if (s.props !== !0)
      if (m && !m.dynamicProps)
        m.props !== void 0 && (s.props = bc.mergeEvaluated.props(i, m.props, s.props));
      else {
        const y = i.var("props", (0, nr._)`${p}.evaluated.props`);
        s.props = bc.mergeEvaluated.props(i, y, s.props, nr.Name);
      }
    if (s.items !== !0)
      if (m && !m.dynamicItems)
        m.items !== void 0 && (s.items = bc.mergeEvaluated.items(i, m.items, s.items));
      else {
        const y = i.var("items", (0, nr._)`${p}.evaluated.items`);
        s.items = bc.mergeEvaluated.items(i, y, s.items, nr.Name);
      }
  }
}
yn.callRef = Vc;
yn.default = Kq;
Object.defineProperty(hg, "__esModule", { value: !0 });
const Jq = yn, eN = [
  "$schema",
  "id",
  "$defs",
  { keyword: "$comment" },
  "definitions",
  Jq.default
];
hg.default = eN;
var pg = {}, mg = {};
Object.defineProperty(mg, "__esModule", { value: !0 });
const _p = co, tN = Qe, Gn = tN.operators, Pp = {
  maximum: {
    exclusive: "exclusiveMaximum",
    ops: [
      { okStr: "<=", ok: Gn.LTE, fail: Gn.GT },
      { okStr: "<", ok: Gn.LT, fail: Gn.GTE }
    ]
  },
  minimum: {
    exclusive: "exclusiveMinimum",
    ops: [
      { okStr: ">=", ok: Gn.GTE, fail: Gn.LT },
      { okStr: ">", ok: Gn.GT, fail: Gn.LTE }
    ]
  }
}, rN = {
  message: (t) => _p.str`must be ${xp(t).okStr} ${t.schemaCode}`,
  params: (t) => _p._`{comparison: ${xp(t).okStr}, limit: ${t.schemaCode}}`
}, nN = {
  keyword: Object.keys(Pp),
  type: "number",
  schemaType: "number",
  $data: !0,
  error: rN,
  code(t) {
    const { data: e, schemaCode: r } = t;
    t.fail$data(_p._`${e} ${xp(t).fail} ${r} || isNaN(${e})`);
  }
};
function xp(t) {
  var e;
  const r = t.keyword, n = !((e = t.parentSchema) === null || e === void 0) && e[Pp[r].exclusive] ? 1 : 0;
  return Pp[r].ops[n];
}
mg.default = nN;
var gg = {};
Object.defineProperty(gg, "__esModule", { value: !0 });
const Xy = {
  exclusiveMaximum: "maximum",
  exclusiveMinimum: "minimum"
}, iN = {
  keyword: Object.keys(Xy),
  type: "number",
  schemaType: "boolean",
  code({ keyword: t, parentSchema: e }) {
    const r = Xy[t];
    if (e[r] === void 0)
      throw new Error(`${t} can only be used with ${r}`);
  }
};
gg.default = iN;
var hd = {};
Object.defineProperty(hd, "__esModule", { value: !0 });
const za = Qe, sN = {
  message: ({ schemaCode: t }) => (0, za.str)`must be multiple of ${t}`,
  params: ({ schemaCode: t }) => (0, za._)`{multipleOf: ${t}}`
}, oN = {
  keyword: "multipleOf",
  type: "number",
  schemaType: "number",
  $data: !0,
  error: sN,
  code(t) {
    const { gen: e, data: r, schemaCode: n, it: i } = t, s = i.opts.multipleOfPrecision, o = e.let("res"), a = s ? (0, za._)`Math.abs(Math.round(${o}) - ${o}) > 1e-${s}` : (0, za._)`${o} !== parseInt(${o})`;
    t.fail$data((0, za._)`(${n} === 0 || (${o} = ${r}/${n}, ${a}))`);
  }
};
hd.default = oN;
var pd = {}, Og = {};
Object.defineProperty(Og, "__esModule", { value: !0 });
function ak(t) {
  const e = t.length;
  let r = 0, n = 0, i;
  for (; n < e; )
    r++, i = t.charCodeAt(n++), i >= 55296 && i <= 56319 && n < e && (i = t.charCodeAt(n), (i & 64512) === 56320 && n++);
  return r;
}
Og.default = ak;
ak.code = 'require("ajv/dist/runtime/ucs2length").default';
Object.defineProperty(pd, "__esModule", { value: !0 });
const Li = Qe, aN = je, lN = Og, cN = {
  message({ keyword: t, schemaCode: e }) {
    const r = t === "maxLength" ? "more" : "fewer";
    return (0, Li.str)`must NOT have ${r} than ${e} characters`;
  },
  params: ({ schemaCode: t }) => (0, Li._)`{limit: ${t}}`
}, uN = {
  keyword: ["maxLength", "minLength"],
  type: "string",
  schemaType: "number",
  $data: !0,
  error: cN,
  code(t) {
    const { keyword: e, data: r, schemaCode: n, it: i } = t, s = e === "maxLength" ? Li.operators.GT : Li.operators.LT, o = i.opts.unicode === !1 ? (0, Li._)`${r}.length` : (0, Li._)`${(0, aN.useFunc)(t.gen, lN.default)}(${r})`;
    t.fail$data((0, Li._)`${o} ${s} ${n}`);
  }
};
pd.default = uN;
var md = {};
Object.defineProperty(md, "__esModule", { value: !0 });
const dN = Re, Cu = Qe, fN = {
  message: ({ schemaCode: t }) => (0, Cu.str)`must match pattern "${t}"`,
  params: ({ schemaCode: t }) => (0, Cu._)`{pattern: ${t}}`
}, hN = {
  keyword: "pattern",
  type: "string",
  schemaType: "string",
  $data: !0,
  error: fN,
  code(t) {
    const { data: e, $data: r, schema: n, schemaCode: i, it: s } = t, o = s.opts.unicodeRegExp ? "u" : "", a = r ? (0, Cu._)`(new RegExp(${i}, ${o}))` : (0, dN.usePattern)(t, n);
    t.fail$data((0, Cu._)`!${a}.test(${e})`);
  }
};
md.default = hN;
var gd = {};
Object.defineProperty(gd, "__esModule", { value: !0 });
const Xa = Qe, pN = {
  message({ keyword: t, schemaCode: e }) {
    const r = t === "maxProperties" ? "more" : "fewer";
    return (0, Xa.str)`must NOT have ${r} than ${e} properties`;
  },
  params: ({ schemaCode: t }) => (0, Xa._)`{limit: ${t}}`
}, mN = {
  keyword: ["maxProperties", "minProperties"],
  type: "object",
  schemaType: "number",
  $data: !0,
  error: pN,
  code(t) {
    const { keyword: e, data: r, schemaCode: n } = t, i = e === "maxProperties" ? Xa.operators.GT : Xa.operators.LT;
    t.fail$data((0, Xa._)`Object.keys(${r}).length ${i} ${n}`);
  }
};
gd.default = mN;
var Od = {};
Object.defineProperty(Od, "__esModule", { value: !0 });
const Oa = Re, Wa = Qe, gN = je, ON = {
  message: ({ params: { missingProperty: t } }) => (0, Wa.str)`must have required property '${t}'`,
  params: ({ params: { missingProperty: t } }) => (0, Wa._)`{missingProperty: ${t}}`
}, yN = {
  keyword: "required",
  type: "object",
  schemaType: "array",
  $data: !0,
  error: ON,
  code(t) {
    const { gen: e, schema: r, schemaCode: n, data: i, $data: s, it: o } = t, { opts: a } = o;
    if (!s && r.length === 0)
      return;
    const l = r.length >= a.loopRequired;
    if (o.allErrors ? c() : u(), a.strictRequired) {
      const h = t.parentSchema.properties, { definedProperties: p } = t.it;
      for (const g of r)
        if ((h == null ? void 0 : h[g]) === void 0 && !p.has(g)) {
          const m = o.schemaEnv.baseId + o.errSchemaPath, y = `required property "${g}" is not defined at "${m}" (strictRequired)`;
          (0, gN.checkStrictMode)(o, y, o.opts.strictRequired);
        }
    }
    function c() {
      if (l || s)
        t.block$data(Wa.nil, d);
      else
        for (const h of r)
          (0, Oa.checkReportMissingProp)(t, h);
    }
    function u() {
      const h = e.let("missing");
      if (l || s) {
        const p = e.let("valid", !0);
        t.block$data(p, () => f(h, p)), t.ok(p);
      } else
        e.if((0, Oa.checkMissingProp)(t, r, h)), (0, Oa.reportMissingProp)(t, h), e.else();
    }
    function d() {
      e.forOf("prop", n, (h) => {
        t.setParams({ missingProperty: h }), e.if((0, Oa.noPropertyInData)(e, i, h, a.ownProperties), () => t.error());
      });
    }
    function f(h, p) {
      t.setParams({ missingProperty: h }), e.forOf(h, n, () => {
        e.assign(p, (0, Oa.propertyInData)(e, i, h, a.ownProperties)), e.if((0, Wa.not)(p), () => {
          t.error(), e.break();
        });
      }, Wa.nil);
    }
  }
};
Od.default = yN;
var yd = {};
Object.defineProperty(yd, "__esModule", { value: !0 });
const Ua = Qe, bN = {
  message({ keyword: t, schemaCode: e }) {
    const r = t === "maxItems" ? "more" : "fewer";
    return (0, Ua.str)`must NOT have ${r} than ${e} items`;
  },
  params: ({ schemaCode: t }) => (0, Ua._)`{limit: ${t}}`
}, vN = {
  keyword: ["maxItems", "minItems"],
  type: "array",
  schemaType: "number",
  $data: !0,
  error: bN,
  code(t) {
    const { keyword: e, data: r, schemaCode: n } = t, i = e === "maxItems" ? Ua.operators.GT : Ua.operators.LT;
    t.fail$data((0, Ua._)`${r}.length ${i} ${n}`);
  }
};
yd.default = vN;
var bd = {}, jl = {};
Object.defineProperty(jl, "__esModule", { value: !0 });
const lk = XS;
lk.code = 'require("ajv/dist/runtime/equal").default';
jl.default = lk;
Object.defineProperty(bd, "__esModule", { value: !0 });
const Df = El, _t = Qe, wN = je, $N = jl, SN = {
  message: ({ params: { i: t, j: e } }) => (0, _t.str)`must NOT have duplicate items (items ## ${e} and ${t} are identical)`,
  params: ({ params: { i: t, j: e } }) => (0, _t._)`{i: ${t}, j: ${e}}`
}, kN = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: !0,
  error: SN,
  code(t) {
    const { gen: e, data: r, $data: n, schema: i, parentSchema: s, schemaCode: o, it: a } = t;
    if (!n && !i)
      return;
    const l = e.let("valid"), c = s.items ? (0, Df.getSchemaTypes)(s.items) : [];
    t.block$data(l, u, (0, _t._)`${o} === false`), t.ok(l);
    function u() {
      const p = e.let("i", (0, _t._)`${r}.length`), g = e.let("j");
      t.setParams({ i: p, j: g }), e.assign(l, !0), e.if((0, _t._)`${p} > 1`, () => (d() ? f : h)(p, g));
    }
    function d() {
      return c.length > 0 && !c.some((p) => p === "object" || p === "array");
    }
    function f(p, g) {
      const m = e.name("item"), y = (0, Df.checkDataTypes)(c, m, a.opts.strictNumbers, Df.DataType.Wrong), O = e.const("indices", (0, _t._)`{}`);
      e.for((0, _t._)`;${p}--;`, () => {
        e.let(m, (0, _t._)`${r}[${p}]`), e.if(y, (0, _t._)`continue`), c.length > 1 && e.if((0, _t._)`typeof ${m} == "string"`, (0, _t._)`${m} += "_"`), e.if((0, _t._)`typeof ${O}[${m}] == "number"`, () => {
          e.assign(g, (0, _t._)`${O}[${m}]`), t.error(), e.assign(l, !1).break();
        }).code((0, _t._)`${O}[${m}] = ${p}`);
      });
    }
    function h(p, g) {
      const m = (0, wN.useFunc)(e, $N.default), y = e.name("outer");
      e.label(y).for((0, _t._)`;${p}--;`, () => e.for((0, _t._)`${g} = ${p}; ${g}--;`, () => e.if((0, _t._)`${m}(${r}[${p}], ${r}[${g}])`, () => {
        t.error(), e.assign(l, !1).break(y);
      })));
    }
  }
};
bd.default = kN;
var vd = {};
Object.defineProperty(vd, "__esModule", { value: !0 });
const Tp = Qe, _N = je, PN = jl, xN = {
  message: "must be equal to constant",
  params: ({ schemaCode: t }) => (0, Tp._)`{allowedValue: ${t}}`
}, TN = {
  keyword: "const",
  $data: !0,
  error: xN,
  code(t) {
    const { gen: e, data: r, $data: n, schemaCode: i, schema: s } = t;
    n || s && typeof s == "object" ? t.fail$data((0, Tp._)`!${(0, _N.useFunc)(e, PN.default)}(${r}, ${i})`) : t.fail((0, Tp._)`${s} !== ${r}`);
  }
};
vd.default = TN;
var wd = {};
Object.defineProperty(wd, "__esModule", { value: !0 });
const Ta = Qe, CN = je, QN = jl, AN = {
  message: "must be equal to one of the allowed values",
  params: ({ schemaCode: t }) => (0, Ta._)`{allowedValues: ${t}}`
}, EN = {
  keyword: "enum",
  schemaType: "array",
  $data: !0,
  error: AN,
  code(t) {
    const { gen: e, data: r, $data: n, schema: i, schemaCode: s, it: o } = t;
    if (!n && i.length === 0)
      throw new Error("enum must have non-empty array");
    const a = i.length >= o.opts.loopEnum;
    let l;
    const c = () => l ?? (l = (0, CN.useFunc)(e, QN.default));
    let u;
    if (a || n)
      u = e.let("valid"), t.block$data(u, d);
    else {
      if (!Array.isArray(i))
        throw new Error("ajv implementation error");
      const h = e.const("vSchema", s);
      u = (0, Ta.or)(...i.map((p, g) => f(h, g)));
    }
    t.pass(u);
    function d() {
      e.assign(u, !1), e.forOf("v", s, (h) => e.if((0, Ta._)`${c()}(${r}, ${h})`, () => e.assign(u, !0).break()));
    }
    function f(h, p) {
      const g = i[p];
      return typeof g == "object" && g !== null ? (0, Ta._)`${c()}(${r}, ${h}[${p}])` : (0, Ta._)`${r} === ${g}`;
    }
  }
};
wd.default = EN;
Object.defineProperty(pg, "__esModule", { value: !0 });
const RN = mg, IN = gg, jN = hd, ZN = pd, MN = md, qN = gd, NN = Od, DN = yd, zN = bd, XN = vd, WN = wd, UN = [
  // number
  RN.default,
  IN.default,
  jN.default,
  // string
  ZN.default,
  MN.default,
  // object
  qN.default,
  NN.default,
  // array
  DN.default,
  zN.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  XN.default,
  WN.default
];
pg.default = UN;
var $d = {}, Vo = {};
Object.defineProperty(Vo, "__esModule", { value: !0 });
Vo.validateAdditionalItems = void 0;
const Yi = Qe, Cp = je, VN = {
  message: ({ params: { len: t } }) => (0, Yi.str)`must NOT have more than ${t} items`,
  params: ({ params: { len: t } }) => (0, Yi._)`{limit: ${t}}`
}, LN = {
  keyword: "additionalItems",
  type: "array",
  schemaType: ["boolean", "object"],
  before: "uniqueItems",
  error: VN,
  code(t) {
    const { parentSchema: e, it: r } = t, { items: n } = e;
    if (!Array.isArray(n)) {
      (0, Cp.checkStrictMode)(r, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    ck(t, n);
  }
};
function ck(t, e) {
  const { gen: r, schema: n, data: i, keyword: s, it: o } = t;
  o.items = !0;
  const a = r.const("len", (0, Yi._)`${i}.length`);
  if (n === !1)
    t.setParams({ len: e.length }), t.pass((0, Yi._)`${a} <= ${e.length}`);
  else if (typeof n == "object" && !(0, Cp.alwaysValidSchema)(o, n)) {
    const c = r.var("valid", (0, Yi._)`${a} <= ${e.length}`);
    r.if((0, Yi.not)(c), () => l(c)), t.ok(c);
  }
  function l(c) {
    r.forRange("i", e.length, a, (u) => {
      t.subschema({ keyword: s, dataProp: u, dataPropType: Cp.Type.Num }, c), o.allErrors || r.if((0, Yi.not)(c), () => r.break());
    });
  }
}
Vo.validateAdditionalItems = ck;
Vo.default = LN;
var yg = {}, Lo = {};
Object.defineProperty(Lo, "__esModule", { value: !0 });
Lo.validateTuple = void 0;
const Wy = Qe, Lc = je, YN = Re, BN = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "array", "boolean"],
  before: "uniqueItems",
  code(t) {
    const { schema: e, it: r } = t;
    if (Array.isArray(e))
      return uk(t, "additionalItems", e);
    r.items = !0, !(0, Lc.alwaysValidSchema)(r, e) && t.ok((0, YN.validateArray)(t));
  }
};
function uk(t, e, r = t.schema) {
  const { gen: n, parentSchema: i, data: s, keyword: o, it: a } = t;
  u(i), a.opts.unevaluated && r.length && a.items !== !0 && (a.items = Lc.mergeEvaluated.items(n, r.length, a.items));
  const l = n.name("valid"), c = n.const("len", (0, Wy._)`${s}.length`);
  r.forEach((d, f) => {
    (0, Lc.alwaysValidSchema)(a, d) || (n.if((0, Wy._)`${c} > ${f}`, () => t.subschema({
      keyword: o,
      schemaProp: f,
      dataProp: f
    }, l)), t.ok(l));
  });
  function u(d) {
    const { opts: f, errSchemaPath: h } = a, p = r.length, g = p === d.minItems && (p === d.maxItems || d[e] === !1);
    if (f.strictTuples && !g) {
      const m = `"${o}" is ${p}-tuple, but minItems or maxItems/${e} are not specified or different at path "${h}"`;
      (0, Lc.checkStrictMode)(a, m, f.strictTuples);
    }
  }
}
Lo.validateTuple = uk;
Lo.default = BN;
Object.defineProperty(yg, "__esModule", { value: !0 });
const FN = Lo, HN = {
  keyword: "prefixItems",
  type: "array",
  schemaType: ["array"],
  before: "uniqueItems",
  code: (t) => (0, FN.validateTuple)(t, "items")
};
yg.default = HN;
var bg = {};
Object.defineProperty(bg, "__esModule", { value: !0 });
const Uy = Qe, GN = je, KN = Re, JN = Vo, eD = {
  message: ({ params: { len: t } }) => (0, Uy.str)`must NOT have more than ${t} items`,
  params: ({ params: { len: t } }) => (0, Uy._)`{limit: ${t}}`
}, tD = {
  keyword: "items",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  error: eD,
  code(t) {
    const { schema: e, parentSchema: r, it: n } = t, { prefixItems: i } = r;
    n.items = !0, !(0, GN.alwaysValidSchema)(n, e) && (i ? (0, JN.validateAdditionalItems)(t, i) : t.ok((0, KN.validateArray)(t)));
  }
};
bg.default = tD;
var vg = {};
Object.defineProperty(vg, "__esModule", { value: !0 });
const br = Qe, vc = je, rD = {
  message: ({ params: { min: t, max: e } }) => e === void 0 ? (0, br.str)`must contain at least ${t} valid item(s)` : (0, br.str)`must contain at least ${t} and no more than ${e} valid item(s)`,
  params: ({ params: { min: t, max: e } }) => e === void 0 ? (0, br._)`{minContains: ${t}}` : (0, br._)`{minContains: ${t}, maxContains: ${e}}`
}, nD = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: !0,
  error: rD,
  code(t) {
    const { gen: e, schema: r, parentSchema: n, data: i, it: s } = t;
    let o, a;
    const { minContains: l, maxContains: c } = n;
    s.opts.next ? (o = l === void 0 ? 1 : l, a = c) : o = 1;
    const u = e.const("len", (0, br._)`${i}.length`);
    if (t.setParams({ min: o, max: a }), a === void 0 && o === 0) {
      (0, vc.checkStrictMode)(s, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
      return;
    }
    if (a !== void 0 && o > a) {
      (0, vc.checkStrictMode)(s, '"minContains" > "maxContains" is always invalid'), t.fail();
      return;
    }
    if ((0, vc.alwaysValidSchema)(s, r)) {
      let g = (0, br._)`${u} >= ${o}`;
      a !== void 0 && (g = (0, br._)`${g} && ${u} <= ${a}`), t.pass(g);
      return;
    }
    s.items = !0;
    const d = e.name("valid");
    a === void 0 && o === 1 ? h(d, () => e.if(d, () => e.break())) : o === 0 ? (e.let(d, !0), a !== void 0 && e.if((0, br._)`${i}.length > 0`, f)) : (e.let(d, !1), f()), t.result(d, () => t.reset());
    function f() {
      const g = e.name("_valid"), m = e.let("count", 0);
      h(g, () => e.if(g, () => p(m)));
    }
    function h(g, m) {
      e.forRange("i", 0, u, (y) => {
        t.subschema({
          keyword: "contains",
          dataProp: y,
          dataPropType: vc.Type.Num,
          compositeRule: !0
        }, g), m();
      });
    }
    function p(g) {
      e.code((0, br._)`${g}++`), a === void 0 ? e.if((0, br._)`${g} >= ${o}`, () => e.assign(d, !0).break()) : (e.if((0, br._)`${g} > ${a}`, () => e.assign(d, !1).break()), o === 1 ? e.assign(d, !0) : e.if((0, br._)`${g} >= ${o}`, () => e.assign(d, !0)));
    }
  }
};
vg.default = nD;
var Sd = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.validateSchemaDeps = t.validatePropertyDeps = t.error = void 0;
  const e = Qe, r = je, n = Re;
  t.error = {
    message: ({ params: { property: l, depsCount: c, deps: u } }) => {
      const d = c === 1 ? "property" : "properties";
      return (0, e.str)`must have ${d} ${u} when property ${l} is present`;
    },
    params: ({ params: { property: l, depsCount: c, deps: u, missingProperty: d } }) => (0, e._)`{property: ${l},
    missingProperty: ${d},
    depsCount: ${c},
    deps: ${u}}`
    // TODO change to reference
  };
  const i = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: t.error,
    code(l) {
      const [c, u] = s(l);
      o(l, c), a(l, u);
    }
  };
  function s({ schema: l }) {
    const c = {}, u = {};
    for (const d in l) {
      if (d === "__proto__")
        continue;
      const f = Array.isArray(l[d]) ? c : u;
      f[d] = l[d];
    }
    return [c, u];
  }
  function o(l, c = l.schema) {
    const { gen: u, data: d, it: f } = l;
    if (Object.keys(c).length === 0)
      return;
    const h = u.let("missing");
    for (const p in c) {
      const g = c[p];
      if (g.length === 0)
        continue;
      const m = (0, n.propertyInData)(u, d, p, f.opts.ownProperties);
      l.setParams({
        property: p,
        depsCount: g.length,
        deps: g.join(", ")
      }), f.allErrors ? u.if(m, () => {
        for (const y of g)
          (0, n.checkReportMissingProp)(l, y);
      }) : (u.if((0, e._)`${m} && (${(0, n.checkMissingProp)(l, g, h)})`), (0, n.reportMissingProp)(l, h), u.else());
    }
  }
  t.validatePropertyDeps = o;
  function a(l, c = l.schema) {
    const { gen: u, data: d, keyword: f, it: h } = l, p = u.name("valid");
    for (const g in c)
      (0, r.alwaysValidSchema)(h, c[g]) || (u.if(
        (0, n.propertyInData)(u, d, g, h.opts.ownProperties),
        () => {
          const m = l.subschema({ keyword: f, schemaProp: g }, p);
          l.mergeValidEvaluated(m, p);
        },
        () => u.var(p, !0)
        // TODO var
      ), l.ok(p));
  }
  t.validateSchemaDeps = a, t.default = i;
})(Sd);
var wg = {};
Object.defineProperty(wg, "__esModule", { value: !0 });
const dk = Qe, iD = je, sD = {
  message: "property name must be valid",
  params: ({ params: t }) => (0, dk._)`{propertyName: ${t.propertyName}}`
}, oD = {
  keyword: "propertyNames",
  type: "object",
  schemaType: ["object", "boolean"],
  error: sD,
  code(t) {
    const { gen: e, schema: r, data: n, it: i } = t;
    if ((0, iD.alwaysValidSchema)(i, r))
      return;
    const s = e.name("valid");
    e.forIn("key", n, (o) => {
      t.setParams({ propertyName: o }), t.subschema({
        keyword: "propertyNames",
        data: o,
        dataTypes: ["string"],
        propertyName: o,
        compositeRule: !0
      }, s), e.if((0, dk.not)(s), () => {
        t.error(!0), i.allErrors || e.break();
      });
    }), t.ok(s);
  }
};
wg.default = oD;
var kd = {};
Object.defineProperty(kd, "__esModule", { value: !0 });
const wc = Re, Er = Qe, aD = mr, $c = je, lD = {
  message: "must NOT have additional properties",
  params: ({ params: t }) => (0, Er._)`{additionalProperty: ${t.additionalProperty}}`
}, cD = {
  keyword: "additionalProperties",
  type: ["object"],
  schemaType: ["boolean", "object"],
  allowUndefined: !0,
  trackErrors: !0,
  error: lD,
  code(t) {
    const { gen: e, schema: r, parentSchema: n, data: i, errsCount: s, it: o } = t;
    if (!s)
      throw new Error("ajv implementation error");
    const { allErrors: a, opts: l } = o;
    if (o.props = !0, l.removeAdditional !== "all" && (0, $c.alwaysValidSchema)(o, r))
      return;
    const c = (0, wc.allSchemaProperties)(n.properties), u = (0, wc.allSchemaProperties)(n.patternProperties);
    d(), t.ok((0, Er._)`${s} === ${aD.default.errors}`);
    function d() {
      e.forIn("key", i, (m) => {
        !c.length && !u.length ? p(m) : e.if(f(m), () => p(m));
      });
    }
    function f(m) {
      let y;
      if (c.length > 8) {
        const O = (0, $c.schemaRefOrVal)(o, n.properties, "properties");
        y = (0, wc.isOwnProperty)(e, O, m);
      } else
        c.length ? y = (0, Er.or)(...c.map((O) => (0, Er._)`${m} === ${O}`)) : y = Er.nil;
      return u.length && (y = (0, Er.or)(y, ...u.map((O) => (0, Er._)`${(0, wc.usePattern)(t, O)}.test(${m})`))), (0, Er.not)(y);
    }
    function h(m) {
      e.code((0, Er._)`delete ${i}[${m}]`);
    }
    function p(m) {
      if (l.removeAdditional === "all" || l.removeAdditional && r === !1) {
        h(m);
        return;
      }
      if (r === !1) {
        t.setParams({ additionalProperty: m }), t.error(), a || e.break();
        return;
      }
      if (typeof r == "object" && !(0, $c.alwaysValidSchema)(o, r)) {
        const y = e.name("valid");
        l.removeAdditional === "failing" ? (g(m, y, !1), e.if((0, Er.not)(y), () => {
          t.reset(), h(m);
        })) : (g(m, y), a || e.if((0, Er.not)(y), () => e.break()));
      }
    }
    function g(m, y, O) {
      const b = {
        keyword: "additionalProperties",
        dataProp: m,
        dataPropType: $c.Type.Str
      };
      O === !1 && Object.assign(b, {
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }), t.subschema(b, y);
    }
  }
};
kd.default = cD;
var $g = {};
Object.defineProperty($g, "__esModule", { value: !0 });
const uD = Ur, Vy = Re, zf = je, Ly = kd, dD = {
  keyword: "properties",
  type: "object",
  schemaType: "object",
  code(t) {
    const { gen: e, schema: r, parentSchema: n, data: i, it: s } = t;
    s.opts.removeAdditional === "all" && n.additionalProperties === void 0 && Ly.default.code(new uD.KeywordCxt(s, Ly.default, "additionalProperties"));
    const o = (0, Vy.allSchemaProperties)(r);
    for (const d of o)
      s.definedProperties.add(d);
    s.opts.unevaluated && o.length && s.props !== !0 && (s.props = zf.mergeEvaluated.props(e, (0, zf.toHash)(o), s.props));
    const a = o.filter((d) => !(0, zf.alwaysValidSchema)(s, r[d]));
    if (a.length === 0)
      return;
    const l = e.name("valid");
    for (const d of a)
      c(d) ? u(d) : (e.if((0, Vy.propertyInData)(e, i, d, s.opts.ownProperties)), u(d), s.allErrors || e.else().var(l, !0), e.endIf()), t.it.definedProperties.add(d), t.ok(l);
    function c(d) {
      return s.opts.useDefaults && !s.compositeRule && r[d].default !== void 0;
    }
    function u(d) {
      t.subschema({
        keyword: "properties",
        schemaProp: d,
        dataProp: d
      }, l);
    }
  }
};
$g.default = dD;
var Sg = {};
Object.defineProperty(Sg, "__esModule", { value: !0 });
const Yy = Re, Sc = Qe, By = je, Fy = je, fD = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(t) {
    const { gen: e, schema: r, data: n, parentSchema: i, it: s } = t, { opts: o } = s, a = (0, Yy.allSchemaProperties)(r), l = a.filter((g) => (0, By.alwaysValidSchema)(s, r[g]));
    if (a.length === 0 || l.length === a.length && (!s.opts.unevaluated || s.props === !0))
      return;
    const c = o.strictSchema && !o.allowMatchingProperties && i.properties, u = e.name("valid");
    s.props !== !0 && !(s.props instanceof Sc.Name) && (s.props = (0, Fy.evaluatedPropsToName)(e, s.props));
    const { props: d } = s;
    f();
    function f() {
      for (const g of a)
        c && h(g), s.allErrors ? p(g) : (e.var(u, !0), p(g), e.if(u));
    }
    function h(g) {
      for (const m in c)
        new RegExp(g).test(m) && (0, By.checkStrictMode)(s, `property ${m} matches pattern ${g} (use allowMatchingProperties)`);
    }
    function p(g) {
      e.forIn("key", n, (m) => {
        e.if((0, Sc._)`${(0, Yy.usePattern)(t, g)}.test(${m})`, () => {
          const y = l.includes(g);
          y || t.subschema({
            keyword: "patternProperties",
            schemaProp: g,
            dataProp: m,
            dataPropType: Fy.Type.Str
          }, u), s.opts.unevaluated && d !== !0 ? e.assign((0, Sc._)`${d}[${m}]`, !0) : !y && !s.allErrors && e.if((0, Sc.not)(u), () => e.break());
        });
      });
    }
  }
};
Sg.default = fD;
var kg = {};
Object.defineProperty(kg, "__esModule", { value: !0 });
const hD = je, pD = {
  keyword: "not",
  schemaType: ["object", "boolean"],
  trackErrors: !0,
  code(t) {
    const { gen: e, schema: r, it: n } = t;
    if ((0, hD.alwaysValidSchema)(n, r)) {
      t.fail();
      return;
    }
    const i = e.name("valid");
    t.subschema({
      keyword: "not",
      compositeRule: !0,
      createErrors: !1,
      allErrors: !1
    }, i), t.failResult(i, () => t.reset(), () => t.error());
  },
  error: { message: "must NOT be valid" }
};
kg.default = pD;
var _g = {};
Object.defineProperty(_g, "__esModule", { value: !0 });
const mD = Re, gD = {
  keyword: "anyOf",
  schemaType: "array",
  trackErrors: !0,
  code: mD.validateUnion,
  error: { message: "must match a schema in anyOf" }
};
_g.default = gD;
var Pg = {};
Object.defineProperty(Pg, "__esModule", { value: !0 });
const Yc = Qe, OD = je, yD = {
  message: "must match exactly one schema in oneOf",
  params: ({ params: t }) => (0, Yc._)`{passingSchemas: ${t.passing}}`
}, bD = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: !0,
  error: yD,
  code(t) {
    const { gen: e, schema: r, parentSchema: n, it: i } = t;
    if (!Array.isArray(r))
      throw new Error("ajv implementation error");
    if (i.opts.discriminator && n.discriminator)
      return;
    const s = r, o = e.let("valid", !1), a = e.let("passing", null), l = e.name("_valid");
    t.setParams({ passing: a }), e.block(c), t.result(o, () => t.reset(), () => t.error(!0));
    function c() {
      s.forEach((u, d) => {
        let f;
        (0, OD.alwaysValidSchema)(i, u) ? e.var(l, !0) : f = t.subschema({
          keyword: "oneOf",
          schemaProp: d,
          compositeRule: !0
        }, l), d > 0 && e.if((0, Yc._)`${l} && ${o}`).assign(o, !1).assign(a, (0, Yc._)`[${a}, ${d}]`).else(), e.if(l, () => {
          e.assign(o, !0), e.assign(a, d), f && t.mergeEvaluated(f, Yc.Name);
        });
      });
    }
  }
};
Pg.default = bD;
var xg = {};
Object.defineProperty(xg, "__esModule", { value: !0 });
const vD = je, wD = {
  keyword: "allOf",
  schemaType: "array",
  code(t) {
    const { gen: e, schema: r, it: n } = t;
    if (!Array.isArray(r))
      throw new Error("ajv implementation error");
    const i = e.name("valid");
    r.forEach((s, o) => {
      if ((0, vD.alwaysValidSchema)(n, s))
        return;
      const a = t.subschema({ keyword: "allOf", schemaProp: o }, i);
      t.ok(i), t.mergeEvaluated(a);
    });
  }
};
xg.default = wD;
var Tg = {};
Object.defineProperty(Tg, "__esModule", { value: !0 });
const Qu = Qe, fk = je, $D = {
  message: ({ params: t }) => (0, Qu.str)`must match "${t.ifClause}" schema`,
  params: ({ params: t }) => (0, Qu._)`{failingKeyword: ${t.ifClause}}`
}, SD = {
  keyword: "if",
  schemaType: ["object", "boolean"],
  trackErrors: !0,
  error: $D,
  code(t) {
    const { gen: e, parentSchema: r, it: n } = t;
    r.then === void 0 && r.else === void 0 && (0, fk.checkStrictMode)(n, '"if" without "then" and "else" is ignored');
    const i = Hy(n, "then"), s = Hy(n, "else");
    if (!i && !s)
      return;
    const o = e.let("valid", !0), a = e.name("_valid");
    if (l(), t.reset(), i && s) {
      const u = e.let("ifClause");
      t.setParams({ ifClause: u }), e.if(a, c("then", u), c("else", u));
    } else
      i ? e.if(a, c("then")) : e.if((0, Qu.not)(a), c("else"));
    t.pass(o, () => t.error(!0));
    function l() {
      const u = t.subschema({
        keyword: "if",
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }, a);
      t.mergeEvaluated(u);
    }
    function c(u, d) {
      return () => {
        const f = t.subschema({ keyword: u }, a);
        e.assign(o, a), t.mergeValidEvaluated(f, o), d ? e.assign(d, (0, Qu._)`${u}`) : t.setParams({ ifClause: u });
      };
    }
  }
};
function Hy(t, e) {
  const r = t.schema[e];
  return r !== void 0 && !(0, fk.alwaysValidSchema)(t, r);
}
Tg.default = SD;
var Cg = {};
Object.defineProperty(Cg, "__esModule", { value: !0 });
const kD = je, _D = {
  keyword: ["then", "else"],
  schemaType: ["object", "boolean"],
  code({ keyword: t, parentSchema: e, it: r }) {
    e.if === void 0 && (0, kD.checkStrictMode)(r, `"${t}" without "if" is ignored`);
  }
};
Cg.default = _D;
Object.defineProperty($d, "__esModule", { value: !0 });
const PD = Vo, xD = yg, TD = Lo, CD = bg, QD = vg, AD = Sd, ED = wg, RD = kd, ID = $g, jD = Sg, ZD = kg, MD = _g, qD = Pg, ND = xg, DD = Tg, zD = Cg;
function XD(t = !1) {
  const e = [
    // any
    ZD.default,
    MD.default,
    qD.default,
    ND.default,
    DD.default,
    zD.default,
    // object
    ED.default,
    RD.default,
    AD.default,
    ID.default,
    jD.default
  ];
  return t ? e.push(xD.default, CD.default) : e.push(PD.default, TD.default), e.push(QD.default), e;
}
$d.default = XD;
var _d = {}, Qg = {};
Object.defineProperty(Qg, "__esModule", { value: !0 });
const ct = Qe, WD = {
  message: ({ schemaCode: t }) => (0, ct.str)`must match format "${t}"`,
  params: ({ schemaCode: t }) => (0, ct._)`{format: ${t}}`
}, UD = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: !0,
  error: WD,
  code(t, e) {
    const { gen: r, data: n, $data: i, schema: s, schemaCode: o, it: a } = t, { opts: l, errSchemaPath: c, schemaEnv: u, self: d } = a;
    if (!l.validateFormats)
      return;
    i ? f() : h();
    function f() {
      const p = r.scopeValue("formats", {
        ref: d.formats,
        code: l.code.formats
      }), g = r.const("fDef", (0, ct._)`${p}[${o}]`), m = r.let("fType"), y = r.let("format");
      r.if((0, ct._)`typeof ${g} == "object" && !(${g} instanceof RegExp)`, () => r.assign(m, (0, ct._)`${g}.type || "string"`).assign(y, (0, ct._)`${g}.validate`), () => r.assign(m, (0, ct._)`"string"`).assign(y, g)), t.fail$data((0, ct.or)(O(), b()));
      function O() {
        return l.strictSchema === !1 ? ct.nil : (0, ct._)`${o} && !${y}`;
      }
      function b() {
        const w = u.$async ? (0, ct._)`(${g}.async ? await ${y}(${n}) : ${y}(${n}))` : (0, ct._)`${y}(${n})`, S = (0, ct._)`(typeof ${y} == "function" ? ${w} : ${y}.test(${n}))`;
        return (0, ct._)`${y} && ${y} !== true && ${m} === ${e} && !${S}`;
      }
    }
    function h() {
      const p = d.formats[s];
      if (!p) {
        O();
        return;
      }
      if (p === !0)
        return;
      const [g, m, y] = b(p);
      g === e && t.pass(w());
      function O() {
        if (l.strictSchema === !1) {
          d.logger.warn(S());
          return;
        }
        throw new Error(S());
        function S() {
          return `unknown format "${s}" ignored in schema at path "${c}"`;
        }
      }
      function b(S) {
        const $ = S instanceof RegExp ? (0, ct.regexpCode)(S) : l.code.formats ? (0, ct._)`${l.code.formats}${(0, ct.getProperty)(s)}` : void 0, _ = r.scopeValue("formats", { key: s, ref: S, code: $ });
        return typeof S == "object" && !(S instanceof RegExp) ? [S.type || "string", S.validate, (0, ct._)`${_}.validate`] : ["string", S, _];
      }
      function w() {
        if (typeof p == "object" && !(p instanceof RegExp) && p.async) {
          if (!u.$async)
            throw new Error("async format in sync schema");
          return (0, ct._)`await ${y}(${n})`;
        }
        return typeof m == "function" ? (0, ct._)`${y}(${n})` : (0, ct._)`${y}.test(${n})`;
      }
    }
  }
};
Qg.default = UD;
Object.defineProperty(_d, "__esModule", { value: !0 });
const VD = Qg, LD = [VD.default];
_d.default = LD;
Object.defineProperty(fg, "__esModule", { value: !0 });
const YD = hg, BD = pg, FD = $d, HD = _d, GD = ["title", "description", "default"], KD = [
  YD.default,
  BD.default,
  FD.default(),
  HD.default,
  GD
];
fg.default = KD;
var Pd = {}, hk = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.DiscrError = void 0, function(e) {
    e.Tag = "tag", e.Mapping = "mapping";
  }(t.DiscrError || (t.DiscrError = {}));
})(hk);
Object.defineProperty(Pd, "__esModule", { value: !0 });
const Ds = Qe, Qp = hk, Gy = Bt, JD = je, ez = {
  message: ({ params: { discrError: t, tagName: e } }) => t === Qp.DiscrError.Tag ? `tag "${e}" must be string` : `value of tag "${e}" must be in oneOf`,
  params: ({ params: { discrError: t, tag: e, tagName: r } }) => (0, Ds._)`{error: ${t}, tag: ${r}, tagValue: ${e}}`
}, tz = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error: ez,
  code(t) {
    const { gen: e, data: r, schema: n, parentSchema: i, it: s } = t, { oneOf: o } = i;
    if (!s.opts.discriminator)
      throw new Error("discriminator: requires discriminator option");
    const a = n.propertyName;
    if (typeof a != "string")
      throw new Error("discriminator: requires propertyName");
    if (n.mapping)
      throw new Error("discriminator: mapping is not supported");
    if (!o)
      throw new Error("discriminator: requires oneOf keyword");
    const l = e.let("valid", !1), c = e.const("tag", (0, Ds._)`${r}${(0, Ds.getProperty)(a)}`);
    e.if((0, Ds._)`typeof ${c} == "string"`, () => u(), () => t.error(!1, { discrError: Qp.DiscrError.Tag, tag: c, tagName: a })), t.ok(l);
    function u() {
      const h = f();
      e.if(!1);
      for (const p in h)
        e.elseIf((0, Ds._)`${c} === ${p}`), e.assign(l, d(h[p]));
      e.else(), t.error(!1, { discrError: Qp.DiscrError.Mapping, tag: c, tagName: a }), e.endIf();
    }
    function d(h) {
      const p = e.name("valid"), g = t.subschema({ keyword: "oneOf", schemaProp: h }, p);
      return t.mergeEvaluated(g, Ds.Name), p;
    }
    function f() {
      var h;
      const p = {}, g = y(i);
      let m = !0;
      for (let w = 0; w < o.length; w++) {
        let S = o[w];
        S != null && S.$ref && !(0, JD.schemaHasRulesButRef)(S, s.self.RULES) && (S = Gy.resolveRef.call(s.self, s.schemaEnv.root, s.baseId, S == null ? void 0 : S.$ref), S instanceof Gy.SchemaEnv && (S = S.schema));
        const $ = (h = S == null ? void 0 : S.properties) === null || h === void 0 ? void 0 : h[a];
        if (typeof $ != "object")
          throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${a}"`);
        m = m && (g || y(S)), O($, w);
      }
      if (!m)
        throw new Error(`discriminator: "${a}" must be required`);
      return p;
      function y({ required: w }) {
        return Array.isArray(w) && w.includes(a);
      }
      function O(w, S) {
        if (w.const)
          b(w.const, S);
        else if (w.enum)
          for (const $ of w.enum)
            b($, S);
        else
          throw new Error(`discriminator: "properties/${a}" must have "const" or "enum"`);
      }
      function b(w, S) {
        if (typeof w != "string" || w in p)
          throw new Error(`discriminator: "${a}" values must be unique strings`);
        p[w] = S;
      }
    }
  }
};
Pd.default = tz;
const rz = "http://json-schema.org/draft-04/schema#", nz = "http://json-schema.org/draft-04/schema#", iz = "Core schema meta-schema", sz = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  positiveInteger: {
    type: "integer",
    minimum: 0
  },
  positiveIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/positiveInteger"
      },
      {
        default: 0
      }
    ]
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    minItems: 1,
    uniqueItems: !0
  }
}, oz = "object", az = {
  id: {
    type: "string",
    format: "uri"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: {},
  multipleOf: {
    type: "number",
    minimum: 0,
    exclusiveMinimum: !0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "boolean",
    default: !1
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "boolean",
    default: !1
  },
  maxLength: {
    $ref: "#/definitions/positiveInteger"
  },
  minLength: {
    $ref: "#/definitions/positiveIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    anyOf: [
      {
        type: "boolean"
      },
      {
        $ref: "#"
      }
    ],
    default: {}
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    default: {}
  },
  maxItems: {
    $ref: "#/definitions/positiveInteger"
  },
  minItems: {
    $ref: "#/definitions/positiveIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: !1
  },
  maxProperties: {
    $ref: "#/definitions/positiveInteger"
  },
  minProperties: {
    $ref: "#/definitions/positiveIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    anyOf: [
      {
        type: "boolean"
      },
      {
        $ref: "#"
      }
    ],
    default: {}
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  enum: {
    type: "array",
    minItems: 1,
    uniqueItems: !0
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: !0
      }
    ]
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
}, lz = {
  exclusiveMaximum: [
    "maximum"
  ],
  exclusiveMinimum: [
    "minimum"
  ]
}, cz = {
  id: rz,
  $schema: nz,
  description: iz,
  definitions: sz,
  type: oz,
  properties: az,
  dependencies: lz,
  default: {}
};
(function(t, e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
  const r = co, n = fg, i = Pd, s = cz, o = ["/properties"], a = "http://json-schema.org/draft-04/schema";
  class l extends r.default {
    constructor(f = {}) {
      super({
        ...f,
        schemaId: "id"
      });
    }
    _addVocabularies() {
      super._addVocabularies(), n.default.forEach((f) => this.addVocabulary(f)), this.opts.discriminator && this.addKeyword(i.default);
    }
    _addDefaultMetaSchema() {
      if (super._addDefaultMetaSchema(), !this.opts.meta)
        return;
      const f = this.opts.$data ? this.$dataMetaSchema(s, o) : s;
      this.addMetaSchema(f, a, !1), this.refs["http://json-schema.org/schema"] = a;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(a) ? a : void 0);
    }
  }
  t.exports = e = l, Object.defineProperty(e, "__esModule", { value: !0 }), e.default = l;
  var c = co;
  Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
    return c.KeywordCxt;
  } });
  var u = co;
  Object.defineProperty(e, "_", { enumerable: !0, get: function() {
    return u._;
  } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
    return u.str;
  } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
    return u.stringify;
  } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
    return u.nil;
  } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
    return u.Name;
  } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
    return u.CodeGen;
  } });
})(wp, wp.exports);
var uz = wp.exports, Ap = { exports: {} }, Ag = {}, Eg = {}, Rg = {};
Object.defineProperty(Rg, "__esModule", { value: !0 });
const dz = {
  keyword: "id",
  code() {
    throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  }
};
Rg.default = dz;
Object.defineProperty(Eg, "__esModule", { value: !0 });
const fz = Rg, hz = yn, pz = [
  "$schema",
  "$id",
  "$defs",
  "$vocabulary",
  { keyword: "$comment" },
  "definitions",
  fz.default,
  hz.default
];
Eg.default = pz;
var Ig = {}, jg = {};
Object.defineProperty(jg, "__esModule", { value: !0 });
const Au = Qe, Kn = Au.operators, Eu = {
  maximum: { okStr: "<=", ok: Kn.LTE, fail: Kn.GT },
  minimum: { okStr: ">=", ok: Kn.GTE, fail: Kn.LT },
  exclusiveMaximum: { okStr: "<", ok: Kn.LT, fail: Kn.GTE },
  exclusiveMinimum: { okStr: ">", ok: Kn.GT, fail: Kn.LTE }
}, mz = {
  message: ({ keyword: t, schemaCode: e }) => (0, Au.str)`must be ${Eu[t].okStr} ${e}`,
  params: ({ keyword: t, schemaCode: e }) => (0, Au._)`{comparison: ${Eu[t].okStr}, limit: ${e}}`
}, gz = {
  keyword: Object.keys(Eu),
  type: "number",
  schemaType: "number",
  $data: !0,
  error: mz,
  code(t) {
    const { keyword: e, data: r, schemaCode: n } = t;
    t.fail$data((0, Au._)`${r} ${Eu[e].fail} ${n} || isNaN(${r})`);
  }
};
jg.default = gz;
Object.defineProperty(Ig, "__esModule", { value: !0 });
const Oz = jg, yz = hd, bz = pd, vz = md, wz = gd, $z = Od, Sz = yd, kz = bd, _z = vd, Pz = wd, xz = [
  // number
  Oz.default,
  yz.default,
  // string
  bz.default,
  vz.default,
  // object
  wz.default,
  $z.default,
  // array
  Sz.default,
  kz.default,
  // any
  { keyword: "type", schemaType: ["string", "array"] },
  { keyword: "nullable", schemaType: "boolean" },
  _z.default,
  Pz.default
];
Ig.default = xz;
var Zg = {}, Yo = {};
Object.defineProperty(Yo, "__esModule", { value: !0 });
Yo.dynamicAnchor = void 0;
const Xf = Qe, Tz = mr, Ky = Bt, Cz = yn, Qz = {
  keyword: "$dynamicAnchor",
  schemaType: "string",
  code: (t) => pk(t, t.schema)
};
function pk(t, e) {
  const { gen: r, it: n } = t;
  n.schemaEnv.root.dynamicAnchors[e] = !0;
  const i = (0, Xf._)`${Tz.default.dynamicAnchors}${(0, Xf.getProperty)(e)}`, s = n.errSchemaPath === "#" ? n.validateName : Az(t);
  r.if((0, Xf._)`!${i}`, () => r.assign(i, s));
}
Yo.dynamicAnchor = pk;
function Az(t) {
  const { schemaEnv: e, schema: r, self: n } = t.it, { root: i, baseId: s, localRefs: o, meta: a } = e.root, { schemaId: l } = n.opts, c = new Ky.SchemaEnv({ schema: r, schemaId: l, root: i, baseId: s, localRefs: o, meta: a });
  return Ky.compileSchema.call(n, c), (0, Cz.getValidate)(t, c);
}
Yo.default = Qz;
var Bo = {};
Object.defineProperty(Bo, "__esModule", { value: !0 });
Bo.dynamicRef = void 0;
const Jy = Qe, Ez = mr, eb = yn, Rz = {
  keyword: "$dynamicRef",
  schemaType: "string",
  code: (t) => mk(t, t.schema)
};
function mk(t, e) {
  const { gen: r, keyword: n, it: i } = t;
  if (e[0] !== "#")
    throw new Error(`"${n}" only supports hash fragment reference`);
  const s = e.slice(1);
  if (i.allErrors)
    o();
  else {
    const l = r.let("valid", !1);
    o(l), t.ok(l);
  }
  function o(l) {
    if (i.schemaEnv.root.dynamicAnchors[s]) {
      const c = r.let("_v", (0, Jy._)`${Ez.default.dynamicAnchors}${(0, Jy.getProperty)(s)}`);
      r.if(c, a(c, l), a(i.validateName, l));
    } else
      a(i.validateName, l)();
  }
  function a(l, c) {
    return c ? () => r.block(() => {
      (0, eb.callRef)(t, l), r.let(c, !0);
    }) : () => (0, eb.callRef)(t, l);
  }
}
Bo.dynamicRef = mk;
Bo.default = Rz;
var Mg = {};
Object.defineProperty(Mg, "__esModule", { value: !0 });
const Iz = Yo, jz = je, Zz = {
  keyword: "$recursiveAnchor",
  schemaType: "boolean",
  code(t) {
    t.schema ? (0, Iz.dynamicAnchor)(t, "") : (0, jz.checkStrictMode)(t.it, "$recursiveAnchor: false is ignored");
  }
};
Mg.default = Zz;
var qg = {};
Object.defineProperty(qg, "__esModule", { value: !0 });
const Mz = Bo, qz = {
  keyword: "$recursiveRef",
  schemaType: "string",
  code: (t) => (0, Mz.dynamicRef)(t, t.schema)
};
qg.default = qz;
Object.defineProperty(Zg, "__esModule", { value: !0 });
const Nz = Yo, Dz = Bo, zz = Mg, Xz = qg, Wz = [Nz.default, Dz.default, zz.default, Xz.default];
Zg.default = Wz;
var Ng = {}, Dg = {};
Object.defineProperty(Dg, "__esModule", { value: !0 });
const tb = Sd, Uz = {
  keyword: "dependentRequired",
  type: "object",
  schemaType: "object",
  error: tb.error,
  code: (t) => (0, tb.validatePropertyDeps)(t)
};
Dg.default = Uz;
var zg = {};
Object.defineProperty(zg, "__esModule", { value: !0 });
const Vz = Sd, Lz = {
  keyword: "dependentSchemas",
  type: "object",
  schemaType: "object",
  code: (t) => (0, Vz.validateSchemaDeps)(t)
};
zg.default = Lz;
var Xg = {};
Object.defineProperty(Xg, "__esModule", { value: !0 });
const Yz = je, Bz = {
  keyword: ["maxContains", "minContains"],
  type: "array",
  schemaType: "number",
  code({ keyword: t, parentSchema: e, it: r }) {
    e.contains === void 0 && (0, Yz.checkStrictMode)(r, `"${t}" without "contains" is ignored`);
  }
};
Xg.default = Bz;
Object.defineProperty(Ng, "__esModule", { value: !0 });
const Fz = Dg, Hz = zg, Gz = Xg, Kz = [Fz.default, Hz.default, Gz.default];
Ng.default = Kz;
var Wg = {}, Ug = {};
Object.defineProperty(Ug, "__esModule", { value: !0 });
const Jn = Qe, rb = je, Jz = mr, eX = {
  message: "must NOT have unevaluated properties",
  params: ({ params: t }) => (0, Jn._)`{unevaluatedProperty: ${t.unevaluatedProperty}}`
}, tX = {
  keyword: "unevaluatedProperties",
  type: "object",
  schemaType: ["boolean", "object"],
  trackErrors: !0,
  error: eX,
  code(t) {
    const { gen: e, schema: r, data: n, errsCount: i, it: s } = t;
    if (!i)
      throw new Error("ajv implementation error");
    const { allErrors: o, props: a } = s;
    a instanceof Jn.Name ? e.if((0, Jn._)`${a} !== true`, () => e.forIn("key", n, (d) => e.if(c(a, d), () => l(d)))) : a !== !0 && e.forIn("key", n, (d) => a === void 0 ? l(d) : e.if(u(a, d), () => l(d))), s.props = !0, t.ok((0, Jn._)`${i} === ${Jz.default.errors}`);
    function l(d) {
      if (r === !1) {
        t.setParams({ unevaluatedProperty: d }), t.error(), o || e.break();
        return;
      }
      if (!(0, rb.alwaysValidSchema)(s, r)) {
        const f = e.name("valid");
        t.subschema({
          keyword: "unevaluatedProperties",
          dataProp: d,
          dataPropType: rb.Type.Str
        }, f), o || e.if((0, Jn.not)(f), () => e.break());
      }
    }
    function c(d, f) {
      return (0, Jn._)`!${d} || !${d}[${f}]`;
    }
    function u(d, f) {
      const h = [];
      for (const p in d)
        d[p] === !0 && h.push((0, Jn._)`${f} !== ${p}`);
      return (0, Jn.and)(...h);
    }
  }
};
Ug.default = tX;
var Vg = {};
Object.defineProperty(Vg, "__esModule", { value: !0 });
const Bi = Qe, nb = je, rX = {
  message: ({ params: { len: t } }) => (0, Bi.str)`must NOT have more than ${t} items`,
  params: ({ params: { len: t } }) => (0, Bi._)`{limit: ${t}}`
}, nX = {
  keyword: "unevaluatedItems",
  type: "array",
  schemaType: ["boolean", "object"],
  error: rX,
  code(t) {
    const { gen: e, schema: r, data: n, it: i } = t, s = i.items || 0;
    if (s === !0)
      return;
    const o = e.const("len", (0, Bi._)`${n}.length`);
    if (r === !1)
      t.setParams({ len: s }), t.fail((0, Bi._)`${o} > ${s}`);
    else if (typeof r == "object" && !(0, nb.alwaysValidSchema)(i, r)) {
      const l = e.var("valid", (0, Bi._)`${o} <= ${s}`);
      e.if((0, Bi.not)(l), () => a(l, s)), t.ok(l);
    }
    i.items = !0;
    function a(l, c) {
      e.forRange("i", c, o, (u) => {
        t.subschema({ keyword: "unevaluatedItems", dataProp: u, dataPropType: nb.Type.Num }, l), i.allErrors || e.if((0, Bi.not)(l), () => e.break());
      });
    }
  }
};
Vg.default = nX;
Object.defineProperty(Wg, "__esModule", { value: !0 });
const iX = Ug, sX = Vg, oX = [iX.default, sX.default];
Wg.default = oX;
var xo = {};
Object.defineProperty(xo, "__esModule", { value: !0 });
xo.contentVocabulary = xo.metadataVocabulary = void 0;
xo.metadataVocabulary = [
  "title",
  "description",
  "default",
  "deprecated",
  "readOnly",
  "writeOnly",
  "examples"
];
xo.contentVocabulary = [
  "contentMediaType",
  "contentEncoding",
  "contentSchema"
];
Object.defineProperty(Ag, "__esModule", { value: !0 });
const aX = Eg, lX = Ig, cX = $d, uX = Zg, dX = Ng, fX = Wg, hX = _d, ib = xo, pX = [
  uX.default,
  aX.default,
  lX.default,
  (0, cX.default)(!0),
  hX.default,
  ib.metadataVocabulary,
  ib.contentVocabulary,
  dX.default,
  fX.default
];
Ag.default = pX;
var Lg = {};
const mX = "https://json-schema.org/draft/2020-12/schema", gX = "https://json-schema.org/draft/2020-12/schema", OX = {
  "https://json-schema.org/draft/2020-12/vocab/core": !0,
  "https://json-schema.org/draft/2020-12/vocab/applicator": !0,
  "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0,
  "https://json-schema.org/draft/2020-12/vocab/validation": !0,
  "https://json-schema.org/draft/2020-12/vocab/meta-data": !0,
  "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0,
  "https://json-schema.org/draft/2020-12/vocab/content": !0
}, yX = "meta", bX = "Core and Validation specifications meta-schema", vX = [
  {
    $ref: "meta/core"
  },
  {
    $ref: "meta/applicator"
  },
  {
    $ref: "meta/unevaluated"
  },
  {
    $ref: "meta/validation"
  },
  {
    $ref: "meta/meta-data"
  },
  {
    $ref: "meta/format-annotation"
  },
  {
    $ref: "meta/content"
  }
], wX = [
  "object",
  "boolean"
], $X = "This meta-schema also defines keywords that have appeared in previous drafts in order to prevent incompatible extensions as they remain in common use.", SX = {
  definitions: {
    $comment: '"definitions" has been replaced by "$defs".',
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    deprecated: !0,
    default: {}
  },
  dependencies: {
    $comment: '"dependencies" has been split and replaced by "dependentSchemas" and "dependentRequired" in order to serve their differing semantics.',
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $dynamicRef: "#meta"
        },
        {
          $ref: "meta/validation#/$defs/stringArray"
        }
      ]
    },
    deprecated: !0,
    default: {}
  },
  $recursiveAnchor: {
    $comment: '"$recursiveAnchor" has been replaced by "$dynamicAnchor".',
    $ref: "meta/core#/$defs/anchorString",
    deprecated: !0
  },
  $recursiveRef: {
    $comment: '"$recursiveRef" has been replaced by "$dynamicRef".',
    $ref: "meta/core#/$defs/uriReferenceString",
    deprecated: !0
  }
}, kX = {
  $schema: mX,
  $id: gX,
  $vocabulary: OX,
  $dynamicAnchor: yX,
  title: bX,
  allOf: vX,
  type: wX,
  $comment: $X,
  properties: SX
}, _X = "https://json-schema.org/draft/2020-12/schema", PX = "https://json-schema.org/draft/2020-12/meta/applicator", xX = {
  "https://json-schema.org/draft/2020-12/vocab/applicator": !0
}, TX = "meta", CX = "Applicator vocabulary meta-schema", QX = [
  "object",
  "boolean"
], AX = {
  prefixItems: {
    $ref: "#/$defs/schemaArray"
  },
  items: {
    $dynamicRef: "#meta"
  },
  contains: {
    $dynamicRef: "#meta"
  },
  additionalProperties: {
    $dynamicRef: "#meta"
  },
  properties: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    propertyNames: {
      format: "regex"
    },
    default: {}
  },
  dependentSchemas: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    },
    default: {}
  },
  propertyNames: {
    $dynamicRef: "#meta"
  },
  if: {
    $dynamicRef: "#meta"
  },
  then: {
    $dynamicRef: "#meta"
  },
  else: {
    $dynamicRef: "#meta"
  },
  allOf: {
    $ref: "#/$defs/schemaArray"
  },
  anyOf: {
    $ref: "#/$defs/schemaArray"
  },
  oneOf: {
    $ref: "#/$defs/schemaArray"
  },
  not: {
    $dynamicRef: "#meta"
  }
}, EX = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $dynamicRef: "#meta"
    }
  }
}, RX = {
  $schema: _X,
  $id: PX,
  $vocabulary: xX,
  $dynamicAnchor: TX,
  title: CX,
  type: QX,
  properties: AX,
  $defs: EX
}, IX = "https://json-schema.org/draft/2020-12/schema", jX = "https://json-schema.org/draft/2020-12/meta/unevaluated", ZX = {
  "https://json-schema.org/draft/2020-12/vocab/unevaluated": !0
}, MX = "meta", qX = "Unevaluated applicator vocabulary meta-schema", NX = [
  "object",
  "boolean"
], DX = {
  unevaluatedItems: {
    $dynamicRef: "#meta"
  },
  unevaluatedProperties: {
    $dynamicRef: "#meta"
  }
}, zX = {
  $schema: IX,
  $id: jX,
  $vocabulary: ZX,
  $dynamicAnchor: MX,
  title: qX,
  type: NX,
  properties: DX
}, XX = "https://json-schema.org/draft/2020-12/schema", WX = "https://json-schema.org/draft/2020-12/meta/content", UX = {
  "https://json-schema.org/draft/2020-12/vocab/content": !0
}, VX = "meta", LX = "Content vocabulary meta-schema", YX = [
  "object",
  "boolean"
], BX = {
  contentEncoding: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentSchema: {
    $dynamicRef: "#meta"
  }
}, FX = {
  $schema: XX,
  $id: WX,
  $vocabulary: UX,
  $dynamicAnchor: VX,
  title: LX,
  type: YX,
  properties: BX
}, HX = "https://json-schema.org/draft/2020-12/schema", GX = "https://json-schema.org/draft/2020-12/meta/core", KX = {
  "https://json-schema.org/draft/2020-12/vocab/core": !0
}, JX = "meta", eW = "Core vocabulary meta-schema", tW = [
  "object",
  "boolean"
], rW = {
  $id: {
    $ref: "#/$defs/uriReferenceString",
    $comment: "Non-empty fragments not allowed.",
    pattern: "^[^#]*#?$"
  },
  $schema: {
    $ref: "#/$defs/uriString"
  },
  $ref: {
    $ref: "#/$defs/uriReferenceString"
  },
  $anchor: {
    $ref: "#/$defs/anchorString"
  },
  $dynamicRef: {
    $ref: "#/$defs/uriReferenceString"
  },
  $dynamicAnchor: {
    $ref: "#/$defs/anchorString"
  },
  $vocabulary: {
    type: "object",
    propertyNames: {
      $ref: "#/$defs/uriString"
    },
    additionalProperties: {
      type: "boolean"
    }
  },
  $comment: {
    type: "string"
  },
  $defs: {
    type: "object",
    additionalProperties: {
      $dynamicRef: "#meta"
    }
  }
}, nW = {
  anchorString: {
    type: "string",
    pattern: "^[A-Za-z_][-A-Za-z0-9._]*$"
  },
  uriString: {
    type: "string",
    format: "uri"
  },
  uriReferenceString: {
    type: "string",
    format: "uri-reference"
  }
}, iW = {
  $schema: HX,
  $id: GX,
  $vocabulary: KX,
  $dynamicAnchor: JX,
  title: eW,
  type: tW,
  properties: rW,
  $defs: nW
}, sW = "https://json-schema.org/draft/2020-12/schema", oW = "https://json-schema.org/draft/2020-12/meta/format-annotation", aW = {
  "https://json-schema.org/draft/2020-12/vocab/format-annotation": !0
}, lW = "meta", cW = "Format vocabulary meta-schema for annotation results", uW = [
  "object",
  "boolean"
], dW = {
  format: {
    type: "string"
  }
}, fW = {
  $schema: sW,
  $id: oW,
  $vocabulary: aW,
  $dynamicAnchor: lW,
  title: cW,
  type: uW,
  properties: dW
}, hW = "https://json-schema.org/draft/2020-12/schema", pW = "https://json-schema.org/draft/2020-12/meta/meta-data", mW = {
  "https://json-schema.org/draft/2020-12/vocab/meta-data": !0
}, gW = "meta", OW = "Meta-data vocabulary meta-schema", yW = [
  "object",
  "boolean"
], bW = {
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: !0,
  deprecated: {
    type: "boolean",
    default: !1
  },
  readOnly: {
    type: "boolean",
    default: !1
  },
  writeOnly: {
    type: "boolean",
    default: !1
  },
  examples: {
    type: "array",
    items: !0
  }
}, vW = {
  $schema: hW,
  $id: pW,
  $vocabulary: mW,
  $dynamicAnchor: gW,
  title: OW,
  type: yW,
  properties: bW
}, wW = "https://json-schema.org/draft/2020-12/schema", $W = "https://json-schema.org/draft/2020-12/meta/validation", SW = {
  "https://json-schema.org/draft/2020-12/vocab/validation": !0
}, kW = "meta", _W = "Validation vocabulary meta-schema", PW = [
  "object",
  "boolean"
], xW = {
  type: {
    anyOf: [
      {
        $ref: "#/$defs/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/$defs/simpleTypes"
        },
        minItems: 1,
        uniqueItems: !0
      }
    ]
  },
  const: !0,
  enum: {
    type: "array",
    items: !0
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/$defs/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  maxItems: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/$defs/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: !1
  },
  maxContains: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minContains: {
    $ref: "#/$defs/nonNegativeInteger",
    default: 1
  },
  maxProperties: {
    $ref: "#/$defs/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/$defs/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/$defs/stringArray"
  },
  dependentRequired: {
    type: "object",
    additionalProperties: {
      $ref: "#/$defs/stringArray"
    }
  }
}, TW = {
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    $ref: "#/$defs/nonNegativeInteger",
    default: 0
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: !0,
    default: []
  }
}, CW = {
  $schema: wW,
  $id: $W,
  $vocabulary: SW,
  $dynamicAnchor: kW,
  title: _W,
  type: PW,
  properties: xW,
  $defs: TW
};
Object.defineProperty(Lg, "__esModule", { value: !0 });
const QW = kX, AW = RX, EW = zX, RW = FX, IW = iW, jW = fW, ZW = vW, MW = CW, qW = ["/properties"];
function NW(t) {
  return [
    QW,
    AW,
    EW,
    RW,
    IW,
    e(this, jW),
    ZW,
    e(this, MW)
  ].forEach((r) => this.addMetaSchema(r, void 0, !1)), this;
  function e(r, n) {
    return t ? r.$dataMetaSchema(n, qW) : n;
  }
}
Lg.default = NW;
(function(t, e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.MissingRefError = e.ValidationError = e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
  const r = co, n = Ag, i = Pd, s = Lg, o = "https://json-schema.org/draft/2020-12/schema";
  class a extends r.default {
    constructor(h = {}) {
      super({
        ...h,
        dynamicRef: !0,
        next: !0,
        unevaluated: !0
      });
    }
    _addVocabularies() {
      super._addVocabularies(), n.default.forEach((h) => this.addVocabulary(h)), this.opts.discriminator && this.addKeyword(i.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      const { $data: h, meta: p } = this.opts;
      p && (s.default.call(this, h), this.refs["http://json-schema.org/schema"] = o);
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(o) ? o : void 0);
    }
  }
  t.exports = e = a, Object.defineProperty(e, "__esModule", { value: !0 }), e.default = a;
  var l = Ur;
  Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
    return l.KeywordCxt;
  } });
  var c = Qe;
  Object.defineProperty(e, "_", { enumerable: !0, get: function() {
    return c._;
  } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
    return c.str;
  } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
    return c.stringify;
  } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
    return c.nil;
  } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
    return c.Name;
  } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
    return c.CodeGen;
  } });
  var u = Rl;
  Object.defineProperty(e, "ValidationError", { enumerable: !0, get: function() {
    return u.default;
  } });
  var d = Il;
  Object.defineProperty(e, "MissingRefError", { enumerable: !0, get: function() {
    return d.default;
  } });
})(Ap, Ap.exports);
var DW = Ap.exports, Ep = { exports: {} };
const zW = "https://raw.githubusercontent.com/OAI/OpenAPI-Specification/master/schemas/v1.2/apiDeclaration.json#", XW = "http://json-schema.org/draft-04/schema#", WW = "object", UW = [
  "swaggerVersion",
  "basePath",
  "apis"
], VW = {
  swaggerVersion: {
    enum: [
      "1.2"
    ]
  },
  apiVersion: {
    type: "string"
  },
  basePath: {
    type: "string",
    format: "uri",
    pattern: "^https?://"
  },
  resourcePath: {
    type: "string",
    format: "uri",
    pattern: "^/"
  },
  apis: {
    type: "array",
    items: {
      $ref: "#/definitions/apiObject"
    }
  },
  models: {
    type: "object",
    additionalProperties: {
      $ref: "modelsObject.json#"
    }
  },
  produces: {
    $ref: "#/definitions/mimeTypeArray"
  },
  consumes: {
    $ref: "#/definitions/mimeTypeArray"
  },
  authorizations: {
    $ref: "authorizationObject.json#"
  }
}, LW = !1, YW = {
  apiObject: {
    type: "object",
    required: [
      "path",
      "operations"
    ],
    properties: {
      path: {
        type: "string",
        format: "uri-template",
        pattern: "^/"
      },
      description: {
        type: "string"
      },
      operations: {
        type: "array",
        items: {
          $ref: "operationObject.json#"
        }
      }
    },
    additionalProperties: !1
  },
  mimeTypeArray: {
    type: "array",
    items: {
      type: "string",
      format: "mime-type"
    },
    uniqueItems: !0
  }
}, BW = {
  id: zW,
  $schema: XW,
  type: WW,
  required: UW,
  properties: VW,
  additionalProperties: LW,
  definitions: YW
}, FW = "A JSON Schema for Swagger 2.0 API.", HW = "http://swagger.io/v2/schema.json#", GW = "http://json-schema.org/draft-04/schema#", KW = "object", JW = [
  "swagger",
  "info",
  "paths"
], eU = !1, tU = {
  "^x-": {
    $ref: "#/definitions/vendorExtension"
  }
}, rU = {
  swagger: {
    type: "string",
    enum: [
      "2.0"
    ],
    description: "The Swagger version of this document."
  },
  info: {
    $ref: "#/definitions/info"
  },
  host: {
    type: "string",
    pattern: "^[^{}/ :\\\\]+(?::\\d+)?$",
    description: "The host (name or ip) of the API. Example: 'swagger.io'"
  },
  basePath: {
    type: "string",
    pattern: "^/",
    description: "The base path to the API. Example: '/api'."
  },
  schemes: {
    $ref: "#/definitions/schemesList"
  },
  consumes: {
    description: "A list of MIME types accepted by the API.",
    allOf: [
      {
        $ref: "#/definitions/mediaTypeList"
      }
    ]
  },
  produces: {
    description: "A list of MIME types the API can produce.",
    allOf: [
      {
        $ref: "#/definitions/mediaTypeList"
      }
    ]
  },
  paths: {
    $ref: "#/definitions/paths"
  },
  definitions: {
    $ref: "#/definitions/definitions"
  },
  parameters: {
    $ref: "#/definitions/parameterDefinitions"
  },
  responses: {
    $ref: "#/definitions/responseDefinitions"
  },
  security: {
    $ref: "#/definitions/security"
  },
  securityDefinitions: {
    $ref: "#/definitions/securityDefinitions"
  },
  tags: {
    type: "array",
    items: {
      $ref: "#/definitions/tag"
    },
    uniqueItems: !0
  },
  externalDocs: {
    $ref: "#/definitions/externalDocs"
  }
}, nU = {
  info: {
    type: "object",
    description: "General information about the API.",
    required: [
      "version",
      "title"
    ],
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      title: {
        type: "string",
        description: "A unique and precise title of the API."
      },
      version: {
        type: "string",
        description: "A semantic version number of the API."
      },
      description: {
        type: "string",
        description: "A longer description of the API. Should be different from the title.  GitHub Flavored Markdown is allowed."
      },
      termsOfService: {
        type: "string",
        description: "The terms of service for the API."
      },
      contact: {
        $ref: "#/definitions/contact"
      },
      license: {
        $ref: "#/definitions/license"
      }
    }
  },
  contact: {
    type: "object",
    description: "Contact information for the owners of the API.",
    additionalProperties: !1,
    properties: {
      name: {
        type: "string",
        description: "The identifying name of the contact person/organization."
      },
      url: {
        type: "string",
        description: "The URL pointing to the contact information.",
        format: "uri"
      },
      email: {
        type: "string",
        description: "The email address of the contact person/organization.",
        format: "email"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  license: {
    type: "object",
    required: [
      "name"
    ],
    additionalProperties: !1,
    properties: {
      name: {
        type: "string",
        description: "The name of the license type. It's encouraged to use an OSI compatible license."
      },
      url: {
        type: "string",
        description: "The URL pointing to the license.",
        format: "uri"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  paths: {
    type: "object",
    description: "Relative paths to the individual endpoints. They must be relative to the 'basePath'.",
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      },
      "^/": {
        $ref: "#/definitions/pathItem"
      }
    },
    additionalProperties: !1
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#/definitions/schema"
    },
    description: "One or more JSON objects describing the schemas being consumed and produced by the API."
  },
  parameterDefinitions: {
    type: "object",
    additionalProperties: {
      $ref: "#/definitions/parameter"
    },
    description: "One or more JSON representations for parameters"
  },
  responseDefinitions: {
    type: "object",
    additionalProperties: {
      $ref: "#/definitions/response"
    },
    description: "One or more JSON representations for responses"
  },
  externalDocs: {
    type: "object",
    additionalProperties: !1,
    description: "information about external documentation",
    required: [
      "url"
    ],
    properties: {
      description: {
        type: "string"
      },
      url: {
        type: "string",
        format: "uri"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  examples: {
    type: "object",
    additionalProperties: !0
  },
  mimeType: {
    type: "string",
    description: "The MIME type of the HTTP message."
  },
  operation: {
    type: "object",
    required: [
      "responses"
    ],
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      tags: {
        type: "array",
        items: {
          type: "string"
        },
        uniqueItems: !0
      },
      summary: {
        type: "string",
        description: "A brief summary of the operation."
      },
      description: {
        type: "string",
        description: "A longer description of the operation, GitHub Flavored Markdown is allowed."
      },
      externalDocs: {
        $ref: "#/definitions/externalDocs"
      },
      operationId: {
        type: "string",
        description: "A unique identifier of the operation."
      },
      produces: {
        description: "A list of MIME types the API can produce.",
        allOf: [
          {
            $ref: "#/definitions/mediaTypeList"
          }
        ]
      },
      consumes: {
        description: "A list of MIME types the API can consume.",
        allOf: [
          {
            $ref: "#/definitions/mediaTypeList"
          }
        ]
      },
      parameters: {
        $ref: "#/definitions/parametersList"
      },
      responses: {
        $ref: "#/definitions/responses"
      },
      schemes: {
        $ref: "#/definitions/schemesList"
      },
      deprecated: {
        type: "boolean",
        default: !1
      },
      security: {
        $ref: "#/definitions/security"
      }
    }
  },
  pathItem: {
    type: "object",
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      $ref: {
        type: "string"
      },
      get: {
        $ref: "#/definitions/operation"
      },
      put: {
        $ref: "#/definitions/operation"
      },
      post: {
        $ref: "#/definitions/operation"
      },
      delete: {
        $ref: "#/definitions/operation"
      },
      options: {
        $ref: "#/definitions/operation"
      },
      head: {
        $ref: "#/definitions/operation"
      },
      patch: {
        $ref: "#/definitions/operation"
      },
      parameters: {
        $ref: "#/definitions/parametersList"
      }
    }
  },
  responses: {
    type: "object",
    description: "Response objects names can either be any valid HTTP status code or 'default'.",
    minProperties: 1,
    additionalProperties: !1,
    patternProperties: {
      "^([0-9]{3})$|^(default)$": {
        $ref: "#/definitions/responseValue"
      },
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    not: {
      type: "object",
      additionalProperties: !1,
      patternProperties: {
        "^x-": {
          $ref: "#/definitions/vendorExtension"
        }
      }
    }
  },
  responseValue: {
    oneOf: [
      {
        $ref: "#/definitions/response"
      },
      {
        $ref: "#/definitions/jsonReference"
      }
    ]
  },
  response: {
    type: "object",
    required: [
      "description"
    ],
    properties: {
      description: {
        type: "string"
      },
      schema: {
        oneOf: [
          {
            $ref: "#/definitions/schema"
          },
          {
            $ref: "#/definitions/fileSchema"
          }
        ]
      },
      headers: {
        $ref: "#/definitions/headers"
      },
      examples: {
        $ref: "#/definitions/examples"
      }
    },
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  headers: {
    type: "object",
    additionalProperties: {
      $ref: "#/definitions/header"
    }
  },
  header: {
    type: "object",
    additionalProperties: !1,
    required: [
      "type"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "string",
          "number",
          "integer",
          "boolean",
          "array"
        ]
      },
      format: {
        type: "string"
      },
      items: {
        $ref: "#/definitions/primitivesItems"
      },
      collectionFormat: {
        $ref: "#/definitions/collectionFormat"
      },
      default: {
        $ref: "#/definitions/default"
      },
      maximum: {
        $ref: "#/definitions/maximum"
      },
      exclusiveMaximum: {
        $ref: "#/definitions/exclusiveMaximum"
      },
      minimum: {
        $ref: "#/definitions/minimum"
      },
      exclusiveMinimum: {
        $ref: "#/definitions/exclusiveMinimum"
      },
      maxLength: {
        $ref: "#/definitions/maxLength"
      },
      minLength: {
        $ref: "#/definitions/minLength"
      },
      pattern: {
        $ref: "#/definitions/pattern"
      },
      maxItems: {
        $ref: "#/definitions/maxItems"
      },
      minItems: {
        $ref: "#/definitions/minItems"
      },
      uniqueItems: {
        $ref: "#/definitions/uniqueItems"
      },
      enum: {
        $ref: "#/definitions/enum"
      },
      multipleOf: {
        $ref: "#/definitions/multipleOf"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  vendorExtension: {
    description: "Any property starting with x- is valid.",
    additionalProperties: !0,
    additionalItems: !0
  },
  bodyParameter: {
    type: "object",
    required: [
      "name",
      "in",
      "schema"
    ],
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      description: {
        type: "string",
        description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
      },
      name: {
        type: "string",
        description: "The name of the parameter."
      },
      in: {
        type: "string",
        description: "Determines the location of the parameter.",
        enum: [
          "body"
        ]
      },
      required: {
        type: "boolean",
        description: "Determines whether or not this parameter is required or optional.",
        default: !1
      },
      schema: {
        $ref: "#/definitions/schema"
      }
    },
    additionalProperties: !1
  },
  headerParameterSubSchema: {
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      required: {
        type: "boolean",
        description: "Determines whether or not this parameter is required or optional.",
        default: !1
      },
      in: {
        type: "string",
        description: "Determines the location of the parameter.",
        enum: [
          "header"
        ]
      },
      description: {
        type: "string",
        description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
      },
      name: {
        type: "string",
        description: "The name of the parameter."
      },
      type: {
        type: "string",
        enum: [
          "string",
          "number",
          "boolean",
          "integer",
          "array"
        ]
      },
      format: {
        type: "string"
      },
      items: {
        $ref: "#/definitions/primitivesItems"
      },
      collectionFormat: {
        $ref: "#/definitions/collectionFormat"
      },
      default: {
        $ref: "#/definitions/default"
      },
      maximum: {
        $ref: "#/definitions/maximum"
      },
      exclusiveMaximum: {
        $ref: "#/definitions/exclusiveMaximum"
      },
      minimum: {
        $ref: "#/definitions/minimum"
      },
      exclusiveMinimum: {
        $ref: "#/definitions/exclusiveMinimum"
      },
      maxLength: {
        $ref: "#/definitions/maxLength"
      },
      minLength: {
        $ref: "#/definitions/minLength"
      },
      pattern: {
        $ref: "#/definitions/pattern"
      },
      maxItems: {
        $ref: "#/definitions/maxItems"
      },
      minItems: {
        $ref: "#/definitions/minItems"
      },
      uniqueItems: {
        $ref: "#/definitions/uniqueItems"
      },
      enum: {
        $ref: "#/definitions/enum"
      },
      multipleOf: {
        $ref: "#/definitions/multipleOf"
      }
    }
  },
  queryParameterSubSchema: {
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      required: {
        type: "boolean",
        description: "Determines whether or not this parameter is required or optional.",
        default: !1
      },
      in: {
        type: "string",
        description: "Determines the location of the parameter.",
        enum: [
          "query"
        ]
      },
      description: {
        type: "string",
        description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
      },
      name: {
        type: "string",
        description: "The name of the parameter."
      },
      allowEmptyValue: {
        type: "boolean",
        default: !1,
        description: "allows sending a parameter by name only or with an empty value."
      },
      type: {
        type: "string",
        enum: [
          "string",
          "number",
          "boolean",
          "integer",
          "array"
        ]
      },
      format: {
        type: "string"
      },
      items: {
        $ref: "#/definitions/primitivesItems"
      },
      collectionFormat: {
        $ref: "#/definitions/collectionFormatWithMulti"
      },
      default: {
        $ref: "#/definitions/default"
      },
      maximum: {
        $ref: "#/definitions/maximum"
      },
      exclusiveMaximum: {
        $ref: "#/definitions/exclusiveMaximum"
      },
      minimum: {
        $ref: "#/definitions/minimum"
      },
      exclusiveMinimum: {
        $ref: "#/definitions/exclusiveMinimum"
      },
      maxLength: {
        $ref: "#/definitions/maxLength"
      },
      minLength: {
        $ref: "#/definitions/minLength"
      },
      pattern: {
        $ref: "#/definitions/pattern"
      },
      maxItems: {
        $ref: "#/definitions/maxItems"
      },
      minItems: {
        $ref: "#/definitions/minItems"
      },
      uniqueItems: {
        $ref: "#/definitions/uniqueItems"
      },
      enum: {
        $ref: "#/definitions/enum"
      },
      multipleOf: {
        $ref: "#/definitions/multipleOf"
      }
    }
  },
  formDataParameterSubSchema: {
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      required: {
        type: "boolean",
        description: "Determines whether or not this parameter is required or optional.",
        default: !1
      },
      in: {
        type: "string",
        description: "Determines the location of the parameter.",
        enum: [
          "formData"
        ]
      },
      description: {
        type: "string",
        description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
      },
      name: {
        type: "string",
        description: "The name of the parameter."
      },
      allowEmptyValue: {
        type: "boolean",
        default: !1,
        description: "allows sending a parameter by name only or with an empty value."
      },
      type: {
        type: "string",
        enum: [
          "string",
          "number",
          "boolean",
          "integer",
          "array",
          "file"
        ]
      },
      format: {
        type: "string"
      },
      items: {
        $ref: "#/definitions/primitivesItems"
      },
      collectionFormat: {
        $ref: "#/definitions/collectionFormatWithMulti"
      },
      default: {
        $ref: "#/definitions/default"
      },
      maximum: {
        $ref: "#/definitions/maximum"
      },
      exclusiveMaximum: {
        $ref: "#/definitions/exclusiveMaximum"
      },
      minimum: {
        $ref: "#/definitions/minimum"
      },
      exclusiveMinimum: {
        $ref: "#/definitions/exclusiveMinimum"
      },
      maxLength: {
        $ref: "#/definitions/maxLength"
      },
      minLength: {
        $ref: "#/definitions/minLength"
      },
      pattern: {
        $ref: "#/definitions/pattern"
      },
      maxItems: {
        $ref: "#/definitions/maxItems"
      },
      minItems: {
        $ref: "#/definitions/minItems"
      },
      uniqueItems: {
        $ref: "#/definitions/uniqueItems"
      },
      enum: {
        $ref: "#/definitions/enum"
      },
      multipleOf: {
        $ref: "#/definitions/multipleOf"
      }
    }
  },
  pathParameterSubSchema: {
    additionalProperties: !1,
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    required: [
      "required"
    ],
    properties: {
      required: {
        type: "boolean",
        enum: [
          !0
        ],
        description: "Determines whether or not this parameter is required or optional."
      },
      in: {
        type: "string",
        description: "Determines the location of the parameter.",
        enum: [
          "path"
        ]
      },
      description: {
        type: "string",
        description: "A brief description of the parameter. This could contain examples of use.  GitHub Flavored Markdown is allowed."
      },
      name: {
        type: "string",
        description: "The name of the parameter."
      },
      type: {
        type: "string",
        enum: [
          "string",
          "number",
          "boolean",
          "integer",
          "array"
        ]
      },
      format: {
        type: "string"
      },
      items: {
        $ref: "#/definitions/primitivesItems"
      },
      collectionFormat: {
        $ref: "#/definitions/collectionFormat"
      },
      default: {
        $ref: "#/definitions/default"
      },
      maximum: {
        $ref: "#/definitions/maximum"
      },
      exclusiveMaximum: {
        $ref: "#/definitions/exclusiveMaximum"
      },
      minimum: {
        $ref: "#/definitions/minimum"
      },
      exclusiveMinimum: {
        $ref: "#/definitions/exclusiveMinimum"
      },
      maxLength: {
        $ref: "#/definitions/maxLength"
      },
      minLength: {
        $ref: "#/definitions/minLength"
      },
      pattern: {
        $ref: "#/definitions/pattern"
      },
      maxItems: {
        $ref: "#/definitions/maxItems"
      },
      minItems: {
        $ref: "#/definitions/minItems"
      },
      uniqueItems: {
        $ref: "#/definitions/uniqueItems"
      },
      enum: {
        $ref: "#/definitions/enum"
      },
      multipleOf: {
        $ref: "#/definitions/multipleOf"
      }
    }
  },
  nonBodyParameter: {
    type: "object",
    required: [
      "name",
      "in",
      "type"
    ],
    oneOf: [
      {
        $ref: "#/definitions/headerParameterSubSchema"
      },
      {
        $ref: "#/definitions/formDataParameterSubSchema"
      },
      {
        $ref: "#/definitions/queryParameterSubSchema"
      },
      {
        $ref: "#/definitions/pathParameterSubSchema"
      }
    ]
  },
  parameter: {
    oneOf: [
      {
        $ref: "#/definitions/bodyParameter"
      },
      {
        $ref: "#/definitions/nonBodyParameter"
      }
    ]
  },
  schema: {
    type: "object",
    description: "A deterministic version of a JSON Schema object.",
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    properties: {
      $ref: {
        type: "string"
      },
      format: {
        type: "string"
      },
      title: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/title"
      },
      description: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/description"
      },
      default: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/default"
      },
      multipleOf: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/multipleOf"
      },
      maximum: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/maximum"
      },
      exclusiveMaximum: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum"
      },
      minimum: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/minimum"
      },
      exclusiveMinimum: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum"
      },
      maxLength: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
      },
      minLength: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
      },
      pattern: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/pattern"
      },
      maxItems: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
      },
      minItems: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
      },
      uniqueItems: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/uniqueItems"
      },
      maxProperties: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
      },
      minProperties: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
      },
      required: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/stringArray"
      },
      enum: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/enum"
      },
      additionalProperties: {
        anyOf: [
          {
            $ref: "#/definitions/schema"
          },
          {
            type: "boolean"
          }
        ],
        default: {}
      },
      type: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/type"
      },
      items: {
        anyOf: [
          {
            $ref: "#/definitions/schema"
          },
          {
            type: "array",
            minItems: 1,
            items: {
              $ref: "#/definitions/schema"
            }
          }
        ],
        default: {}
      },
      allOf: {
        type: "array",
        minItems: 1,
        items: {
          $ref: "#/definitions/schema"
        }
      },
      properties: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/schema"
        },
        default: {}
      },
      discriminator: {
        type: "string"
      },
      readOnly: {
        type: "boolean",
        default: !1
      },
      xml: {
        $ref: "#/definitions/xml"
      },
      externalDocs: {
        $ref: "#/definitions/externalDocs"
      },
      example: {}
    },
    additionalProperties: !1
  },
  fileSchema: {
    type: "object",
    description: "A deterministic version of a JSON Schema object.",
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    },
    required: [
      "type"
    ],
    properties: {
      format: {
        type: "string"
      },
      title: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/title"
      },
      description: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/description"
      },
      default: {
        $ref: "http://json-schema.org/draft-04/schema#/properties/default"
      },
      required: {
        $ref: "http://json-schema.org/draft-04/schema#/definitions/stringArray"
      },
      type: {
        type: "string",
        enum: [
          "file"
        ]
      },
      readOnly: {
        type: "boolean",
        default: !1
      },
      externalDocs: {
        $ref: "#/definitions/externalDocs"
      },
      example: {}
    },
    additionalProperties: !1
  },
  primitivesItems: {
    type: "object",
    additionalProperties: !1,
    properties: {
      type: {
        type: "string",
        enum: [
          "string",
          "number",
          "integer",
          "boolean",
          "array"
        ]
      },
      format: {
        type: "string"
      },
      items: {
        $ref: "#/definitions/primitivesItems"
      },
      collectionFormat: {
        $ref: "#/definitions/collectionFormat"
      },
      default: {
        $ref: "#/definitions/default"
      },
      maximum: {
        $ref: "#/definitions/maximum"
      },
      exclusiveMaximum: {
        $ref: "#/definitions/exclusiveMaximum"
      },
      minimum: {
        $ref: "#/definitions/minimum"
      },
      exclusiveMinimum: {
        $ref: "#/definitions/exclusiveMinimum"
      },
      maxLength: {
        $ref: "#/definitions/maxLength"
      },
      minLength: {
        $ref: "#/definitions/minLength"
      },
      pattern: {
        $ref: "#/definitions/pattern"
      },
      maxItems: {
        $ref: "#/definitions/maxItems"
      },
      minItems: {
        $ref: "#/definitions/minItems"
      },
      uniqueItems: {
        $ref: "#/definitions/uniqueItems"
      },
      enum: {
        $ref: "#/definitions/enum"
      },
      multipleOf: {
        $ref: "#/definitions/multipleOf"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  security: {
    type: "array",
    items: {
      $ref: "#/definitions/securityRequirement"
    },
    uniqueItems: !0
  },
  securityRequirement: {
    type: "object",
    additionalProperties: {
      type: "array",
      items: {
        type: "string"
      },
      uniqueItems: !0
    }
  },
  xml: {
    type: "object",
    additionalProperties: !1,
    properties: {
      name: {
        type: "string"
      },
      namespace: {
        type: "string"
      },
      prefix: {
        type: "string"
      },
      attribute: {
        type: "boolean",
        default: !1
      },
      wrapped: {
        type: "boolean",
        default: !1
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  tag: {
    type: "object",
    additionalProperties: !1,
    required: [
      "name"
    ],
    properties: {
      name: {
        type: "string"
      },
      description: {
        type: "string"
      },
      externalDocs: {
        $ref: "#/definitions/externalDocs"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  securityDefinitions: {
    type: "object",
    additionalProperties: {
      oneOf: [
        {
          $ref: "#/definitions/basicAuthenticationSecurity"
        },
        {
          $ref: "#/definitions/apiKeySecurity"
        },
        {
          $ref: "#/definitions/oauth2ImplicitSecurity"
        },
        {
          $ref: "#/definitions/oauth2PasswordSecurity"
        },
        {
          $ref: "#/definitions/oauth2ApplicationSecurity"
        },
        {
          $ref: "#/definitions/oauth2AccessCodeSecurity"
        }
      ]
    }
  },
  basicAuthenticationSecurity: {
    type: "object",
    additionalProperties: !1,
    required: [
      "type"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "basic"
        ]
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  apiKeySecurity: {
    type: "object",
    additionalProperties: !1,
    required: [
      "type",
      "name",
      "in"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "apiKey"
        ]
      },
      name: {
        type: "string"
      },
      in: {
        type: "string",
        enum: [
          "header",
          "query"
        ]
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  oauth2ImplicitSecurity: {
    type: "object",
    additionalProperties: !1,
    required: [
      "type",
      "flow",
      "authorizationUrl"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "oauth2"
        ]
      },
      flow: {
        type: "string",
        enum: [
          "implicit"
        ]
      },
      scopes: {
        $ref: "#/definitions/oauth2Scopes"
      },
      authorizationUrl: {
        type: "string",
        format: "uri"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  oauth2PasswordSecurity: {
    type: "object",
    additionalProperties: !1,
    required: [
      "type",
      "flow",
      "tokenUrl"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "oauth2"
        ]
      },
      flow: {
        type: "string",
        enum: [
          "password"
        ]
      },
      scopes: {
        $ref: "#/definitions/oauth2Scopes"
      },
      tokenUrl: {
        type: "string",
        format: "uri"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  oauth2ApplicationSecurity: {
    type: "object",
    additionalProperties: !1,
    required: [
      "type",
      "flow",
      "tokenUrl"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "oauth2"
        ]
      },
      flow: {
        type: "string",
        enum: [
          "application"
        ]
      },
      scopes: {
        $ref: "#/definitions/oauth2Scopes"
      },
      tokenUrl: {
        type: "string",
        format: "uri"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  oauth2AccessCodeSecurity: {
    type: "object",
    additionalProperties: !1,
    required: [
      "type",
      "flow",
      "authorizationUrl",
      "tokenUrl"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "oauth2"
        ]
      },
      flow: {
        type: "string",
        enum: [
          "accessCode"
        ]
      },
      scopes: {
        $ref: "#/definitions/oauth2Scopes"
      },
      authorizationUrl: {
        type: "string",
        format: "uri"
      },
      tokenUrl: {
        type: "string",
        format: "uri"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {
        $ref: "#/definitions/vendorExtension"
      }
    }
  },
  oauth2Scopes: {
    type: "object",
    additionalProperties: {
      type: "string"
    }
  },
  mediaTypeList: {
    type: "array",
    items: {
      $ref: "#/definitions/mimeType"
    },
    uniqueItems: !0
  },
  parametersList: {
    type: "array",
    description: "The parameters needed to send a valid API call.",
    additionalItems: !1,
    items: {
      oneOf: [
        {
          $ref: "#/definitions/parameter"
        },
        {
          $ref: "#/definitions/jsonReference"
        }
      ]
    },
    uniqueItems: !0
  },
  schemesList: {
    type: "array",
    description: "The transfer protocol of the API.",
    items: {
      type: "string",
      enum: [
        "http",
        "https",
        "ws",
        "wss"
      ]
    },
    uniqueItems: !0
  },
  collectionFormat: {
    type: "string",
    enum: [
      "csv",
      "ssv",
      "tsv",
      "pipes"
    ],
    default: "csv"
  },
  collectionFormatWithMulti: {
    type: "string",
    enum: [
      "csv",
      "ssv",
      "tsv",
      "pipes",
      "multi"
    ],
    default: "csv"
  },
  title: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/title"
  },
  description: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/description"
  },
  default: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/default"
  },
  multipleOf: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/multipleOf"
  },
  maximum: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/maximum"
  },
  exclusiveMaximum: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMaximum"
  },
  minimum: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/minimum"
  },
  exclusiveMinimum: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/exclusiveMinimum"
  },
  maxLength: {
    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
  },
  minLength: {
    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
  },
  pattern: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/pattern"
  },
  maxItems: {
    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveInteger"
  },
  minItems: {
    $ref: "http://json-schema.org/draft-04/schema#/definitions/positiveIntegerDefault0"
  },
  uniqueItems: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/uniqueItems"
  },
  enum: {
    $ref: "http://json-schema.org/draft-04/schema#/properties/enum"
  },
  jsonReference: {
    type: "object",
    required: [
      "$ref"
    ],
    additionalProperties: !1,
    properties: {
      $ref: {
        type: "string"
      }
    }
  }
}, iU = {
  title: FW,
  id: HW,
  $schema: GW,
  type: KW,
  required: JW,
  additionalProperties: eU,
  patternProperties: tU,
  properties: rU,
  definitions: nU
}, sU = "https://spec.openapis.org/oas/3.0/schema/2019-04-02", oU = "http://json-schema.org/draft-04/schema#", aU = "Validation schema for OpenAPI Specification 3.0.X.", lU = "object", cU = [
  "openapi",
  "info",
  "paths"
], uU = {
  openapi: {
    type: "string",
    pattern: "^3\\.0\\.\\d(-.+)?$"
  },
  info: {
    $ref: "#/definitions/Info"
  },
  externalDocs: {
    $ref: "#/definitions/ExternalDocumentation"
  },
  servers: {
    type: "array",
    items: {
      $ref: "#/definitions/Server"
    }
  },
  security: {
    type: "array",
    items: {
      $ref: "#/definitions/SecurityRequirement"
    }
  },
  tags: {
    type: "array",
    items: {
      $ref: "#/definitions/Tag"
    },
    uniqueItems: !0
  },
  paths: {
    $ref: "#/definitions/Paths"
  },
  components: {
    $ref: "#/definitions/Components"
  }
}, dU = {
  "^x-": {}
}, fU = !1, hU = {
  Reference: {
    type: "object",
    required: [
      "$ref"
    ],
    patternProperties: {
      "^\\$ref$": {
        type: "string",
        format: "uri-reference"
      }
    }
  },
  Info: {
    type: "object",
    required: [
      "title",
      "version"
    ],
    properties: {
      title: {
        type: "string"
      },
      description: {
        type: "string"
      },
      termsOfService: {
        type: "string",
        format: "uri-reference"
      },
      contact: {
        $ref: "#/definitions/Contact"
      },
      license: {
        $ref: "#/definitions/License"
      },
      version: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Contact: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      url: {
        type: "string",
        format: "uri-reference"
      },
      email: {
        type: "string",
        format: "email"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  License: {
    type: "object",
    required: [
      "name"
    ],
    properties: {
      name: {
        type: "string"
      },
      url: {
        type: "string",
        format: "uri-reference"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Server: {
    type: "object",
    required: [
      "url"
    ],
    properties: {
      url: {
        type: "string"
      },
      description: {
        type: "string"
      },
      variables: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/ServerVariable"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  ServerVariable: {
    type: "object",
    required: [
      "default"
    ],
    properties: {
      enum: {
        type: "array",
        items: {
          type: "string"
        }
      },
      default: {
        type: "string"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Components: {
    type: "object",
    properties: {
      schemas: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Schema"
              },
              {
                $ref: "#/definitions/Reference"
              }
            ]
          }
        }
      },
      responses: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/Response"
              }
            ]
          }
        }
      },
      parameters: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/Parameter"
              }
            ]
          }
        }
      },
      examples: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/Example"
              }
            ]
          }
        }
      },
      requestBodies: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/RequestBody"
              }
            ]
          }
        }
      },
      headers: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/Header"
              }
            ]
          }
        }
      },
      securitySchemes: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/SecurityScheme"
              }
            ]
          }
        }
      },
      links: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/Link"
              }
            ]
          }
        }
      },
      callbacks: {
        type: "object",
        patternProperties: {
          "^[a-zA-Z0-9\\.\\-_]+$": {
            oneOf: [
              {
                $ref: "#/definitions/Reference"
              },
              {
                $ref: "#/definitions/Callback"
              }
            ]
          }
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Schema: {
    type: "object",
    properties: {
      title: {
        type: "string"
      },
      multipleOf: {
        type: "number",
        minimum: 0,
        exclusiveMinimum: !0
      },
      maximum: {
        type: "number"
      },
      exclusiveMaximum: {
        type: "boolean",
        default: !1
      },
      minimum: {
        type: "number"
      },
      exclusiveMinimum: {
        type: "boolean",
        default: !1
      },
      maxLength: {
        type: "integer",
        minimum: 0
      },
      minLength: {
        type: "integer",
        minimum: 0,
        default: 0
      },
      pattern: {
        type: "string",
        format: "regex"
      },
      maxItems: {
        type: "integer",
        minimum: 0
      },
      minItems: {
        type: "integer",
        minimum: 0,
        default: 0
      },
      uniqueItems: {
        type: "boolean",
        default: !1
      },
      maxProperties: {
        type: "integer",
        minimum: 0
      },
      minProperties: {
        type: "integer",
        minimum: 0,
        default: 0
      },
      required: {
        type: "array",
        items: {
          type: "string"
        },
        minItems: 1,
        uniqueItems: !0
      },
      enum: {
        type: "array",
        items: {},
        minItems: 1,
        uniqueItems: !1
      },
      type: {
        type: "string",
        enum: [
          "array",
          "boolean",
          "integer",
          "number",
          "object",
          "string"
        ]
      },
      not: {
        oneOf: [
          {
            $ref: "#/definitions/Schema"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      allOf: {
        type: "array",
        items: {
          oneOf: [
            {
              $ref: "#/definitions/Schema"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      oneOf: {
        type: "array",
        items: {
          oneOf: [
            {
              $ref: "#/definitions/Schema"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      anyOf: {
        type: "array",
        items: {
          oneOf: [
            {
              $ref: "#/definitions/Schema"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      items: {
        oneOf: [
          {
            $ref: "#/definitions/Schema"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      properties: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Schema"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      additionalProperties: {
        oneOf: [
          {
            $ref: "#/definitions/Schema"
          },
          {
            $ref: "#/definitions/Reference"
          },
          {
            type: "boolean"
          }
        ],
        default: !0
      },
      description: {
        type: "string"
      },
      format: {
        type: "string"
      },
      default: {},
      nullable: {
        type: "boolean",
        default: !1
      },
      discriminator: {
        $ref: "#/definitions/Discriminator"
      },
      readOnly: {
        type: "boolean",
        default: !1
      },
      writeOnly: {
        type: "boolean",
        default: !1
      },
      example: {},
      externalDocs: {
        $ref: "#/definitions/ExternalDocumentation"
      },
      deprecated: {
        type: "boolean",
        default: !1
      },
      xml: {
        $ref: "#/definitions/XML"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Discriminator: {
    type: "object",
    required: [
      "propertyName"
    ],
    properties: {
      propertyName: {
        type: "string"
      },
      mapping: {
        type: "object",
        additionalProperties: {
          type: "string"
        }
      }
    }
  },
  XML: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      namespace: {
        type: "string",
        format: "uri"
      },
      prefix: {
        type: "string"
      },
      attribute: {
        type: "boolean",
        default: !1
      },
      wrapped: {
        type: "boolean",
        default: !1
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Response: {
    type: "object",
    required: [
      "description"
    ],
    properties: {
      description: {
        type: "string"
      },
      headers: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Header"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      content: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/MediaType"
        }
      },
      links: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Link"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  MediaType: {
    type: "object",
    properties: {
      schema: {
        oneOf: [
          {
            $ref: "#/definitions/Schema"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      example: {},
      examples: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Example"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      encoding: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/Encoding"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1,
    allOf: [
      {
        $ref: "#/definitions/ExampleXORExamples"
      }
    ]
  },
  Example: {
    type: "object",
    properties: {
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      value: {},
      externalValue: {
        type: "string",
        format: "uri-reference"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Header: {
    type: "object",
    properties: {
      description: {
        type: "string"
      },
      required: {
        type: "boolean",
        default: !1
      },
      deprecated: {
        type: "boolean",
        default: !1
      },
      allowEmptyValue: {
        type: "boolean",
        default: !1
      },
      style: {
        type: "string",
        enum: [
          "simple"
        ],
        default: "simple"
      },
      explode: {
        type: "boolean"
      },
      allowReserved: {
        type: "boolean",
        default: !1
      },
      schema: {
        oneOf: [
          {
            $ref: "#/definitions/Schema"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      content: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/MediaType"
        },
        minProperties: 1,
        maxProperties: 1
      },
      example: {},
      examples: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Example"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1,
    allOf: [
      {
        $ref: "#/definitions/ExampleXORExamples"
      },
      {
        $ref: "#/definitions/SchemaXORContent"
      }
    ]
  },
  Paths: {
    type: "object",
    patternProperties: {
      "^\\/": {
        $ref: "#/definitions/PathItem"
      },
      "^x-": {}
    },
    additionalProperties: !1
  },
  PathItem: {
    type: "object",
    properties: {
      $ref: {
        type: "string"
      },
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      servers: {
        type: "array",
        items: {
          $ref: "#/definitions/Server"
        }
      },
      parameters: {
        type: "array",
        items: {
          oneOf: [
            {
              $ref: "#/definitions/Parameter"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        },
        uniqueItems: !0
      }
    },
    patternProperties: {
      "^(get|put|post|delete|options|head|patch|trace)$": {
        $ref: "#/definitions/Operation"
      },
      "^x-": {}
    },
    additionalProperties: !1
  },
  Operation: {
    type: "object",
    required: [
      "responses"
    ],
    properties: {
      tags: {
        type: "array",
        items: {
          type: "string"
        }
      },
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      externalDocs: {
        $ref: "#/definitions/ExternalDocumentation"
      },
      operationId: {
        type: "string"
      },
      parameters: {
        type: "array",
        items: {
          oneOf: [
            {
              $ref: "#/definitions/Parameter"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        },
        uniqueItems: !0
      },
      requestBody: {
        oneOf: [
          {
            $ref: "#/definitions/RequestBody"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      responses: {
        $ref: "#/definitions/Responses"
      },
      callbacks: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Callback"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      },
      deprecated: {
        type: "boolean",
        default: !1
      },
      security: {
        type: "array",
        items: {
          $ref: "#/definitions/SecurityRequirement"
        }
      },
      servers: {
        type: "array",
        items: {
          $ref: "#/definitions/Server"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Responses: {
    type: "object",
    properties: {
      default: {
        oneOf: [
          {
            $ref: "#/definitions/Response"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      }
    },
    patternProperties: {
      "^[1-5](?:\\d{2}|XX)$": {
        oneOf: [
          {
            $ref: "#/definitions/Response"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      "^x-": {}
    },
    minProperties: 1,
    additionalProperties: !1
  },
  SecurityRequirement: {
    type: "object",
    additionalProperties: {
      type: "array",
      items: {
        type: "string"
      }
    }
  },
  Tag: {
    type: "object",
    required: [
      "name"
    ],
    properties: {
      name: {
        type: "string"
      },
      description: {
        type: "string"
      },
      externalDocs: {
        $ref: "#/definitions/ExternalDocumentation"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  ExternalDocumentation: {
    type: "object",
    required: [
      "url"
    ],
    properties: {
      description: {
        type: "string"
      },
      url: {
        type: "string",
        format: "uri-reference"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  ExampleXORExamples: {
    description: "Example and examples are mutually exclusive",
    not: {
      required: [
        "example",
        "examples"
      ]
    }
  },
  SchemaXORContent: {
    description: "Schema and content are mutually exclusive, at least one is required",
    not: {
      required: [
        "schema",
        "content"
      ]
    },
    oneOf: [
      {
        required: [
          "schema"
        ]
      },
      {
        required: [
          "content"
        ],
        description: "Some properties are not allowed if content is present",
        allOf: [
          {
            not: {
              required: [
                "style"
              ]
            }
          },
          {
            not: {
              required: [
                "explode"
              ]
            }
          },
          {
            not: {
              required: [
                "allowReserved"
              ]
            }
          },
          {
            not: {
              required: [
                "example"
              ]
            }
          },
          {
            not: {
              required: [
                "examples"
              ]
            }
          }
        ]
      }
    ]
  },
  Parameter: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      in: {
        type: "string"
      },
      description: {
        type: "string"
      },
      required: {
        type: "boolean",
        default: !1
      },
      deprecated: {
        type: "boolean",
        default: !1
      },
      allowEmptyValue: {
        type: "boolean",
        default: !1
      },
      style: {
        type: "string"
      },
      explode: {
        type: "boolean"
      },
      allowReserved: {
        type: "boolean",
        default: !1
      },
      schema: {
        oneOf: [
          {
            $ref: "#/definitions/Schema"
          },
          {
            $ref: "#/definitions/Reference"
          }
        ]
      },
      content: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/MediaType"
        },
        minProperties: 1,
        maxProperties: 1
      },
      example: {},
      examples: {
        type: "object",
        additionalProperties: {
          oneOf: [
            {
              $ref: "#/definitions/Example"
            },
            {
              $ref: "#/definitions/Reference"
            }
          ]
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1,
    required: [
      "name",
      "in"
    ],
    allOf: [
      {
        $ref: "#/definitions/ExampleXORExamples"
      },
      {
        $ref: "#/definitions/SchemaXORContent"
      },
      {
        $ref: "#/definitions/ParameterLocation"
      }
    ]
  },
  ParameterLocation: {
    description: "Parameter location",
    oneOf: [
      {
        description: "Parameter in path",
        required: [
          "required"
        ],
        properties: {
          in: {
            enum: [
              "path"
            ]
          },
          style: {
            enum: [
              "matrix",
              "label",
              "simple"
            ],
            default: "simple"
          },
          required: {
            enum: [
              !0
            ]
          }
        }
      },
      {
        description: "Parameter in query",
        properties: {
          in: {
            enum: [
              "query"
            ]
          },
          style: {
            enum: [
              "form",
              "spaceDelimited",
              "pipeDelimited",
              "deepObject"
            ],
            default: "form"
          }
        }
      },
      {
        description: "Parameter in header",
        properties: {
          in: {
            enum: [
              "header"
            ]
          },
          style: {
            enum: [
              "simple"
            ],
            default: "simple"
          }
        }
      },
      {
        description: "Parameter in cookie",
        properties: {
          in: {
            enum: [
              "cookie"
            ]
          },
          style: {
            enum: [
              "form"
            ],
            default: "form"
          }
        }
      }
    ]
  },
  RequestBody: {
    type: "object",
    required: [
      "content"
    ],
    properties: {
      description: {
        type: "string"
      },
      content: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/MediaType"
        }
      },
      required: {
        type: "boolean",
        default: !1
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  SecurityScheme: {
    oneOf: [
      {
        $ref: "#/definitions/APIKeySecurityScheme"
      },
      {
        $ref: "#/definitions/HTTPSecurityScheme"
      },
      {
        $ref: "#/definitions/OAuth2SecurityScheme"
      },
      {
        $ref: "#/definitions/OpenIdConnectSecurityScheme"
      }
    ]
  },
  APIKeySecurityScheme: {
    type: "object",
    required: [
      "type",
      "name",
      "in"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "apiKey"
        ]
      },
      name: {
        type: "string"
      },
      in: {
        type: "string",
        enum: [
          "header",
          "query",
          "cookie"
        ]
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  HTTPSecurityScheme: {
    type: "object",
    required: [
      "scheme",
      "type"
    ],
    properties: {
      scheme: {
        type: "string"
      },
      bearerFormat: {
        type: "string"
      },
      description: {
        type: "string"
      },
      type: {
        type: "string",
        enum: [
          "http"
        ]
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1,
    oneOf: [
      {
        description: "Bearer",
        properties: {
          scheme: {
            enum: [
              "bearer"
            ]
          }
        }
      },
      {
        description: "Non Bearer",
        not: {
          required: [
            "bearerFormat"
          ]
        },
        properties: {
          scheme: {
            not: {
              enum: [
                "bearer"
              ]
            }
          }
        }
      }
    ]
  },
  OAuth2SecurityScheme: {
    type: "object",
    required: [
      "type",
      "flows"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "oauth2"
        ]
      },
      flows: {
        $ref: "#/definitions/OAuthFlows"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  OpenIdConnectSecurityScheme: {
    type: "object",
    required: [
      "type",
      "openIdConnectUrl"
    ],
    properties: {
      type: {
        type: "string",
        enum: [
          "openIdConnect"
        ]
      },
      openIdConnectUrl: {
        type: "string",
        format: "uri-reference"
      },
      description: {
        type: "string"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  OAuthFlows: {
    type: "object",
    properties: {
      implicit: {
        $ref: "#/definitions/ImplicitOAuthFlow"
      },
      password: {
        $ref: "#/definitions/PasswordOAuthFlow"
      },
      clientCredentials: {
        $ref: "#/definitions/ClientCredentialsFlow"
      },
      authorizationCode: {
        $ref: "#/definitions/AuthorizationCodeOAuthFlow"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  ImplicitOAuthFlow: {
    type: "object",
    required: [
      "authorizationUrl",
      "scopes"
    ],
    properties: {
      authorizationUrl: {
        type: "string",
        format: "uri-reference"
      },
      refreshUrl: {
        type: "string",
        format: "uri-reference"
      },
      scopes: {
        type: "object",
        additionalProperties: {
          type: "string"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  PasswordOAuthFlow: {
    type: "object",
    required: [
      "tokenUrl"
    ],
    properties: {
      tokenUrl: {
        type: "string",
        format: "uri-reference"
      },
      refreshUrl: {
        type: "string",
        format: "uri-reference"
      },
      scopes: {
        type: "object",
        additionalProperties: {
          type: "string"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  ClientCredentialsFlow: {
    type: "object",
    required: [
      "tokenUrl"
    ],
    properties: {
      tokenUrl: {
        type: "string",
        format: "uri-reference"
      },
      refreshUrl: {
        type: "string",
        format: "uri-reference"
      },
      scopes: {
        type: "object",
        additionalProperties: {
          type: "string"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  AuthorizationCodeOAuthFlow: {
    type: "object",
    required: [
      "authorizationUrl",
      "tokenUrl"
    ],
    properties: {
      authorizationUrl: {
        type: "string",
        format: "uri-reference"
      },
      tokenUrl: {
        type: "string",
        format: "uri-reference"
      },
      refreshUrl: {
        type: "string",
        format: "uri-reference"
      },
      scopes: {
        type: "object",
        additionalProperties: {
          type: "string"
        }
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1
  },
  Link: {
    type: "object",
    properties: {
      operationId: {
        type: "string"
      },
      operationRef: {
        type: "string",
        format: "uri-reference"
      },
      parameters: {
        type: "object",
        additionalProperties: {}
      },
      requestBody: {},
      description: {
        type: "string"
      },
      server: {
        $ref: "#/definitions/Server"
      }
    },
    patternProperties: {
      "^x-": {}
    },
    additionalProperties: !1,
    not: {
      description: "Operation Id and Operation Ref are mutually exclusive",
      required: [
        "operationId",
        "operationRef"
      ]
    }
  },
  Callback: {
    type: "object",
    additionalProperties: {
      $ref: "#/definitions/PathItem"
    },
    patternProperties: {
      "^x-": {}
    }
  },
  Encoding: {
    type: "object",
    properties: {
      contentType: {
        type: "string"
      },
      headers: {
        type: "object",
        additionalProperties: {
          $ref: "#/definitions/Header"
        }
      },
      style: {
        type: "string",
        enum: [
          "form",
          "spaceDelimited",
          "pipeDelimited",
          "deepObject"
        ]
      },
      explode: {
        type: "boolean"
      },
      allowReserved: {
        type: "boolean",
        default: !1
      }
    },
    additionalProperties: !1
  }
}, pU = {
  id: sU,
  $schema: oU,
  description: aU,
  type: lU,
  required: cU,
  properties: uU,
  patternProperties: dU,
  additionalProperties: fU,
  definitions: hU
}, mU = "https://spec.openapis.org/oas/3.1/schema/2021-04-15", gU = "https://json-schema.org/draft/2020-12/schema", OU = "object", yU = {
  openapi: {
    type: "string",
    pattern: "^3\\.1\\.\\d+(-.+)?$"
  },
  info: {
    $ref: "#/$defs/info"
  },
  jsonSchemaDialect: {
    $ref: "#/$defs/uri",
    default: "https://spec.openapis.org/oas/3.1/dialect/base"
  },
  servers: {
    type: "array",
    items: {
      $ref: "#/$defs/server"
    }
  },
  paths: {
    $ref: "#/$defs/paths"
  },
  webhooks: {
    type: "object",
    additionalProperties: {
      $ref: "#/$defs/path-item-or-reference"
    }
  },
  components: {
    $ref: "#/$defs/components"
  },
  security: {
    type: "array",
    items: {
      $ref: "#/$defs/security-requirement"
    }
  },
  tags: {
    type: "array",
    items: {
      $ref: "#/$defs/tag"
    }
  },
  externalDocs: {
    $ref: "#/$defs/external-documentation"
  }
}, bU = [
  "openapi",
  "info"
], vU = [
  {
    required: [
      "paths"
    ]
  },
  {
    required: [
      "components"
    ]
  },
  {
    required: [
      "webhooks"
    ]
  }
], wU = "#/$defs/specification-extensions", $U = !1, SU = {
  info: {
    type: "object",
    properties: {
      title: {
        type: "string"
      },
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      termsOfService: {
        type: "string"
      },
      contact: {
        $ref: "#/$defs/contact"
      },
      license: {
        $ref: "#/$defs/license"
      },
      version: {
        type: "string"
      }
    },
    required: [
      "title",
      "version"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  contact: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      url: {
        type: "string"
      },
      email: {
        type: "string"
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  license: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      identifier: {
        type: "string"
      },
      url: {
        $ref: "#/$defs/uri"
      }
    },
    required: [
      "name"
    ],
    oneOf: [
      {
        required: [
          "identifier"
        ]
      },
      {
        required: [
          "url"
        ]
      }
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  server: {
    type: "object",
    properties: {
      url: {
        $ref: "#/$defs/uri"
      },
      description: {
        type: "string"
      },
      variables: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/server-variable"
        }
      }
    },
    required: [
      "url"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "server-variable": {
    type: "object",
    properties: {
      enum: {
        type: "array",
        items: {
          type: "string"
        },
        minItems: 1
      },
      default: {
        type: "string"
      },
      descriptions: {
        type: "string"
      }
    },
    required: [
      "default"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  components: {
    type: "object",
    properties: {
      schemas: {
        type: "object",
        additionalProperties: {
          $dynamicRef: "#meta"
        }
      },
      responses: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/response-or-reference"
        }
      },
      parameters: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/parameter-or-reference"
        }
      },
      examples: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/example-or-reference"
        }
      },
      requestBodies: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/request-body-or-reference"
        }
      },
      headers: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/header-or-reference"
        }
      },
      securitySchemes: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/security-scheme-or-reference"
        }
      },
      links: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/link-or-reference"
        }
      },
      callbacks: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/callbacks-or-reference"
        }
      },
      pathItems: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/path-item-or-reference"
        }
      }
    },
    patternProperties: {
      "^(schemas|responses|parameters|examples|requestBodies|headers|securitySchemes|links|callbacks|pathItems)$": {
        $comment: "Enumerating all of the property names in the regex above is necessary for unevaluatedProperties to work as expected",
        propertyNames: {
          pattern: "^[a-zA-Z0-9._-]+$"
        }
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  paths: {
    type: "object",
    patternProperties: {
      "^/": {
        $ref: "#/$defs/path-item"
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "path-item": {
    type: "object",
    properties: {
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      servers: {
        type: "array",
        items: {
          $ref: "#/$defs/server"
        }
      },
      parameters: {
        type: "array",
        items: {
          $ref: "#/$defs/parameter-or-reference"
        }
      }
    },
    patternProperties: {
      "^(get|put|post|delete|options|head|patch|trace)$": {
        $ref: "#/$defs/operation"
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "path-item-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/path-item"
    }
  },
  operation: {
    type: "object",
    properties: {
      tags: {
        type: "array",
        items: {
          type: "string"
        }
      },
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      externalDocs: {
        $ref: "#/$defs/external-documentation"
      },
      operationId: {
        type: "string"
      },
      parameters: {
        type: "array",
        items: {
          $ref: "#/$defs/parameter-or-reference"
        }
      },
      requestBody: {
        $ref: "#/$defs/request-body-or-reference"
      },
      responses: {
        $ref: "#/$defs/responses"
      },
      callbacks: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/callbacks-or-reference"
        }
      },
      deprecated: {
        default: !1,
        type: "boolean"
      },
      security: {
        type: "array",
        items: {
          $ref: "#/$defs/security-requirement"
        }
      },
      servers: {
        type: "array",
        items: {
          $ref: "#/$defs/server"
        }
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "external-documentation": {
    type: "object",
    properties: {
      description: {
        type: "string"
      },
      url: {
        $ref: "#/$defs/uri"
      }
    },
    required: [
      "url"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  parameter: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      in: {
        enum: [
          "query",
          "header",
          "path",
          "cookie"
        ]
      },
      description: {
        type: "string"
      },
      required: {
        default: !1,
        type: "boolean"
      },
      deprecated: {
        default: !1,
        type: "boolean"
      },
      allowEmptyValue: {
        default: !1,
        type: "boolean"
      },
      schema: {
        $dynamicRef: "#meta"
      },
      content: {
        $ref: "#/$defs/content"
      }
    },
    required: [
      "in"
    ],
    oneOf: [
      {
        required: [
          "schema"
        ]
      },
      {
        required: [
          "content"
        ]
      }
    ],
    dependentSchemas: {
      schema: {
        properties: {
          style: {
            type: "string"
          },
          explode: {
            type: "boolean"
          },
          allowReserved: {
            default: !1,
            type: "boolean"
          }
        },
        allOf: [
          {
            $ref: "#/$defs/examples"
          },
          {
            $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-path"
          },
          {
            $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-header"
          },
          {
            $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-query"
          },
          {
            $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-cookie"
          },
          {
            $ref: "#/$defs/parameter/dependentSchemas/schema/$defs/styles-for-form"
          }
        ],
        $defs: {
          "styles-for-path": {
            if: {
              properties: {
                in: {
                  const: "path"
                }
              },
              required: [
                "in"
              ]
            },
            then: {
              properties: {
                style: {
                  default: "simple",
                  enum: [
                    "matrix",
                    "label",
                    "simple"
                  ]
                },
                required: {
                  const: !0
                }
              },
              required: [
                "required"
              ]
            }
          },
          "styles-for-header": {
            if: {
              properties: {
                in: {
                  const: "header"
                }
              },
              required: [
                "in"
              ]
            },
            then: {
              properties: {
                style: {
                  default: "simple",
                  enum: [
                    "simple"
                  ]
                }
              }
            }
          },
          "styles-for-query": {
            if: {
              properties: {
                in: {
                  const: "query"
                }
              },
              required: [
                "in"
              ]
            },
            then: {
              properties: {
                style: {
                  default: "form",
                  enum: [
                    "form",
                    "spaceDelimited",
                    "pipeDelimited",
                    "deepObject"
                  ]
                }
              }
            }
          },
          "styles-for-cookie": {
            if: {
              properties: {
                in: {
                  const: "cookie"
                }
              },
              required: [
                "in"
              ]
            },
            then: {
              properties: {
                style: {
                  default: "form",
                  enum: [
                    "form"
                  ]
                }
              }
            }
          },
          "styles-for-form": {
            if: {
              properties: {
                style: {
                  const: "form"
                }
              },
              required: [
                "style"
              ]
            },
            then: {
              properties: {
                explode: {
                  default: !0
                }
              }
            },
            else: {
              properties: {
                explode: {
                  default: !1
                }
              }
            }
          }
        }
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "parameter-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/parameter"
    }
  },
  "request-body": {
    type: "object",
    properties: {
      description: {
        type: "string"
      },
      content: {
        $ref: "#/$defs/content"
      },
      required: {
        default: !1,
        type: "boolean"
      }
    },
    required: [
      "content"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "request-body-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/request-body"
    }
  },
  content: {
    type: "object",
    additionalProperties: {
      $ref: "#/$defs/media-type"
    },
    propertyNames: {
      format: "media-range"
    }
  },
  "media-type": {
    type: "object",
    properties: {
      schema: {
        $dynamicRef: "#meta"
      },
      encoding: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/encoding"
        }
      }
    },
    allOf: [
      {
        $ref: "#/$defs/specification-extensions"
      },
      {
        $ref: "#/$defs/examples"
      }
    ],
    unevaluatedProperties: !1
  },
  encoding: {
    type: "object",
    properties: {
      contentType: {
        type: "string",
        format: "media-range"
      },
      headers: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/header-or-reference"
        }
      },
      style: {
        default: "form",
        enum: [
          "form",
          "spaceDelimited",
          "pipeDelimited",
          "deepObject"
        ]
      },
      explode: {
        type: "boolean"
      },
      allowReserved: {
        default: !1,
        type: "boolean"
      }
    },
    allOf: [
      {
        $ref: "#/$defs/specification-extensions"
      },
      {
        $ref: "#/$defs/encoding/$defs/explode-default"
      }
    ],
    unevaluatedProperties: !1,
    $defs: {
      "explode-default": {
        if: {
          properties: {
            style: {
              const: "form"
            }
          },
          required: [
            "style"
          ]
        },
        then: {
          properties: {
            explode: {
              default: !0
            }
          }
        },
        else: {
          properties: {
            explode: {
              default: !1
            }
          }
        }
      }
    }
  },
  responses: {
    type: "object",
    properties: {
      default: {
        $ref: "#/$defs/response-or-reference"
      }
    },
    patternProperties: {
      "^[1-5][0-9X]{2}$": {
        $ref: "#/$defs/response-or-reference"
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  response: {
    type: "object",
    properties: {
      description: {
        type: "string"
      },
      headers: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/header-or-reference"
        }
      },
      content: {
        $ref: "#/$defs/content"
      },
      links: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/link-or-reference"
        }
      }
    },
    required: [
      "description"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "response-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/response"
    }
  },
  callbacks: {
    type: "object",
    $ref: "#/$defs/specification-extensions",
    additionalProperties: {
      $ref: "#/$defs/path-item-or-reference"
    }
  },
  "callbacks-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/callbacks"
    }
  },
  example: {
    type: "object",
    properties: {
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      },
      value: !0,
      externalValue: {
        $ref: "#/$defs/uri"
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "example-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/example"
    }
  },
  link: {
    type: "object",
    properties: {
      operationRef: {
        $ref: "#/$defs/uri"
      },
      operationId: !0,
      parameters: {
        $ref: "#/$defs/map-of-strings"
      },
      requestBody: !0,
      description: {
        type: "string"
      },
      body: {
        $ref: "#/$defs/server"
      }
    },
    oneOf: [
      {
        required: [
          "operationRef"
        ]
      },
      {
        required: [
          "operationId"
        ]
      }
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "link-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/link"
    }
  },
  header: {
    type: "object",
    properties: {
      description: {
        type: "string"
      },
      required: {
        default: !1,
        type: "boolean"
      },
      deprecated: {
        default: !1,
        type: "boolean"
      },
      allowEmptyValue: {
        default: !1,
        type: "boolean"
      }
    },
    dependentSchemas: {
      schema: {
        properties: {
          style: {
            default: "simple",
            enum: [
              "simple"
            ]
          },
          explode: {
            default: !1,
            type: "boolean"
          },
          allowReserved: {
            default: !1,
            type: "boolean"
          },
          schema: {
            $dynamicRef: "#meta"
          }
        },
        $ref: "#/$defs/examples"
      },
      content: {
        properties: {
          content: {
            $ref: "#/$defs/content"
          }
        }
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  "header-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/header"
    }
  },
  tag: {
    type: "object",
    properties: {
      name: {
        type: "string"
      },
      description: {
        type: "string"
      },
      externalDocs: {
        $ref: "#/$defs/external-documentation"
      }
    },
    required: [
      "name"
    ],
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1
  },
  reference: {
    type: "object",
    properties: {
      $ref: {
        $ref: "#/$defs/uri"
      },
      summary: {
        type: "string"
      },
      description: {
        type: "string"
      }
    },
    unevaluatedProperties: !1
  },
  schema: {
    $dynamicAnchor: "meta",
    type: [
      "object",
      "boolean"
    ]
  },
  "security-scheme": {
    type: "object",
    properties: {
      type: {
        enum: [
          "apiKey",
          "http",
          "mutualTLS",
          "oauth2",
          "openIdConnect"
        ]
      },
      description: {
        type: "string"
      }
    },
    required: [
      "type"
    ],
    allOf: [
      {
        $ref: "#/$defs/specification-extensions"
      },
      {
        $ref: "#/$defs/security-scheme/$defs/type-apikey"
      },
      {
        $ref: "#/$defs/security-scheme/$defs/type-http"
      },
      {
        $ref: "#/$defs/security-scheme/$defs/type-http-bearer"
      },
      {
        $ref: "#/$defs/security-scheme/$defs/type-oauth2"
      },
      {
        $ref: "#/$defs/security-scheme/$defs/type-oidc"
      }
    ],
    unevaluatedProperties: !1,
    $defs: {
      "type-apikey": {
        if: {
          properties: {
            type: {
              const: "apiKey"
            }
          },
          required: [
            "type"
          ]
        },
        then: {
          properties: {
            name: {
              type: "string"
            },
            in: {
              enum: [
                "query",
                "header",
                "cookie"
              ]
            }
          },
          required: [
            "name",
            "in"
          ]
        }
      },
      "type-http": {
        if: {
          properties: {
            type: {
              const: "http"
            }
          },
          required: [
            "type"
          ]
        },
        then: {
          properties: {
            scheme: {
              type: "string"
            }
          },
          required: [
            "scheme"
          ]
        }
      },
      "type-http-bearer": {
        if: {
          properties: {
            type: {
              const: "http"
            },
            scheme: {
              const: "bearer"
            }
          },
          required: [
            "type",
            "scheme"
          ]
        },
        then: {
          properties: {
            bearerFormat: {
              type: "string"
            }
          },
          required: [
            "scheme"
          ]
        }
      },
      "type-oauth2": {
        if: {
          properties: {
            type: {
              const: "oauth2"
            }
          },
          required: [
            "type"
          ]
        },
        then: {
          properties: {
            flows: {
              $ref: "#/$defs/oauth-flows"
            }
          },
          required: [
            "flows"
          ]
        }
      },
      "type-oidc": {
        if: {
          properties: {
            type: {
              const: "openIdConnect"
            }
          },
          required: [
            "type"
          ]
        },
        then: {
          properties: {
            openIdConnectUrl: {
              $ref: "#/$defs/uri"
            }
          },
          required: [
            "openIdConnectUrl"
          ]
        }
      }
    }
  },
  "security-scheme-or-reference": {
    if: {
      required: [
        "$ref"
      ]
    },
    then: {
      $ref: "#/$defs/reference"
    },
    else: {
      $ref: "#/$defs/security-scheme"
    }
  },
  "oauth-flows": {
    type: "object",
    properties: {
      implicit: {
        $ref: "#/$defs/oauth-flows/$defs/implicit"
      },
      password: {
        $ref: "#/$defs/oauth-flows/$defs/password"
      },
      clientCredentials: {
        $ref: "#/$defs/oauth-flows/$defs/client-credentials"
      },
      authorizationCode: {
        $ref: "#/$defs/oauth-flows/$defs/authorization-code"
      }
    },
    $ref: "#/$defs/specification-extensions",
    unevaluatedProperties: !1,
    $defs: {
      implicit: {
        type: "object",
        properties: {
          authorizationUrl: {
            type: "string"
          },
          refreshUrl: {
            type: "string"
          },
          scopes: {
            $ref: "#/$defs/map-of-strings"
          }
        },
        required: [
          "authorizationUrl",
          "scopes"
        ],
        $ref: "#/$defs/specification-extensions",
        unevaluatedProperties: !1
      },
      password: {
        type: "object",
        properties: {
          tokenUrl: {
            type: "string"
          },
          refreshUrl: {
            type: "string"
          },
          scopes: {
            $ref: "#/$defs/map-of-strings"
          }
        },
        required: [
          "tokenUrl",
          "scopes"
        ],
        $ref: "#/$defs/specification-extensions",
        unevaluatedProperties: !1
      },
      "client-credentials": {
        type: "object",
        properties: {
          tokenUrl: {
            type: "string"
          },
          refreshUrl: {
            type: "string"
          },
          scopes: {
            $ref: "#/$defs/map-of-strings"
          }
        },
        required: [
          "tokenUrl",
          "scopes"
        ],
        $ref: "#/$defs/specification-extensions",
        unevaluatedProperties: !1
      },
      "authorization-code": {
        type: "object",
        properties: {
          authorizationUrl: {
            type: "string"
          },
          tokenUrl: {
            type: "string"
          },
          refreshUrl: {
            type: "string"
          },
          scopes: {
            $ref: "#/$defs/map-of-strings"
          }
        },
        required: [
          "authorizationUrl",
          "tokenUrl",
          "scopes"
        ],
        $ref: "#/$defs/specification-extensions",
        unevaluatedProperties: !1
      }
    }
  },
  "security-requirement": {
    type: "object",
    additionalProperties: {
      type: "array",
      items: {
        type: "string"
      }
    }
  },
  "specification-extensions": {
    patternProperties: {
      "^x-": !0
    }
  },
  examples: {
    properties: {
      example: !0,
      examples: {
        type: "object",
        additionalProperties: {
          $ref: "#/$defs/example-or-reference"
        }
      }
    }
  },
  uri: {
    type: "string",
    format: "uri"
  },
  "map-of-strings": {
    type: "object",
    additionalProperties: {
      type: "string"
    }
  }
}, kU = {
  $id: mU,
  $schema: gU,
  type: OU,
  properties: yU,
  required: bU,
  anyOf: vU,
  $ref: wU,
  unevaluatedProperties: $U,
  $defs: SU
};
(function(t, e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.openapi = e.openapiV31 = e.openapiV3 = e.openapiV2 = e.openapiV1 = void 0, e.openapiV1 = BW, e.openapiV2 = iU, e.openapiV3 = pU, e.openapiV31 = kU, e.openapi = {
    v1: e.openapiV1,
    v2: e.openapiV2,
    v3: e.openapiV3,
    v31: e.openapiV31
  }, e.default = e.openapi, t.exports = Object.assign(t.exports.default, t.exports);
})(Ep, Ep.exports);
var _U = Ep.exports;
const PU = ys, { ono: xU } = $n, TU = uz, CU = DW, { openapi: Wf } = _U;
var gk = QU;
function QU(t) {
  let e, r;
  if (t.swagger)
    r = Wf.v2, e = Uf();
  else if (t.openapi.startsWith("3.1")) {
    r = Wf.v31;
    const i = r.$defs.schema;
    delete i.$dynamicAnchor, r.$defs.components.properties.schemas.additionalProperties = i, r.$defs.header.dependentSchemas.schema.properties.schema = i, r.$defs["media-type"].properties.schema = i, r.$defs.parameter.properties.schema = i, e = Uf(!1);
  } else
    r = Wf.v3, e = Uf();
  if (!e.validate(r, t)) {
    let i = e.errors, s = `Swagger schema validation failed.
` + AU(i);
    throw xU.syntax(i, { details: i }, s);
  }
}
function Uf(t = !0) {
  const e = {
    allErrors: !0,
    strict: !1,
    validateFormats: !1
  };
  return t ? new TU(e) : new CU(e);
}
function AU(t, e) {
  e = e || "  ";
  let r = "";
  for (let n of t)
    r += PU.format(`${e}#${n.instancePath.length ? n.instancePath : "/"} ${n.message}
`);
  return r;
}
var EU = [
  "get",
  "put",
  "post",
  "delete",
  "options",
  "head",
  "patch"
];
const RU = ys, { ono: Dt } = $n, IU = EU, Rp = ["array", "boolean", "integer", "number", "string"], Ok = ["array", "boolean", "integer", "number", "string", "object", "null", void 0];
var yk = jU;
function jU(t) {
  if (t.openapi)
    return;
  let e = Object.keys(t.paths || {}), r = [];
  for (let i of e) {
    let s = t.paths[i], o = "/paths" + i;
    s && i.indexOf("/") === 0 && ZU(t, s, o, r);
  }
  let n = Object.keys(t.definitions || {});
  for (let i of n) {
    let s = t.definitions[i], o = "/definitions/" + i;
    bk(s, o);
  }
}
function ZU(t, e, r, n) {
  for (let i of IU) {
    let s = e[i], o = r + "/" + i;
    if (s) {
      let a = s.operationId;
      if (a)
        if (n.indexOf(a) === -1)
          n.push(a);
        else
          throw Dt.syntax(`Validation failed. Duplicate operation id '${a}'`);
      MU(t, e, r, s, o);
      let l = Object.keys(s.responses || {});
      for (let c of l) {
        let u = s.responses[c], d = o + "/responses/" + c;
        zU(c, u || {}, d);
      }
    }
  }
}
function MU(t, e, r, n, i) {
  let s = e.parameters || [], o = n.parameters || [];
  try {
    sb(s);
  } catch (l) {
    throw Dt.syntax(l, `Validation failed. ${r} has duplicate parameters`);
  }
  try {
    sb(o);
  } catch (l) {
    throw Dt.syntax(l, `Validation failed. ${i} has duplicate parameters`);
  }
  let a = s.reduce((l, c) => (l.some((d) => d.in === c.in && d.name === c.name) || l.push(c), l), o.slice());
  qU(a, i), NU(a, r, i), DU(a, t, n, i);
}
function qU(t, e) {
  let r = t.filter((i) => i.in === "body"), n = t.filter((i) => i.in === "formData");
  if (r.length > 1)
    throw Dt.syntax(
      `Validation failed. ${e} has ${r.length} body parameters. Only one is allowed.`
    );
  if (r.length > 0 && n.length > 0)
    throw Dt.syntax(
      `Validation failed. ${e} has body parameters and formData parameters. Only one or the other is allowed.`
    );
}
function NU(t, e, r) {
  let n = e.match(RU.swaggerParamRegExp) || [];
  for (let i = 0; i < n.length; i++)
    for (let s = i + 1; s < n.length; s++)
      if (n[i] === n[s])
        throw Dt.syntax(
          `Validation failed. ${r} has multiple path placeholders named ${n[i]}`
        );
  t = t.filter((i) => i.in === "path");
  for (let i of t) {
    if (i.required !== !0)
      throw Dt.syntax(
        `Validation failed. Path parameters cannot be optional. Set required=true for the "${i.name}" parameter at ${r}`
      );
    let s = n.indexOf("{" + i.name + "}");
    if (s === -1)
      throw Dt.syntax(
        `Validation failed. ${r} has a path parameter named "${i.name}", but there is no corresponding {${i.name}} in the path string`
      );
    n.splice(s, 1);
  }
  if (n.length > 0)
    throw Dt.syntax(`Validation failed. ${r} is missing path parameter(s) for ${n}`);
}
function DU(t, e, r, n) {
  for (let i of t) {
    let s = n + "/parameters/" + i.name, o, a;
    switch (i.in) {
      case "body":
        o = i.schema, a = Ok;
        break;
      case "formData":
        o = i, a = Rp.concat("file");
        break;
      default:
        o = i, a = Rp;
    }
    if (Ip(o, s, a), bk(o, s), o.type === "file") {
      let l = /multipart\/(.*\+)?form-data/, c = /application\/(.*\+)?x-www-form-urlencoded/;
      if (!(r.consumes || e.consumes || []).some((f) => l.test(f) || c.test(f)))
        throw Dt.syntax(
          `Validation failed. ${n} has a file parameter, so it must consume multipart/form-data or application/x-www-form-urlencoded`
        );
    }
  }
}
function sb(t) {
  for (let e = 0; e < t.length - 1; e++) {
    let r = t[e];
    for (let n = e + 1; n < t.length; n++) {
      let i = t[n];
      if (r.name === i.name && r.in === i.in)
        throw Dt.syntax(`Validation failed. Found multiple ${r.in} parameters named "${r.name}"`);
    }
  }
}
function zU(t, e, r) {
  if (t !== "default" && (t < 100 || t > 599))
    throw Dt.syntax(`Validation failed. ${r} has an invalid response code (${t})`);
  let n = Object.keys(e.headers || {});
  for (let i of n) {
    let s = e.headers[i], o = r + "/headers/" + i;
    Ip(s, o, Rp);
  }
  if (e.schema) {
    let i = Ok.concat("file");
    if (i.indexOf(e.schema.type) === -1)
      throw Dt.syntax(
        `Validation failed. ${r} has an invalid response schema type (${e.schema.type})`
      );
    Ip(e.schema, r + "/schema", i);
  }
}
function Ip(t, e, r) {
  if (r.indexOf(t.type) === -1)
    throw Dt.syntax(
      `Validation failed. ${e} has an invalid type (${t.type})`
    );
  if (t.type === "array" && !t.items)
    throw Dt.syntax(`Validation failed. ${e} is an array, so it must include an "items" schema`);
}
function bk(t, e) {
  function r(n, i) {
    if (n.properties)
      for (let s in n.properties)
        n.properties.hasOwnProperty(s) && (i[s] = n.properties[s]);
    if (n.allOf)
      for (let s of n.allOf)
        r(s, i);
  }
  if (t.required && Array.isArray(t.required)) {
    let n = {};
    r(t, n);
    for (let i of t.required)
      if (!n[i])
        throw Dt.syntax(
          `Validation failed. Property '${i}' listed as required but does not exist in '${e}'`
        );
  }
}
var gt = {};
const { Ono: vk } = $n, { stripHash: wk, toFileSystemPath: XU } = Cr, Ai = gt.JSONParserError = class extends Error {
  constructor(e, r) {
    super(), this.code = "EUNKNOWN", this.message = e, this.source = r, this.path = null, vk.extend(this);
  }
};
Ei(Ai);
const $k = gt.JSONParserErrorGroup = class Sk extends Error {
  constructor(e) {
    super(), this.files = e, this.message = `${this.errors.length} error${this.errors.length > 1 ? "s" : ""} occurred while reading '${XU(e.$refs._root$Ref.path)}'`, vk.extend(this);
  }
  static getParserErrors(e) {
    const r = [];
    for (const n of Object.values(e.$refs._$refs))
      n.errors && r.push(...n.errors);
    return r;
  }
  get errors() {
    return Sk.getParserErrors(this.files);
  }
};
Ei($k);
const WU = gt.ParserError = class extends Ai {
  constructor(e, r) {
    super(`Error parsing ${r}: ${e}`, r), this.code = "EPARSER";
  }
};
Ei(WU);
const UU = gt.UnmatchedParserError = class extends Ai {
  constructor(e) {
    super(`Could not find parser for "${e}"`, e), this.code = "EUNMATCHEDPARSER";
  }
};
Ei(UU);
const VU = gt.ResolverError = class extends Ai {
  constructor(e, r) {
    super(e.message || `Error reading file "${r}"`, r), this.code = "ERESOLVER", "code" in e && (this.ioErrorCode = String(e.code));
  }
};
Ei(VU);
const LU = gt.UnmatchedResolverError = class extends Ai {
  constructor(e) {
    super(`Could not find resolver for "${e}"`, e), this.code = "EUNMATCHEDRESOLVER";
  }
};
Ei(LU);
const YU = gt.MissingPointerError = class extends Ai {
  constructor(e, r) {
    super(`Token "${e}" does not exist.`, wk(r)), this.code = "EMISSINGPOINTER";
  }
};
Ei(YU);
const BU = gt.InvalidPointerError = class extends Ai {
  constructor(e, r) {
    super(`Invalid $ref pointer "${e}". Pointers must begin with "#/"`, wk(r)), this.code = "EINVALIDPOINTER";
  }
};
Ei(BU);
function Ei(t) {
  Object.defineProperty(t.prototype, "name", {
    value: t.name,
    enumerable: !0
  });
}
gt.isHandledError = function(t) {
  return t instanceof Ai || t instanceof $k;
};
gt.normalizeError = function(t) {
  return t.path === null && (t.path = []), t;
};
const { ParserError: FU } = gt;
var HU = {
  /**
   * The order that this parser will run, in relation to other parsers.
   *
   * @type {number}
   */
  order: 100,
  /**
   * Whether to allow "empty" files. This includes zero-byte files, as well as empty JSON objects.
   *
   * @type {boolean}
   */
  allowEmpty: !0,
  /**
   * Determines whether this parser can parse a given file reference.
   * Parsers that match will be tried, in order, until one successfully parses the file.
   * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case
   * every parser will be tried.
   *
   * @type {RegExp|string|string[]|function}
   */
  canParse: ".json",
  /**
   * Parses the given file as JSON
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns {Promise}
   */
  async parse(t) {
    let e = t.data;
    if (Buffer.isBuffer(e) && (e = e.toString()), typeof e == "string") {
      if (e.trim().length === 0)
        return;
      try {
        return JSON.parse(e);
      } catch (r) {
        throw new FU(r.message, t.url);
      }
    } else
      return e;
  }
}, ot = {}, Zl = {}, Qr = {};
function kk(t) {
  return typeof t > "u" || t === null;
}
function GU(t) {
  return typeof t == "object" && t !== null;
}
function KU(t) {
  return Array.isArray(t) ? t : kk(t) ? [] : [t];
}
function JU(t, e) {
  var r, n, i, s;
  if (e)
    for (s = Object.keys(e), r = 0, n = s.length; r < n; r += 1)
      i = s[r], t[i] = e[i];
  return t;
}
function eV(t, e) {
  var r = "", n;
  for (n = 0; n < e; n += 1)
    r += t;
  return r;
}
function tV(t) {
  return t === 0 && Number.NEGATIVE_INFINITY === 1 / t;
}
Qr.isNothing = kk;
Qr.isObject = GU;
Qr.toArray = KU;
Qr.repeat = eV;
Qr.isNegativeZero = tV;
Qr.extend = JU;
function cl(t, e) {
  Error.call(this), this.name = "YAMLException", this.reason = t, this.mark = e, this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : ""), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
}
cl.prototype = Object.create(Error.prototype);
cl.prototype.constructor = cl;
cl.prototype.toString = function(e) {
  var r = this.name + ": ";
  return r += this.reason || "(unknown reason)", !e && this.mark && (r += " " + this.mark.toString()), r;
};
var Ml = cl, ob = Qr;
function Yg(t, e, r, n, i) {
  this.name = t, this.buffer = e, this.position = r, this.line = n, this.column = i;
}
Yg.prototype.getSnippet = function(e, r) {
  var n, i, s, o, a;
  if (!this.buffer)
    return null;
  for (e = e || 4, r = r || 75, n = "", i = this.position; i > 0 && `\0\r
Â…\u2028\u2029`.indexOf(this.buffer.charAt(i - 1)) === -1; )
    if (i -= 1, this.position - i > r / 2 - 1) {
      n = " ... ", i += 5;
      break;
    }
  for (s = "", o = this.position; o < this.buffer.length && `\0\r
Â…\u2028\u2029`.indexOf(this.buffer.charAt(o)) === -1; )
    if (o += 1, o - this.position > r / 2 - 1) {
      s = " ... ", o -= 5;
      break;
    }
  return a = this.buffer.slice(i, o), ob.repeat(" ", e) + n + a + s + `
` + ob.repeat(" ", e + this.position - i + n.length) + "^";
};
Yg.prototype.toString = function(e) {
  var r, n = "";
  return this.name && (n += 'in "' + this.name + '" '), n += "at line " + (this.line + 1) + ", column " + (this.column + 1), e || (r = this.getSnippet(), r && (n += `:
` + r)), n;
};
var rV = Yg, ab = Ml, nV = [
  "kind",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "defaultStyle",
  "styleAliases"
], iV = [
  "scalar",
  "sequence",
  "mapping"
];
function sV(t) {
  var e = {};
  return t !== null && Object.keys(t).forEach(function(r) {
    t[r].forEach(function(n) {
      e[String(n)] = r;
    });
  }), e;
}
function oV(t, e) {
  if (e = e || {}, Object.keys(e).forEach(function(r) {
    if (nV.indexOf(r) === -1)
      throw new ab('Unknown option "' + r + '" is met in definition of "' + t + '" YAML type.');
  }), this.tag = t, this.kind = e.kind || null, this.resolve = e.resolve || function() {
    return !0;
  }, this.construct = e.construct || function(r) {
    return r;
  }, this.instanceOf = e.instanceOf || null, this.predicate = e.predicate || null, this.represent = e.represent || null, this.defaultStyle = e.defaultStyle || null, this.styleAliases = sV(e.styleAliases || null), iV.indexOf(this.kind) === -1)
    throw new ab('Unknown kind "' + this.kind + '" is specified for "' + t + '" YAML type.');
}
var St = oV, lb = Qr, Bc = Ml, aV = St;
function jp(t, e, r) {
  var n = [];
  return t.include.forEach(function(i) {
    r = jp(i, e, r);
  }), t[e].forEach(function(i) {
    r.forEach(function(s, o) {
      s.tag === i.tag && s.kind === i.kind && n.push(o);
    }), r.push(i);
  }), r.filter(function(i, s) {
    return n.indexOf(s) === -1;
  });
}
function lV() {
  var t = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {}
  }, e, r;
  function n(i) {
    t[i.kind][i.tag] = t.fallback[i.tag] = i;
  }
  for (e = 0, r = arguments.length; e < r; e += 1)
    arguments[e].forEach(n);
  return t;
}
function Ys(t) {
  this.include = t.include || [], this.implicit = t.implicit || [], this.explicit = t.explicit || [], this.implicit.forEach(function(e) {
    if (e.loadKind && e.loadKind !== "scalar")
      throw new Bc("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
  }), this.compiledImplicit = jp(this, "implicit", []), this.compiledExplicit = jp(this, "explicit", []), this.compiledTypeMap = lV(this.compiledImplicit, this.compiledExplicit);
}
Ys.DEFAULT = null;
Ys.create = function() {
  var e, r;
  switch (arguments.length) {
    case 1:
      e = Ys.DEFAULT, r = arguments[0];
      break;
    case 2:
      e = arguments[0], r = arguments[1];
      break;
    default:
      throw new Bc("Wrong number of arguments for Schema.create function");
  }
  if (e = lb.toArray(e), r = lb.toArray(r), !e.every(function(n) {
    return n instanceof Ys;
  }))
    throw new Bc("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
  if (!r.every(function(n) {
    return n instanceof aV;
  }))
    throw new Bc("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  return new Ys({
    include: e,
    explicit: r
  });
};
var Fo = Ys, cV = St, uV = new cV("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(t) {
    return t !== null ? t : "";
  }
}), dV = St, fV = new dV("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(t) {
    return t !== null ? t : [];
  }
}), hV = St, pV = new hV("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(t) {
    return t !== null ? t : {};
  }
}), mV = Fo, Bg = new mV({
  explicit: [
    uV,
    fV,
    pV
  ]
}), gV = St;
function OV(t) {
  if (t === null)
    return !0;
  var e = t.length;
  return e === 1 && t === "~" || e === 4 && (t === "null" || t === "Null" || t === "NULL");
}
function yV() {
  return null;
}
function bV(t) {
  return t === null;
}
var vV = new gV("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: OV,
  construct: yV,
  predicate: bV,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    }
  },
  defaultStyle: "lowercase"
}), wV = St;
function $V(t) {
  if (t === null)
    return !1;
  var e = t.length;
  return e === 4 && (t === "true" || t === "True" || t === "TRUE") || e === 5 && (t === "false" || t === "False" || t === "FALSE");
}
function SV(t) {
  return t === "true" || t === "True" || t === "TRUE";
}
function kV(t) {
  return Object.prototype.toString.call(t) === "[object Boolean]";
}
var _V = new wV("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: $V,
  construct: SV,
  predicate: kV,
  represent: {
    lowercase: function(t) {
      return t ? "true" : "false";
    },
    uppercase: function(t) {
      return t ? "TRUE" : "FALSE";
    },
    camelcase: function(t) {
      return t ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
}), PV = Qr, xV = St;
function TV(t) {
  return 48 <= t && t <= 57 || 65 <= t && t <= 70 || 97 <= t && t <= 102;
}
function CV(t) {
  return 48 <= t && t <= 55;
}
function QV(t) {
  return 48 <= t && t <= 57;
}
function AV(t) {
  if (t === null)
    return !1;
  var e = t.length, r = 0, n = !1, i;
  if (!e)
    return !1;
  if (i = t[r], (i === "-" || i === "+") && (i = t[++r]), i === "0") {
    if (r + 1 === e)
      return !0;
    if (i = t[++r], i === "b") {
      for (r++; r < e; r++)
        if (i = t[r], i !== "_") {
          if (i !== "0" && i !== "1")
            return !1;
          n = !0;
        }
      return n && i !== "_";
    }
    if (i === "x") {
      for (r++; r < e; r++)
        if (i = t[r], i !== "_") {
          if (!TV(t.charCodeAt(r)))
            return !1;
          n = !0;
        }
      return n && i !== "_";
    }
    for (; r < e; r++)
      if (i = t[r], i !== "_") {
        if (!CV(t.charCodeAt(r)))
          return !1;
        n = !0;
      }
    return n && i !== "_";
  }
  if (i === "_")
    return !1;
  for (; r < e; r++)
    if (i = t[r], i !== "_") {
      if (i === ":")
        break;
      if (!QV(t.charCodeAt(r)))
        return !1;
      n = !0;
    }
  return !n || i === "_" ? !1 : i !== ":" ? !0 : /^(:[0-5]?[0-9])+$/.test(t.slice(r));
}
function EV(t) {
  var e = t, r = 1, n, i, s = [];
  return e.indexOf("_") !== -1 && (e = e.replace(/_/g, "")), n = e[0], (n === "-" || n === "+") && (n === "-" && (r = -1), e = e.slice(1), n = e[0]), e === "0" ? 0 : n === "0" ? e[1] === "b" ? r * parseInt(e.slice(2), 2) : e[1] === "x" ? r * parseInt(e, 16) : r * parseInt(e, 8) : e.indexOf(":") !== -1 ? (e.split(":").forEach(function(o) {
    s.unshift(parseInt(o, 10));
  }), e = 0, i = 1, s.forEach(function(o) {
    e += o * i, i *= 60;
  }), r * e) : r * parseInt(e, 10);
}
function RV(t) {
  return Object.prototype.toString.call(t) === "[object Number]" && t % 1 === 0 && !PV.isNegativeZero(t);
}
var IV = new xV("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: AV,
  construct: EV,
  predicate: RV,
  represent: {
    binary: function(t) {
      return t >= 0 ? "0b" + t.toString(2) : "-0b" + t.toString(2).slice(1);
    },
    octal: function(t) {
      return t >= 0 ? "0" + t.toString(8) : "-0" + t.toString(8).slice(1);
    },
    decimal: function(t) {
      return t.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(t) {
      return t >= 0 ? "0x" + t.toString(16).toUpperCase() : "-0x" + t.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
}), _k = Qr, jV = St, ZV = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function MV(t) {
  return !(t === null || !ZV.test(t) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  t[t.length - 1] === "_");
}
function qV(t) {
  var e, r, n, i;
  return e = t.replace(/_/g, "").toLowerCase(), r = e[0] === "-" ? -1 : 1, i = [], "+-".indexOf(e[0]) >= 0 && (e = e.slice(1)), e === ".inf" ? r === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : e === ".nan" ? NaN : e.indexOf(":") >= 0 ? (e.split(":").forEach(function(s) {
    i.unshift(parseFloat(s, 10));
  }), e = 0, n = 1, i.forEach(function(s) {
    e += s * n, n *= 60;
  }), r * e) : r * parseFloat(e, 10);
}
var NV = /^[-+]?[0-9]+e/;
function DV(t, e) {
  var r;
  if (isNaN(t))
    switch (e) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === t)
    switch (e) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === t)
    switch (e) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if (_k.isNegativeZero(t))
    return "-0.0";
  return r = t.toString(10), NV.test(r) ? r.replace("e", ".e") : r;
}
function zV(t) {
  return Object.prototype.toString.call(t) === "[object Number]" && (t % 1 !== 0 || _k.isNegativeZero(t));
}
var XV = new jV("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: MV,
  construct: qV,
  predicate: zV,
  represent: DV,
  defaultStyle: "lowercase"
}), WV = Fo, Pk = new WV({
  include: [
    Bg
  ],
  implicit: [
    vV,
    _V,
    IV,
    XV
  ]
}), UV = Fo, xk = new UV({
  include: [
    Pk
  ]
}), VV = St, Tk = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
), Ck = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function LV(t) {
  return t === null ? !1 : Tk.exec(t) !== null || Ck.exec(t) !== null;
}
function YV(t) {
  var e, r, n, i, s, o, a, l = 0, c = null, u, d, f;
  if (e = Tk.exec(t), e === null && (e = Ck.exec(t)), e === null)
    throw new Error("Date resolve error");
  if (r = +e[1], n = +e[2] - 1, i = +e[3], !e[4])
    return new Date(Date.UTC(r, n, i));
  if (s = +e[4], o = +e[5], a = +e[6], e[7]) {
    for (l = e[7].slice(0, 3); l.length < 3; )
      l += "0";
    l = +l;
  }
  return e[9] && (u = +e[10], d = +(e[11] || 0), c = (u * 60 + d) * 6e4, e[9] === "-" && (c = -c)), f = new Date(Date.UTC(r, n, i, s, o, a, l)), c && f.setTime(f.getTime() - c), f;
}
function BV(t) {
  return t.toISOString();
}
var FV = new VV("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: LV,
  construct: YV,
  instanceOf: Date,
  represent: BV
}), HV = St;
function GV(t) {
  return t === "<<" || t === null;
}
var KV = new HV("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: GV
});
function Qk(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var rs;
try {
  var JV = Qk;
  rs = JV("buffer").Buffer;
} catch {
}
var eL = St, Fg = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function tL(t) {
  if (t === null)
    return !1;
  var e, r, n = 0, i = t.length, s = Fg;
  for (r = 0; r < i; r++)
    if (e = s.indexOf(t.charAt(r)), !(e > 64)) {
      if (e < 0)
        return !1;
      n += 6;
    }
  return n % 8 === 0;
}
function rL(t) {
  var e, r, n = t.replace(/[\r\n=]/g, ""), i = n.length, s = Fg, o = 0, a = [];
  for (e = 0; e < i; e++)
    e % 4 === 0 && e && (a.push(o >> 16 & 255), a.push(o >> 8 & 255), a.push(o & 255)), o = o << 6 | s.indexOf(n.charAt(e));
  return r = i % 4 * 6, r === 0 ? (a.push(o >> 16 & 255), a.push(o >> 8 & 255), a.push(o & 255)) : r === 18 ? (a.push(o >> 10 & 255), a.push(o >> 2 & 255)) : r === 12 && a.push(o >> 4 & 255), rs ? rs.from ? rs.from(a) : new rs(a) : a;
}
function nL(t) {
  var e = "", r = 0, n, i, s = t.length, o = Fg;
  for (n = 0; n < s; n++)
    n % 3 === 0 && n && (e += o[r >> 18 & 63], e += o[r >> 12 & 63], e += o[r >> 6 & 63], e += o[r & 63]), r = (r << 8) + t[n];
  return i = s % 3, i === 0 ? (e += o[r >> 18 & 63], e += o[r >> 12 & 63], e += o[r >> 6 & 63], e += o[r & 63]) : i === 2 ? (e += o[r >> 10 & 63], e += o[r >> 4 & 63], e += o[r << 2 & 63], e += o[64]) : i === 1 && (e += o[r >> 2 & 63], e += o[r << 4 & 63], e += o[64], e += o[64]), e;
}
function iL(t) {
  return rs && rs.isBuffer(t);
}
var sL = new eL("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: tL,
  construct: rL,
  predicate: iL,
  represent: nL
}), oL = St, aL = Object.prototype.hasOwnProperty, lL = Object.prototype.toString;
function cL(t) {
  if (t === null)
    return !0;
  var e = [], r, n, i, s, o, a = t;
  for (r = 0, n = a.length; r < n; r += 1) {
    if (i = a[r], o = !1, lL.call(i) !== "[object Object]")
      return !1;
    for (s in i)
      if (aL.call(i, s))
        if (!o)
          o = !0;
        else
          return !1;
    if (!o)
      return !1;
    if (e.indexOf(s) === -1)
      e.push(s);
    else
      return !1;
  }
  return !0;
}
function uL(t) {
  return t !== null ? t : [];
}
var dL = new oL("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: cL,
  construct: uL
}), fL = St, hL = Object.prototype.toString;
function pL(t) {
  if (t === null)
    return !0;
  var e, r, n, i, s, o = t;
  for (s = new Array(o.length), e = 0, r = o.length; e < r; e += 1) {
    if (n = o[e], hL.call(n) !== "[object Object]" || (i = Object.keys(n), i.length !== 1))
      return !1;
    s[e] = [i[0], n[i[0]]];
  }
  return !0;
}
function mL(t) {
  if (t === null)
    return [];
  var e, r, n, i, s, o = t;
  for (s = new Array(o.length), e = 0, r = o.length; e < r; e += 1)
    n = o[e], i = Object.keys(n), s[e] = [i[0], n[i[0]]];
  return s;
}
var gL = new fL("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: pL,
  construct: mL
}), OL = St, yL = Object.prototype.hasOwnProperty;
function bL(t) {
  if (t === null)
    return !0;
  var e, r = t;
  for (e in r)
    if (yL.call(r, e) && r[e] !== null)
      return !1;
  return !0;
}
function vL(t) {
  return t !== null ? t : {};
}
var wL = new OL("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: bL,
  construct: vL
}), $L = Fo, ql = new $L({
  include: [
    xk
  ],
  implicit: [
    FV,
    KV
  ],
  explicit: [
    sL,
    dL,
    gL,
    wL
  ]
}), SL = St;
function kL() {
  return !0;
}
function _L() {
}
function PL() {
  return "";
}
function xL(t) {
  return typeof t > "u";
}
var TL = new SL("tag:yaml.org,2002:js/undefined", {
  kind: "scalar",
  resolve: kL,
  construct: _L,
  predicate: xL,
  represent: PL
}), CL = St;
function QL(t) {
  if (t === null || t.length === 0)
    return !1;
  var e = t, r = /\/([gim]*)$/.exec(t), n = "";
  return !(e[0] === "/" && (r && (n = r[1]), n.length > 3 || e[e.length - n.length - 1] !== "/"));
}
function AL(t) {
  var e = t, r = /\/([gim]*)$/.exec(t), n = "";
  return e[0] === "/" && (r && (n = r[1]), e = e.slice(1, e.length - n.length - 1)), new RegExp(e, n);
}
function EL(t) {
  var e = "/" + t.source + "/";
  return t.global && (e += "g"), t.multiline && (e += "m"), t.ignoreCase && (e += "i"), e;
}
function RL(t) {
  return Object.prototype.toString.call(t) === "[object RegExp]";
}
var IL = new CL("tag:yaml.org,2002:js/regexp", {
  kind: "scalar",
  resolve: QL,
  construct: AL,
  predicate: RL,
  represent: EL
}), Ru;
try {
  var jL = Qk;
  Ru = jL("esprima");
} catch {
  typeof window < "u" && (Ru = window.esprima);
}
var ZL = St;
function ML(t) {
  if (t === null)
    return !1;
  try {
    var e = "(" + t + ")", r = Ru.parse(e, { range: !0 });
    return !(r.type !== "Program" || r.body.length !== 1 || r.body[0].type !== "ExpressionStatement" || r.body[0].expression.type !== "ArrowFunctionExpression" && r.body[0].expression.type !== "FunctionExpression");
  } catch {
    return !1;
  }
}
function qL(t) {
  var e = "(" + t + ")", r = Ru.parse(e, { range: !0 }), n = [], i;
  if (r.type !== "Program" || r.body.length !== 1 || r.body[0].type !== "ExpressionStatement" || r.body[0].expression.type !== "ArrowFunctionExpression" && r.body[0].expression.type !== "FunctionExpression")
    throw new Error("Failed to resolve function");
  return r.body[0].expression.params.forEach(function(s) {
    n.push(s.name);
  }), i = r.body[0].expression.body.range, r.body[0].expression.body.type === "BlockStatement" ? new Function(n, e.slice(i[0] + 1, i[1] - 1)) : new Function(n, "return " + e.slice(i[0], i[1]));
}
function NL(t) {
  return t.toString();
}
function DL(t) {
  return Object.prototype.toString.call(t) === "[object Function]";
}
var zL = new ZL("tag:yaml.org,2002:js/function", {
  kind: "scalar",
  resolve: ML,
  construct: qL,
  predicate: DL,
  represent: NL
}), cb = Fo, xd = cb.DEFAULT = new cb({
  include: [
    ql
  ],
  explicit: [
    TL,
    IL,
    zL
  ]
}), An = Qr, Ak = Ml, XL = rV, Ek = ql, WL = xd, ki = Object.prototype.hasOwnProperty, Iu = 1, Rk = 2, Ik = 3, ju = 4, Vf = 1, UL = 2, ub = 3, VL = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, LL = /[\x85\u2028\u2029]/, YL = /[,\[\]\{\}]/, jk = /^(?:!|!!|![a-z\-]+!)$/i, Zk = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function db(t) {
  return Object.prototype.toString.call(t);
}
function On(t) {
  return t === 10 || t === 13;
}
function os(t) {
  return t === 9 || t === 32;
}
function sr(t) {
  return t === 9 || t === 32 || t === 10 || t === 13;
}
function Bs(t) {
  return t === 44 || t === 91 || t === 93 || t === 123 || t === 125;
}
function BL(t) {
  var e;
  return 48 <= t && t <= 57 ? t - 48 : (e = t | 32, 97 <= e && e <= 102 ? e - 97 + 10 : -1);
}
function FL(t) {
  return t === 120 ? 2 : t === 117 ? 4 : t === 85 ? 8 : 0;
}
function HL(t) {
  return 48 <= t && t <= 57 ? t - 48 : -1;
}
function fb(t) {
  return t === 48 ? "\0" : t === 97 ? "\x07" : t === 98 ? "\b" : t === 116 || t === 9 ? "	" : t === 110 ? `
` : t === 118 ? "\v" : t === 102 ? "\f" : t === 114 ? "\r" : t === 101 ? "\x1B" : t === 32 ? " " : t === 34 ? '"' : t === 47 ? "/" : t === 92 ? "\\" : t === 78 ? "Â…" : t === 95 ? "Â " : t === 76 ? "\u2028" : t === 80 ? "\u2029" : "";
}
function GL(t) {
  return t <= 65535 ? String.fromCharCode(t) : String.fromCharCode(
    (t - 65536 >> 10) + 55296,
    (t - 65536 & 1023) + 56320
  );
}
var Mk = new Array(256), qk = new Array(256);
for (var Zs = 0; Zs < 256; Zs++)
  Mk[Zs] = fb(Zs) ? 1 : 0, qk[Zs] = fb(Zs);
function KL(t, e) {
  this.input = t, this.filename = e.filename || null, this.schema = e.schema || WL, this.onWarning = e.onWarning || null, this.legacy = e.legacy || !1, this.json = e.json || !1, this.listener = e.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = t.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.documents = [];
}
function Nk(t, e) {
  return new Ak(
    e,
    new XL(t.filename, t.input, t.position, t.line, t.position - t.lineStart)
  );
}
function we(t, e) {
  throw Nk(t, e);
}
function Zu(t, e) {
  t.onWarning && t.onWarning.call(null, Nk(t, e));
}
var hb = {
  YAML: function(e, r, n) {
    var i, s, o;
    e.version !== null && we(e, "duplication of %YAML directive"), n.length !== 1 && we(e, "YAML directive accepts exactly one argument"), i = /^([0-9]+)\.([0-9]+)$/.exec(n[0]), i === null && we(e, "ill-formed argument of the YAML directive"), s = parseInt(i[1], 10), o = parseInt(i[2], 10), s !== 1 && we(e, "unacceptable YAML version of the document"), e.version = n[0], e.checkLineBreaks = o < 2, o !== 1 && o !== 2 && Zu(e, "unsupported YAML version of the document");
  },
  TAG: function(e, r, n) {
    var i, s;
    n.length !== 2 && we(e, "TAG directive accepts exactly two arguments"), i = n[0], s = n[1], jk.test(i) || we(e, "ill-formed tag handle (first argument) of the TAG directive"), ki.call(e.tagMap, i) && we(e, 'there is a previously declared suffix for "' + i + '" tag handle'), Zk.test(s) || we(e, "ill-formed tag prefix (second argument) of the TAG directive"), e.tagMap[i] = s;
  }
};
function gi(t, e, r, n) {
  var i, s, o, a;
  if (e < r) {
    if (a = t.input.slice(e, r), n)
      for (i = 0, s = a.length; i < s; i += 1)
        o = a.charCodeAt(i), o === 9 || 32 <= o && o <= 1114111 || we(t, "expected valid JSON character");
    else
      VL.test(a) && we(t, "the stream contains non-printable characters");
    t.result += a;
  }
}
function pb(t, e, r, n) {
  var i, s, o, a;
  for (An.isObject(r) || we(t, "cannot merge mappings; the provided source object is unacceptable"), i = Object.keys(r), o = 0, a = i.length; o < a; o += 1)
    s = i[o], ki.call(e, s) || (e[s] = r[s], n[s] = !0);
}
function Fs(t, e, r, n, i, s, o, a) {
  var l, c;
  if (Array.isArray(i))
    for (i = Array.prototype.slice.call(i), l = 0, c = i.length; l < c; l += 1)
      Array.isArray(i[l]) && we(t, "nested arrays are not supported inside keys"), typeof i == "object" && db(i[l]) === "[object Object]" && (i[l] = "[object Object]");
  if (typeof i == "object" && db(i) === "[object Object]" && (i = "[object Object]"), i = String(i), e === null && (e = {}), n === "tag:yaml.org,2002:merge")
    if (Array.isArray(s))
      for (l = 0, c = s.length; l < c; l += 1)
        pb(t, e, s[l], r);
    else
      pb(t, e, s, r);
  else
    !t.json && !ki.call(r, i) && ki.call(e, i) && (t.line = o || t.line, t.position = a || t.position, we(t, "duplicated mapping key")), e[i] = s, delete r[i];
  return e;
}
function Hg(t) {
  var e;
  e = t.input.charCodeAt(t.position), e === 10 ? t.position++ : e === 13 ? (t.position++, t.input.charCodeAt(t.position) === 10 && t.position++) : we(t, "a line break is expected"), t.line += 1, t.lineStart = t.position;
}
function pt(t, e, r) {
  for (var n = 0, i = t.input.charCodeAt(t.position); i !== 0; ) {
    for (; os(i); )
      i = t.input.charCodeAt(++t.position);
    if (e && i === 35)
      do
        i = t.input.charCodeAt(++t.position);
      while (i !== 10 && i !== 13 && i !== 0);
    if (On(i))
      for (Hg(t), i = t.input.charCodeAt(t.position), n++, t.lineIndent = 0; i === 32; )
        t.lineIndent++, i = t.input.charCodeAt(++t.position);
    else
      break;
  }
  return r !== -1 && n !== 0 && t.lineIndent < r && Zu(t, "deficient indentation"), n;
}
function Td(t) {
  var e = t.position, r;
  return r = t.input.charCodeAt(e), !!((r === 45 || r === 46) && r === t.input.charCodeAt(e + 1) && r === t.input.charCodeAt(e + 2) && (e += 3, r = t.input.charCodeAt(e), r === 0 || sr(r)));
}
function Gg(t, e) {
  e === 1 ? t.result += " " : e > 1 && (t.result += An.repeat(`
`, e - 1));
}
function JL(t, e, r) {
  var n, i, s, o, a, l, c, u, d = t.kind, f = t.result, h;
  if (h = t.input.charCodeAt(t.position), sr(h) || Bs(h) || h === 35 || h === 38 || h === 42 || h === 33 || h === 124 || h === 62 || h === 39 || h === 34 || h === 37 || h === 64 || h === 96 || (h === 63 || h === 45) && (i = t.input.charCodeAt(t.position + 1), sr(i) || r && Bs(i)))
    return !1;
  for (t.kind = "scalar", t.result = "", s = o = t.position, a = !1; h !== 0; ) {
    if (h === 58) {
      if (i = t.input.charCodeAt(t.position + 1), sr(i) || r && Bs(i))
        break;
    } else if (h === 35) {
      if (n = t.input.charCodeAt(t.position - 1), sr(n))
        break;
    } else {
      if (t.position === t.lineStart && Td(t) || r && Bs(h))
        break;
      if (On(h))
        if (l = t.line, c = t.lineStart, u = t.lineIndent, pt(t, !1, -1), t.lineIndent >= e) {
          a = !0, h = t.input.charCodeAt(t.position);
          continue;
        } else {
          t.position = o, t.line = l, t.lineStart = c, t.lineIndent = u;
          break;
        }
    }
    a && (gi(t, s, o, !1), Gg(t, t.line - l), s = o = t.position, a = !1), os(h) || (o = t.position + 1), h = t.input.charCodeAt(++t.position);
  }
  return gi(t, s, o, !1), t.result ? !0 : (t.kind = d, t.result = f, !1);
}
function eY(t, e) {
  var r, n, i;
  if (r = t.input.charCodeAt(t.position), r !== 39)
    return !1;
  for (t.kind = "scalar", t.result = "", t.position++, n = i = t.position; (r = t.input.charCodeAt(t.position)) !== 0; )
    if (r === 39)
      if (gi(t, n, t.position, !0), r = t.input.charCodeAt(++t.position), r === 39)
        n = t.position, t.position++, i = t.position;
      else
        return !0;
    else
      On(r) ? (gi(t, n, i, !0), Gg(t, pt(t, !1, e)), n = i = t.position) : t.position === t.lineStart && Td(t) ? we(t, "unexpected end of the document within a single quoted scalar") : (t.position++, i = t.position);
  we(t, "unexpected end of the stream within a single quoted scalar");
}
function tY(t, e) {
  var r, n, i, s, o, a;
  if (a = t.input.charCodeAt(t.position), a !== 34)
    return !1;
  for (t.kind = "scalar", t.result = "", t.position++, r = n = t.position; (a = t.input.charCodeAt(t.position)) !== 0; ) {
    if (a === 34)
      return gi(t, r, t.position, !0), t.position++, !0;
    if (a === 92) {
      if (gi(t, r, t.position, !0), a = t.input.charCodeAt(++t.position), On(a))
        pt(t, !1, e);
      else if (a < 256 && Mk[a])
        t.result += qk[a], t.position++;
      else if ((o = FL(a)) > 0) {
        for (i = o, s = 0; i > 0; i--)
          a = t.input.charCodeAt(++t.position), (o = BL(a)) >= 0 ? s = (s << 4) + o : we(t, "expected hexadecimal character");
        t.result += GL(s), t.position++;
      } else
        we(t, "unknown escape sequence");
      r = n = t.position;
    } else
      On(a) ? (gi(t, r, n, !0), Gg(t, pt(t, !1, e)), r = n = t.position) : t.position === t.lineStart && Td(t) ? we(t, "unexpected end of the document within a double quoted scalar") : (t.position++, n = t.position);
  }
  we(t, "unexpected end of the stream within a double quoted scalar");
}
function rY(t, e) {
  var r = !0, n, i = t.tag, s, o = t.anchor, a, l, c, u, d, f = {}, h, p, g, m;
  if (m = t.input.charCodeAt(t.position), m === 91)
    l = 93, d = !1, s = [];
  else if (m === 123)
    l = 125, d = !0, s = {};
  else
    return !1;
  for (t.anchor !== null && (t.anchorMap[t.anchor] = s), m = t.input.charCodeAt(++t.position); m !== 0; ) {
    if (pt(t, !0, e), m = t.input.charCodeAt(t.position), m === l)
      return t.position++, t.tag = i, t.anchor = o, t.kind = d ? "mapping" : "sequence", t.result = s, !0;
    r || we(t, "missed comma between flow collection entries"), p = h = g = null, c = u = !1, m === 63 && (a = t.input.charCodeAt(t.position + 1), sr(a) && (c = u = !0, t.position++, pt(t, !0, e))), n = t.line, To(t, e, Iu, !1, !0), p = t.tag, h = t.result, pt(t, !0, e), m = t.input.charCodeAt(t.position), (u || t.line === n) && m === 58 && (c = !0, m = t.input.charCodeAt(++t.position), pt(t, !0, e), To(t, e, Iu, !1, !0), g = t.result), d ? Fs(t, s, f, p, h, g) : c ? s.push(Fs(t, null, f, p, h, g)) : s.push(h), pt(t, !0, e), m = t.input.charCodeAt(t.position), m === 44 ? (r = !0, m = t.input.charCodeAt(++t.position)) : r = !1;
  }
  we(t, "unexpected end of the stream within a flow collection");
}
function nY(t, e) {
  var r, n, i = Vf, s = !1, o = !1, a = e, l = 0, c = !1, u, d;
  if (d = t.input.charCodeAt(t.position), d === 124)
    n = !1;
  else if (d === 62)
    n = !0;
  else
    return !1;
  for (t.kind = "scalar", t.result = ""; d !== 0; )
    if (d = t.input.charCodeAt(++t.position), d === 43 || d === 45)
      Vf === i ? i = d === 43 ? ub : UL : we(t, "repeat of a chomping mode identifier");
    else if ((u = HL(d)) >= 0)
      u === 0 ? we(t, "bad explicit indentation width of a block scalar; it cannot be less than one") : o ? we(t, "repeat of an indentation width identifier") : (a = e + u - 1, o = !0);
    else
      break;
  if (os(d)) {
    do
      d = t.input.charCodeAt(++t.position);
    while (os(d));
    if (d === 35)
      do
        d = t.input.charCodeAt(++t.position);
      while (!On(d) && d !== 0);
  }
  for (; d !== 0; ) {
    for (Hg(t), t.lineIndent = 0, d = t.input.charCodeAt(t.position); (!o || t.lineIndent < a) && d === 32; )
      t.lineIndent++, d = t.input.charCodeAt(++t.position);
    if (!o && t.lineIndent > a && (a = t.lineIndent), On(d)) {
      l++;
      continue;
    }
    if (t.lineIndent < a) {
      i === ub ? t.result += An.repeat(`
`, s ? 1 + l : l) : i === Vf && s && (t.result += `
`);
      break;
    }
    for (n ? os(d) ? (c = !0, t.result += An.repeat(`
`, s ? 1 + l : l)) : c ? (c = !1, t.result += An.repeat(`
`, l + 1)) : l === 0 ? s && (t.result += " ") : t.result += An.repeat(`
`, l) : t.result += An.repeat(`
`, s ? 1 + l : l), s = !0, o = !0, l = 0, r = t.position; !On(d) && d !== 0; )
      d = t.input.charCodeAt(++t.position);
    gi(t, r, t.position, !1);
  }
  return !0;
}
function mb(t, e) {
  var r, n = t.tag, i = t.anchor, s = [], o, a = !1, l;
  for (t.anchor !== null && (t.anchorMap[t.anchor] = s), l = t.input.charCodeAt(t.position); l !== 0 && !(l !== 45 || (o = t.input.charCodeAt(t.position + 1), !sr(o))); ) {
    if (a = !0, t.position++, pt(t, !0, -1) && t.lineIndent <= e) {
      s.push(null), l = t.input.charCodeAt(t.position);
      continue;
    }
    if (r = t.line, To(t, e, Ik, !1, !0), s.push(t.result), pt(t, !0, -1), l = t.input.charCodeAt(t.position), (t.line === r || t.lineIndent > e) && l !== 0)
      we(t, "bad indentation of a sequence entry");
    else if (t.lineIndent < e)
      break;
  }
  return a ? (t.tag = n, t.anchor = i, t.kind = "sequence", t.result = s, !0) : !1;
}
function iY(t, e, r) {
  var n, i, s, o, a = t.tag, l = t.anchor, c = {}, u = {}, d = null, f = null, h = null, p = !1, g = !1, m;
  for (t.anchor !== null && (t.anchorMap[t.anchor] = c), m = t.input.charCodeAt(t.position); m !== 0; ) {
    if (n = t.input.charCodeAt(t.position + 1), s = t.line, o = t.position, (m === 63 || m === 58) && sr(n))
      m === 63 ? (p && (Fs(t, c, u, d, f, null), d = f = h = null), g = !0, p = !0, i = !0) : p ? (p = !1, i = !0) : we(t, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), t.position += 1, m = n;
    else if (To(t, r, Rk, !1, !0))
      if (t.line === s) {
        for (m = t.input.charCodeAt(t.position); os(m); )
          m = t.input.charCodeAt(++t.position);
        if (m === 58)
          m = t.input.charCodeAt(++t.position), sr(m) || we(t, "a whitespace character is expected after the key-value separator within a block mapping"), p && (Fs(t, c, u, d, f, null), d = f = h = null), g = !0, p = !1, i = !1, d = t.tag, f = t.result;
        else if (g)
          we(t, "can not read an implicit mapping pair; a colon is missed");
        else
          return t.tag = a, t.anchor = l, !0;
      } else if (g)
        we(t, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else
        return t.tag = a, t.anchor = l, !0;
    else
      break;
    if ((t.line === s || t.lineIndent > e) && (To(t, e, ju, !0, i) && (p ? f = t.result : h = t.result), p || (Fs(t, c, u, d, f, h, s, o), d = f = h = null), pt(t, !0, -1), m = t.input.charCodeAt(t.position)), t.lineIndent > e && m !== 0)
      we(t, "bad indentation of a mapping entry");
    else if (t.lineIndent < e)
      break;
  }
  return p && Fs(t, c, u, d, f, null), g && (t.tag = a, t.anchor = l, t.kind = "mapping", t.result = c), g;
}
function sY(t) {
  var e, r = !1, n = !1, i, s, o;
  if (o = t.input.charCodeAt(t.position), o !== 33)
    return !1;
  if (t.tag !== null && we(t, "duplication of a tag property"), o = t.input.charCodeAt(++t.position), o === 60 ? (r = !0, o = t.input.charCodeAt(++t.position)) : o === 33 ? (n = !0, i = "!!", o = t.input.charCodeAt(++t.position)) : i = "!", e = t.position, r) {
    do
      o = t.input.charCodeAt(++t.position);
    while (o !== 0 && o !== 62);
    t.position < t.length ? (s = t.input.slice(e, t.position), o = t.input.charCodeAt(++t.position)) : we(t, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; o !== 0 && !sr(o); )
      o === 33 && (n ? we(t, "tag suffix cannot contain exclamation marks") : (i = t.input.slice(e - 1, t.position + 1), jk.test(i) || we(t, "named tag handle cannot contain such characters"), n = !0, e = t.position + 1)), o = t.input.charCodeAt(++t.position);
    s = t.input.slice(e, t.position), YL.test(s) && we(t, "tag suffix cannot contain flow indicator characters");
  }
  return s && !Zk.test(s) && we(t, "tag name cannot contain such characters: " + s), r ? t.tag = s : ki.call(t.tagMap, i) ? t.tag = t.tagMap[i] + s : i === "!" ? t.tag = "!" + s : i === "!!" ? t.tag = "tag:yaml.org,2002:" + s : we(t, 'undeclared tag handle "' + i + '"'), !0;
}
function oY(t) {
  var e, r;
  if (r = t.input.charCodeAt(t.position), r !== 38)
    return !1;
  for (t.anchor !== null && we(t, "duplication of an anchor property"), r = t.input.charCodeAt(++t.position), e = t.position; r !== 0 && !sr(r) && !Bs(r); )
    r = t.input.charCodeAt(++t.position);
  return t.position === e && we(t, "name of an anchor node must contain at least one character"), t.anchor = t.input.slice(e, t.position), !0;
}
function aY(t) {
  var e, r, n;
  if (n = t.input.charCodeAt(t.position), n !== 42)
    return !1;
  for (n = t.input.charCodeAt(++t.position), e = t.position; n !== 0 && !sr(n) && !Bs(n); )
    n = t.input.charCodeAt(++t.position);
  return t.position === e && we(t, "name of an alias node must contain at least one character"), r = t.input.slice(e, t.position), ki.call(t.anchorMap, r) || we(t, 'unidentified alias "' + r + '"'), t.result = t.anchorMap[r], pt(t, !0, -1), !0;
}
function To(t, e, r, n, i) {
  var s, o, a, l = 1, c = !1, u = !1, d, f, h, p, g;
  if (t.listener !== null && t.listener("open", t), t.tag = null, t.anchor = null, t.kind = null, t.result = null, s = o = a = ju === r || Ik === r, n && pt(t, !0, -1) && (c = !0, t.lineIndent > e ? l = 1 : t.lineIndent === e ? l = 0 : t.lineIndent < e && (l = -1)), l === 1)
    for (; sY(t) || oY(t); )
      pt(t, !0, -1) ? (c = !0, a = s, t.lineIndent > e ? l = 1 : t.lineIndent === e ? l = 0 : t.lineIndent < e && (l = -1)) : a = !1;
  if (a && (a = c || i), (l === 1 || ju === r) && (Iu === r || Rk === r ? p = e : p = e + 1, g = t.position - t.lineStart, l === 1 ? a && (mb(t, g) || iY(t, g, p)) || rY(t, p) ? u = !0 : (o && nY(t, p) || eY(t, p) || tY(t, p) ? u = !0 : aY(t) ? (u = !0, (t.tag !== null || t.anchor !== null) && we(t, "alias node should not have any properties")) : JL(t, p, Iu === r) && (u = !0, t.tag === null && (t.tag = "?")), t.anchor !== null && (t.anchorMap[t.anchor] = t.result)) : l === 0 && (u = a && mb(t, g))), t.tag !== null && t.tag !== "!")
    if (t.tag === "?") {
      for (t.result !== null && t.kind !== "scalar" && we(t, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + t.kind + '"'), d = 0, f = t.implicitTypes.length; d < f; d += 1)
        if (h = t.implicitTypes[d], h.resolve(t.result)) {
          t.result = h.construct(t.result), t.tag = h.tag, t.anchor !== null && (t.anchorMap[t.anchor] = t.result);
          break;
        }
    } else
      ki.call(t.typeMap[t.kind || "fallback"], t.tag) ? (h = t.typeMap[t.kind || "fallback"][t.tag], t.result !== null && h.kind !== t.kind && we(t, "unacceptable node kind for !<" + t.tag + '> tag; it should be "' + h.kind + '", not "' + t.kind + '"'), h.resolve(t.result) ? (t.result = h.construct(t.result), t.anchor !== null && (t.anchorMap[t.anchor] = t.result)) : we(t, "cannot resolve a node with !<" + t.tag + "> explicit tag")) : we(t, "unknown tag !<" + t.tag + ">");
  return t.listener !== null && t.listener("close", t), t.tag !== null || t.anchor !== null || u;
}
function lY(t) {
  var e = t.position, r, n, i, s = !1, o;
  for (t.version = null, t.checkLineBreaks = t.legacy, t.tagMap = {}, t.anchorMap = {}; (o = t.input.charCodeAt(t.position)) !== 0 && (pt(t, !0, -1), o = t.input.charCodeAt(t.position), !(t.lineIndent > 0 || o !== 37)); ) {
    for (s = !0, o = t.input.charCodeAt(++t.position), r = t.position; o !== 0 && !sr(o); )
      o = t.input.charCodeAt(++t.position);
    for (n = t.input.slice(r, t.position), i = [], n.length < 1 && we(t, "directive name must not be less than one character in length"); o !== 0; ) {
      for (; os(o); )
        o = t.input.charCodeAt(++t.position);
      if (o === 35) {
        do
          o = t.input.charCodeAt(++t.position);
        while (o !== 0 && !On(o));
        break;
      }
      if (On(o))
        break;
      for (r = t.position; o !== 0 && !sr(o); )
        o = t.input.charCodeAt(++t.position);
      i.push(t.input.slice(r, t.position));
    }
    o !== 0 && Hg(t), ki.call(hb, n) ? hb[n](t, n, i) : Zu(t, 'unknown document directive "' + n + '"');
  }
  if (pt(t, !0, -1), t.lineIndent === 0 && t.input.charCodeAt(t.position) === 45 && t.input.charCodeAt(t.position + 1) === 45 && t.input.charCodeAt(t.position + 2) === 45 ? (t.position += 3, pt(t, !0, -1)) : s && we(t, "directives end mark is expected"), To(t, t.lineIndent - 1, ju, !1, !0), pt(t, !0, -1), t.checkLineBreaks && LL.test(t.input.slice(e, t.position)) && Zu(t, "non-ASCII line breaks are interpreted as content"), t.documents.push(t.result), t.position === t.lineStart && Td(t)) {
    t.input.charCodeAt(t.position) === 46 && (t.position += 3, pt(t, !0, -1));
    return;
  }
  if (t.position < t.length - 1)
    we(t, "end of the stream or a document separator is expected");
  else
    return;
}
function Dk(t, e) {
  t = String(t), e = e || {}, t.length !== 0 && (t.charCodeAt(t.length - 1) !== 10 && t.charCodeAt(t.length - 1) !== 13 && (t += `
`), t.charCodeAt(0) === 65279 && (t = t.slice(1)));
  var r = new KL(t, e), n = t.indexOf("\0");
  for (n !== -1 && (r.position = n, we(r, "null byte is not allowed in input")), r.input += "\0"; r.input.charCodeAt(r.position) === 32; )
    r.lineIndent += 1, r.position += 1;
  for (; r.position < r.length - 1; )
    lY(r);
  return r.documents;
}
function zk(t, e, r) {
  e !== null && typeof e == "object" && typeof r > "u" && (r = e, e = null);
  var n = Dk(t, r);
  if (typeof e != "function")
    return n;
  for (var i = 0, s = n.length; i < s; i += 1)
    e(n[i]);
}
function Xk(t, e) {
  var r = Dk(t, e);
  if (r.length !== 0) {
    if (r.length === 1)
      return r[0];
    throw new Ak("expected a single document in the stream, but found more");
  }
}
function cY(t, e, r) {
  return typeof e == "object" && e !== null && typeof r > "u" && (r = e, e = null), zk(t, e, An.extend({ schema: Ek }, r));
}
function uY(t, e) {
  return Xk(t, An.extend({ schema: Ek }, e));
}
Zl.loadAll = zk;
Zl.load = Xk;
Zl.safeLoadAll = cY;
Zl.safeLoad = uY;
var Kg = {}, Nl = Qr, Dl = Ml, dY = xd, fY = ql, Wk = Object.prototype.toString, Uk = Object.prototype.hasOwnProperty, hY = 9, ul = 10, pY = 13, mY = 32, gY = 33, OY = 34, Vk = 35, yY = 37, bY = 38, vY = 39, wY = 42, Lk = 44, $Y = 45, Yk = 58, SY = 61, kY = 62, _Y = 63, PY = 64, Bk = 91, Fk = 93, xY = 96, Hk = 123, TY = 124, Gk = 125, Ut = {};
Ut[0] = "\\0";
Ut[7] = "\\a";
Ut[8] = "\\b";
Ut[9] = "\\t";
Ut[10] = "\\n";
Ut[11] = "\\v";
Ut[12] = "\\f";
Ut[13] = "\\r";
Ut[27] = "\\e";
Ut[34] = '\\"';
Ut[92] = "\\\\";
Ut[133] = "\\N";
Ut[160] = "\\_";
Ut[8232] = "\\L";
Ut[8233] = "\\P";
var CY = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
function QY(t, e) {
  var r, n, i, s, o, a, l;
  if (e === null)
    return {};
  for (r = {}, n = Object.keys(e), i = 0, s = n.length; i < s; i += 1)
    o = n[i], a = String(e[o]), o.slice(0, 2) === "!!" && (o = "tag:yaml.org,2002:" + o.slice(2)), l = t.compiledTypeMap.fallback[o], l && Uk.call(l.styleAliases, a) && (a = l.styleAliases[a]), r[o] = a;
  return r;
}
function gb(t) {
  var e, r, n;
  if (e = t.toString(16).toUpperCase(), t <= 255)
    r = "x", n = 2;
  else if (t <= 65535)
    r = "u", n = 4;
  else if (t <= 4294967295)
    r = "U", n = 8;
  else
    throw new Dl("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + r + Nl.repeat("0", n - e.length) + e;
}
function AY(t) {
  this.schema = t.schema || dY, this.indent = Math.max(1, t.indent || 2), this.noArrayIndent = t.noArrayIndent || !1, this.skipInvalid = t.skipInvalid || !1, this.flowLevel = Nl.isNothing(t.flowLevel) ? -1 : t.flowLevel, this.styleMap = QY(this.schema, t.styles || null), this.sortKeys = t.sortKeys || !1, this.lineWidth = t.lineWidth || 80, this.noRefs = t.noRefs || !1, this.noCompatMode = t.noCompatMode || !1, this.condenseFlow = t.condenseFlow || !1, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
}
function Ob(t, e) {
  for (var r = Nl.repeat(" ", e), n = 0, i = -1, s = "", o, a = t.length; n < a; )
    i = t.indexOf(`
`, n), i === -1 ? (o = t.slice(n), n = a) : (o = t.slice(n, i + 1), n = i + 1), o.length && o !== `
` && (s += r), s += o;
  return s;
}
function Zp(t, e) {
  return `
` + Nl.repeat(" ", t.indent * e);
}
function EY(t, e) {
  var r, n, i;
  for (r = 0, n = t.implicitTypes.length; r < n; r += 1)
    if (i = t.implicitTypes[r], i.resolve(e))
      return !0;
  return !1;
}
function Jg(t) {
  return t === mY || t === hY;
}
function Co(t) {
  return 32 <= t && t <= 126 || 161 <= t && t <= 55295 && t !== 8232 && t !== 8233 || 57344 <= t && t <= 65533 && t !== 65279 || 65536 <= t && t <= 1114111;
}
function RY(t) {
  return Co(t) && !Jg(t) && t !== 65279 && t !== pY && t !== ul;
}
function yb(t, e) {
  return Co(t) && t !== 65279 && t !== Lk && t !== Bk && t !== Fk && t !== Hk && t !== Gk && t !== Yk && (t !== Vk || e && RY(e));
}
function IY(t) {
  return Co(t) && t !== 65279 && !Jg(t) && t !== $Y && t !== _Y && t !== Yk && t !== Lk && t !== Bk && t !== Fk && t !== Hk && t !== Gk && t !== Vk && t !== bY && t !== wY && t !== gY && t !== TY && t !== SY && t !== kY && t !== vY && t !== OY && t !== yY && t !== PY && t !== xY;
}
function Kk(t) {
  var e = /^\n* /;
  return e.test(t);
}
var Jk = 1, e5 = 2, t5 = 3, r5 = 4, Fc = 5;
function jY(t, e, r, n, i) {
  var s, o, a, l = !1, c = !1, u = n !== -1, d = -1, f = IY(t.charCodeAt(0)) && !Jg(t.charCodeAt(t.length - 1));
  if (e)
    for (s = 0; s < t.length; s++) {
      if (o = t.charCodeAt(s), !Co(o))
        return Fc;
      a = s > 0 ? t.charCodeAt(s - 1) : null, f = f && yb(o, a);
    }
  else {
    for (s = 0; s < t.length; s++) {
      if (o = t.charCodeAt(s), o === ul)
        l = !0, u && (c = c || // Foldable line = too long, and not more-indented.
        s - d - 1 > n && t[d + 1] !== " ", d = s);
      else if (!Co(o))
        return Fc;
      a = s > 0 ? t.charCodeAt(s - 1) : null, f = f && yb(o, a);
    }
    c = c || u && s - d - 1 > n && t[d + 1] !== " ";
  }
  return !l && !c ? f && !i(t) ? Jk : e5 : r > 9 && Kk(t) ? Fc : c ? r5 : t5;
}
function ZY(t, e, r, n) {
  t.dump = function() {
    if (e.length === 0)
      return "''";
    if (!t.noCompatMode && CY.indexOf(e) !== -1)
      return "'" + e + "'";
    var i = t.indent * Math.max(1, r), s = t.lineWidth === -1 ? -1 : Math.max(Math.min(t.lineWidth, 40), t.lineWidth - i), o = n || t.flowLevel > -1 && r >= t.flowLevel;
    function a(l) {
      return EY(t, l);
    }
    switch (jY(e, o, t.indent, s, a)) {
      case Jk:
        return e;
      case e5:
        return "'" + e.replace(/'/g, "''") + "'";
      case t5:
        return "|" + bb(e, t.indent) + vb(Ob(e, i));
      case r5:
        return ">" + bb(e, t.indent) + vb(Ob(MY(e, s), i));
      case Fc:
        return '"' + qY(e) + '"';
      default:
        throw new Dl("impossible error: invalid scalar style");
    }
  }();
}
function bb(t, e) {
  var r = Kk(t) ? String(e) : "", n = t[t.length - 1] === `
`, i = n && (t[t.length - 2] === `
` || t === `
`), s = i ? "+" : n ? "" : "-";
  return r + s + `
`;
}
function vb(t) {
  return t[t.length - 1] === `
` ? t.slice(0, -1) : t;
}
function MY(t, e) {
  for (var r = /(\n+)([^\n]*)/g, n = function() {
    var c = t.indexOf(`
`);
    return c = c !== -1 ? c : t.length, r.lastIndex = c, wb(t.slice(0, c), e);
  }(), i = t[0] === `
` || t[0] === " ", s, o; o = r.exec(t); ) {
    var a = o[1], l = o[2];
    s = l[0] === " ", n += a + (!i && !s && l !== "" ? `
` : "") + wb(l, e), i = s;
  }
  return n;
}
function wb(t, e) {
  if (t === "" || t[0] === " ")
    return t;
  for (var r = / [^ ]/g, n, i = 0, s, o = 0, a = 0, l = ""; n = r.exec(t); )
    a = n.index, a - i > e && (s = o > i ? o : a, l += `
` + t.slice(i, s), i = s + 1), o = a;
  return l += `
`, t.length - i > e && o > i ? l += t.slice(i, o) + `
` + t.slice(o + 1) : l += t.slice(i), l.slice(1);
}
function qY(t) {
  for (var e = "", r, n, i, s = 0; s < t.length; s++) {
    if (r = t.charCodeAt(s), r >= 55296 && r <= 56319 && (n = t.charCodeAt(s + 1), n >= 56320 && n <= 57343)) {
      e += gb((r - 55296) * 1024 + n - 56320 + 65536), s++;
      continue;
    }
    i = Ut[r], e += !i && Co(r) ? t[s] : i || gb(r);
  }
  return e;
}
function NY(t, e, r) {
  var n = "", i = t.tag, s, o;
  for (s = 0, o = r.length; s < o; s += 1)
    ms(t, e, r[s], !1, !1) && (s !== 0 && (n += "," + (t.condenseFlow ? "" : " ")), n += t.dump);
  t.tag = i, t.dump = "[" + n + "]";
}
function DY(t, e, r, n) {
  var i = "", s = t.tag, o, a;
  for (o = 0, a = r.length; o < a; o += 1)
    ms(t, e + 1, r[o], !0, !0) && ((!n || o !== 0) && (i += Zp(t, e)), t.dump && ul === t.dump.charCodeAt(0) ? i += "-" : i += "- ", i += t.dump);
  t.tag = s, t.dump = i || "[]";
}
function zY(t, e, r) {
  var n = "", i = t.tag, s = Object.keys(r), o, a, l, c, u;
  for (o = 0, a = s.length; o < a; o += 1)
    u = "", o !== 0 && (u += ", "), t.condenseFlow && (u += '"'), l = s[o], c = r[l], ms(t, e, l, !1, !1) && (t.dump.length > 1024 && (u += "? "), u += t.dump + (t.condenseFlow ? '"' : "") + ":" + (t.condenseFlow ? "" : " "), ms(t, e, c, !1, !1) && (u += t.dump, n += u));
  t.tag = i, t.dump = "{" + n + "}";
}
function XY(t, e, r, n) {
  var i = "", s = t.tag, o = Object.keys(r), a, l, c, u, d, f;
  if (t.sortKeys === !0)
    o.sort();
  else if (typeof t.sortKeys == "function")
    o.sort(t.sortKeys);
  else if (t.sortKeys)
    throw new Dl("sortKeys must be a boolean or a function");
  for (a = 0, l = o.length; a < l; a += 1)
    f = "", (!n || a !== 0) && (f += Zp(t, e)), c = o[a], u = r[c], ms(t, e + 1, c, !0, !0, !0) && (d = t.tag !== null && t.tag !== "?" || t.dump && t.dump.length > 1024, d && (t.dump && ul === t.dump.charCodeAt(0) ? f += "?" : f += "? "), f += t.dump, d && (f += Zp(t, e)), ms(t, e + 1, u, !0, d) && (t.dump && ul === t.dump.charCodeAt(0) ? f += ":" : f += ": ", f += t.dump, i += f));
  t.tag = s, t.dump = i || "{}";
}
function $b(t, e, r) {
  var n, i, s, o, a, l;
  for (i = r ? t.explicitTypes : t.implicitTypes, s = 0, o = i.length; s < o; s += 1)
    if (a = i[s], (a.instanceOf || a.predicate) && (!a.instanceOf || typeof e == "object" && e instanceof a.instanceOf) && (!a.predicate || a.predicate(e))) {
      if (t.tag = r ? a.tag : "?", a.represent) {
        if (l = t.styleMap[a.tag] || a.defaultStyle, Wk.call(a.represent) === "[object Function]")
          n = a.represent(e, l);
        else if (Uk.call(a.represent, l))
          n = a.represent[l](e, l);
        else
          throw new Dl("!<" + a.tag + '> tag resolver accepts not "' + l + '" style');
        t.dump = n;
      }
      return !0;
    }
  return !1;
}
function ms(t, e, r, n, i, s) {
  t.tag = null, t.dump = r, $b(t, r, !1) || $b(t, r, !0);
  var o = Wk.call(t.dump);
  n && (n = t.flowLevel < 0 || t.flowLevel > e);
  var a = o === "[object Object]" || o === "[object Array]", l, c;
  if (a && (l = t.duplicates.indexOf(r), c = l !== -1), (t.tag !== null && t.tag !== "?" || c || t.indent !== 2 && e > 0) && (i = !1), c && t.usedDuplicates[l])
    t.dump = "*ref_" + l;
  else {
    if (a && c && !t.usedDuplicates[l] && (t.usedDuplicates[l] = !0), o === "[object Object]")
      n && Object.keys(t.dump).length !== 0 ? (XY(t, e, t.dump, i), c && (t.dump = "&ref_" + l + t.dump)) : (zY(t, e, t.dump), c && (t.dump = "&ref_" + l + " " + t.dump));
    else if (o === "[object Array]") {
      var u = t.noArrayIndent && e > 0 ? e - 1 : e;
      n && t.dump.length !== 0 ? (DY(t, u, t.dump, i), c && (t.dump = "&ref_" + l + t.dump)) : (NY(t, u, t.dump), c && (t.dump = "&ref_" + l + " " + t.dump));
    } else if (o === "[object String]")
      t.tag !== "?" && ZY(t, t.dump, e, s);
    else {
      if (t.skipInvalid)
        return !1;
      throw new Dl("unacceptable kind of an object to dump " + o);
    }
    t.tag !== null && t.tag !== "?" && (t.dump = "!<" + t.tag + "> " + t.dump);
  }
  return !0;
}
function WY(t, e) {
  var r = [], n = [], i, s;
  for (Mp(t, r, n), i = 0, s = n.length; i < s; i += 1)
    e.duplicates.push(r[n[i]]);
  e.usedDuplicates = new Array(s);
}
function Mp(t, e, r) {
  var n, i, s;
  if (t !== null && typeof t == "object")
    if (i = e.indexOf(t), i !== -1)
      r.indexOf(i) === -1 && r.push(i);
    else if (e.push(t), Array.isArray(t))
      for (i = 0, s = t.length; i < s; i += 1)
        Mp(t[i], e, r);
    else
      for (n = Object.keys(t), i = 0, s = n.length; i < s; i += 1)
        Mp(t[n[i]], e, r);
}
function n5(t, e) {
  e = e || {};
  var r = new AY(e);
  return r.noRefs || WY(t, r), ms(r, 0, t, !0, !0) ? r.dump + `
` : "";
}
function UY(t, e) {
  return n5(t, Nl.extend({ schema: fY }, e));
}
Kg.dump = n5;
Kg.safeDump = UY;
var Cd = Zl, i5 = Kg;
function Qd(t) {
  return function() {
    throw new Error("Function " + t + " is deprecated and cannot be used.");
  };
}
ot.Type = St;
ot.Schema = Fo;
ot.FAILSAFE_SCHEMA = Bg;
ot.JSON_SCHEMA = Pk;
ot.CORE_SCHEMA = xk;
ot.DEFAULT_SAFE_SCHEMA = ql;
ot.DEFAULT_FULL_SCHEMA = xd;
ot.load = Cd.load;
ot.loadAll = Cd.loadAll;
ot.safeLoad = Cd.safeLoad;
ot.safeLoadAll = Cd.safeLoadAll;
ot.dump = i5.dump;
ot.safeDump = i5.safeDump;
ot.YAMLException = Ml;
ot.MINIMAL_SCHEMA = Bg;
ot.SAFE_SCHEMA = ql;
ot.DEFAULT_SCHEMA = xd;
ot.scan = Qd("scan");
ot.parse = Qd("parse");
ot.compose = Qd("compose");
ot.addConstructor = Qd("addConstructor");
var VY = ot, LY = VY;
const { ParserError: YY } = gt, BY = LY;
var FY = {
  /**
   * The order that this parser will run, in relation to other parsers.
   *
   * @type {number}
   */
  order: 200,
  /**
   * Whether to allow "empty" files. This includes zero-byte files, as well as empty JSON objects.
   *
   * @type {boolean}
   */
  allowEmpty: !0,
  /**
   * Determines whether this parser can parse a given file reference.
   * Parsers that match will be tried, in order, until one successfully parses the file.
   * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case
   * every parser will be tried.
   *
   * @type {RegExp|string[]|function}
   */
  canParse: [".yaml", ".yml", ".json"],
  // JSON is valid YAML
  /**
   * Parses the given file as YAML
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns {Promise}
   */
  async parse(t) {
    let e = t.data;
    if (Buffer.isBuffer(e) && (e = e.toString()), typeof e == "string")
      try {
        return BY.safeLoad(e);
      } catch (r) {
        throw new YY(r.message, t.url);
      }
    else
      return e;
  }
};
const { ParserError: HY } = gt;
let GY = /\.(txt|htm|html|md|xml|js|min|map|css|scss|less|svg)$/i;
var KY = {
  /**
   * The order that this parser will run, in relation to other parsers.
   *
   * @type {number}
   */
  order: 300,
  /**
   * Whether to allow "empty" files (zero bytes).
   *
   * @type {boolean}
   */
  allowEmpty: !0,
  /**
   * The encoding that the text is expected to be in.
   *
   * @type {string}
   */
  encoding: "utf8",
  /**
   * Determines whether this parser can parse a given file reference.
   * Parsers that return true will be tried, in order, until one successfully parses the file.
   * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case
   * every parser will be tried.
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns {boolean}
   */
  canParse(t) {
    return (typeof t.data == "string" || Buffer.isBuffer(t.data)) && GY.test(t.url);
  },
  /**
   * Parses the given file as text
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns {string}
   */
  parse(t) {
    if (typeof t.data == "string")
      return t.data;
    if (Buffer.isBuffer(t.data))
      return t.data.toString(this.encoding);
    throw new HY("data is not text", t.url);
  }
};
let JY = /\.(jpeg|jpg|gif|png|bmp|ico)$/i;
var eB = {
  /**
   * The order that this parser will run, in relation to other parsers.
   *
   * @type {number}
   */
  order: 400,
  /**
   * Whether to allow "empty" files (zero bytes).
   *
   * @type {boolean}
   */
  allowEmpty: !0,
  /**
   * Determines whether this parser can parse a given file reference.
   * Parsers that return true will be tried, in order, until one successfully parses the file.
   * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case
   * every parser will be tried.
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns {boolean}
   */
  canParse(t) {
    return Buffer.isBuffer(t.data) && JY.test(t.url);
  },
  /**
   * Parses the given data as a Buffer (byte array).
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns {Buffer}
   */
  parse(t) {
    return Buffer.isBuffer(t.data) ? t.data : Buffer.from(t.data);
  }
};
const tB = cd, { ono: Lf } = $n, Sb = Cr, { ResolverError: Yf } = gt;
var rB = {
  /**
   * The order that this resolver will run, in relation to other resolvers.
   *
   * @type {number}
   */
  order: 100,
  /**
   * Determines whether this resolver can read a given file reference.
   * Resolvers that return true will be tried, in order, until one successfully resolves the file.
   * Resolvers that return false will not be given a chance to resolve the file.
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @returns {boolean}
   */
  canRead(t) {
    return Sb.isFileSystemPath(t.url);
  },
  /**
   * Reads the given file and returns its raw contents as a Buffer.
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @returns {Promise<Buffer>}
   */
  read(t) {
    return new Promise((e, r) => {
      let n;
      try {
        n = Sb.toFileSystemPath(t.url);
      } catch (i) {
        r(new Yf(Lf.uri(i, `Malformed URI: ${t.url}`), t.url));
      }
      try {
        tB.readFile(n, (i, s) => {
          i ? r(new Yf(Lf(i, `Error opening file "${n}"`), n)) : e(s);
        });
      } catch (i) {
        r(new Yf(Lf(i, `Error opening file "${n}"`), n));
      }
    });
  }
};
const nB = cd, iB = cd, { ono: kc } = $n, Va = Cr, { ResolverError: kb } = gt;
var sB = {
  /**
   * The order that this resolver will run, in relation to other resolvers.
   *
   * @type {number}
   */
  order: 200,
  /**
   * HTTP headers to send when downloading files.
   *
   * @example:
   * {
   *   "User-Agent": "JSON Schema $Ref Parser",
   *   Accept: "application/json"
   * }
   *
   * @type {object}
   */
  headers: null,
  /**
   * HTTP request timeout (in milliseconds).
   *
   * @type {number}
   */
  timeout: 5e3,
  // 5 seconds
  /**
   * The maximum number of HTTP redirects to follow.
   * To disable automatic following of redirects, set this to zero.
   *
   * @type {number}
   */
  redirects: 5,
  /**
   * The `withCredentials` option of XMLHttpRequest.
   * Set this to `true` if you're downloading files from a CORS-enabled server that requires authentication
   *
   * @type {boolean}
   */
  withCredentials: !1,
  /**
   * Determines whether this resolver can read a given file reference.
   * Resolvers that return true will be tried in order, until one successfully resolves the file.
   * Resolvers that return false will not be given a chance to resolve the file.
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @returns {boolean}
   */
  canRead(t) {
    return Va.isHttp(t.url);
  },
  /**
   * Reads the given URL and returns its raw contents as a Buffer.
   *
   * @param {object} file           - An object containing information about the referenced file
   * @param {string} file.url       - The full URL of the referenced file
   * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @returns {Promise<Buffer>}
   */
  read(t) {
    let e = Va.parse(t.url);
    return process.browser && !e.protocol && (e.protocol = Va.parse(location.href).protocol), s5(e, this);
  }
};
function s5(t, e, r) {
  return new Promise((n, i) => {
    t = Va.parse(t), r = r || [], r.push(t.href), oB(t, e).then((s) => {
      if (s.statusCode >= 400)
        throw kc({ status: s.statusCode }, `HTTP ERROR ${s.statusCode}`);
      if (s.statusCode >= 300)
        if (r.length > e.redirects)
          i(new kb(kc(
            { status: s.statusCode },
            `Error downloading ${r[0]}. 
Too many redirects: 
  ${r.join(` 
  `)}`
          )));
        else if (s.headers.location) {
          let o = Va.resolve(t, s.headers.location);
          s5(o, e, r).then(n, i);
        } else
          throw kc({ status: s.statusCode }, `HTTP ${s.statusCode} redirect with no location header`);
      else
        n(s.body || Buffer.alloc(0));
    }).catch((s) => {
      i(new kb(kc(s, `Error downloading ${t.href}`), t.href));
    });
  });
}
function oB(t, e) {
  return new Promise((r, n) => {
    let s = (t.protocol === "https:" ? iB : nB).get({
      hostname: t.hostname,
      port: t.port,
      path: t.path,
      auth: t.auth,
      protocol: t.protocol,
      headers: e.headers || {},
      withCredentials: e.withCredentials
    });
    typeof s.setTimeout == "function" && s.setTimeout(e.timeout), s.on("timeout", () => {
      s.abort();
    }), s.on("error", n), s.once("response", (o) => {
      o.body = Buffer.alloc(0), o.on("data", (a) => {
        o.body = Buffer.concat([o.body, Buffer.from(a)]);
      }), o.on("error", n), o.on("end", () => {
        r(o);
      });
    });
  });
}
const aB = HU, lB = FY, cB = KY, uB = eB, dB = rB, fB = sB;
var o5 = e0;
function e0(t) {
  qp(this, e0.defaults), qp(this, t);
}
e0.defaults = {
  /**
   * Determines how different types of files will be parsed.
   *
   * You can add additional parsers of your own, replace an existing one with
   * your own implementation, or disable any parser by setting it to false.
   */
  parse: {
    json: aB,
    yaml: lB,
    text: cB,
    binary: uB
  },
  /**
   * Determines how JSON References will be resolved.
   *
   * You can add additional resolvers of your own, replace an existing one with
   * your own implementation, or disable any resolver by setting it to false.
   */
  resolve: {
    file: dB,
    http: fB,
    /**
     * Determines whether external $ref pointers will be resolved.
     * If this option is disabled, then none of above resolvers will be called.
     * Instead, external $ref pointers will simply be ignored.
     *
     * @type {boolean}
     */
    external: !0
  },
  /**
   * By default, JSON Schema $Ref Parser throws the first error it encounters. Setting `continueOnError` to `true`
   * causes it to keep processing as much as possible and then throw a single error that contains all errors
   * that were encountered.
  */
  continueOnError: !1,
  /**
   * Determines the types of JSON references that are allowed.
   */
  dereference: {
    /**
     * Dereference circular (recursive) JSON references?
     * If false, then a {@link ReferenceError} will be thrown if a circular reference is found.
     * If "ignore", then circular references will not be dereferenced.
     *
     * @type {boolean|string}
     */
    circular: !0
  }
};
function qp(t, e) {
  if (_b(e)) {
    let r = Object.keys(e);
    for (let n = 0; n < r.length; n++) {
      let i = r[n], s = e[i], o = t[i];
      _b(s) ? t[i] = qp(o || {}, s) : s !== void 0 && (t[i] = s);
    }
  }
  return t;
}
function _b(t) {
  return t && typeof t == "object" && !Array.isArray(t) && !(t instanceof RegExp) && !(t instanceof Date);
}
const Pb = o5;
var a5 = hB;
function hB(t) {
  let e, r, n, i;
  return t = Array.prototype.slice.call(t), typeof t[t.length - 1] == "function" && (i = t.pop()), typeof t[0] == "string" ? (e = t[0], typeof t[2] == "object" ? (r = t[1], n = t[2]) : (r = void 0, n = t[1])) : (e = "", r = t[0], n = t[1]), n instanceof Pb || (n = new Pb(n)), {
    path: e,
    schema: r,
    options: n,
    callback: i
  };
}
const Np = o5, pB = gk, mB = yk, gB = Hm;
var OB = Ad;
function Ad(t) {
  Np.call(this, Ad.defaults), Np.apply(this, arguments);
}
Ad.defaults = {
  /**
   * Determines how the API definition will be validated.
   *
   * You can add additional validators of your own, replace an existing one with
   * your own implemenation, or disable any validator by setting it to false.
   */
  validate: {
    schema: pB,
    spec: mB
  }
};
gB.inherits(Ad, Np);
function yB() {
  return typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : typeof setImmediate == "function" ? setImmediate : function(e) {
    setTimeout(e, 0);
  };
}
var bB = yB(), xb = bB, l5 = function(e, r) {
  if (e) {
    r.then(function(n) {
      xb(function() {
        e(null, n);
      });
    }, function(n) {
      xb(function() {
        e(n);
      });
    });
    return;
  } else
    return r;
}, Sn = { exports: {} }, Bf, Tb;
function Ed() {
  if (Tb)
    return Bf;
  Tb = 1, Bf = u;
  const t = zl(), e = Cr, { JSONParserError: r, InvalidPointerError: n, MissingPointerError: i, isHandledError: s } = gt, o = /\//g, a = /~/g, l = /~1/g, c = /~0/g;
  function u(p, g, m) {
    this.$ref = p, this.path = g, this.originalPath = m || g, this.value = void 0, this.circular = !1, this.indirections = 0;
  }
  u.prototype.resolve = function(p, g, m) {
    let y = u.parse(this.path, this.originalPath);
    this.value = h(p);
    for (let O = 0; O < y.length; O++) {
      if (d(this, g) && (this.path = u.join(this.path, y.slice(O))), typeof this.value == "object" && this.value !== null && "$ref" in this.value)
        return this;
      let b = y[O];
      if (this.value[b] === void 0 || this.value[b] === null)
        throw this.value = null, new i(b, this.originalPath);
      this.value = this.value[b];
    }
    return (!this.value || this.value.$ref && e.resolve(this.path, this.value.$ref) !== m) && d(this, g), this;
  }, u.prototype.set = function(p, g, m) {
    let y = u.parse(this.path), O;
    if (y.length === 0)
      return this.value = g, g;
    this.value = h(p);
    for (let b = 0; b < y.length - 1; b++)
      d(this, m), O = y[b], this.value && this.value[O] !== void 0 ? this.value = this.value[O] : this.value = f(this, O, {});
    return d(this, m), O = y[y.length - 1], f(this, O, g), p;
  }, u.parse = function(p, g) {
    let m = e.getHash(p).substr(1);
    if (!m)
      return [];
    m = m.split("/");
    for (let y = 0; y < m.length; y++)
      m[y] = decodeURIComponent(m[y].replace(l, "/").replace(c, "~"));
    if (m[0] !== "")
      throw new n(m, g === void 0 ? p : g);
    return m.slice(1);
  }, u.join = function(p, g) {
    p.indexOf("#") === -1 && (p += "#"), g = Array.isArray(g) ? g : [g];
    for (let m = 0; m < g.length; m++) {
      let y = g[m];
      p += "/" + encodeURIComponent(y.replace(a, "~0").replace(o, "~1"));
    }
    return p;
  };
  function d(p, g) {
    if (t.isAllowed$Ref(p.value, g)) {
      let m = e.resolve(p.path, p.value.$ref);
      if (m === p.path)
        p.circular = !0;
      else {
        let y = p.$ref.$refs._resolve(m, p.path, g);
        return p.indirections += y.indirections + 1, t.isExtended$Ref(p.value) ? (p.value = t.dereference(p.value, y.value), !1) : (p.$ref = y.$ref, p.path = y.path, p.value = y.value, !0);
      }
    }
  }
  function f(p, g, m) {
    if (p.value && typeof p.value == "object")
      g === "-" && Array.isArray(p.value) ? p.value.push(m) : p.value[g] = m;
    else
      throw new r(`Error assigning $ref pointer "${p.path}". 
Cannot set "${g}" of a non-object.`);
    return m;
  }
  function h(p) {
    if (s(p))
      throw p;
    return p;
  }
  return Bf;
}
var Ff, Cb;
function zl() {
  if (Cb)
    return Ff;
  Cb = 1, Ff = a;
  const t = Ed(), { InvalidPointerError: e, isHandledError: r, normalizeError: n } = gt, { safePointerToPath: i, stripHash: s, getHash: o } = Cr;
  function a() {
    this.path = void 0, this.value = void 0, this.$refs = void 0, this.pathType = void 0, this.errors = void 0;
  }
  return a.prototype.addError = function(l) {
    this.errors === void 0 && (this.errors = []), Array.isArray(l.errors) ? this.errors.push(...l.errors.map(n)) : this.errors.push(n(l));
  }, a.prototype.exists = function(l, c) {
    try {
      return this.resolve(l, c), !0;
    } catch {
      return !1;
    }
  }, a.prototype.get = function(l, c) {
    return this.resolve(l, c).value;
  }, a.prototype.resolve = function(l, c, u, d) {
    let f = new t(this, l, u);
    try {
      return f.resolve(this.value, c, d);
    } catch (h) {
      if (!c || !c.continueOnError || !r(h))
        throw h;
      return h.path === null && (h.path = i(o(d))), h instanceof e && (h.source = s(d)), this.addError(h), null;
    }
  }, a.prototype.set = function(l, c) {
    let u = new t(this, l);
    this.value = u.set(this.value, c);
  }, a.is$Ref = function(l) {
    return l && typeof l == "object" && typeof l.$ref == "string" && l.$ref.length > 0;
  }, a.isExternal$Ref = function(l) {
    return a.is$Ref(l) && l.$ref[0] !== "#";
  }, a.isAllowed$Ref = function(l, c) {
    if (a.is$Ref(l)) {
      if (l.$ref.substr(0, 2) === "#/" || l.$ref === "#")
        return !0;
      if (l.$ref[0] !== "#" && (!c || c.resolve.external))
        return !0;
    }
  }, a.isExtended$Ref = function(l) {
    return a.is$Ref(l) && Object.keys(l).length > 1;
  }, a.dereference = function(l, c) {
    if (c && typeof c == "object" && a.isExtended$Ref(l)) {
      let u = {};
      for (let d of Object.keys(l))
        d !== "$ref" && (u[d] = l[d]);
      for (let d of Object.keys(c))
        d in u || (u[d] = c[d]);
      return u;
    } else
      return c;
  }, Ff;
}
const { ono: c5 } = $n, vB = zl(), _i = Cr;
var wB = Yr;
function Yr() {
  this.circular = !1, this._$refs = {}, this._root$Ref = null;
}
Yr.prototype.paths = function(t) {
  return u5(this._$refs, arguments).map((r) => r.decoded);
};
Yr.prototype.values = function(t) {
  let e = this._$refs;
  return u5(e, arguments).reduce((n, i) => (n[i.decoded] = e[i.encoded].value, n), {});
};
Yr.prototype.toJSON = Yr.prototype.values;
Yr.prototype.exists = function(t, e) {
  try {
    return this._resolve(t, "", e), !0;
  } catch {
    return !1;
  }
};
Yr.prototype.get = function(t, e) {
  return this._resolve(t, "", e).value;
};
Yr.prototype.set = function(t, e) {
  let r = _i.resolve(this._root$Ref.path, t), n = _i.stripHash(r), i = this._$refs[n];
  if (!i)
    throw c5(`Error resolving $ref pointer "${t}". 
"${n}" not found.`);
  i.set(r, e);
};
Yr.prototype._add = function(t) {
  let e = _i.stripHash(t), r = new vB();
  return r.path = e, r.$refs = this, this._$refs[e] = r, this._root$Ref = this._root$Ref || r, r;
};
Yr.prototype._resolve = function(t, e, r) {
  let n = _i.resolve(this._root$Ref.path, t), i = _i.stripHash(n), s = this._$refs[i];
  if (!s)
    throw c5(`Error resolving $ref pointer "${t}". 
"${i}" not found.`);
  return s.resolve(n, r, t, e);
};
Yr.prototype._get$Ref = function(t) {
  t = _i.resolve(this._root$Ref.path, t);
  let e = _i.stripHash(t);
  return this._$refs[e];
};
function u5(t, e) {
  let r = Object.keys(t);
  return e = Array.isArray(e[0]) ? e[0] : Array.prototype.slice.call(e), e.length > 0 && e[0] && (r = r.filter((n) => e.indexOf(t[n].pathType) !== -1)), r.map((n) => ({
    encoded: n,
    decoded: t[n].pathType === "file" ? _i.toFileSystemPath(n, !0) : n
  }));
}
var Xl = {};
Xl.all = function(t) {
  return Object.keys(t).filter((e) => typeof t[e] == "object").map((e) => (t[e].name = e, t[e]));
};
Xl.filter = function(t, e, r) {
  return t.filter((n) => !!d5(n, e, r));
};
Xl.sort = function(t) {
  for (let e of t)
    e.order = e.order || Number.MAX_SAFE_INTEGER;
  return t.sort((e, r) => e.order - r.order);
};
Xl.run = function(t, e, r, n) {
  let i, s, o = 0;
  return new Promise((a, l) => {
    c();
    function c() {
      if (i = t[o++], !i)
        return l(s);
      try {
        let h = d5(i, e, r, u, n);
        if (h && typeof h.then == "function")
          h.then(d, f);
        else if (h !== void 0)
          d(h);
        else if (o === t.length)
          throw new Error("No promise has been returned or callback has been called.");
      } catch (h) {
        f(h);
      }
    }
    function u(h, p) {
      h ? f(h) : d(p);
    }
    function d(h) {
      a({
        plugin: i,
        result: h
      });
    }
    function f(h) {
      s = {
        plugin: i,
        error: h
      }, c();
    }
  });
};
function d5(t, e, r, n, i) {
  let s = t[e];
  if (typeof s == "function")
    return s.apply(t, [r, n, i]);
  if (!n) {
    if (s instanceof RegExp)
      return s.test(r.url);
    if (typeof s == "string")
      return s === r.extension;
    if (Array.isArray(s))
      return s.indexOf(r.extension) !== -1;
  }
  return s;
}
const { ono: Dp } = $n, Qb = Cr, ui = Xl, { ResolverError: Ab, ParserError: Eb, UnmatchedParserError: $B, UnmatchedResolverError: SB, isHandledError: kB } = gt;
var f5 = _B;
async function _B(t, e, r) {
  t = Qb.stripHash(t);
  let n = e._add(t), i = {
    url: t,
    extension: Qb.getExtension(t)
  };
  try {
    const s = await PB(i, r, e);
    n.pathType = s.plugin.name, i.data = s.result;
    const o = await xB(i, r, e);
    return n.value = o.result, o.result;
  } catch (s) {
    throw kB(s) && (n.value = s), s;
  }
}
function PB(t, e, r) {
  return new Promise((n, i) => {
    let s = ui.all(e.resolve);
    s = ui.filter(s, "canRead", t), ui.sort(s), ui.run(s, "read", t, r).then(n, o);
    function o(a) {
      !a && e.continueOnError ? i(new SB(t.url)) : !a || !("error" in a) ? i(Dp.syntax(`Unable to resolve $ref pointer "${t.url}"`)) : a.error instanceof Ab ? i(a.error) : i(new Ab(a, t.url));
    }
  });
}
function xB(t, e, r) {
  return new Promise((n, i) => {
    let s = ui.all(e.parse), o = ui.filter(s, "canParse", t), a = o.length > 0 ? o : s;
    ui.sort(a), ui.run(a, "parse", t, r).then(l, c);
    function l(u) {
      !u.plugin.allowEmpty && TB(u.result) ? i(Dp.syntax(`Error parsing "${t.url}" as ${u.plugin.name}. 
Parsed value is empty`)) : n(u);
    }
    function c(u) {
      !u && e.continueOnError ? i(new $B(t.url)) : !u || !("error" in u) ? i(Dp.syntax(`Unable to parse ${t.url}`)) : u.error instanceof Eb ? i(u.error) : i(new Eb(u.error.message, t.url));
    }
  });
}
function TB(t) {
  return t === void 0 || typeof t == "object" && Object.keys(t).length === 0 || typeof t == "string" && t.trim().length === 0 || Buffer.isBuffer(t) && t.length === 0;
}
const Rb = zl(), CB = Ed(), QB = f5, ya = Cr, { isHandledError: AB } = gt;
var EB = RB;
function RB(t, e) {
  if (!e.resolve.external)
    return Promise.resolve();
  try {
    let r = t0(t.schema, t.$refs._root$Ref.path + "#", t.$refs, e);
    return Promise.all(r);
  } catch (r) {
    return Promise.reject(r);
  }
}
function t0(t, e, r, n) {
  let i = [];
  if (t && typeof t == "object" && !ArrayBuffer.isView(t))
    if (Rb.isExternal$Ref(t))
      i.push(Ib(t, e, r, n));
    else
      for (let s of Object.keys(t)) {
        let o = CB.join(e, s), a = t[s];
        Rb.isExternal$Ref(a) ? i.push(Ib(a, o, r, n)) : i = i.concat(t0(a, o, r, n));
      }
  return i;
}
async function Ib(t, e, r, n) {
  let i = ya.resolve(e, t.$ref), s = ya.stripHash(i);
  if (t = r._$refs[s], t)
    return Promise.resolve(t.value);
  try {
    const o = await QB(i, r, n);
    let a = t0(o, s + "#", r, n);
    return Promise.all(a);
  } catch (o) {
    if (!n.continueOnError || !AB(o))
      throw o;
    return r._$refs[s] && (o.source = ya.stripHash(e), o.path = ya.safePointerToPath(ya.getHash(e))), [];
  }
}
const Mu = zl(), dl = Ed(), Hf = Cr;
var IB = jB;
function jB(t, e) {
  let r = [];
  r0(t, "schema", t.$refs._root$Ref.path + "#", "#", 0, r, t.$refs, e), ZB(r);
}
function r0(t, e, r, n, i, s, o, a) {
  let l = e === null ? t : t[e];
  if (l && typeof l == "object" && !ArrayBuffer.isView(l))
    if (Mu.isAllowed$Ref(l))
      jb(t, e, r, n, i, s, o, a);
    else {
      let c = Object.keys(l).sort((u, d) => u === "definitions" ? -1 : d === "definitions" ? 1 : u.length - d.length);
      for (let u of c) {
        let d = dl.join(r, u), f = dl.join(n, u), h = l[u];
        Mu.isAllowed$Ref(h) ? jb(l, u, r, f, i, s, o, a) : r0(l, u, d, f, i, s, o, a);
      }
    }
}
function jb(t, e, r, n, i, s, o, a) {
  let l = e === null ? t : t[e], c = Hf.resolve(r, l.$ref), u = o._resolve(c, n, a);
  if (u === null)
    return;
  let d = dl.parse(n).length, f = Hf.stripHash(u.path), h = Hf.getHash(u.path), p = f !== o._root$Ref.path, g = Mu.isExtended$Ref(l);
  i += u.indirections;
  let m = MB(s, t, e);
  if (m)
    if (d < m.depth || i < m.indirections)
      qB(s, m);
    else
      return;
  s.push({
    $ref: l,
    // The JSON Reference (e.g. {$ref: string})
    parent: t,
    // The object that contains this $ref pointer
    key: e,
    // The key in `parent` that is the $ref pointer
    pathFromRoot: n,
    // The path to the $ref pointer, from the JSON Schema root
    depth: d,
    // How far from the JSON Schema root is this $ref pointer?
    file: f,
    // The file that the $ref pointer resolves to
    hash: h,
    // The hash within `file` that the $ref pointer resolves to
    value: u.value,
    // The resolved value of the $ref pointer
    circular: u.circular,
    // Is this $ref pointer DIRECTLY circular? (i.e. it references itself)
    extended: g,
    // Does this $ref extend its resolved value? (i.e. it has extra properties, in addition to "$ref")
    external: p,
    // Does this $ref pointer point to a file other than the main JSON Schema file?
    indirections: i
    // The number of indirect references that were traversed to resolve the value
  }), m || r0(u.value, null, u.path, n, i + 1, s, o, a);
}
function ZB(t) {
  t.sort((i, s) => {
    if (i.file !== s.file)
      return i.file < s.file ? -1 : 1;
    if (i.hash !== s.hash)
      return i.hash < s.hash ? -1 : 1;
    if (i.circular !== s.circular)
      return i.circular ? -1 : 1;
    if (i.extended !== s.extended)
      return i.extended ? 1 : -1;
    if (i.indirections !== s.indirections)
      return i.indirections - s.indirections;
    if (i.depth !== s.depth)
      return i.depth - s.depth;
    {
      let o = i.pathFromRoot.lastIndexOf("/definitions"), a = s.pathFromRoot.lastIndexOf("/definitions");
      return o !== a ? a - o : i.pathFromRoot.length - s.pathFromRoot.length;
    }
  });
  let e, r, n;
  for (let i of t)
    i.external ? i.file === e && i.hash === r ? i.$ref.$ref = n : i.file === e && i.hash.indexOf(r + "/") === 0 ? i.$ref.$ref = dl.join(n, dl.parse(i.hash.replace(r, "#"))) : (e = i.file, r = i.hash, n = i.pathFromRoot, i.$ref = i.parent[i.key] = Mu.dereference(i.$ref, i.value), i.circular && (i.$ref.$ref = i.pathFromRoot)) : i.$ref.$ref = i.hash;
}
function MB(t, e, r) {
  for (let n = 0; n < t.length; n++) {
    let i = t[n];
    if (i.parent === e && i.key === r)
      return i;
  }
}
function qB(t, e) {
  let r = t.indexOf(e);
  t.splice(r, 1);
}
const zp = zl(), Zb = Ed(), { ono: NB } = $n, DB = Cr;
var h5 = zB;
function zB(t, e) {
  let r = n0(t.schema, t.$refs._root$Ref.path, "#", [], [], {}, t.$refs, e);
  t.$refs.circular = r.circular, t.schema = r.value;
}
function n0(t, e, r, n, i, s, o, a) {
  let l, c = {
    value: t,
    circular: !1
  };
  if ((a.dereference.circular === "ignore" || i.indexOf(t) === -1) && t && typeof t == "object" && !ArrayBuffer.isView(t)) {
    if (n.push(t), i.push(t), zp.isAllowed$Ref(t, a))
      l = Mb(t, e, r, n, i, s, o, a), c.circular = l.circular, c.value = l.value;
    else
      for (let u of Object.keys(t)) {
        let d = Zb.join(e, u), f = Zb.join(r, u), h = t[u], p = !1;
        zp.isAllowed$Ref(h, a) ? (l = Mb(h, d, f, n, i, s, o, a), p = l.circular, t[u] !== l.value && (t[u] = l.value)) : n.indexOf(h) === -1 ? (l = n0(h, d, f, n, i, s, o, a), p = l.circular, t[u] !== l.value && (t[u] = l.value)) : p = p5(d, o, a), c.circular = c.circular || p;
      }
    n.pop();
  }
  return c;
}
function Mb(t, e, r, n, i, s, o, a) {
  let l = DB.resolve(e, t.$ref);
  if (s[l]) {
    const p = s[l], g = Object.keys(t);
    if (g.length > 1) {
      const m = {};
      for (let y of g)
        y !== "$ref" && !(y in p.value) && (m[y] = t[y]);
      return {
        circular: p.circular,
        value: Object.assign({}, p.value, m)
      };
    }
    return p;
  }
  let c = o._resolve(l, e, a);
  if (c === null)
    return {
      circular: !1,
      value: null
    };
  let u = c.circular, d = u || n.indexOf(c.value) !== -1;
  d && p5(e, o, a);
  let f = zp.dereference(t, c.value);
  if (!d) {
    let p = n0(f, c.path, r, n, i, s, o, a);
    d = p.circular, f = p.value;
  }
  d && !u && a.dereference.circular === "ignore" && (f = t), u && (f.$ref = r);
  const h = {
    circular: d,
    value: f
  };
  return Object.keys(t).length === 1 && (s[l] = h), h;
}
function p5(t, e, r) {
  if (e.circular = !0, !r.dereference.circular)
    throw NB.reference(`Circular $ref pointer found at ${t}`);
  return !0;
}
const m5 = wB, XB = f5, Rd = a5, WB = EB, UB = IB, VB = h5, Ms = Cr, { JSONParserError: LB, InvalidPointerError: YB, MissingPointerError: BB, ResolverError: FB, ParserError: HB, UnmatchedParserError: GB, UnmatchedResolverError: KB, isHandledError: JB, JSONParserErrorGroup: qb } = gt, Dr = l5, { ono: Nb } = $n;
Sn.exports = kn;
Sn.exports.default = kn;
Sn.exports.JSONParserError = LB;
Sn.exports.InvalidPointerError = YB;
Sn.exports.MissingPointerError = BB;
Sn.exports.ResolverError = FB;
Sn.exports.ParserError = HB;
Sn.exports.UnmatchedParserError = GB;
Sn.exports.UnmatchedResolverError = KB;
function kn() {
  this.schema = null, this.$refs = new m5();
}
kn.parse = function(e, r, n, i) {
  let s = this, o = new s();
  return o.parse.apply(o, arguments);
};
kn.prototype.parse = async function(e, r, n, i) {
  let s = Rd(arguments), o;
  if (!s.path && !s.schema) {
    let c = Nb(`Expected a file path, URL, or object. Got ${s.path || s.schema}`);
    return Dr(s.callback, Promise.reject(c));
  }
  this.schema = null, this.$refs = new m5();
  let a = "http";
  if (Ms.isFileSystemPath(s.path) && (s.path = Ms.fromFileSystemPath(s.path), a = "file"), s.path = Ms.resolve(Ms.cwd(), s.path), s.schema && typeof s.schema == "object") {
    let c = this.$refs._add(s.path);
    c.value = s.schema, c.pathType = a, o = Promise.resolve(s.schema);
  } else
    o = XB(s.path, this.$refs, s.options);
  let l = this;
  try {
    let c = await o;
    if (c !== null && typeof c == "object" && !Buffer.isBuffer(c))
      return l.schema = c, Dr(s.callback, Promise.resolve(l.schema));
    if (s.options.continueOnError)
      return l.schema = null, Dr(s.callback, Promise.resolve(l.schema));
    throw Nb.syntax(`"${l.$refs._root$Ref.path || c}" is not a valid JSON Schema`);
  } catch (c) {
    return !s.options.continueOnError || !JB(c) ? Dr(s.callback, Promise.reject(c)) : (this.$refs._$refs[Ms.stripHash(s.path)] && this.$refs._$refs[Ms.stripHash(s.path)].addError(c), Dr(s.callback, Promise.resolve(null)));
  }
};
kn.resolve = function(e, r, n, i) {
  let s = this, o = new s();
  return o.resolve.apply(o, arguments);
};
kn.prototype.resolve = async function(e, r, n, i) {
  let s = this, o = Rd(arguments);
  try {
    return await this.parse(o.path, o.schema, o.options), await WB(s, o.options), i0(s), Dr(o.callback, Promise.resolve(s.$refs));
  } catch (a) {
    return Dr(o.callback, Promise.reject(a));
  }
};
kn.bundle = function(e, r, n, i) {
  let s = this, o = new s();
  return o.bundle.apply(o, arguments);
};
kn.prototype.bundle = async function(e, r, n, i) {
  let s = this, o = Rd(arguments);
  try {
    return await this.resolve(o.path, o.schema, o.options), UB(s, o.options), i0(s), Dr(o.callback, Promise.resolve(s.schema));
  } catch (a) {
    return Dr(o.callback, Promise.reject(a));
  }
};
kn.dereference = function(e, r, n, i) {
  let s = this, o = new s();
  return o.dereference.apply(o, arguments);
};
kn.prototype.dereference = async function(e, r, n, i) {
  let s = this, o = Rd(arguments);
  try {
    return await this.resolve(o.path, o.schema, o.options), VB(s, o.options), i0(s), Dr(o.callback, Promise.resolve(s.schema));
  } catch (a) {
    return Dr(o.callback, Promise.reject(a));
  }
};
function i0(t) {
  if (qb.getParserErrors(t).length > 0)
    throw new qb(t);
}
var eF = Sn.exports;
const tF = gk, rF = yk, g5 = a5, O5 = ys, y5 = OB, qu = l5, { ono: Rr } = $n, bs = eF, nF = h5;
var iF = _n;
function _n() {
  bs.apply(this, arguments);
}
O5.inherits(_n, bs);
_n.parse = bs.parse;
_n.resolve = bs.resolve;
_n.bundle = bs.bundle;
_n.dereference = bs.dereference;
Object.defineProperty(_n.prototype, "api", {
  configurable: !0,
  enumerable: !0,
  get() {
    return this.schema;
  }
});
_n.prototype.parse = async function(t, e, r, n) {
  let i = g5(arguments);
  i.options = new y5(i.options);
  try {
    let s = await bs.prototype.parse.call(this, i.path, i.schema, i.options);
    if (s.swagger) {
      if (s.swagger === void 0 || s.info === void 0 || s.paths === void 0)
        throw Rr.syntax(`${i.path || i.schema} is not a valid Swagger API definition`);
      if (typeof s.swagger == "number")
        throw Rr.syntax('Swagger version number must be a string (e.g. "2.0") not a number.');
      if (typeof s.info.version == "number")
        throw Rr.syntax('API version number must be a string (e.g. "1.0.0") not a number.');
      if (s.swagger !== "2.0")
        throw Rr.syntax(`Unrecognized Swagger version: ${s.swagger}. Expected 2.0`);
    } else {
      let o = ["3.0.0", "3.0.1", "3.0.2", "3.0.3", "3.1.0"];
      if (s.openapi === void 0 || s.info === void 0)
        throw Rr.syntax(`${i.path || i.schema} is not a valid Openapi API definition`);
      if (s.paths === void 0)
        if (s.openapi === "3.1.0") {
          if (s.webhooks === void 0)
            throw Rr.syntax(`${i.path || i.schema} is not a valid Openapi API definition`);
        } else
          throw Rr.syntax(`${i.path || i.schema} is not a valid Openapi API definition`);
      else {
        if (typeof s.openapi == "number")
          throw Rr.syntax('Openapi version number must be a string (e.g. "3.0.0") not a number.');
        if (typeof s.info.version == "number")
          throw Rr.syntax('API version number must be a string (e.g. "1.0.0") not a number.');
        if (o.indexOf(s.openapi) === -1)
          throw Rr.syntax(
            `Unsupported OpenAPI version: ${s.openapi}. Swagger Parser only supports versions ${o.join(", ")}`
          );
      }
      O5.fixOasRelativeServers(s, i.path);
    }
    return qu(i.callback, Promise.resolve(s));
  } catch (s) {
    return qu(i.callback, Promise.reject(s));
  }
};
_n.validate = function(t, e, r, n) {
  let i = this, s = new i();
  return s.validate.apply(s, arguments);
};
_n.prototype.validate = async function(t, e, r, n) {
  let i = this, s = g5(arguments);
  s.options = new y5(s.options);
  let o = s.options.dereference.circular;
  s.options.validate.schema && (s.options.dereference.circular = "ignore");
  try {
    if (await this.dereference(s.path, s.schema, s.options), s.options.dereference.circular = o, s.options.validate.schema && (tF(i.api), i.$refs.circular)) {
      if (o === !0)
        nF(i, s.options);
      else if (o === !1)
        throw Rr.reference("The API contains circular references");
    }
    return s.options.validate.spec && rF(i.api), qu(s.callback, Promise.resolve(i.schema));
  } catch (a) {
    return qu(s.callback, Promise.reject(a));
  }
};
const sF = /* @__PURE__ */ X$(iF), oF = [
  "GET",
  "POST",
  "PUT",
  "HEAD",
  "DELETE",
  "PATCH",
  "OPTIONS",
  "CONNECT",
  "TRACE"
], aF = (t) => new Promise((e, r) => {
  try {
    const n = JC(t);
    sF.dereference(n, (i, s) => {
      if (i && r(i), s === void 0) {
        r("Couldnâ€™t parse the Swagger file.");
        return;
      }
      const o = lF(s);
      e(o);
    });
  } catch (n) {
    r(n);
  }
}), lF = (t) => {
  t.tags || (t.tags = []), t.paths || (t.paths = {});
  const e = {};
  Object.keys(t.webhooks ?? {}).forEach(
    (n) => {
      var i;
      Object.keys(
        ((i = t.webhooks) == null ? void 0 : i[n]) ?? {}
      ).forEach((s) => {
        var a, l, c;
        const o = ((a = t.webhooks) == null ? void 0 : a[n])[s];
        e[n] === void 0 && (e[n] = {}), e[n][s] = {
          // Transformed data
          httpVerb: s,
          path: n,
          operationId: (o == null ? void 0 : o.operationId) || n,
          name: (o == null ? void 0 : o.summary) || n || "",
          description: (o == null ? void 0 : o.description) || "",
          pathParameters: (c = (l = t.paths) == null ? void 0 : l[n]) == null ? void 0 : c.parameters,
          // Original webhook
          information: {
            ...o
          }
        };
      });
    }
  ), Object.keys(t.paths).forEach((n) => {
    Object.keys(t.paths[n]).filter(
      (s) => oF.includes(s.toUpperCase())
    ).forEach((s) => {
      var l, c, u, d, f, h;
      const o = t.paths[n][s], a = {
        httpVerb: s,
        path: n,
        operationId: o.operationId || n,
        name: o.summary || n || "",
        description: o.description || "",
        information: {
          ...o
        },
        pathParameters: (c = (l = t.paths) == null ? void 0 : l[n]) == null ? void 0 : c.parameters
      };
      if (!o.tags || o.tags.length === 0) {
        (u = t.tags) != null && u.find(
          (g) => g.name === "default"
        ) || (d = t.tags) == null || d.push({
          name: "default",
          description: "",
          // @ts-ignore
          operations: []
        });
        const p = (f = t.tags) == null ? void 0 : f.findIndex(
          (g) => g.name === "default"
        );
        p >= 0 && ((h = t.tags[p]) == null || h.operations.push(a));
      } else
        o.tags.forEach((p) => {
          var y, O, b;
          const g = (y = t.tags) == null ? void 0 : y.findIndex(
            // @ts-ignore
            (w) => w.name === p
          );
          g === -1 && ((O = t.tags) == null || O.push({
            name: p,
            description: ""
          }));
          const m = g !== -1 ? g : (
            // @ts-ignore
            t.tags.length - 1
          );
          typeof ((b = t.tags[m]) == null ? void 0 : b.operations) > "u" && (t.tags[m].operations = []), t.tags[m].operations.push(a);
        });
    });
  });
  const r = {
    ...t,
    webhooks: e
  };
  return cF(r);
}, cF = (t) => {
  var e;
  return {
    ...t,
    tags: (e = t.tags) == null ? void 0 : e.filter((r) => {
      var n;
      return ((n = r.operations) == null ? void 0 : n.length) > 0;
    })
  };
}, Db = () => ({
  info: {
    title: "",
    description: "",
    termsOfService: "",
    version: "",
    license: {
      name: "",
      url: ""
    },
    contact: {
      email: ""
    }
  },
  externalDocs: {
    description: "",
    url: ""
  },
  components: {
    schemas: {},
    securitySchemes: {}
  },
  servers: [],
  tags: []
}), uF = async ({ url: t, content: e }, r) => {
  if (t)
    return DR(t) ? await D1(t, r) : await D1(t);
  const n = typeof e == "function" ? e() : e;
  if (typeof n == "string")
    return n;
  if (typeof n == "object")
    return JSON.stringify(n);
};
function dF({
  specConfig: t,
  proxy: e
}) {
  const r = ge(""), n = vn(Db()), i = ge(null);
  function s(o) {
    return o ? aF(o).then((a) => {
      i.value = null, Object.assign(n, {
        servers: [],
        ...a
      });
    }).catch((a) => {
      i.value = a.toString();
    }) : Object.assign(n, Db());
  }
  return Ve(
    () => Pt(t),
    async (o) => {
      var a;
      if (o) {
        const l = (a = await uF(o, Pt(e))) == null ? void 0 : a.trim();
        typeof l == "string" && (r.value = l);
      }
    },
    { immediate: !0, deep: !0 }
  ), Ve(r, () => {
    s(r.value);
  }), {
    rawSpec: r,
    parsedSpec: n,
    specErrors: i
  };
}
const fF = (t) => Object.fromEntries(Array.from(t).map((e) => [e.name, e.value])), hF = (t) => ({ raw: e }) => {
  const n = new t().parseFromString(e, "image/svg+xml");
  if (n.getElementsByTagName("parsererror").length)
    return;
  const i = n.documentElement, s = fF(i.attributes), { width: o, height: a, ...l } = s;
  return Hb("svg", { ...l, innerHTML: i.innerHTML });
}, pF = Fb(async () => {
  const t = typeof DOMParser > "u" ? (await import("@xmldom/xmldom")).DOMParser : DOMParser, e = hF(t);
  return e.props = {
    raw: {
      type: String,
      required: !0
    }
  }, e;
}), mF = '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" d="M23.25 7.311 12.53 18.03a.749.749 0 0 1-1.06 0L.75 7.311"></path></svg>', gF = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" stroke-width="1.5"><path d="M16.25 23.25 5.53 12.53a.749.749 0 0 1 0-1.06L16.25.75" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path></svg>', OF = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" stroke-width="1.5"><path d="m5.5.75 10.72 10.72a.749.749 0 0 1 0 1.06L5.5 23.25" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path></svg>', yF = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" stroke-width="1.5"><path d="M.75 17.189 11.47 6.47a.749.749 0 0 1 1.06 0l10.72 10.719" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path></svg>', bF = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" stroke-width="1.5"><path d="M12 .75v22.5" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M1.5 12.75 12 23.25l10.5-10.5" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path></svg>', vF = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" stroke-width="1.5"><path d="M23.25 12H.75" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M11.25 1.5.75 12l10.5 10.5" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path></svg>', wF = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" stroke-width="1.5"><path d="M.75 12h22.5" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M12.75 22.5 23.25 12 12.75 1.5" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path></svg>', $F = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" stroke-width="1.5"><path d="M12 23.25V.75" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M22.5 11.25 12 .75 1.5 11.25" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path></svg>', SF = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" stroke-width="1.5"><path d="M.75 12h22.5" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M12 .75v22.5" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path></svg>', kF = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" stroke-width="1.5"><path d="m.75 23.249 22.5-22.5" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="M23.25 23.249.75.749" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path></svg>', _F = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" stroke-width="1.5"><path d="m7.629 4.5-6.44 6.439a1.5 1.5 0 0 0 0 2.121l6.44 6.44" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path><path d="m16.371 4.5 6.44 6.439a1.5 1.5 0 0 1 0 2.121l-6.44 6.44" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"></path></svg>', PF = `<svg fill="currentColor" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <title>GitHub</title>
    <path
        d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12" />
</svg>`, xF = `<svg fill="currentColor" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <title>Angular</title>
    <path
        d="M9.931 12.645h4.138l-2.07-4.908m0-7.737L.68 3.982l1.726 14.771L12 24l9.596-5.242L23.32 3.984 11.999.001zm7.064 18.31h-2.638l-1.422-3.503H8.996l-1.422 3.504h-2.64L12 2.65z" />
</svg>`, TF = `<svg fill="currentColor" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <title>Astro</title>
    <path
        d="M16.074 16.86c-.72.616-2.157 1.035-3.812 1.035-2.032 0-3.735-.632-4.187-1.483-.161.488-.198 1.046-.198 1.402 0 0-.106 1.75 1.111 2.968 0-.632.513-1.145 1.145-1.145 1.083 0 1.082.945 1.081 1.712v.069c0 1.164.711 2.161 1.723 2.582a2.347 2.347 0 0 1-.236-1.029c0-1.11.652-1.523 1.41-2.003.602-.383 1.272-.807 1.733-1.66a3.129 3.129 0 0 0 .378-1.494 3.14 3.14 0 0 0-.148-.954zM15.551.6c.196.244.296.572.496 1.229l4.368 14.347a18.18 18.18 0 0 0-5.222-1.768L12.35 4.8a.37.37 0 0 0-.71.002l-2.81 9.603a18.175 18.175 0 0 0-5.245 1.771L7.974 1.827c.2-.656.3-.984.497-1.227a1.613 1.613 0 0 1 .654-.484C9.415 0 9.757 0 10.443 0h3.135c.686 0 1.03 0 1.32.117A1.614 1.614 0 0 1 15.55.6z" />
</svg>`, CF = '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M6.335.83a.75.75 0 0 0-.67 0L1.667 2.827a.754.754 0 0 0-.417.672V18c0 .271.146.52.382.654l7.989 4.493a.753.753 0 0 0 .747.007l8-4.5A.75.75 0 0 0 18.75 18v-4.537l3.585-1.792A.75.75 0 0 0 22.75 11V6a.75.75 0 0 0-.417-.672l-3.998-1.999a.75.75 0 0 0-.67 0l-3.997 1.999a.722.722 0 0 0-.246.194.748.748 0 0 0-.172.478v4.561l-2.5 1.407V3.5a.747.747 0 0 0-.43-.678L6.336.829Zm7.686 11.019 2.38 1.19-6.422 3.612-2.38-1.19 6.422-3.612Zm3.229-.063-2.5-1.25V7.215l2.5 1.25v3.322Zm1.5 0 2.5-1.25V7.215l-2.5 1.25v3.322Zm-9.5 1.025V4.714l-2.5 1.25v8.254l2.5-1.407Zm-1.005 4.65.743.372c.17.091.262.153.262.183v3.202l-6.5-3.657V4.714l2.5 1.25V15.5a.75.75 0 0 0 .415.67s1.122.591 2.108 1.064l.472.227Zm2.505.478 6.5-3.657v3.28l-6.5 3.656v-3.28ZM6 4.66 3.677 3.5 6 2.339 8.323 3.5 6 4.661ZM20.323 6 18 4.839 15.677 6 18 7.161 20.323 6Z" clip-rule="evenodd"></path></svg>', QF = `<svg fill="currentColor" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <title>Next.js</title>
    <path
        d="M11.5725 0c-.1763 0-.3098.0013-.3584.0067-.0516.0053-.2159.021-.3636.0328-3.4088.3073-6.6017 2.1463-8.624 4.9728C1.1004 6.584.3802 8.3666.1082 10.255c-.0962.659-.108.8537-.108 1.7474s.012 1.0884.108 1.7476c.652 4.506 3.8591 8.2919 8.2087 9.6945.7789.2511 1.6.4223 2.5337.5255.3636.04 1.9354.04 2.299 0 1.6117-.1783 2.9772-.577 4.3237-1.2643.2065-.1056.2464-.1337.2183-.1573-.0188-.0139-.8987-1.1938-1.9543-2.62l-1.919-2.592-2.4047-3.5583c-1.3231-1.9564-2.4117-3.556-2.4211-3.556-.0094-.0026-.0187 1.5787-.0235 3.509-.0067 3.3802-.0093 3.5162-.0516 3.596-.061.115-.108.1618-.2064.2134-.075.0374-.1408.0445-.495.0445h-.406l-.1078-.068a.4383.4383 0 01-.1572-.1712l-.0493-.1056.0053-4.703.0067-4.7054.0726-.0915c.0376-.0493.1174-.1125.1736-.143.0962-.047.1338-.0517.5396-.0517.4787 0 .5584.0187.6827.1547.0353.0377 1.3373 1.9987 2.895 4.3608a10760.433 10760.433 0 004.7344 7.1706l1.9002 2.8782.096-.0633c.8518-.5536 1.7525-1.3418 2.4657-2.1627 1.5179-1.7429 2.4963-3.868 2.8247-6.134.0961-.6591.1078-.854.1078-1.7475 0-.8937-.012-1.0884-.1078-1.7476-.6522-4.506-3.8592-8.2919-8.2087-9.6945-.7672-.2487-1.5836-.42-2.4985-.5232-.169-.0176-1.0835-.0366-1.6123-.037zm4.0685 7.217c.3473 0 .4082.0053.4857.047.1127.0562.204.1642.237.2767.0186.061.0234 1.3653.0186 4.3044l-.0067 4.2175-.7436-1.14-.7461-1.14v-3.066c0-1.982.0093-3.0963.0234-3.1502.0375-.1313.1196-.2346.2323-.2955.0961-.0494.1313-.054.4997-.054z" />
</svg>`, AF = `<svg fill="currentColor" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <title>React</title>
    <path
        d="M14.23 12.004a2.236 2.236 0 0 1-2.235 2.236 2.236 2.236 0 0 1-2.236-2.236 2.236 2.236 0 0 1 2.235-2.236 2.236 2.236 0 0 1 2.236 2.236zm2.648-10.69c-1.346 0-3.107.96-4.888 2.622-1.78-1.653-3.542-2.602-4.887-2.602-.41 0-.783.093-1.106.278-1.375.793-1.683 3.264-.973 6.365C1.98 8.917 0 10.42 0 12.004c0 1.59 1.99 3.097 5.043 4.03-.704 3.113-.39 5.588.988 6.38.32.187.69.275 1.102.275 1.345 0 3.107-.96 4.888-2.624 1.78 1.654 3.542 2.603 4.887 2.603.41 0 .783-.09 1.106-.275 1.374-.792 1.683-3.263.973-6.365C22.02 15.096 24 13.59 24 12.004c0-1.59-1.99-3.097-5.043-4.032.704-3.11.39-5.587-.988-6.38-.318-.184-.688-.277-1.092-.278zm-.005 1.09v.006c.225 0 .406.044.558.127.666.382.955 1.835.73 3.704-.054.46-.142.945-.25 1.44-.96-.236-2.006-.417-3.107-.534-.66-.905-1.345-1.727-2.035-2.447 1.592-1.48 3.087-2.292 4.105-2.295zm-9.77.02c1.012 0 2.514.808 4.11 2.28-.686.72-1.37 1.537-2.02 2.442-1.107.117-2.154.298-3.113.538-.112-.49-.195-.964-.254-1.42-.23-1.868.054-3.32.714-3.707.19-.09.4-.127.563-.132zm4.882 3.05c.455.468.91.992 1.36 1.564-.44-.02-.89-.034-1.345-.034-.46 0-.915.01-1.36.034.44-.572.895-1.096 1.345-1.565zM12 8.1c.74 0 1.477.034 2.202.093.406.582.802 1.203 1.183 1.86.372.64.71 1.29 1.018 1.946-.308.655-.646 1.31-1.013 1.95-.38.66-.773 1.288-1.18 1.87-.728.063-1.466.098-2.21.098-.74 0-1.477-.035-2.202-.093-.406-.582-.802-1.204-1.183-1.86-.372-.64-.71-1.29-1.018-1.946.303-.657.646-1.313 1.013-1.954.38-.66.773-1.286 1.18-1.868.728-.064 1.466-.098 2.21-.098zm-3.635.254c-.24.377-.48.763-.704 1.16-.225.39-.435.782-.635 1.174-.265-.656-.49-1.31-.676-1.947.64-.15 1.315-.283 2.015-.386zm7.26 0c.695.103 1.365.23 2.006.387-.18.632-.405 1.282-.66 1.933-.2-.39-.41-.783-.64-1.174-.225-.392-.465-.774-.705-1.146zm3.063.675c.484.15.944.317 1.375.498 1.732.74 2.852 1.708 2.852 2.476-.005.768-1.125 1.74-2.857 2.475-.42.18-.88.342-1.355.493-.28-.958-.646-1.956-1.1-2.98.45-1.017.81-2.01 1.085-2.964zm-13.395.004c.278.96.645 1.957 1.1 2.98-.45 1.017-.812 2.01-1.086 2.964-.484-.15-.944-.318-1.37-.5-1.732-.737-2.852-1.706-2.852-2.474 0-.768 1.12-1.742 2.852-2.476.42-.18.88-.342 1.356-.494zm11.678 4.28c.265.657.49 1.312.676 1.948-.64.157-1.316.29-2.016.39.24-.375.48-.762.705-1.158.225-.39.435-.788.636-1.18zm-9.945.02c.2.392.41.783.64 1.175.23.39.465.772.705 1.143-.695-.102-1.365-.23-2.006-.386.18-.63.406-1.282.66-1.933zM17.92 16.32c.112.493.2.968.254 1.423.23 1.868-.054 3.32-.714 3.708-.147.09-.338.128-.563.128-1.012 0-2.514-.807-4.11-2.28.686-.72 1.37-1.536 2.02-2.44 1.107-.118 2.154-.3 3.113-.54zm-11.83.01c.96.234 2.006.415 3.107.532.66.905 1.345 1.727 2.035 2.446-1.595 1.483-3.092 2.295-4.11 2.295-.22-.005-.406-.05-.553-.132-.666-.38-.955-1.834-.73-3.703.054-.46.142-.944.25-1.438zm4.56.64c.44.02.89.034 1.345.034.46 0 .915-.01 1.36-.034-.44.572-.895 1.095-1.345 1.565-.455-.47-.91-.993-1.36-1.565z" />
</svg>`, EF = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g><path d="M23.94 3a.5.5 0 0 0-.44-.25h-2.31l-8.55 13.91a.75.75 0 0 1-1.28 0L2.81 2.77H.5A.5.5 0 0 0 .06 3a.54.54 0 0 0 0 .51l11.5 19a.51.51 0 0 0 .86 0l11.5-19a.54.54 0 0 0 .02-.51Z" fill="currentColor"></path><path d="m12 14.84 7.43-12.07H16a.47.47 0 0 0-.43.25L12 9.26 8.43 3A.47.47 0 0 0 8 2.77H4.57Z" fill="currentColor"></path></g></svg>', RF = `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128">
    <path
        d="M117.5 33.5l.3-.2c-.6-1.1-1.5-2.1-2.4-2.6L67.1 2.9c-.8-.5-1.9-.7-3.1-.7-1.2 0-2.3.3-3.1.7l-48 27.9c-1.7 1-2.9 3.5-2.9 5.4v55.7c0 1.1.2 2.3.9 3.4l-.2.1c.5.8 1.2 1.5 1.9 1.9l48.2 27.9c.8.5 1.9.7 3.1.7 1.2 0 2.3-.3 3.1-.7l48-27.9c1.7-1 2.9-3.5 2.9-5.4V36.1c.1-.8 0-1.7-.4-2.6zM64 88.5c9.1 0 17.1-5 21.3-12.4l12.9 7.6c-6.8 11.8-19.6 19.8-34.2 19.8-21.8 0-39.5-17.7-39.5-39.5S42.2 24.5 64 24.5c14.7 0 27.5 8.1 34.3 20l-13 7.5C81.1 44.5 73.1 39.5 64 39.5c-13.5 0-24.5 11-24.5 24.5s11 24.5 24.5 24.5z"
        fill="currentColor" />
</svg>`, IF = `<svg viewBox="0 0 128 128">
    <path
        d="M60.952.266C27.377.266.065 28.77.065 63.806s27.318 63.54 60.887 63.54c33.576 0 60.893-28.505 60.893-63.54S94.528.266 60.952.266zm0 6.117c30.39 0 55.025 25.712 55.025 57.423 0 2.482-.167 4.924-.46 7.321-1.495 6.214-4.194 10.358-7.412 13.19-4.941 4.336-11.524 5.738-17.62 5.733a41.444 41.444 0 01-4.973-.289C97.506 77.4 99.336 57.866 89.864 43.315 80.39 28.763 62.315 23.338 46.882 30.416a23.787 23.787 0 00-1.68-1.114c-2.41-1.413-7.439-3.482-13.837-3.505-5.361-.022-10.615 1.568-15.133 4.58C26.554 15.317 43.21 6.386 60.952 6.394v-.011zM51.341 84.6c.894-4.07 3.343-10.431 5.548-15.655.623-1.481 1.23-2.872 1.777-4.104 3.451 12.822 5.635 20.449 9.546 25.65a17.884 17.884 0 001.913 2.114 28.056 28.056 0 01-9.173 1.56 28.176 28.176 0 01-10.023-1.86c-.065-.817-.1-1.638-.103-2.459a24.45 24.45 0 01.515-5.24V84.6zm-7.444 3.77c-7.555-5.703-12.031-14.84-12.04-24.57.008-9.88 4.625-19.138 12.375-24.813 1.637.984 3.121 2.143 4.34 3.477 2.395 2.56 5.077 8.214 6.94 13.082.51 1.312.965 2.567 1.36 3.709C50.16 73.502 45.685 80.608 43.898 88.37zm21.802-18.226c-1.501-4.037-2.374-7.079-2.379-7.084l-.005-.012c-2.747-10.984-5.592-21.025-11.497-28.052a27.998 27.998 0 019.134-1.55c16.06.022 29.074 13.602 29.095 30.36-.007 9.673-4.432 18.764-11.914 24.474a14.975 14.975 0 01-2.184-.78c-1.137-.514-2.812-2.267-4.329-4.698-2.313-3.635-4.437-8.622-5.927-12.653l.006-.005zm-4.747 51.08c-30.39 0-55.025-25.707-55.025-57.424 0-2.086.114-4.144.32-6.173 4.508-16 15.338-21.92 25.595-22.02 2.08-.007 4.117.282 6.068.774-13.182 12.081-15.74 32.487-5.979 47.7 9.762 15.213 28.817 20.518 44.544 12.403 2.78 1.023 5.96 1.633 9.812 2.137 1.447.186 3.007.277 4.665.277a61.612 61.612 0 0014.997-2.087c-10.29 15.308-27.088 24.417-45.007 24.407l.01.006z"
        fill="currentColor" />
</svg>`, jF = `<svg fill="currentColor" viewBox="0 0 128 128">
    <path
        d="M117.5 33.5l.3-.2c-.6-1.1-1.5-2.1-2.4-2.6L67.1 2.9c-.8-.5-1.9-.7-3.1-.7-1.2 0-2.3.3-3.1.7l-48 27.9c-1.7 1-2.9 3.5-2.9 5.4v55.7c0 1.1.2 2.3.9 3.4l-.2.1c.5.8 1.2 1.5 1.9 1.9l48.2 27.9c.8.5 1.9.7 3.1.7 1.2 0 2.3-.3 3.1-.7l48-27.9c1.7-1 2.9-3.5 2.9-5.4V36.1c.1-.8 0-1.7-.4-2.6zm-53.5 70c-21.8 0-39.5-17.7-39.5-39.5S42.2 24.5 64 24.5c14.7 0 27.5 8.1 34.3 20l-13 7.5C81.1 44.5 73.1 39.5 64 39.5c-13.5 0-24.5 11-24.5 24.5s11 24.5 24.5 24.5c9.1 0 17.1-5 21.3-12.4l12.9 7.6c-6.8 11.8-19.6 19.8-34.2 19.8zM115 62h-3.2l-.9 4h4.1v5h-5l-1.2 6h-4.9l1.2-6h-3.8l-1.2 6h-4.8l1.2-6H94v-5h3.5l.9-4H94v-5h5.3l1.2-6h4.9l-1.2 6h3.8l1.2-6h4.8l-1.2 6h2.2v5zm-12.7 4h3.8l.9-4h-3.8z" />
</svg>`, ZF = `<svg fill="currentColor" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <path
        d="M1.5 0h21l-1.91 21.563L11.977 24l-8.565-2.438L1.5 0zm17.09 4.413L5.41 4.41l.213 2.622 10.125.002-.255 2.716h-6.64l.24 2.573h6.182l-.366 3.523-2.91.804-2.956-.81-.188-2.11h-2.61l.29 3.855L12 19.288l5.373-1.53L18.59 4.414z" />
</svg>`, MF = `<svg fill="currentColor" viewBox="0 0 128 128">
    <path
        d="M108.2 64.8c-.1-.1-.2-.2-.4-.2l-.1-.1c-.1-.1-.2-.1-.2-.2l-.1-.1c-.1 0-.2-.1-.2-.1l-.2-.1c-.1 0-.2-.1-.2-.1l-.2-.1c-.1 0-.2-.1-.2-.1-.1 0-.1 0-.2-.1l-.3-.1c-.1 0-.1 0-.2-.1l-.3-.1h-.1l-.4-.1h-.2c-.1 0-.2 0-.3-.1h-2.3c-.6-13.3.6-26.8-2.8-39.6 12.9-4.6 2.8-22.3-8.4-14.4-7.4-6.4-17.6-7.8-28.3-7.8-10.5.7-20.4 2.9-27.4 8.4-2.8-1.4-5.5-1.8-7.9-1.1v.1c-.1 0-.3.1-.4.2-.1 0-.3.1-.4.2h-.1c-.1 0-.2.1-.4.2h-.1l-.3.2h-.1l-.3.2h-.1l-.3.2s-.1 0-.1.1l-.3.2s-.1 0-.1.1l-.3.2s-.1 0-.1.1l-.3.2-.1.1c-.1.1-.2.1-.2.2l-.1.1-.2.2-.1.1c-.1.1-.1.2-.2.2l-.1.1c-.1.1-.1.2-.2.2l-.1.1c-.1.1-.1.2-.2.2l-.1.1c-.1.1-.1.2-.2.2l-.1.1c-.1.1-.1.2-.2.2l-.1.1-.1.3s0 .1-.1.1l-.1.3s0 .1-.1.1l-.1.3s0 .1-.1.1l-.1.3s0 .1-.1.1c.4.3.4.4.4.4v.1l-.1.3v.1c0 .1 0 .2-.1.3v3.1c0 .1 0 .2.1.3v.1l.1.3v.1l.1.3s0 .1.1.1l.1.3s0 .1.1.1l.1.3s0 .1.1.1l.2.3s0 .1.1.1l.2.3s0 .1.1.1l.2.3.1.1.3.3.3.3h.1c1 .9 2 1.6 4 2.2v-.2C23 37.3 26.5 50 26.7 63c-.6 0-.7.4-1.7.5h-.5c-.1 0-.3 0-.5.1-.1 0-.3 0-.4.1l-.4.1h-.1l-.4.1h-.1l-.3.1h-.1l-.3.1s-.1 0-.1.1l-.3.1-.2.1c-.1 0-.2.1-.2.1l-.2.1-.2.1c-.1 0-.2.1-.2.1l-.2.1-.4.3c-.1.1-.2.2-.3.2l-.4.4-.1.1c-.1.2-.3.4-.4.5l-.2.3-.3.6-.1.3v.3c0 .5.2.9.9 1.2.2 3.7 3.9 2 5.6.8l.1-.1c.2-.2.5-.3.6-.3h.1l.2-.1c.1 0 .1 0 .2-.1.2-.1.4-.1.5-.2.1 0 .1-.1.1-.2l.1-.1c.1-.2.2-.6.2-1.2l.1-1.3v1.8c-.5 13.1-4 30.7 3.3 42.5 1.3 2.1 2.9 3.9 4.7 5.4h-.5c-.2.2-.5.4-.8.6l-.9.6-.3.2-.6.4-.9.7-1.1 1c-.2.2-.3.4-.4.5l-.4.6-.2.3c-.1.2-.2.4-.2.6l-.1.3c-.2.8 0 1.7.6 2.7l.4.4h.2c.1 0 .2 0 .4.1.2.4 1.2 2.5 3.9.9 2.8-1.5 4.7-4.6 8.1-5.1l-.5-.6c5.9 2.8 12.8 4 19 4.2 8.7.3 18.6-.9 26.5-5.2 2.2.7 3.9 3.9 5.8 5.4l.1.1.1.1.1.1.1.1s.1 0 .1.1c0 0 .1 0 .1.1 0 0 .1 0 .1.1h2.1s.1 0 .1-.1h.1s.1 0 .1-.1h.1s.1 0 .1-.1c0 0 .1 0 .1-.1l.1-.1s.1 0 .1-.1l.1-.1h.1l.2-.2.2-.1h.1l.1-.1h.1l.1-.1.1-.1.1-.1.1-.1.1-.1.1-.1.1-.1v-.1s0-.1.1-.1v-.1s0-.1.1-.1v-.1s0-.1.1-.1v-1.4s-.3 0-.3-.1l-.3-.1v-.1l.3-.1s.2 0 .2-.1l.1-.1v-2.1s0-.1-.1-.1v-.1s0-.1-.1-.1v-.1s0-.1-.1-.1c0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1 0 0 0-.1-.1-.1l-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1v-.1l-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1-.1c2-1.9 3.8-4.2 5.1-6.9 5.9-11.8 4.9-26.2 4.1-39.2h.1c.1 0 .2.1.2.1h.3s.1 0 .1.1h.1s.1 0 .1.1l.2.1c1.7 1.2 5.4 2.9 5.6-.8 1.6.6-.3-1.8-1.3-2.5zM36 23C32.8 7 58.4 4 59.3 19.6c.8 13-20 16.3-23.3 3.4zm36.1 15c-1.3 1.4-2.7 1.2-4.1.7 0 1.9.4 3.9.1 5.9-.5.9-1.5 1-2.3 1.4-1.2-.2-2.1-.9-2.6-2l-.2-.1c-3.9 5.2-6.3-1.1-5.2-5-1.2.1-2.2-.2-3-1.5-1.4-2.6.7-5.8 3.4-6.3.7 3 8.7 2.6 10.1-.2 3.1 1.5 6.5 4.3 3.8 7.1zm-7-17.5c-.9-13.8 20.3-17.5 23.4-4 3.5 15-20.8 18.9-23.4 4zM41.7 17c-1.9 0-3.5 1.7-3.5 3.8 0 2.1 1.6 3.8 3.5 3.8s3.5-1.7 3.5-3.8c0-2.1-1.5-3.8-3.5-3.8zm1.6 5.7c-.5 0-.8-.4-.8-1 0-.5.4-1 .8-1 .5 0 .8.4.8 1 0 .5-.3 1-.8 1zm27.8-6.6c-1.9 0-3.4 1.7-3.4 3.8 0 2.1 1.5 3.8 3.4 3.8s3.4-1.7 3.4-3.8c0-2.1-1.5-3.8-3.4-3.8zm1.6 5.6c-.4 0-.8-.4-.8-1 0-.5.4-1 .8-1s.8.4.8 1-.4 1-.8 1z" />
</svg>`, qF = `<svg fill="currentColor" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <path
        d="M1.5 0h21l-1.91 21.563L11.977 24l-8.564-2.438L1.5 0zm7.031 9.75l-.232-2.718 10.059.003.23-2.622L5.412 4.41l.698 8.01h9.126l-.326 3.426-2.91.804-2.955-.81-.188-2.11H6.248l.33 4.171L12 19.351l5.379-1.443.744-8.157H8.531z" />
</svg>`, NF = `<svg width="373.7" height="200" viewBox="0 0 373.7 200" xmlns="http://www.w3.org/2000/svg">
    <path
        d="m326 0 47.7 100L326 200H47.7L0 100 47.7 0H326Zm-16 16.6H58.3L18.4 100l39.8 83.4h251.9l39.7-83.4L310 16.6ZM87.3 72v23.5h27V71.9h13.9v59.5h-13.8V107h-27v24.4H73.5V72h13.7Zm100.1 0V83h-19v48.3h-13.8V83.1h-19V72h51.8Zm53.4 0V83h-19v48.3h-13.8V83.1h-19V72h51.8Zm47 2.6c3.6 1.6 6.7 4.2 9 7.5 2 3.4 3.2 7.4 3 11.5.2 4-1 8-3 11.4a20 20 0 0 1-9 7.5c-4.4 1.8-9.1 2.7-13.8 2.6h-12v16.4H248V72H274a33 33 0 0 1 13.7 2.6ZM273 83.1H262v20.7H273c4.2 0 7.3-1 9.5-2.7a9.3 9.3 0 0 0 3.2-7.6c0-3.3-1-6-3.2-7.7-2.2-1.8-5.3-2.7-9.5-2.7Z"
        fill="currentColor" fill-rule="nonzero" />
</svg>`, DF = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <path
        d="M11.26 15.27c3.37-.15 7.15-1.09 7-2.21a25.93 25.93 0 0 1-4.76.59c-3.62.16-6.58-.24-6.61-.9 0-.2.24-.4.69-.58-2.39-.64-3.67.53-3.69 1.22-.1 1.45 3.22 2.06 7.37 1.88Z"
        fill="currentColor"></path>
    <path
        d="M17.17 16.91a23 23 0 0 1-4.07.5c-3.09.14-5.61-.21-5.64-.77 0-.17.21-.34.59-.49-2-.55-3.13.45-3.15 1-.05 1.24 2.78 1.77 6.33 1.61 2.87-.1 6.25-1 5.94-1.85Z"
        fill="currentColor"></path>
    <path
        d="M3.61 20.8a.93.93 0 0 1 .29-.65c-2.09.1-2.54 1.13-2.51 1.76.07 1.39 4.67 2.31 10 2.05 4.44-.22 9.16-1 9.16-2.34a26.34 26.34 0 0 1-7.2 1.23c-5.35.26-9.67-.66-9.74-2.05Z"
        fill="currentColor"></path>
    <path
        d="M22.4 12.65c-.55-1.48-2.67-2.34-4.74-1.57a2.47 2.47 0 0 0-1 .81c1.94-.56 3.83 0 4.34 1.41.45 1.21-.3 2.64-1.72 3.54a1.37 1.37 0 0 0 .92-.13c2.25-1.05 2.8-2.58 2.2-4.06Z"
        fill="currentColor"></path>
    <path d="M12.52 11.27s-3.1-2.19-1.92-4.35S14.37 2.43 13.38 0c0 0 .12 1-3.12 3.91s-2.14 6.33 2.26 7.36Z"
        fill="currentColor"></path>
    <path d="M15.17 4.83s-4.24 1.51-2.83 3.53c1 1.43 2.13 2 1.42 4 0 0 2.83-1.51.71-3.53s.7-4 .7-4Z"
        fill="currentColor"></path>
    <path
        d="M8.69 19.26c-1.6-.43-2.46.35-2.47.81 0 1 2.18 1.39 5 1.27 2.26-.11 4.73-.95 4.67-1.49a16.59 16.59 0 0 1-3.2.4c-2.43.11-4.41-.16-4.43-.61-.04-.13.13-.26.43-.38Z"
        fill="currentColor"></path>
</svg>`, zF = `<svg fill="currentColor" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <path
        d="M0 0h24v24H0V0zm22.034 18.276c-.175-1.095-.888-2.015-3.003-2.873-.736-.345-1.554-.585-1.797-1.14-.091-.33-.105-.51-.046-.705.15-.646.915-.84 1.515-.66.39.12.75.42.976.9 1.034-.676 1.034-.676 1.755-1.125-.27-.42-.404-.601-.586-.78-.63-.705-1.469-1.065-2.834-1.034l-.705.089c-.676.165-1.32.525-1.71 1.005-1.14 1.291-.811 3.541.569 4.471 1.365 1.02 3.361 1.244 3.616 2.205.24 1.17-.87 1.545-1.966 1.41-.811-.18-1.26-.586-1.755-1.336l-1.83 1.051c.21.48.45.689.81 1.109 1.74 1.756 6.09 1.666 6.871-1.004.029-.09.24-.705.074-1.65l.046.067zm-8.983-7.245h-2.248c0 1.938-.009 3.864-.009 5.805 0 1.232.063 2.363-.138 2.711-.33.689-1.18.601-1.566.48-.396-.196-.597-.466-.83-.855-.063-.105-.11-.196-.127-.196l-1.825 1.125c.305.63.75 1.172 1.324 1.517.855.51 2.004.675 3.207.405.783-.226 1.458-.691 1.811-1.411.51-.93.402-2.07.397-3.346.012-2.054 0-4.109 0-6.179l.004-.056z" />
</svg>`, XF = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <path
        d="M4.56 18.71c-1.41-4-.65-8.94 1.77-11.48A5.47 5.47 0 0 1 12 5.71h.15a.78.78 0 0 1 .22.12c4 1.65 4.28 8.57 1.28 11.41a4.15 4.15 0 0 0 3.08-1.35c2.12-2.23 2.76-6.62 1.49-10.22A7.75 7.75 0 0 0 12.81.54H12a11.5 11.5 0 0 0-5.42 21.6 10 10 0 0 1-2.02-3.43Z"
        fill="currentColor"></path>
    <path
        d="M23.5 12a11.49 11.49 0 0 0-6.09-10.14 9.86 9.86 0 0 1 2 3.43c1.41 4 .65 9-1.77 11.5a5.42 5.42 0 0 1-4 1.75A6.53 6.53 0 0 1 12 18.3h-.15a.78.78 0 0 1-.22-.12c-4-1.65-4.29-8.57-1.29-11.41a4.14 4.14 0 0 0-3.11 1.32c-2.12 2.22-2.76 6.61-1.49 10.2a7.77 7.77 0 0 0 5.45 5.17H12A11.5 11.5 0 0 0 23.5 12Z"
        fill="currentColor"></path>
</svg>`, WF = `<svg viewBox="0 0 128 128" fill="currentColor">
    <path d="M0 0h61.4L0 60.4zM0 128L128 0H64.6L0 63.7zM128 128L64.6 66.6 3.3 128z" />
</svg>`, UF = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <g>
        <path
            d="M21.75 5.52 13 .28a2 2 0 0 0-2 0L2.25 5.52a2 2 0 0 0-1 1.69v9.58a2 2 0 0 0 1 1.69l2.62 1.57a3.12 3.12 0 0 0 4.73-2.68V8.12a1 1 0 0 0-2 0v9.25a1.13 1.13 0 0 1-.57 1 1.14 1.14 0 0 1-1.13 0l-2.61-1.58V7.24L12 2l8.73 5.21v9.55L12 22l-1.7-1a1 1 0 1 0-1 1.71l1.72 1a2 2 0 0 0 2 0l8.74-5.24a2 2 0 0 0 1-1.69V7.21a2 2 0 0 0-1.01-1.69Z"
            fill="currentColor"></path>
        <path
            d="M15.51 14.76a9.33 9.33 0 0 1-2.24 0 .85.85 0 0 1-.75-.85 1 1 0 0 0-2 0A2.87 2.87 0 0 0 13 16.75a11.84 11.84 0 0 0 1.36.08 12.16 12.16 0 0 0 1.37-.08 2.87 2.87 0 0 0 2.5-2.84A2.68 2.68 0 0 0 16 11.26l-2.91-.49a.69.69 0 0 1-.58-.68.85.85 0 0 1 .75-.85 9.33 9.33 0 0 1 2.24 0 .85.85 0 0 1 .75.85 1 1 0 0 0 2 0 2.87 2.87 0 0 0-2.5-2.84 12.46 12.46 0 0 0-2.73 0 2.87 2.87 0 0 0-2.51 2.84 2.68 2.68 0 0 0 2.25 2.65l2.91.49a.68.68 0 0 1 .58.68.85.85 0 0 1-.74.85Z"
            fill="currentColor"></path>
    </g>
</svg>`, VF = `<svg viewBox="0 0 128 128" fill="currentColor">
    <path
        d="M63.877 125.392c-32.671 0-60.37-27.594-60.627-60.469a59.94 59.94 0 0117.506-42.759 60.939 60.939 0 0143.279-18.36 60.081 60.081 0 0142.647 17.71 60.145 60.145 0 0118.157 42.522c.151 33.604-26.864 61.021-60.469 61.363h-.493zm.19-118.406a57.774 57.774 0 00-41.01 17.427 56.775 56.775 0 00-16.63 40.484c.236 31.159 26.495 57.286 57.43 57.286h.414c31.863-.29 57.504-26.266 57.385-58.128a56.97 56.97 0 00-17.217-40.273A56.7 56.7 0 0064.068 6.986z" />
    <path
        d="M16.89 82.383V46.865h8.64v3.183h-4.583v29.218h4.584v3.183l-8.642-.066zM46.213 64.272c0 6.478-3.933 10.167-9.26 10.167s-8.877-4.156-8.877-9.831c0-5.939 3.722-10.121 9.167-10.121s8.97 4.36 8.97 9.785zm-14.415.29c0 3.932 1.973 7.05 5.36 7.05s5.333-3.183 5.333-7.195c0-3.643-1.796-7.083-5.334-7.083s-5.392 3.328-5.392 7.307l.033-.08zM49.205 55.158c1.69-.29 3.407-.434 5.123-.428a9.17 9.17 0 015.537 1.223 4.062 4.062 0 012.006 3.61 4.48 4.48 0 01-3.183 4.183c2.269.46 3.9 2.46 3.9 4.775a5.016 5.016 0 01-1.861 3.978c-1.368 1.21-3.643 1.796-7.162 1.796a33.966 33.966 0 01-4.327-.257l-.033-18.88zm3.499 7.622h1.795c2.433 0 3.801-1.145 3.801-2.782 0-1.638-1.368-2.644-3.61-2.644a9.779 9.779 0 00-2.006.145l.02 5.28zm0 8.878c.618.065 1.243.092 1.86.078 2.263 0 4.262-.861 4.262-3.182s-1.94-3.183-4.373-3.183h-1.75v6.287zM69.54 54.901h3.517v12.554c0 5.334-2.577 7.116-6.365 7.116a9.313 9.313 0 01-2.973-.507l.428-2.834c.703.224 1.44.335 2.183.349 2.006 0 3.183-.921 3.183-4.262l.026-12.416zM83.067 65.357v2.434h-7.32v-2.434h7.32zM100.158 73.63c-1.585.632-3.281.921-4.978.862-6.129 0-9.851-3.834-9.851-9.707-.283-5.353 3.827-9.923 9.18-10.206.375-.02.757-.02 1.131.006a11.112 11.112 0 014.775.862l-.783 2.801a9.476 9.476 0 00-3.788-.75c-3.932 0-6.76 2.467-6.76 7.116 0 4.235 2.499 6.971 6.734 6.971a9.806 9.806 0 003.834-.717l.506 2.762zM111.2 46.766v35.61h-8.641v-3.182h4.583V49.949h-4.583v-3.183h8.64z" />
</svg>`, LF = `<svg fill="currentColor" viewBox="0 0 128 128">
    <path
        d="M65.004 115.355c-.461-.894-1.004-2.796-1.356-3.601-.378-.711-1.46-2.692-1.984-3.332-1.164-1.332-1.437-1.438-1.809-3.23-.628-3.067-2.148-8.462-4.042-12.227-1.004-2-2.626-3.606-4.067-5.07-1.246-1.247-4.121-3.31-4.668-3.227-4.766.894-6.226 5.586-8.457 9.27-1.27 2.062-2.516 3.769-3.52 5.937-.898 1.98-.812 4.23-2.331 5.938a15.44 15.44 0 00-3.333 5.855c-.195.453-.546 4.957-1.003 6.016l7.02-.438c6.585.461 4.687 2.961 14.858 2.438l16.098-.54a24.864 24.864 0 00-1.433-3.792zM111.793 8.254H16.207C7.312 8.23.086 15.457.086 24.352v35.105c2.352-.812 5.578-5.75 6.668-6.934 1.789-2.062 2.16-4.77 3.059-6.378 2.062-3.793 2.433-6.477 7.101-6.477 2.164 0 3.063.516 4.5 2.516.996 1.332 2.79 3.957 3.602 5.668 1.004 1.98 2.523 4.582 3.254 5.125.515.351.972.722 1.433.894.707.27 1.356-.27 1.902-.629.622-.539.895-1.52 1.52-2.953.895-2.086 1.813-4.418 2.332-5.312.914-1.461 1.273-3.254 2.25-4.067 1.461-1.246 3.441-1.355 3.957-1.437 2.98-.625 4.336 1.437 5.777 2.707.973.894 2.243 2.605 3.246 4.851.708 1.793 1.606 3.52 2.067 4.5.351.98 1.266 2.606 1.789 4.582.543 1.711 1.809 3.067 2.352 3.961 0 0 .812 2.164 5.476 4.145a34.992 34.992 0 004.336 1.52c2.066.734 4.047.644 6.563.374 1.789 0 2.793-2.625 3.601-4.683.438-1.254.98-4.774 1.25-5.758.27-.996-.437-1.707.192-2.625.722-.977 1.164-1.082 1.519-2.332.914-2.793 5.957-2.875 8.832-2.875 2.414 0 2.063 2.332 6.125 1.52 2.336-.434 4.586.273 7.023.995 2.063.543 4.043 1.168 5.204 2.524.73.898 2.629 5.312.73 5.476.164.188.36.645.625.817-.46 1.707-2.25.46-3.332.27-1.355-.27-2.332 0-3.684.624-2.335.996-5.668.918-7.726 2.625-1.715 1.438-1.715 4.582-2.543 6.371 0 0-2.254 5.696-6.996 9.192-1.278.914-3.715 3.058-8.918 3.871-2.356.355-4.586.355-7.024.27-1.164-.079-2.332-.079-3.52-.079-.706 0-3.062-.109-2.96.164l-.27.645c.024.29.063.602.164.895.102.515.102.976.192 1.437 0 .98-.086 2.063 0 3.066.082 2.063.894 3.957 1.004 6.102.078 2.355 1.246 4.875 2.414 6.77.46.707 1.086.789 1.355 1.71.352.98 0 2.141.188 3.227.625 4.227 1.875 8.73 3.773 12.61v.078c2.332-.352 4.77-1.247 7.836-1.684 5.664-.832 13.5-.461 18.54-.914 12.796-1.168 19.706 5.226 31.148 2.601V24.336c-.063-8.895-7.293-16.102-16.207-16.102zM64.086 83.855c0-.187 0-.187 0 0zm-34.457 14.75c.894-1.98 1.433-4.125 2.144-6.101.73-1.899 1.813-4.61 3.684-5.582-.246-.274-3.957-.375-4.934-.461-1.082-.086-2.171-.273-3.25-.438a135.241 135.241 0 01-6.125-1.265c-1.168-.274-5.21-1.715-6.02-2.067-2.085-.894-3.421-3.52-4.96-3.246-.977.188-1.98.54-2.605 1.54-.543.812-.731 2.242-1.083 3.226-.437 1.086-1.168 2.164-1.707 3.25-1.277 1.875-3.332 3.582-4.23 5.484-.191.457-.27.895-.457 1.356v21.683c1.082.188 2.16.371 3.328.73 8.996 2.438 11.164 2.606 19.98 1.63l.813-.11c.625-1.437 1.188-6.207 1.629-7.644.352-1.164.812-2.063.996-3.14.164-1.09 0-2.173-.102-3.15-.171-2.628 1.895-3.519 2.899-5.69zm0 0" />
</svg>`, YF = `<svg fill="currentColor" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <path
        d="M7.01 10.207h-.944l-.515 2.648h.838c.556 0 .97-.105 1.242-.314.272-.21.455-.559.55-1.049.092-.47.05-.802-.124-.995-.175-.193-.523-.29-1.047-.29zM12 5.688C5.373 5.688 0 8.514 0 12s5.373 6.313 12 6.313S24 15.486 24 12c0-3.486-5.373-6.312-12-6.312zm-3.26 7.451c-.261.25-.575.438-.917.551-.336.108-.765.164-1.285.164H5.357l-.327 1.681H3.652l1.23-6.326h2.65c.797 0 1.378.209 1.744.628.366.418.476 1.002.33 1.752a2.836 2.836 0 0 1-.305.847c-.143.255-.33.49-.561.703zm4.024.715l.543-2.799c.063-.318.039-.536-.068-.651-.107-.116-.336-.174-.687-.174H11.46l-.704 3.625H9.388l1.23-6.327h1.367l-.327 1.682h1.218c.767 0 1.295.134 1.586.401s.378.7.263 1.299l-.572 2.944h-1.389zm7.597-2.265a2.782 2.782 0 0 1-.305.847c-.143.255-.33.49-.561.703a2.44 2.44 0 0 1-.917.551c-.336.108-.765.164-1.286.164h-1.18l-.327 1.682h-1.378l1.23-6.326h2.649c.797 0 1.378.209 1.744.628.366.417.477 1.001.331 1.751zM17.766 10.207h-.943l-.516 2.648h.838c.557 0 .971-.105 1.242-.314.272-.21.455-.559.551-1.049.092-.47.049-.802-.125-.995s-.524-.29-1.047-.29z" />
</svg>`, BF = `<svg viewBox="0 0 101 121" xmlns="http://www.w3.org/2000/svg">
  <g fill="none" fill-rule="evenodd">
    <path
      d="M63.69 58.855c-1.543-1.81-3.237-3.894-5.03-5.886-10.174-11.3-20.257-22.684-30.61-33.815C23.31 14.06 21.8 9.114 27.49 4.085c5.623-4.97 11.148-4.53 16.306 1.188C58.162 21.193 72.51 37.13 87.113 52.83c5.452 5.864 4.182 9.851-1.823 14.196-23.049 16.683-45.968 33.547-68.862 50.443-5.146 3.8-10.052 4.75-14.209-.86-4.586-6.19-.343-9.872 4.414-13.336 17.013-12.392 33.993-24.83 50.9-37.366 2.355-1.746 5.736-2.764 6.157-7.05Z"
      fill="currentColor" />
    <path
      d="M70.977 118.723c-6.196 0-12.4.213-18.583-.068-4.932-.223-7.9-2.979-7.838-8.174.06-4.912 2.536-8.605 7.463-8.738 13.542-.363 27.104-.285 40.651-.02 4.305.084 7.483 2.89 7.457 7.375-.03 5.146-2.739 9.133-8.25 9.465-6.944.42-13.93.104-20.899.104v.056Z"
      fill="currentColor" />
  </g>
</svg>`, FF = `<svg fill="currentColor" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <path
        d="M14.25.18l.9.2.73.26.59.3.45.32.34.34.25.34.16.33.1.3.04.26.02.2-.01.13V8.5l-.05.63-.13.55-.21.46-.26.38-.3.31-.33.25-.35.19-.35.14-.33.1-.3.07-.26.04-.21.02H8.77l-.69.05-.59.14-.5.22-.41.27-.33.32-.27.35-.2.36-.15.37-.1.35-.07.32-.04.27-.02.21v3.06H3.17l-.21-.03-.28-.07-.32-.12-.35-.18-.36-.26-.36-.36-.35-.46-.32-.59-.28-.73-.21-.88-.14-1.05-.05-1.23.06-1.22.16-1.04.24-.87.32-.71.36-.57.4-.44.42-.33.42-.24.4-.16.36-.1.32-.05.24-.01h.16l.06.01h8.16v-.83H6.18l-.01-2.75-.02-.37.05-.34.11-.31.17-.28.25-.26.31-.23.38-.2.44-.18.51-.15.58-.12.64-.1.71-.06.77-.04.84-.02 1.27.05zm-6.3 1.98l-.23.33-.08.41.08.41.23.34.33.22.41.09.41-.09.33-.22.23-.34.08-.41-.08-.41-.23-.33-.33-.22-.41-.09-.41.09zm13.09 3.95l.28.06.32.12.35.18.36.27.36.35.35.47.32.59.28.73.21.88.14 1.04.05 1.23-.06 1.23-.16 1.04-.24.86-.32.71-.36.57-.4.45-.42.33-.42.24-.4.16-.36.09-.32.05-.24.02-.16-.01h-8.22v.82h5.84l.01 2.76.02.36-.05.34-.11.31-.17.29-.25.25-.31.24-.38.2-.44.17-.51.15-.58.13-.64.09-.71.07-.77.04-.84.01-1.27-.04-1.07-.14-.9-.2-.73-.25-.59-.3-.45-.33-.34-.34-.25-.34-.16-.33-.1-.3-.04-.25-.02-.2.01-.13v-5.34l.05-.64.13-.54.21-.46.26-.38.3-.32.33-.24.35-.2.35-.14.33-.1.3-.06.26-.04.21-.02.13-.01h5.84l.69-.05.59-.14.5-.21.41-.28.33-.32.27-.35.2-.36.15-.36.1-.35.07-.32.04-.28.02-.21V6.07h2.09l.14.01zm-6.47 14.25l-.23.33-.08.41.08.41.23.33.33.23.41.08.41-.08.33-.23.23-.33.08-.41-.08-.41-.23-.33-.33-.23-.41-.08-.41.08z" />
</svg>`, HF = `<svg fill="currentColor" viewBox="0 0 128 128">
  <path
    d="M64 14.648c-35.346 0-64 19.19-64 42.863C0 78.275 22.046 95.589 51.316 99.53V86.699c-15.55-4.89-26.166-14.693-26.166-25.991 0-16.183 21.779-29.303 48.646-29.303 26.866 0 46.693 8.975 46.693 29.303 0 10.486-5.273 17.95-14.066 22.72 1.204.908 2.22 2.072 2.904 3.419l.388.655C121.025 79.772 128 69.189 128 57.51c0-23.672-28.654-42.863-64-42.863zm20.1 74.88c-2.612.257-5.322.41-8.114.462l.002 9.63a88.362 88.362 0 0012.474-2.492l-.501-.941c-.68-1.268-1.347-2.543-2.033-3.807a41.01 41.01 0 00-1.828-2.851z" />
  <path
    d="M97.469 81.036s3.874 1.169 6.124 2.307c.78.396 2.132 1.184 3.106 2.22a8.388 8.388 0 011.42 2.04l15.266 25.74-24.674.01-11.537-21.666s-2.363-4.06-3.817-5.237c-1.213-.982-1.73-1.331-2.929-1.331h-5.862l.004 28.219-21.834.009V41.263h43.845s19.97.36 19.97 19.359S97.47 81.035 97.47 81.035zm-9.497-24.137l-13.218-.009-.006 12.257 13.224-.004s6.124-.019 6.124-6.235c0-6.34-6.124-6.01-6.124-6.01z"
    fill-rule="evenodd" />
</svg>`, GF = `<svg fill="currentColor" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <title>Ruby</title>
    <path
        d="M20.156.083c3.033.525 3.893 2.598 3.829 4.77L24 4.822 22.635 22.71 4.89 23.926h.016C3.433 23.864.15 23.729 0 19.139l1.645-3 2.819 6.586.503 1.172 2.805-9.144-.03.007.016-.03 9.255 2.956-1.396-5.431-.99-3.9 8.82-.569-.615-.51L16.5 2.114 20.159.073l-.003.01zM0 19.089zM5.13 5.073c3.561-3.533 8.157-5.621 9.922-3.84 1.762 1.777-.105 6.105-3.673 9.636-3.563 3.532-8.103 5.734-9.864 3.957-1.766-1.777.045-6.217 3.612-9.75l.003-.003z" />
</svg>`, KF = `<svg fill="currentColor" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <title>Scala</title>
    <path
        d="M4.589 24c4.537 0 13.81-1.516 14.821-3v-5.729c-.957 1.408-10.284 2.912-14.821 2.912V24zM4.589 16.365c4.537 0 13.81-1.516 14.821-3V7.636c-.957 1.408-10.284 2.912-14.821 2.912v5.817zM4.589 8.729c4.537 0 13.81-1.516 14.821-3V0C18.453 1.408 9.126 2.912 4.589 2.912v5.817z" />
</svg>`, JF = `<svg fill="currentColor" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 17 14">
  <path
    d="m2.378 9.9 5.139-4.627L2.377.645.69 2.205l3.4 3.042v.051L.69 8.341 2.378 9.9Zm14.19 3.299V11H8.591v2.199h7.977Z"
    fill-rule="nonzero" fill="currentColor" />
</svg>`, eH = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128" fill="currentColor">
	<path
		d="M117.3 87.3c.2-.6.4-1.3.5-1.9 7-28-10.1-61.2-39.2-78.6C91.4 24 97 44.9 92 63.2c-.4 1.6-1 3.2-1.6 4.7-.6-.4-1.5-.9-2.5-1.5 0 0-28.9-17.9-60.2-49.4-.9-.8 16.7 25 36.6 46.1-9.4-5.3-35.5-24.3-52-39.4 2 3.4 4.4 6.7 7.1 9.8C33.1 51 51.2 72.6 72.7 89.2c-15.2 9.3-36.6 10-57.9 0C9.5 86.7 4.6 83.7 0 80.3c9 14.4 22.9 26.9 39.9 34.2 20.2 8.7 40.3 8.1 55.2.1.1 0 .1-.1.2-.1.7-.4 1.3-.7 2-1.1 7.2-3.7 21.3-7.4 28.9 7.4 1.7 3.6 5.7-15.6-8.9-33.5z" />
</svg>`, tH = `<svg fill="currentColor" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <title>TypeScript</title>
    <path
        d="M1.125 0C.502 0 0 .502 0 1.125v21.75C0 23.498.502 24 1.125 24h21.75c.623 0 1.125-.502 1.125-1.125V1.125C24 .502 23.498 0 22.875 0zm17.363 9.75c.612 0 1.154.037 1.627.111a6.38 6.38 0 0 1 1.306.34v2.458a3.95 3.95 0 0 0-.643-.361 5.093 5.093 0 0 0-.717-.26 5.453 5.453 0 0 0-1.426-.2c-.3 0-.573.028-.819.086a2.1 2.1 0 0 0-.623.242c-.17.104-.3.229-.393.374a.888.888 0 0 0-.14.49c0 .196.053.373.156.529.104.156.252.304.443.444s.423.276.696.41c.273.135.582.274.926.416.47.197.892.407 1.266.628.374.222.695.473.963.753.268.279.472.598.614.957.142.359.214.776.214 1.253 0 .657-.125 1.21-.373 1.656a3.033 3.033 0 0 1-1.012 1.085 4.38 4.38 0 0 1-1.487.596c-.566.12-1.163.18-1.79.18a9.916 9.916 0 0 1-1.84-.164 5.544 5.544 0 0 1-1.512-.493v-2.63a5.033 5.033 0 0 0 3.237 1.2c.333 0 .624-.03.872-.09.249-.06.456-.144.623-.25.166-.108.29-.234.373-.38a1.023 1.023 0 0 0-.074-1.089 2.12 2.12 0 0 0-.537-.5 5.597 5.597 0 0 0-.807-.444 27.72 27.72 0 0 0-1.007-.436c-.918-.383-1.602-.852-2.053-1.405-.45-.553-.676-1.222-.676-2.005 0-.614.123-1.141.369-1.582.246-.441.58-.804 1.004-1.089a4.494 4.494 0 0 1 1.47-.629 7.536 7.536 0 0 1 1.77-.201zm-15.113.188h9.563v2.166H9.506v9.646H6.789v-9.646H3.375z" />
</svg>`, rH = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M23.55 10.91 13.09.45a1.55 1.55 0 0 0-2.18 0L8.46 2.9 11 5.48a2.06 2.06 0 0 1 1-.23 2.25 2.25 0 0 1 2.25 2.25 2.18 2.18 0 0 1-.22 1l2.19 2.2a2 2 0 1 1-1.06 1.06L13 9.52a1 1 0 0 1-.21.09v5.54a2 2 0 1 1-1.5 0V9.61A2.24 2.24 0 0 1 9.75 7.5a2.18 2.18 0 0 1 .22-1L7.4 4 .45 11a1.55 1.55 0 0 0 0 2.18l10.46 10.37a1.55 1.55 0 0 0 2.18 0l10.46-10.46a1.55 1.55 0 0 0 0-2.18Z" fill="currentColor"></path></svg>', nH = `<svg fill="currentColor" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
    <title>Tailwind CSS</title>
    <path
        d="M12.001,4.8c-3.2,0-5.2,1.6-6,4.8c1.2-1.6,2.6-2.2,4.2-1.8c0.913,0.228,1.565,0.89,2.288,1.624 C13.666,10.618,15.027,12,18.001,12c3.2,0,5.2-1.6,6-4.8c-1.2,1.6-2.6,2.2-4.2,1.8c-0.913-0.228-1.565-0.89-2.288-1.624 C16.337,6.182,14.976,4.8,12.001,4.8z M6.001,12c-3.2,0-5.2,1.6-6,4.8c1.2-1.6,2.6-2.2,4.2-1.8c0.913,0.228,1.565,0.89,2.288,1.624 c1.177,1.194,2.538,2.576,5.512,2.576c3.2,0,5.2-1.6,6-4.8c-1.2,1.6-2.6,2.2-4.2,1.8c-0.913-0.228-1.565-0.89-2.288-1.624 C10.337,13.382,8.976,12,6.001,12z" />
</svg>`, iH = /* @__PURE__ */ Object.assign({}), sH = /* @__PURE__ */ Object.assign({ "./line/arrow-chevron-down.svg": mF, "./line/arrow-chevron-left.svg": gF, "./line/arrow-chevron-right.svg": OF, "./line/arrow-chevron-up.svg": yF, "./line/arrow-down.svg": bF, "./line/arrow-left.svg": vF, "./line/arrow-right.svg": wF, "./line/arrow-up.svg": $F, "./line/interface-add.svg": SF, "./line/interface-close.svg": kF, "./line/programming-script-code.svg": _F }), oH = /* @__PURE__ */ Object.assign({ "./brand/brand-software-development-github.svg": PF, "./brand/programming-framework-angular.svg": xF, "./brand/programming-framework-astro.svg": TF, "./brand/programming-framework-laravel.svg": CF, "./brand/programming-framework-nextdotjs.svg": QF, "./brand/programming-framework-react.svg": AF, "./brand/programming-framework-vuedotjs.svg": EF, "./brand/programming-language-c.svg": RF, "./brand/programming-language-clojure.svg": IF, "./brand/programming-language-csharp.svg": jF, "./brand/programming-language-css3.svg": ZF, "./brand/programming-language-go.svg": MF, "./brand/programming-language-html5.svg": qF, "./brand/programming-language-http.svg": NF, "./brand/programming-language-java.svg": DF, "./brand/programming-language-javascript-js.svg": zF, "./brand/programming-language-json.svg": XF, "./brand/programming-language-kotlin.svg": WF, "./brand/programming-language-node.svg": UF, "./brand/programming-language-objc.svg": VF, "./brand/programming-language-ocaml.svg": LF, "./brand/programming-language-php.svg": YF, "./brand/programming-language-powershell.svg": BF, "./brand/programming-language-python.svg": FF, "./brand/programming-language-r.svg": HF, "./brand/programming-language-ruby.svg": GF, "./brand/programming-language-scala.svg": KF, "./brand/programming-language-shell.svg": JF, "./brand/programming-language-swift.svg": eH, "./brand/programming-language-typescript.svg": tH, "./brand/programming-tool-git.svg": rH, "./brand/programming-tool-tailwindcss.svg": nH });
function s0(t, e) {
  const r = Object.entries(t).map(([s, o]) => {
    const a = s.replace("./solid/", "").replace("./line/", "").replace("./brand/", "").replace(".svg", "");
    return {
      icon: {
        // Prefix the src with the group so that the final flat icon map has unique keys
        src: `${e}/${a}`,
        title: a.replaceAll("-", " "),
        group: e,
        tags: []
      },
      rawData: o
    };
  }), n = r.map((s) => s.icon), i = Object.fromEntries(
    r.map((s) => [s.icon.src, s.rawData])
  );
  return {
    iconDefinitionList: n,
    iconDataMap: i
  };
}
const b5 = s0(iH, "solid"), v5 = s0(sH, "line"), w5 = s0(oH, "brand");
[
  ...b5.iconDefinitionList,
  ...v5.iconDefinitionList,
  ...w5.iconDefinitionList
];
const aH = {
  ...b5.iconDataMap,
  ...v5.iconDataMap,
  ...w5.iconDataMap
}, lH = (t) => aH[t], cH = ["alt", "src"], Xp = /* @__PURE__ */ G({
  __name: "Icon",
  props: {
    src: {},
    title: {}
  },
  setup(t) {
    const e = t, r = fe(() => lH(e.src));
    return (n, i) => r.value ? (k(), Y(v(pF), {
      key: 0,
      raw: r.value
    }, null, 8, ["raw"])) : (k(), C("img", {
      key: 1,
      alt: n.title,
      src: n.src
    }, null, 8, cH));
  }
}), uH = ["id"], dH = {
  key: 0,
  class: "sidebar-heading-chevron"
}, fH = ["href"], hH = { class: "sidebar-heading-link-title" }, pH = {
  key: 1,
  class: "sidebar-heading-link-method"
}, mH = {
  key: 1,
  class: "action-menu"
}, gH = /* @__PURE__ */ G({
  __name: "SidebarElement",
  props: {
    id: {},
    item: {},
    isActive: { type: Boolean },
    hasChildren: { type: Boolean },
    open: { type: Boolean }
  },
  emits: ["toggleOpen"],
  setup(t, { emit: e }) {
    const r = t, n = e, i = async () => {
      var s, o;
      r.hasChildren && n("toggleOpen"), (o = (s = r.item) == null ? void 0 : s.select) == null || o.call(s);
    };
    return (s, o) => {
      var a, l;
      return k(), C("li", {
        id: s.id,
        class: "sidebar-group-item"
      }, [
        x("div", {
          class: $e(["sidebar-heading", {
            "sidebar-group-item__folder": s.hasChildren,
            active_page: s.isActive,
            deprecated: s.item.deprecated ?? !1
          }]),
          onClick: i
        }, [
          s.hasChildren ? (k(), C("p", dH, [
            Z(v(Vm), {
              class: "toggle-nested-icon",
              icon: s.open ? "ChevronDown" : "ChevronRight",
              label: "Toggle group",
              size: "sm",
              onClick: hl(i, ["stop"])
            }, null, 8, ["icon"]),
            re(" â€Š ")
          ])) : H("", !0),
          x("a", {
            class: "sidebar-heading-link",
            href: `#${s.item.id}`
          }, [
            (l = (a = s.item) == null ? void 0 : a.icon) != null && l.src ? (k(), Y(v(Xp), {
              key: 0,
              class: "sidebar-icon",
              src: s.item.icon.src
            }, null, 8, ["src"])) : H("", !0),
            x("p", hH, te(s.item.title), 1),
            s.item.httpVerb ? (k(), C("p", pH, [
              re(" â€Š "),
              Z(v(xi), {
                as: "div",
                class: "sidebar-heading-type",
                method: s.item.httpVerb,
                property: "--method-color",
                short: ""
              }, null, 8, ["method"])
            ])) : H("", !0)
          ], 8, fH)
        ], 2),
        s.open ? se(s.$slots, "default", { key: 0 }, void 0, !0) : H("", !0),
        s.$slots["action-menu"] ? (k(), C("div", mH, [
          se(s.$slots, "action-menu", {}, void 0, !0)
        ])) : H("", !0)
      ], 8, uH);
    };
  }
}), zb = /* @__PURE__ */ oe(gH, [["__scopeId", "data-v-feffd927"]]), OH = /* @__PURE__ */ G({
  __name: "SidebarGroup",
  props: {
    level: {}
  },
  setup(t) {
    return (e, r) => (k(), C("ul", {
      class: "sidebar-group sidebar-indent-nested",
      style: Eo({ "--sidebar-level": e.level })
    }, [
      se(e.$slots, "default", {}, void 0, !0)
    ], 4));
  }
}), Xb = /* @__PURE__ */ oe(OH, [["__scopeId", "data-v-3fac4969"]]), yH = { class: "sidebar" }, bH = -160, vH = /* @__PURE__ */ G({
  __name: "Sidebar",
  props: {
    parsedSpec: {}
  },
  setup(t) {
    const e = t, { hash: r, isIntersectionEnabled: n } = Jt(), { items: i, toggleCollapsedSidebarItem: s, collapsedSidebarItems: o } = Un(
      {
        parsedSpec: e.parsedSpec
      }
    ), a = ge(null), l = ge(!0);
    Ve(r, (u) => {
      !n.value || l.value || c(u);
    });
    const c = (u) => {
      var h, p, g, m;
      const d = document.getElementById(`sidebar-${u}`);
      if (!d || !a.value)
        return;
      let f = bH;
      d.getAttribute("data-sidebar-type") === "heading" ? f += d.offsetTop + ((h = d.getElementsByClassName("sidebar-heading")) == null ? void 0 : h[0]).offsetHeight : f += d.offsetTop + (((p = d.parentElement) == null ? void 0 : p.offsetTop) ?? 0) + (((m = (g = d.parentElement) == null ? void 0 : g.parentElement) == null ? void 0 : m.offsetTop) ?? 0), a.value.scrollTo({ top: f, behavior: "smooth" });
    };
    return Xn(() => {
      setTimeout(() => {
        c(window.location.hash.replace(/^#/, ""));
      }, 500), l.value = !1;
    }), (u, d) => (k(), C("div", yH, [
      se(u.$slots, "sidebar-start", {}, void 0, !0),
      x("div", {
        ref_key: "scrollerEl",
        ref: a,
        class: "sidebar-pages custom-scroll custom-scroll-self-contain-overflow"
      }, [
        Z(Xb, { level: 0 }, {
          default: I(() => [
            (k(!0), C(ee, null, _e(v(i).entries, (f) => (k(), C(ee, {
              key: f.id
            }, [
              f.show ? (k(), Y(zb, {
                key: 0,
                id: `sidebar-${f.id}`,
                "data-sidebar-type": "heading",
                hasChildren: f.children && f.children.length > 0,
                isActive: v(r) === f.id,
                item: {
                  id: f.id,
                  title: f.title,
                  select: f.select,
                  httpVerb: f.httpVerb,
                  deprecated: f.deprecated ?? !1
                },
                open: v(o)[f.id] ?? !1,
                onToggleOpen: async () => {
                  l.value = !0, v(s)(f.id), await v(nS)(100), l.value = !1;
                }
              }, {
                default: I(() => {
                  var h;
                  return [
                    f.children && ((h = f.children) == null ? void 0 : h.length) > 0 ? (k(), Y(Xb, {
                      key: 0,
                      level: 1
                    }, {
                      default: I(() => [
                        (k(!0), C(ee, null, _e(f.children, (p) => (k(), C(ee, {
                          key: p.id
                        }, [
                          f.show ? (k(), Y(zb, {
                            key: 0,
                            id: `sidebar-${p.id}`,
                            isActive: v(r) === p.id,
                            item: {
                              id: p.id,
                              title: p.title,
                              select: p.select,
                              httpVerb: p.httpVerb,
                              deprecated: p.deprecated ?? !1
                            }
                          }, null, 8, ["id", "isActive", "item"])) : H("", !0)
                        ], 64))), 128))
                      ]),
                      _: 2
                    }, 1024)) : H("", !0)
                  ];
                }),
                _: 2
              }, 1032, ["id", "hasChildren", "isActive", "item", "open", "onToggleOpen"])) : H("", !0)
            ], 64))), 128))
          ]),
          _: 1
        })
      ], 512),
      se(u.$slots, "sidebar-end", {}, void 0, !0)
    ]));
  }
}), Wp = /* @__PURE__ */ oe(vH, [["__scopeId", "data-v-38ea937d"]]), wH = {
  key: 0,
  class: "api-client-drawer"
}, $H = { class: "api-client-container" }, SH = { class: "scalar-api-client-height" }, kH = {
  key: 0,
  class: "t-doc__sidebar"
}, _H = {
  key: 1,
  class: "t-doc__sidebar"
}, PH = /* @__PURE__ */ G({
  __name: "ApiClientModal",
  props: {
    parsedSpec: {},
    overloadShow: { type: Boolean },
    tabMode: { type: Boolean },
    activeTab: {},
    proxyUrl: {}
  },
  emits: ["toggleDarkMode"],
  setup(t) {
    const { hideApiClient: e, state: r } = Gp(), n = Vu("(max-width: 1000px)");
    return (i, s) => (k(), C(ee, null, [
      v(r).showApiClient || i.overloadShow ? (k(), C("div", wH, [
        x("div", $H, [
          se(i.$slots, "header", {}, void 0, !0),
          x("div", SH, [
            i.tabMode ? (k(), C(ee, { key: 0 }, [
              i.activeTab === "sidebar" ? (k(), C("div", kH, [
                Ne(Z(v(Wp), { parsedSpec: i.parsedSpec }, null, 8, ["parsedSpec"]), [
                  [mn, !v(n)]
                ])
              ])) : se(i.$slots, "active-tab", { key: 1 }, void 0, !0)
            ], 64)) : (k(), C("div", _H, [
              Ne(Z(v(Wp), { parsedSpec: i.parsedSpec }, {
                "sidebar-start": I(() => [
                  se(i.$slots, "sidebar-start", {}, void 0, !0)
                ]),
                "sidebar-end": I(() => [
                  se(i.$slots, "sidebar-end", {}, void 0, !0)
                ]),
                _: 3
              }, 8, ["parsedSpec"]), [
                [mn, !v(n)]
              ])
            ])),
            Z(v(AR), {
              proxyUrl: i.proxyUrl,
              readOnly: "",
              theme: "none",
              onEscapeKeyPress: v(e)
            }, null, 8, ["proxyUrl", "onEscapeKeyPress"])
          ])
        ])
      ])) : H("", !0),
      v(r).showApiClient ? (k(), C("div", {
        key: 1,
        class: "api-client-drawer-exit",
        onClick: s[0] || (s[0] = //@ts-ignore
        (...o) => v(e) && v(e)(...o))
      })) : H("", !0)
    ], 64));
  }
}), xH = /* @__PURE__ */ oe(PH, [["__scopeId", "data-v-47da1305"]]), TH = /* @__PURE__ */ G({
  __name: "CustomToaster",
  setup(t) {
    return (e, r) => (k(), Y(v(_3), { toastOptions: { className: "toaster" } }));
  }
}), CH = {}, QH = { class: "scalar-card" };
function AH(t, e) {
  return k(), C("div", QH, [
    se(t.$slots, "default", {}, void 0, !0)
  ]);
}
const vs = /* @__PURE__ */ oe(CH, [["render", AH], ["__scopeId", "data-v-f9d4a1f3"]]), EH = /* @__PURE__ */ G({
  __name: "CardContent",
  props: {
    muted: { type: Boolean },
    contrast: { type: Boolean },
    frameless: { type: Boolean },
    transparent: { type: Boolean },
    borderless: { type: Boolean }
  },
  setup(t) {
    return (e, r) => (k(), C("div", {
      class: $e(["scalar-card-content", {
        "scalar-card--muted": e.muted,
        "scalar-card--contrast": e.contrast,
        "scalar-card--frameless": e.frameless,
        "scalar-card--transparent": e.transparent,
        "scalar-card--borderless": e.borderless
      }])
    }, [
      se(e.$slots, "default", {}, void 0, !0)
    ], 2));
  }
}), bn = /* @__PURE__ */ oe(EH, [["__scopeId", "data-v-47a41f7c"]]), RH = { class: "scalar-card-header-slots" }, IH = { class: "scalar-card-header-slot scalar-card-header-title" }, jH = { class: "scalar-card-header-slot scalar-card-header-actions" }, ZH = /* @__PURE__ */ G({
  __name: "CardHeader",
  props: {
    muted: { type: Boolean },
    contrast: { type: Boolean },
    frameless: { type: Boolean },
    transparent: { type: Boolean },
    borderless: { type: Boolean }
  },
  setup(t) {
    const e = t;
    return (r, n) => (k(), Y(bn, Bp(e, { class: "scalar-card-header" }), {
      default: I(() => [
        x("div", RH, [
          x("div", IH, [
            se(r.$slots, "default", {}, void 0, !0)
          ]),
          x("div", jH, [
            se(r.$slots, "actions", {}, void 0, !0)
          ])
        ])
      ]),
      _: 3
    }, 16));
  }
}), ws = /* @__PURE__ */ oe(ZH, [["__scopeId", "data-v-403cccd4"]]), MH = /* @__PURE__ */ G({
  __name: "CardFooter",
  props: {
    muted: { type: Boolean },
    contrast: { type: Boolean },
    frameless: { type: Boolean },
    transparent: { type: Boolean },
    borderless: { type: Boolean }
  },
  setup(t) {
    const e = t;
    return (r, n) => (k(), Y(bn, Ir(jr(e)), {
      default: I(() => [
        se(r.$slots, "default", {}, void 0, !0)
      ]),
      _: 3
    }, 16));
  }
}), Id = /* @__PURE__ */ oe(MH, [["__scopeId", "data-v-c179b8a4"]]), qH = /* @__PURE__ */ G({
  __name: "CardTabHeader",
  emits: ["change"],
  setup(t, { emit: e }) {
    const r = e, n = (i) => {
      r("change", i);
    };
    return (i, s) => (k(), Y(ws, { class: "scalar-card-header-tabs" }, {
      actions: I(() => [
        se(i.$slots, "actions", {}, void 0, !0)
      ]),
      default: I(() => [
        Z(v(Gb), { onChange: n }, {
          default: I(() => [
            Z(v(Kb), { class: "tab-list custom-scroll" }, {
              default: I(() => [
                se(i.$slots, "default", {}, void 0, !0)
              ]),
              _: 3
            })
          ]),
          _: 3
        })
      ]),
      _: 3
    }));
  }
}), NH = /* @__PURE__ */ oe(qH, [["__scopeId", "data-v-6a91b57c"]]), DH = /* @__PURE__ */ G({
  __name: "CardTab",
  setup(t) {
    return (e, r) => (k(), Y(v(Gf), { as: "template" }, {
      default: I(({ selected: n }) => [
        x("button", {
          class: $e({ tab: !0, "tab-selected": n }),
          type: "button"
        }, [
          x("span", null, [
            se(e.$slots, "default", {}, void 0, !0)
          ])
        ], 2)
      ]),
      _: 3
    }));
  }
}), zH = /* @__PURE__ */ oe(DH, [["__scopeId", "data-v-d044c876"]]), XH = ["innerHTML"], WH = /* @__PURE__ */ G({
  __name: "MarkdownRenderer",
  props: {
    value: {},
    withImages: { type: Boolean, default: !1 }
  },
  setup(t) {
    const e = t, r = ge(""), n = e.withImages ? [] : ["img", "picture"];
    return Ve(
      () => e.value,
      async () => {
        var i;
        rv().use(tv).use(R3).use(I3, { allowDangerousHtml: !0 }).use(Q3).use(A3, {
          ..._0,
          // Makes it even more strict
          tagNames: (i = _0.tagNames) == null ? void 0 : i.filter(
            (s) => !n.includes(s)
          )
        }).use(C3, {
          detect: !0
        }).use(x3, { target: "_blank" }).use(T3).use(E3).process(e.value).then((s) => r.value = String(s));
      },
      { immediate: !0 }
    ), (i, s) => (k(), C("div", {
      class: "markdown",
      innerHTML: r.value
    }, null, 8, XH));
  }
}), Tr = /* @__PURE__ */ oe(WH, [["__scopeId", "data-v-61251c75"]]), UH = {}, VH = { class: "card-form" };
function LH(t, e) {
  return k(), C("div", VH, [
    se(t.$slots, "default", {}, void 0, !0)
  ]);
}
const Wb = /* @__PURE__ */ oe(UH, [["render", LH], ["__scopeId", "data-v-d0caa558"]]), YH = /* @__PURE__ */ G({
  __name: "CardFormButton",
  setup(t, { expose: e }) {
    const r = ge();
    return e({ el: r }), (n, i) => (k(), C("button", {
      ref_key: "el",
      ref: r,
      class: "card-form-button",
      type: "button"
    }, [
      se(n.$slots, "default", {}, void 0, !0)
    ], 512));
  }
}), $5 = /* @__PURE__ */ oe(YH, [["__scopeId", "data-v-05ca8905"]]), BH = {}, FH = { class: "card-form-group" };
function HH(t, e) {
  return k(), C("div", FH, [
    se(t.$slots, "default", {}, void 0, !0)
  ]);
}
const Ub = /* @__PURE__ */ oe(BH, [["render", HH], ["__scopeId", "data-v-cadb0c16"]]), GH = { class: "card-form-input" }, KH = ["for"], JH = ["id", "type"], eG = /* @__PURE__ */ G({
  inheritAttrs: !1,
  __name: "CardFormTextInput",
  props: {
    id: {},
    type: {}
  },
  setup(t) {
    return (e, r) => (k(), C("div", GH, [
      x("label", { for: e.id }, [
        se(e.$slots, "default", {}, void 0, !0)
      ], 8, KH),
      x("input", Bp(e.$attrs, {
        id: e.id,
        autocomplete: "off",
        spellcheck: "false",
        type: e.type ?? "text"
      }), null, 16, JH)
    ]));
  }
}), ba = /* @__PURE__ */ oe(eG, [["__scopeId", "data-v-88939d2d"]]), tG = {}, rG = { class: "badge" };
function nG(t, e) {
  return k(), C("div", rG, [
    se(t.$slots, "default", {}, void 0, !0)
  ]);
}
const Qo = /* @__PURE__ */ oe(tG, [["render", nG], ["__scopeId", "data-v-08c68ac3"]]), iG = (t) => (fr("data-v-9ad9d97a"), t = t(), hr(), t), sG = { class: "scopes-label" }, oG = /* @__PURE__ */ iG(() => /* @__PURE__ */ x("em", null, "|", -1)), aG = ["checked"], lG = { class: "dropdown-item-title" }, cG = { class: "dropdown-item-description" }, uG = /* @__PURE__ */ G({
  __name: "SecuritySchemeScopes",
  props: {
    scopes: {},
    selected: {}
  },
  emits: ["update:selected"],
  setup(t, { emit: e }) {
    const r = t, n = e, i = ge(), s = ge(), { floatingStyles: o } = j3(i, s, {
      placement: "bottom-end",
      whileElementsMounted: Z3,
      middleware: [M3(5), q3(), N3()]
    }), a = fe({
      get: () => r.selected,
      set: (l) => n("update:selected", l)
    });
    return (l, c) => (k(), Y(v(l3), {
      modelValue: a.value,
      "onUpdate:modelValue": c[0] || (c[0] = (u) => a.value = u),
      multiple: ""
    }, {
      default: I(({ open: u }) => [
        x("div", {
          ref_key: "trigger",
          ref: i,
          class: $e(["wrapper", { "wrapper-open": u }])
        }, [
          Z(v(c3), { as: $5 }, {
            default: I(() => [
              x("div", sG, [
                Z(v($t), {
                  icon: u ? "ChevronUp" : "ChevronDown",
                  size: "sm"
                }, null, 8, ["icon"]),
                re(" Scopes "),
                Z(v(Qo), { class: "scopes-label-badge" }, {
                  default: I(() => [
                    re(te(a.value.length), 1),
                    oG,
                    re(te(Object.entries(l.scopes).length), 1)
                  ]),
                  _: 1
                })
              ])
            ]),
            _: 2
          }, 1024)
        ], 2),
        (k(), Y(r3, { to: "body" }, [
          Z(v(av), null, {
            default: I(({ styles: d }) => [
              x("div", {
                ref_key: "dropdown",
                ref: s,
                class: $e(["floating", d]),
                style: Eo(v(o))
              }, [
                Z(v(u3), {
                  as: "dl",
                  class: "dropdown"
                }, {
                  default: I(() => [
                    (k(!0), C(ee, null, _e(Object.entries(l.scopes), ([f, h]) => (k(), Y(v(d3), {
                      key: f,
                      as: "div",
                      class: "dropdown-item",
                      value: f
                    }, {
                      default: I(({ selected: p }) => [
                        x("input", {
                          checked: p,
                          class: "dropdown-item-check",
                          tabindex: "-1",
                          type: "checkbox"
                        }, null, 8, aG),
                        x("dt", lG, te(f), 1),
                        x("dd", cG, te(h), 1)
                      ]),
                      _: 2
                    }, 1032, ["value"]))), 128))
                  ]),
                  _: 1
                })
              ], 6)
            ]),
            _: 1
          })
        ]))
      ]),
      _: 1
    }, 8, ["modelValue"]));
  }
}), dG = /* @__PURE__ */ oe(uG, [["__scopeId", "data-v-9ad9d97a"]]), fG = { class: "description" }, hG = /* @__PURE__ */ G({
  __name: "SecurityScheme",
  props: {
    value: {}
  },
  setup(t) {
    const { authentication: e, setAuthentication: r } = Ti(), n = (d) => {
      r({
        apiKey: {
          ...e.apiKey,
          token: d.target.value
        }
      });
    }, i = (d) => {
      r({
        http: {
          ...e.http,
          basic: {
            ...e.http.basic,
            username: d.target.value
          }
        }
      });
    }, s = (d) => {
      r({
        http: {
          ...e.http,
          basic: {
            ...e.http.basic,
            password: d.target.value
          }
        }
      });
    }, o = (d) => {
      r({
        http: {
          ...e.http,
          bearer: {
            ...e.http.bearer,
            token: d.target.value
          }
        }
      });
    }, a = (d) => {
      r({
        oAuth2: {
          ...e.oAuth2,
          clientId: d.target.value
        }
      });
    }, l = (d) => {
      const f = e.oAuth2.scopes.join(" "), h = new URL(d.authorizationUrl);
      return h.searchParams.set("response_type", "token"), h.searchParams.set("client_id", e.oAuth2.clientId), h.searchParams.set("redirect_uri", window.location.href), h.searchParams.set("scope", f), h.searchParams.set("state", "something-random"), h.toString();
    }, c = fe({
      get: () => e.oAuth2.scopes,
      set: (d) => r({ oAuth2: { ...e.oAuth2, scopes: d } })
    }), u = (d) => {
      window.open(d, "openAuth2Window", "left=100,top=100,width=800,height=600");
    };
    return (d, f) => {
      var h, p;
      return k(), C(ee, null, [
        d.value && ((h = d.value) != null && h.type) ? (k(), Y(Wb, { key: 0 }, {
          default: I(() => [
            d.value.type === "apiKey" ? (k(), Y(ba, {
              key: 0,
              id: `security-scheme-${d.value.name}`,
              placeholder: "Token",
              type: "password",
              value: v(e).apiKey.token,
              onInput: n
            }, {
              default: I(() => [
                re(te(d.value.in.charAt(0).toUpperCase() + d.value.in.slice(1)) + " API Key ", 1)
              ]),
              _: 1
            }, 8, ["id", "value"])) : d.value.type === "http" || d.value.type === "basic" ? (k(), C(ee, { key: 1 }, [
              d.value.type === "basic" || d.value.scheme === "basic" ? (k(), Y(Ub, { key: 0 }, {
                default: I(() => [
                  Z(ba, {
                    id: "http.basic.username",
                    placeholder: "Username",
                    value: v(e).http.basic.username,
                    onInput: i
                  }, {
                    default: I(() => [
                      re(" Username ")
                    ]),
                    _: 1
                  }, 8, ["value"]),
                  Z(ba, {
                    id: "http.basic.password",
                    placeholder: "Password",
                    type: "password",
                    value: v(e).http.basic.password,
                    onInput: s
                  }, {
                    default: I(() => [
                      re(" Password ")
                    ]),
                    _: 1
                  }, 8, ["value"])
                ]),
                _: 1
              })) : d.value.type === "http" && d.value.scheme === "bearer" ? (k(), Y(ba, {
                key: 1,
                id: "http.bearer.token",
                placeholder: "Token",
                type: "password",
                value: v(e).http.bearer.token,
                onInput: o
              }, {
                default: I(() => [
                  re(" Bearer Token ")
                ]),
                _: 1
              }, 8, ["value"])) : H("", !0)
            ], 64)) : d.value.type.toLowerCase() === "oauth2" && d.value.flows && d.value.flows.implicit ? (k(), Y(Ub, { key: 2 }, {
              default: I(() => [
                Z(ba, {
                  id: "oAuth2.clientId",
                  placeholder: "Token",
                  type: "password",
                  value: v(e).oAuth2.clientId,
                  onInput: a
                }, {
                  default: I(() => [
                    re(" Client ID ")
                  ]),
                  _: 1
                }, 8, ["value"]),
                d.value !== void 0 ? (k(), Y(dG, {
                  key: 0,
                  selected: c.value,
                  "onUpdate:selected": f[0] || (f[0] = (g) => c.value = g),
                  scopes: (
                    //@ts-ignore
                    d.value.flows.implicit.scopes
                  )
                }, null, 8, ["selected", "scopes"])) : H("", !0),
                Z($5, {
                  onClick: f[1] || (f[1] = () => {
                    var g;
                    return u(
                      l(
                        //@ts-ignore
                        (g = d.value) == null ? void 0 : g.flows.implicit
                      )
                    );
                  })
                }, {
                  default: I(() => [
                    re(" Authorize ")
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })) : H("", !0)
          ]),
          _: 1
        })) : H("", !0),
        (p = d.value) != null && p.description ? (k(), Y(Wb, { key: 1 }, {
          default: I(() => {
            var g;
            return [
              x("div", fG, [
                Z(v(Tr), {
                  value: (g = d.value) == null ? void 0 : g.description
                }, null, 8, ["value"])
              ])
            ];
          }),
          _: 1
        })) : H("", !0)
      ], 64);
    };
  }
}), pG = /* @__PURE__ */ oe(hG, [["__scopeId", "data-v-936d99bd"]]), mG = {
  key: 1,
  class: "security-scheme-selector"
}, gG = ["value"], OG = /* @__PURE__ */ G({
  __name: "SecuritySchemeSelector",
  props: {
    value: {}
  },
  emits: ["input"],
  setup(t, { emit: e }) {
    const r = t, n = e, { authentication: i, setAuthentication: s } = Ti(), o = (m) => {
      a(m.target.value);
    };
    Xn(() => {
      i.securitySchemeKey || a(Object.keys(r.value ?? {})[0] ?? null);
    });
    const a = (m) => {
      s({
        securitySchemeKey: m
      }), n("input", m);
    }, l = (m) => !(m != null && m.type), c = (m) => m.type.toLowerCase() === "apikey", u = (m) => m.type === "http" && m.scheme.toLowerCase() === "basic" || m.type.toLowerCase() === "basic", d = (m) => m.type === "http" && m.scheme.toLowerCase() === "bearer", f = (m) => m.type.toLowerCase() === "oauth2", h = (m, y) => `${y} (${p(m)})`, p = (m) => l(m) ? "No Authentication" : c(m) ? "API Key" : u(m) ? "Basic Authentication" : d(m) ? "Bearer Authentication" : f(m) ? "OAuth 2.0" : `${m.type} (not yet supported)`, g = fe(() => Object.keys(r.value ?? {}));
    return (m, y) => {
      var O, b;
      return g.value.length === 1 ? (k(), C(ee, { key: 0 }, [
        re(te(h((O = m.value) == null ? void 0 : O[g.value[0]], g.value[0])), 1)
      ], 64)) : g.value.length > 1 ? (k(), C("div", mG, [
        x("span", null, te(v(i).securitySchemeKey ? h(
          (b = m.value) == null ? void 0 : b[v(i).securitySchemeKey],
          v(i).securitySchemeKey
        ) : ""), 1),
        Z(v($t), { icon: "ChevronDown" }),
        x("select", {
          onInput: o,
          onValue: y[0] || (y[0] = //@ts-ignore
          (...w) => v(i).securitySchemeKey && v(i).securitySchemeKey(...w))
        }, [
          (k(!0), C(ee, null, _e(g.value, (w) => {
            var S;
            return k(), C("option", {
              key: w,
              value: w ?? null
            }, te(h((S = m.value) == null ? void 0 : S[w], w)), 9, gG);
          }), 128))
        ], 32)
      ])) : H("", !0);
    };
  }
}), yG = /* @__PURE__ */ oe(OG, [["__scopeId", "data-v-e8bd7046"]]), bG = { class: "selector" }, vG = /* @__PURE__ */ G({
  __name: "Authentication",
  props: {
    parsedSpec: {}
  },
  setup(t) {
    const e = t, { authentication: r, setAuthentication: n } = Ti(), i = fe(() => {
      var o, a, l;
      if (!r.securitySchemeKey)
        return !1;
      const s = (l = (a = (o = e.parsedSpec) == null ? void 0 : o.components) == null ? void 0 : a.securitySchemes) == null ? void 0 : l[r.securitySchemeKey];
      return !!s && "type" in s && !!s.type;
    });
    return Ve(
      () => {
        var s, o;
        return (o = (s = e.parsedSpec) == null ? void 0 : s.components) == null ? void 0 : o.securitySchemes;
      },
      () => {
        var s, o;
        n({
          securitySchemes: (o = (s = e.parsedSpec) == null ? void 0 : s.components) == null ? void 0 : o.securitySchemes
        });
      },
      { deep: !0, immediate: !0 }
    ), (s, o) => v(qR)(s.parsedSpec) ? (k(), Y(v(vs), { key: 0 }, {
      default: I(() => [
        Z(v(ws), {
          borderless: "",
          class: "authentication-header",
          transparent: ""
        }, {
          actions: I(() => {
            var a, l;
            return [
              x("div", bG, [
                Z(yG, {
                  value: (l = (a = s.parsedSpec) == null ? void 0 : a.components) == null ? void 0 : l.securitySchemes
                }, null, 8, ["value"])
              ])
            ];
          }),
          default: I(() => [
            re(" Authentication ")
          ]),
          _: 1
        }),
        i.value ? (k(), Y(v(bn), {
          key: 0,
          class: "authentication-content",
          transparent: ""
        }, {
          default: I(() => {
            var a, l, c;
            return [
              v(r).securitySchemeKey ? (k(), Y(pG, {
                key: 0,
                value: (c = (l = (a = s.parsedSpec) == null ? void 0 : a.components) == null ? void 0 : l.securitySchemes) == null ? void 0 : c[v(r).securitySchemeKey]
              }, null, 8, ["value"])) : H("", !0)
            ];
          }),
          _: 1
        })) : H("", !0)
      ]),
      _: 1
    })) : H("", !0);
  }
}), wG = /* @__PURE__ */ oe(vG, [["__scopeId", "data-v-7d6a7d2e"]]), $G = ["title", "innerHTML"], SG = /* @__PURE__ */ G({
  __name: "ServerItem",
  props: {
    value: {},
    variables: {}
  },
  setup(t) {
    const e = t, { copyToClipboard: r } = Xo(), n = fe(() => {
      var o;
      const s = (((o = e.value) == null ? void 0 : o.url) ?? "").replace(/(<([^>]+)>)/gi, "");
      return eS(s, (a) => {
        var c;
        const l = (c = e.variables) == null ? void 0 : c.find(
          (u) => u.name === a
        );
        return `<span class="base-url-variable">${((l == null ? void 0 : l.value) ?? "") !== "" ? l == null ? void 0 : l.value : `{${a}}`}</span>`;
      });
    });
    return (i, s) => i.value ? (k(), C("a", {
      key: 0,
      class: "base-url",
      title: i.value.description,
      onClick: s[0] || (s[0] = (o) => v(r)(i.value.url)),
      innerHTML: n.value
    }, null, 8, $G)) : H("", !0);
  }
}), kG = /* @__PURE__ */ oe(SG, [["__scopeId", "data-v-3be410d7"]]), _G = { key: 0 }, PG = ["for"], xG = ["id", "value", "onInput"], TG = ["value"], CG = { class: "input-value" }, QG = ["id", "value", "onInput"], AG = /* @__PURE__ */ G({
  __name: "ServerVariables",
  props: {
    value: {}
  },
  setup(t) {
    const { server: e, setServer: r } = Ti(), n = (s, o) => {
      const a = o.target.value, l = [...e.variables], c = l.findIndex((u) => u.name === s);
      l[c].value = a, r({
        variables: l
      });
    }, i = (s) => {
      const o = e.variables.findIndex((a) => a.name === s);
      return e.variables[o].value ?? "";
    };
    return (s, o) => s.value ? (k(), C("div", _G, [
      (k(!0), C(ee, null, _e(s.value, (a) => (k(), C("div", {
        key: a.name,
        class: "input"
      }, [
        x("label", {
          for: `variable-${a.name}`
        }, [
          x("code", null, te(a.name), 1)
        ], 8, PG),
        a.enum ? (k(), C(ee, { key: 0 }, [
          x("select", {
            id: `variable-${a.name}`,
            value: i(a.name),
            onInput: (l) => n(a.name, l)
          }, [
            (k(!0), C(ee, null, _e(a.enum, (l) => (k(), C("option", {
              key: l,
              value: l
            }, te(l), 9, TG))), 128))
          ], 40, xG),
          x("div", CG, te(a.default), 1)
        ], 64)) : (k(), C("input", {
          key: 1,
          id: `variable-${a.name}`,
          autocomplete: "off",
          placeholder: "value",
          spellcheck: "false",
          type: "text",
          value: i(a.name),
          onInput: (l) => n(a.name, l)
        }, null, 40, QG))
      ]))), 128))
    ])) : H("", !0);
  }
}), EG = /* @__PURE__ */ oe(AG, [["__scopeId", "data-v-d9d597ef"]]), RG = { class: "scalar-card-serverlist-container" }, IG = { class: "server-item" }, jG = { class: "server-selector" }, ZG = ["value"], MG = ["value"], qG = { class: "description" }, NG = /* @__PURE__ */ G({
  __name: "BaseUrl",
  props: {
    value: {}
  },
  setup(t) {
    const e = t, { server: r, setServer: n } = Ti(), i = ge(0);
    return Ve(
      i,
      () => {
        var l, c, u;
        const s = ((l = e.value[i.value]) == null ? void 0 : l.variables) ?? {}, o = s ? Object.keys(s).map((d) => {
          var f;
          return {
            name: d,
            value: ((f = s[d].default) == null ? void 0 : f.toString()) ?? ""
          };
        }) : [];
        jT(
          (c = e.value[i.value]) == null ? void 0 : c.url
        ).filter((d) => !s[d]).forEach((d) => {
          o.push({
            name: d,
            value: ""
          });
        }), n({
          selectedServer: i.value,
          description: (u = e.value[i.value]) == null ? void 0 : u.description,
          servers: e.value,
          variables: o
        });
      },
      {
        immediate: !0
      }
    ), Ve(
      () => e.value,
      () => {
        n({
          servers: e.value
        });
      }
    ), (s, o) => s.value.length > 0 ? (k(), Y(v(vs), { key: 0 }, {
      default: I(() => [
        Z(v(ws), {
          borderless: "",
          muted: ""
        }, {
          default: I(() => [
            re(" Base URL ")
          ]),
          _: 1
        }),
        Z(v(bn), { class: "scalar-card-serverlist" }, {
          default: I(() => [
            x("div", RG, [
              x("div", IG, [
                x("div", jG, [
                  s.value.length > 1 ? (k(), C("select", {
                    key: 0,
                    value: i.value,
                    onInput: o[0] || (o[0] = (a) => i.value = parseInt(
                      a.target.value,
                      10
                    ))
                  }, [
                    (k(!0), C(ee, null, _e(s.value, (a, l) => (k(), C("option", {
                      key: l,
                      value: l
                    }, te(a.url), 9, MG))), 128))
                  ], 40, ZG)) : H("", !0),
                  Z(kG, {
                    value: s.value[i.value],
                    variables: v(r).variables
                  }, null, 8, ["value", "variables"]),
                  s.value.length > 1 ? (k(), Y(v($t), {
                    key: 1,
                    icon: "ChevronDown"
                  })) : H("", !0)
                ])
              ]),
              Z(EG, {
                value: v(r).variables
              }, null, 8, ["value"])
            ])
          ]),
          _: 1
        }),
        v(r).description ? (k(), Y(v(bn), {
          key: 0,
          muted: ""
        }, {
          default: I(() => [
            x("div", qG, [
              Z(v(Tr), {
                value: v(r).description
              }, null, 8, ["value"])
            ])
          ]),
          _: 1
        })) : H("", !0)
      ]),
      _: 1
    })) : H("", !0);
  }
}), DG = /* @__PURE__ */ oe(NG, [["__scopeId", "data-v-66aa4425"]]);
function zG(t) {
  return function(r, n) {
    t[r] = n;
  };
}
function XG(t) {
  return function(r) {
    typeof t[r] == "boolean" && (t[r] = !t[r]);
  };
}
const S5 = () => ({
  isDark: !1,
  activeNavState: "Guide",
  selectedClient: {
    targetKey: "shell",
    clientKey: "curl"
  }
}), Hc = vn(S5());
function WG() {
  WR(Hc, S5());
}
function UG(t) {
  var r;
  const { availableTargets: e } = xl();
  return ((r = e.value.find((n) => n.key === t.targetKey)) == null ? void 0 : r.title) ?? t.targetKey;
}
function VG(t) {
  var r, n;
  const { availableTargets: e } = xl();
  return ((n = (r = e.value.find((i) => i.key === t.targetKey)) == null ? void 0 : r.clients.find((i) => i.key === t.clientKey)) == null ? void 0 : n.title) ?? t.clientKey;
}
const o0 = () => ({
  state: Yp(Hc),
  resetState: WG,
  setItem: zG(Hc),
  toggleItem: XG(Hc),
  getClientTitle: VG,
  getTargetTitle: UG
}), k5 = (t) => (fr("data-v-b11e68cd"), t = t(), hr(), t), LG = ["onClick"], YG = ["value"], BG = ["label"], FG = ["value"], HG = { class: "code-languages-background code-languages-icon__more" }, GG = {
  key: 1,
  class: "code-languages-icon",
  height: "50",
  viewBox: "0 0 50 50",
  width: "50",
  xmlns: "http://www.w3.org/2000/svg"
}, KG = /* @__PURE__ */ k5(() => /* @__PURE__ */ x("g", {
  fill: "currentColor",
  "fill-rule": "nonzero"
}, [
  /* @__PURE__ */ x("path", { d: "M10.71 25.3a3.87 3.87 0 1 0 7.74 0 3.87 3.87 0 0 0-7.74 0M21.13 25.3a3.87 3.87 0 1 0 7.74 0 3.87 3.87 0 0 0-7.74 0M31.55 25.3a3.87 3.87 0 1 0 7.74 0 3.87 3.87 0 0 0-7.74 0" })
], -1)), JG = [
  KG
], eK = /* @__PURE__ */ k5(() => /* @__PURE__ */ x("span", null, "More", -1)), tK = /* @__PURE__ */ G({
  __name: "ClientSelector",
  setup(t) {
    const { state: e, setItem: r, getClientTitle: n, getTargetTitle: i } = o0(), { availableTargets: s } = xl(), o = ge(!1), a = ge();
    ev(
      a,
      (f) => o.value = f[0].contentRect.width < 500
    );
    const l = fe(
      () => o.value ? (
        // Mobile
        [
          {
            targetKey: "shell",
            clientKey: "curl"
          },
          {
            targetKey: "ruby",
            clientKey: "native"
          },
          {
            targetKey: "node",
            clientKey: "undici"
          },
          {
            targetKey: "python",
            clientKey: "python3"
          }
        ]
      ) : (
        // Desktop
        [
          {
            targetKey: "shell",
            clientKey: "curl"
          },
          {
            targetKey: "ruby",
            clientKey: "native"
          },
          {
            targetKey: "node",
            clientKey: "undici"
          },
          {
            targetKey: "php",
            clientKey: "guzzle"
          },
          {
            targetKey: "python",
            clientKey: "python3"
          },
          {
            targetKey: "c",
            clientKey: "libcurl"
          }
        ]
      )
    ), c = (f) => `brand/programming-language-${{
      javascript: "javascript-js"
    }[f] ?? f}`, u = (f) => f.targetKey === e.selectedClient.targetKey && f.clientKey === e.selectedClient.clientKey;
    function d(f) {
      return l.value.some((h) => h.targetKey === f.targetKey && h.clientKey === f.clientKey);
    }
    return (f, h) => (k(), C("div", {
      ref_key: "containerRef",
      ref: a,
      class: "client-libraries-content"
    }, [
      (k(!0), C(ee, null, _e(l.value, (p) => (k(), C("div", {
        key: p.clientKey,
        class: $e(["code-languages rendered-code-sdks", {
          "code-languages__active": u(p)
        }]),
        onClick: () => v(r)("selectedClient", p)
      }, [
        x("div", {
          class: $e(["code-languages-background", `code-languages-icon__${p.targetKey}`])
        }, [
          Z(v(Xp), {
            class: "code-languages-icon",
            src: c(p.targetKey)
          }, null, 8, ["src"])
        ], 2),
        x("span", null, te(v(i)(p)), 1)
      ], 10, LG))), 128)),
      x("div", {
        class: $e(["code-languages code-languages__select", {
          "code-languages__active": v(e).selectedClient && !d(v(e).selectedClient)
        }])
      }, [
        x("select", {
          class: "language-select",
          value: JSON.stringify(v(e).selectedClient),
          onInput: h[0] || (h[0] = (p) => v(r)(
            "selectedClient",
            JSON.parse(p.target.value)
          ))
        }, [
          (k(!0), C(ee, null, _e(v(s), (p) => (k(), C("optgroup", {
            key: p.key,
            label: p.title
          }, [
            (k(!0), C(ee, null, _e(p.clients, (g) => (k(), C("option", {
              key: g.key,
              value: JSON.stringify({
                targetKey: p.key,
                clientKey: g.key
              })
            }, te(v(n)({
              targetKey: p.key,
              clientKey: g.key
            })), 9, FG))), 128))
          ], 8, BG))), 128))
        ], 40, YG),
        x("div", HG, [
          v(e).selectedClient && !d(v(e).selectedClient) ? (k(), C("div", {
            key: 0,
            class: $e(["code-languages-background", `code-languages-icon__${v(e).selectedClient.targetKey}`])
          }, [
            Z(v(Xp), {
              class: "code-languages-icon",
              src: c(v(e).selectedClient.targetKey)
            }, null, 8, ["src"])
          ], 2)) : (k(), C("svg", GG, JG))
        ]),
        eK
      ], 2)
    ], 512));
  }
}), rK = /* @__PURE__ */ oe(tK, [["__scopeId", "data-v-b11e68cd"]]), nK = /* @__PURE__ */ G({
  __name: "ClientLibraries",
  setup(t) {
    const { state: e, getClientTitle: r, getTargetTitle: n } = o0();
    return (i, s) => (k(), Y(v(vs), null, {
      default: I(() => [
        Z(v(ws), {
          borderless: "",
          transparent: ""
        }, {
          default: I(() => [
            re(" Client Libraries ")
          ]),
          _: 1
        }),
        Z(v(bn), {
          frameless: "",
          transparent: ""
        }, {
          default: I(() => [
            Z(rK)
          ]),
          _: 1
        }),
        Z(v(Id), {
          class: "selected-client card-footer",
          muted: ""
        }, {
          default: I(() => [
            re(te(v(n)(v(e).selectedClient)) + " " + te(v(r)(v(e).selectedClient)), 1)
          ]),
          _: 1
        })
      ]),
      _: 1
    }));
  }
}), iK = /* @__PURE__ */ oe(nK, [["__scopeId", "data-v-6359a4ee"]]), a0 = /* @__PURE__ */ G({
  __name: "IntersectionObserver",
  props: {
    id: {},
    is: {}
  },
  emits: ["intersecting"],
  setup(t, { emit: e }) {
    const r = t, n = e, i = ge();
    return Xn(() => {
      f3(
        i,
        ([{ isIntersecting: s }]) => {
          r.id && s && n("intersecting");
        },
        {
          rootMargin: "0px 0px 50% 0px",
          threshold: 0.2
        }
      );
    }), (s, o) => (k(), Y(Oi(s.is ?? "div"), {
      id: s.id,
      ref_key: "intersectionObserverRef",
      ref: i
    }, {
      default: I(() => [
        se(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["id"]));
  }
}), sK = /* @__PURE__ */ G({
  __name: "Section",
  props: {
    id: {},
    label: {}
  },
  setup(t) {
    const e = t, { getSectionId: r, hash: n, isIntersectionEnabled: i } = Jt(), { setCollapsedSidebarItem: s } = Un();
    function o() {
      var a;
      !e.label || !i.value || (window.history.replaceState({}, "", `#${e.id}`), n.value = e.id ?? "", (a = e.id) != null && a.startsWith("model") && s(r(e.id), !0));
    }
    return (a, l) => (k(), Y(a0, {
      is: "section",
      id: a.id,
      class: "section",
      onIntersecting: o
    }, {
      default: I(() => [
        se(a.$slots, "default", {}, void 0, !0)
      ]),
      _: 3
    }, 8, ["id"]));
  }
}), Ho = /* @__PURE__ */ oe(sK, [["__scopeId", "data-v-167724b9"]]), oK = { class: "section-accordion-button-content" }, aK = {
  key: 0,
  class: "section-accordion-button-actions"
}, lK = {
  key: 0,
  class: "section-accordion-description"
}, cK = { class: "section-accordion-content-card" }, uK = /* @__PURE__ */ G({
  __name: "SectionAccordion",
  props: {
    id: {},
    transparent: { type: Boolean }
  },
  setup(t) {
    const e = ge(), r = h3(e);
    return (n, i) => (k(), Y(a0, {
      id: n.id,
      class: "section-wrapper"
    }, {
      default: I(() => [
        Z(v(zu), {
          as: "section",
          class: $e(["section-accordion", { "section-accordion-transparent": n.transparent }])
        }, {
          default: I(({ open: s }) => [
            Z(v(Xu), {
              ref_key: "button",
              ref: e,
              class: "section-accordion-button"
            }, {
              default: I(() => [
                x("div", oK, [
                  se(n.$slots, "title", {}, void 0, !0)
                ]),
                n.$slots.actions ? (k(), C("div", aK, [
                  se(n.$slots, "actions", {
                    active: v(r) || s
                  }, void 0, !0)
                ])) : H("", !0),
                Z(v($t), {
                  class: "section-accordion-chevron",
                  icon: s ? "ChevronDown" : "ChevronRight"
                }, null, 8, ["icon"])
              ]),
              _: 2
            }, 1536),
            Z(v(Wu), { class: "section-accordion-content" }, {
              default: I(() => [
                n.$slots.description ? (k(), C("div", lK, [
                  se(n.$slots, "description", {}, void 0, !0)
                ])) : H("", !0),
                x("div", cK, [
                  se(n.$slots, "default", {}, void 0, !0)
                ])
              ]),
              _: 3
            })
          ]),
          _: 3
        }, 8, ["class"])
      ]),
      _: 3
    }, 8, ["id"]));
  }
}), _5 = /* @__PURE__ */ oe(uK, [["__scopeId", "data-v-d82ba6d9"]]), dK = {}, fK = { class: "section-column" };
function hK(t, e) {
  return k(), C("div", fK, [
    se(t.$slots, "default", {}, void 0, !0)
  ]);
}
const Ao = /* @__PURE__ */ oe(dK, [["render", hK], ["__scopeId", "data-v-d64e7382"]]), pK = {}, mK = { class: "section-columns" };
function gK(t, e) {
  return k(), C("div", mK, [
    se(t.$slots, "default", {}, void 0, !0)
  ]);
}
const l0 = /* @__PURE__ */ oe(pK, [["render", gK], ["__scopeId", "data-v-8b9602bf"]]), OK = {}, yK = { class: "section-container" };
function bK(t, e) {
  return k(), C("div", yK, [
    se(t.$slots, "default", {}, void 0, !0)
  ]);
}
const Wl = /* @__PURE__ */ oe(OK, [["render", bK], ["__scopeId", "data-v-b630668c"]]), vK = { class: "section-accordion-wrapper" }, wK = { class: "section-accordion-title" }, $K = /* @__PURE__ */ G({
  __name: "SectionContainerAccordion",
  setup(t) {
    return (e, r) => (k(), C("div", vK, [
      Z(v(zu), {
        as: "div",
        class: "section-accordion",
        defaultOpen: ""
      }, {
        default: I(({ open: n }) => [
          Z(v(Xu), { class: "section-accordion-button" }, {
            default: I(() => [
              Z(v($t), {
                class: "section-accordion-chevron",
                icon: n ? "ChevronDown" : "ChevronRight"
              }, null, 8, ["icon"]),
              x("div", wK, [
                se(e.$slots, "title", {}, void 0, !0)
              ])
            ]),
            _: 2
          }, 1024),
          Z(v(Wu), { class: "section-accordion-content" }, {
            default: I(() => [
              se(e.$slots, "default", {}, void 0, !0)
            ]),
            _: 3
          })
        ]),
        _: 3
      })
    ]));
  }
}), P5 = /* @__PURE__ */ oe($K, [["__scopeId", "data-v-02cdcc1e"]]), SK = /* @__PURE__ */ G({
  __name: "LoadingSkeleton",
  props: {
    lines: { default: 1 }
  },
  setup(t) {
    return (e, r) => (k(!0), C(ee, null, _e([...Array(e.lines).keys()], (n) => (k(), C("div", {
      key: n,
      class: $e(["loading", { "single-line": e.lines === 1 }])
    }, null, 2))), 128));
  }
}), x5 = /* @__PURE__ */ oe(SK, [["__scopeId", "data-v-99d52311"]]), kK = { class: "section-content" }, _K = /* @__PURE__ */ G({
  __name: "SectionContent",
  props: {
    loading: { type: Boolean, default: !1 }
  },
  setup(t) {
    return (e, r) => (k(), C("div", kK, [
      e.loading ? (k(), Y(x5, {
        key: 1,
        lines: 8
      })) : se(e.$slots, "default", { key: 0 }, void 0, !0)
    ]));
  }
}), Go = /* @__PURE__ */ oe(_K, [["__scopeId", "data-v-9735459e"]]), PK = /* @__PURE__ */ G({
  __name: "SectionHeader",
  props: {
    loading: { type: Boolean, default: !1 },
    tight: { type: Boolean, default: !1 },
    level: { default: 1 }
  },
  setup(t) {
    return (e, r) => e.loading ? (k(), Y(x5, { key: 0 })) : (k(), Y(Oi(`h${e.level}`), {
      key: 1,
      class: $e(["section-header", { tight: e.tight }])
    }, {
      default: I(() => [
        se(e.$slots, "default", {}, void 0, !0)
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Ri = /* @__PURE__ */ oe(PK, [["__scopeId", "data-v-9e0df4d5"]]), xK = /* @__PURE__ */ G({
  __name: "Description",
  props: {
    value: {}
  },
  setup(t) {
    const e = t, r = p3(
      async () => {
        if (!e.value)
          return [];
        const a = await vu(e.value), l = G$(a);
        return await Promise.all(
          tI(e.value, l).map(
            async (c) => ({
              heading: (await vu(c))[0],
              content: c
            })
          )
        );
      },
      []
      // initial state
    ), { getHeadingId: n, hash: i, isIntersectionEnabled: s } = Jt();
    function o(a) {
      s.value && (window.history.replaceState({}, "", `#${a}`), i.value = a ?? "");
    }
    return (a, l) => a.value ? (k(!0), C(ee, { key: 0 }, _e(v(r), (c, u) => (k(), C("div", { key: u }, [
      c.heading ? (k(), Y(a0, {
        key: 0,
        id: v(n)(c.heading),
        class: "introduction-description-heading",
        onIntersecting: () => o(v(n)(c.heading))
      }, {
        default: I(() => [
          Z(v(Tr), {
            value: c.content,
            withImages: ""
          }, null, 8, ["value"])
        ]),
        _: 2
      }, 1032, ["id", "onIntersecting"])) : (k(), Y(v(Tr), {
        key: 1,
        value: c.content,
        withImages: ""
      }, null, 8, ["value"]))
    ]))), 128)) : H("", !0);
  }
}), TK = /* @__PURE__ */ oe(xK, [["__scopeId", "data-v-18921431"]]), CK = { class: "download" }, QK = { class: "download-cta" }, AK = /* @__PURE__ */ G({
  __name: "DownloadSpec",
  setup(t) {
    return (e, r) => (k(), C("div", CK, [
      x("div", QK, [
        x("button", {
          class: "download-button",
          type: "button",
          onClick: r[0] || (r[0] = (n) => v(iS).emit())
        }, " Download OpenAPI Spec ")
      ])
    ]));
  }
}), EK = /* @__PURE__ */ oe(AK, [["__scopeId", "data-v-903fee61"]]), RK = (t) => (fr("data-v-a408c8e6"), t = t(), hr(), t), IK = /* @__PURE__ */ RK(() => /* @__PURE__ */ x("div", { class: "section-flare" }, [
  /* @__PURE__ */ x("div", { class: "section-flare-item" }),
  /* @__PURE__ */ x("div", { class: "section-flare-item" }),
  /* @__PURE__ */ x("div", { class: "section-flare-item" }),
  /* @__PURE__ */ x("div", { class: "section-flare-item" }),
  /* @__PURE__ */ x("div", { class: "section-flare-item" }),
  /* @__PURE__ */ x("div", { class: "section-flare-item" }),
  /* @__PURE__ */ x("div", { class: "section-flare-item" }),
  /* @__PURE__ */ x("div", { class: "section-flare-item" })
], -1)), jK = { class: "badges" }, ZK = { class: "sticky-cards" }, MK = /* @__PURE__ */ G({
  __name: "Introduction",
  props: {
    info: {},
    parsedSpec: {}
  },
  setup(t) {
    const e = t, r = fe(() => e.parsedSpec.openapi ?? e.parsedSpec.swagger ?? "");
    return (n, i) => (k(), Y(v(Wl), null, {
      default: I(() => [
        IK,
        Z(v(Ho), { class: "introduction-section" }, {
          default: I(() => [
            Z(v(Go), {
              loading: !n.info.description && !n.info.title
            }, {
              default: I(() => [
                Z(v(l0), null, {
                  default: I(() => [
                    Z(v(Ao), null, {
                      default: I(() => [
                        x("div", jK, [
                          n.info.version ? (k(), Y(v(Qo), { key: 0 }, {
                            default: I(() => [
                              re(te(n.info.version), 1)
                            ]),
                            _: 1
                          })) : H("", !0),
                          r.value ? (k(), Y(v(Qo), { key: 1 }, {
                            default: I(() => [
                              re(" OAS " + te(r.value), 1)
                            ]),
                            _: 1
                          })) : H("", !0)
                        ]),
                        Z(v(Ri), {
                          level: 1,
                          loading: !n.info.title,
                          tight: ""
                        }, {
                          default: I(() => [
                            re(te(n.info.title), 1)
                          ]),
                          _: 1
                        }, 8, ["loading"]),
                        Z(EK),
                        Z(TK, {
                          value: n.info.description
                        }, null, 8, ["value"])
                      ]),
                      _: 1
                    }),
                    n.$slots.aside ? (k(), Y(v(Ao), { key: 0 }, {
                      default: I(() => [
                        x("div", ZK, [
                          se(n.$slots, "aside", {}, void 0, !0)
                        ])
                      ]),
                      _: 3
                    })) : H("", !0)
                  ]),
                  _: 3
                })
              ]),
              _: 3
            }, 8, ["loading"]),
            se(n.$slots, "after", {}, void 0, !0)
          ]),
          _: 3
        })
      ]),
      _: 3
    }));
  }
}), qK = /* @__PURE__ */ oe(MK, [["__scopeId", "data-v-a408c8e6"]]), NK = Symbol("lazyEventBusKey"), Up = Jb(NK), Nu = /* @__PURE__ */ G({
  __name: "Lazy",
  props: {
    id: {},
    isLazy: { type: Boolean, default: !0 },
    lazyTimeout: { default: 0 }
  },
  setup(t) {
    const e = t, r = (i = () => {
    }) => {
      typeof window < "u" && "requestIdleCallback" in window ? setTimeout(() => window.requestIdleCallback(i), e.lazyTimeout) : setTimeout(() => _c(i), e.lazyTimeout ?? 300);
    }, n = ge(!e.isLazy);
    return e.isLazy ? r(() => {
      n.value = !0, e.id && _c(() => Up.emit({ id: e.id }));
    }) : e.id && _c(() => Up.emit({ id: e.id })), (i, s) => n.value ? se(i.$slots, "default", { key: 0 }) : H("", !0);
  }
}), DK = {
  key: 0,
  class: "screenreader-only"
}, zK = /* @__PURE__ */ G({
  __name: "ScreenReader",
  props: {
    if: { type: Boolean, default: !0 }
  },
  setup(t) {
    return (e, r) => e.$props.if ? (k(), C("span", DK, [
      se(e.$slots, "default", {}, void 0, !0)
    ])) : se(e.$slots, "default", { key: 1 }, void 0, !0);
  }
}), T5 = /* @__PURE__ */ oe(zK, [["__scopeId", "data-v-681ebf2c"]]), XK = (t) => (fr("data-v-6dd4d525"), t = t(), hr(), t), WK = { class: "label" }, UK = { class: "anchor" }, VK = /* @__PURE__ */ XK(() => /* @__PURE__ */ x("span", null, "â€‹", -1)), LK = /* @__PURE__ */ G({
  __name: "Anchor",
  props: {
    id: {}
  },
  setup(t) {
    const { copyToClipboard: e } = Xo(), r = (n) => {
      const i = new URL(window.location.href);
      return i.hash = n, i.toString();
    };
    return (n, i) => (k(), C("span", WK, [
      se(n.$slots, "default", {}, void 0, !0),
      x("span", UK, [
        VK,
        x("button", {
          class: "anchor-copy",
          type: "button",
          onClick: i[0] || (i[0] = hl((s) => v(e)(r(n.id)), ["stop"]))
        }, [
          re(" # "),
          Z(T5, null, {
            default: I(() => [
              re('Copy link to "'),
              se(n.$slots, "default", {}, void 0, !0),
              re('"')
            ]),
            _: 3
          })
        ])
      ])
    ]));
  }
}), Ii = /* @__PURE__ */ oe(LK, [["__scopeId", "data-v-6dd4d525"]]), YK = ["value"], BK = ["label"], FK = ["value"], HK = ["value"], c0 = /* @__PURE__ */ G({
  __name: "TextSelect",
  props: {
    modelValue: {},
    options: {}
  },
  emits: ["update:modelValue"],
  setup(t) {
    return (e, r) => (k(), C("div", {
      class: $e(["text-select", e.options.length === 1 ? "text-select--single-option" : ""])
    }, [
      x("span", null, [
        se(e.$slots, "default")
      ]),
      x("select", {
        value: e.modelValue,
        onInput: r[0] || (r[0] = (n) => e.$emit("update:modelValue", n.target.value))
      }, [
        (k(!0), C(ee, null, _e(e.options, (n) => (k(), C(ee, {
          key: n.value
        }, [
          n.options ? (k(), C("optgroup", {
            key: 0,
            label: n.label
          }, [
            (k(!0), C(ee, null, _e(n.options, (i) => (k(), C("option", {
              key: i.value,
              value: i.value
            }, te(i.label), 9, FK))), 128))
          ], 8, BK)) : (k(), C("option", {
            key: n.value,
            value: n.value
          }, te(n.label), 9, HK))
        ], 64))), 128))
      ], 40, YK)
    ], 2));
  }
}), GK = { class: "request-header" }, KK = /* @__PURE__ */ G({
  __name: "CustomRequestExamples",
  props: {
    operation: {},
    examples: {}
  },
  setup(t) {
    const e = t, r = ge(0), n = fe(() => (
      // @ts-ignore
      {
        C: "c",
        "C#": "csharp",
        // 'C++': '',
        // 'CoffeeScript': '',
        // 'CSS': '',
        // 'Dart': '',
        // 'DM': '',
        // 'Elixir': '',
        Go: "go",
        // 'Groovy': '',
        HTML: "html",
        Java: "java",
        JavaScript: "javascript",
        Kotlin: "kotlin",
        "Objective-C": "objc",
        // 'Perl': '',
        // 'PHP': '',
        PowerShell: "powershell",
        Python: "python",
        Ruby: "ruby",
        // 'Rust': '',
        // 'Scala': '',
        Shell: "shell",
        Swift: "swift",
        TypeScript: "javascript",
        cURL: "shell"
      }[e.examples[r.value].lang] ?? e.examples[r.value].lang
    )), i = fe(() => e.examples[r.value]);
    Ve(e.examples, () => {
      e.examples[r.value] === "undefined" && (r.value = 0);
    });
    const { copyToClipboard: s } = Xo();
    return (o, a) => (k(), Y(v(vs), { class: "dark-mode" }, {
      default: I(() => [
        Z(v(ws), { muted: "" }, {
          actions: I(() => [
            Z(c0, {
              class: "request-client-picker",
              modelValue: r.value,
              options: o.examples.map((l, c) => ({
                value: c.toString(),
                label: l.label
              })),
              "onUpdate:modelValue": a[0] || (a[0] = (l) => (r.value = parseInt(l), 10))
            }, {
              default: I(() => [
                re(te(i.value.label), 1)
              ]),
              _: 1
            }, 8, ["modelValue", "options"]),
            x("button", {
              class: "copy-button",
              type: "button",
              onClick: a[1] || (a[1] = (l) => v(s)(i.value.source.trim()))
            }, [
              Z(v($t), {
                icon: "Clipboard",
                width: "10px"
              })
            ])
          ]),
          default: I(() => [
            x("div", GK, [
              Z(v(xi), {
                class: "request-method",
                method: o.operation.httpVerb
              }, null, 8, ["method"]),
              se(o.$slots, "header", {}, void 0, !0)
            ])
          ]),
          _: 3
        }),
        Z(v(bn), {
          borderless: "",
          class: "request-editor-section custom-scroll",
          frameless: ""
        }, {
          default: I(() => [
            Z(v(Qn), {
              content: i.value.source.trim(),
              lang: n.value,
              lineNumbers: ""
            }, null, 8, ["content", "lang"])
          ]),
          _: 1
        }),
        o.$slots.footer ? (k(), Y(v(Id), {
          key: 0,
          class: "scalar-card-footer",
          contrast: ""
        }, {
          default: I(() => [
            se(o.$slots, "footer", {}, void 0, !0)
          ]),
          _: 3
        })) : H("", !0)
      ]),
      _: 3
    }));
  }
}), JK = /* @__PURE__ */ oe(KK, [["__scopeId", "data-v-3ea9bca2"]]), eJ = { class: "schema-type" }, tJ = ["title"], rJ = /* @__PURE__ */ G({
  __name: "SchemaHeading",
  props: {
    value: {},
    name: {}
  },
  setup(t) {
    return (e, r) => {
      var n, i, s, o, a, l;
      return k(), C("span", eJ, [
        x("span", {
          class: "schema-type-icon",
          title: typeof e.value.type == "string" ? e.value.type : Array.isArray(e.value.type) ? e.value.type.join(" | ") : "unkown type"
        }, [
          e.value.type === "object" ? (k(), C(ee, { key: 0 }, [
            re(" {} ")
          ], 64)) : H("", !0),
          e.value.type === "array" ? (k(), C(ee, { key: 1 }, [
            re(" [] ")
          ], 64)) : H("", !0),
          e.value.enum ? (k(), C(ee, { key: 2 }, [
            re(" enum ")
          ], 64)) : H("", !0)
        ], 8, tJ),
        (i = (n = e.value) == null ? void 0 : n.xml) != null && i.name && ((o = (s = e.value) == null ? void 0 : s.xml) == null ? void 0 : o.name) !== "##default" ? (k(), C(ee, { key: 0 }, [
          re(" <" + te((l = (a = e.value) == null ? void 0 : a.xml) == null ? void 0 : l.name) + " /> ", 1)
        ], 64)) : e.name ? (k(), C(ee, { key: 1 }, [
          re(te(e.name), 1)
        ], 64)) : (k(), C(ee, { key: 2 }, [
          re(te(e.value.type), 1)
        ], 64))
      ]);
    };
  }
}), C5 = /* @__PURE__ */ oe(rJ, [["__scopeId", "data-v-c00c09cf"]]), nJ = { class: "property-information" }, iJ = {
  key: 0,
  class: "property-name"
}, sJ = {
  key: 1,
  class: "property-deprecated"
}, oJ = {
  key: 2,
  class: "required"
}, aJ = {
  key: 3,
  class: "property-type"
}, lJ = {
  key: 0,
  class: "property-example-value"
}, cJ = { class: "pattern" }, uJ = {
  key: 4,
  class: "write-only"
}, dJ = {
  key: 5,
  class: "read-only"
}, fJ = {
  key: 0,
  class: "property-rule-badge"
}, hJ = {
  key: 6,
  class: "property-nullable"
}, pJ = {
  key: 7,
  class: "property-example"
}, mJ = { class: "property-example-value" }, gJ = {
  key: 0,
  class: "property-description"
}, OJ = {
  key: 1,
  class: "property-description"
}, yJ = {
  key: 2,
  class: "property-enum"
}, bJ = { class: "property-enum-values" }, vJ = {
  key: 3,
  class: "children"
}, wJ = {
  key: 0,
  class: "children"
}, $J = {
  key: 0,
  class: "property-rule"
}, SJ = {
  key: 1,
  class: "property-rule"
}, kJ = /* @__PURE__ */ G({
  __name: "SchemaProperty",
  props: {
    value: {},
    level: { default: 0 },
    name: {},
    required: { type: Boolean, default: !1 },
    compact: { type: Boolean, default: !1 },
    description: {}
  },
  setup(t) {
    const e = {
      number: {
        _default: "",
        float: "Floating-point numbers.",
        double: "Floating-point numbers with double precision."
      },
      integer: {
        _default: "Integer numbers.",
        int32: "Signed 32-bit integers (commonly used integer type).",
        int64: "Signed 64-bit integers (long type)."
      },
      string: {
        date: "full-date notation as defined by RFC 3339, section 5.6, for example, 2017-07-21",
        "date-time": "the date-time notation as defined by RFC 3339, section 5.6, for example, 2017-07-21T17:32:28Z",
        password: "a hint to UIs to mask the input",
        byte: "base64-encoded characters, for example, U3dhZ2dlciByb2Nrcw==",
        binary: "binary data, used to describe files"
      }
    }, r = function(i) {
      return !i || !e[i.type] ? null : e[i.type][i.format || "_default"];
    }, n = ["oneOf", "anyOf", "allOf", "not"];
    return (i, s) => {
      var o, a, l, c, u, d, f, h, p, g, m, y, O, b, w;
      return k(), C("div", {
        class: $e(["property", [
          `property--level-${i.level}`,
          {
            "property--compact": i.compact,
            "property--deprecated": (o = i.value) == null ? void 0 : o.deprecated
          }
        ]])
      }, [
        x("div", nJ, [
          i.name ? (k(), C("div", iJ, te(i.name), 1)) : H("", !0),
          (a = i.value) != null && a.deprecated ? (k(), C("div", sJ, [
            Z(v(Qo), null, {
              default: I(() => [
                re("deprecated")
              ]),
              _: 1
            })
          ])) : H("", !0),
          i.required ? (k(), C("div", oJ, " required ")) : H("", !0),
          (l = i.value) != null && l.type ? (k(), C("div", aJ, [
            (c = i.value) != null && c.items && !["object"].includes(i.value.items.type) ? (k(), C(ee, { key: 0 }, [
              re(te(i.value.type) + " " + te(i.value.items.type) + "[] ", 1),
              i.value.items.example ? (k(), C("code", lJ, " example: " + te(i.value.items.example), 1)) : H("", !0)
            ], 64)) : (k(), C(ee, { key: 1 }, [
              re(te(i.value.type), 1)
            ], 64)),
            i.value.minItems || i.value.maxItems ? (k(), C(ee, { key: 2 }, [
              re(te(i.value.minItems) + ".." + te(i.value.maxItems), 1)
            ], 64)) : H("", !0),
            i.value.minLength ? (k(), C(ee, { key: 3 }, [
              re(" Â· min: " + te(i.value.minLength), 1)
            ], 64)) : H("", !0),
            i.value.maxLength ? (k(), C(ee, { key: 4 }, [
              re(" Â· max: " + te(i.value.maxLength), 1)
            ], 64)) : H("", !0),
            i.value.uniqueItems ? (k(), C(ee, { key: 5 }, [
              re(" unique! ")
            ], 64)) : H("", !0),
            i.value.format ? (k(), C(ee, { key: 6 }, [
              re(" Â· " + te(i.value.format), 1)
            ], 64)) : H("", !0),
            i.value.minimum ? (k(), C(ee, { key: 7 }, [
              re(" Â· min: " + te(i.value.minimum), 1)
            ], 64)) : H("", !0),
            i.value.maximum ? (k(), C(ee, { key: 8 }, [
              re(" Â· max: " + te(i.value.maximum), 1)
            ], 64)) : H("", !0),
            i.value.pattern ? (k(), C(ee, { key: 9 }, [
              re(" Â· "),
              x("code", cJ, te(i.value.pattern), 1)
            ], 64)) : H("", !0),
            i.value.enum ? (k(), C(ee, { key: 10 }, [
              re(" Â· enum ")
            ], 64)) : H("", !0),
            i.value.default ? (k(), C(ee, { key: 11 }, [
              re(" Â· default: " + te(i.value.default), 1)
            ], 64)) : H("", !0)
          ])) : H("", !0),
          (u = i.value) != null && u.writeOnly ? (k(), C("div", uJ, " write-only ")) : (d = i.value) != null && d.readOnly ? (k(), C("div", dJ, " read-only ")) : H("", !0),
          (k(), C(ee, null, _e(n, (S) => {
            var $, _, Q;
            return k(), C(ee, { key: S }, [
              ($ = i.value) != null && $[S] || (Q = (_ = i.value) == null ? void 0 : _.items) != null && Q[S] ? (k(), C("div", fJ, [
                Z(v(Qo), null, {
                  default: I(() => [
                    re(te(S), 1)
                  ]),
                  _: 2
                }, 1024)
              ])) : H("", !0)
            ], 64);
          }), 64)),
          (f = i.value) != null && f.nullable ? (k(), C("div", hJ, " nullable ")) : H("", !0),
          ((h = i.value) == null ? void 0 : h.example) !== void 0 ? (k(), C("div", pJ, [
            x("code", mJ, " example: " + te(i.value.example), 1)
          ])) : H("", !0)
        ]),
        i.description || (p = i.value) != null && p.description ? (k(), C("div", gJ, [
          Z(v(Tr), {
            value: i.description || ((g = i.value) == null ? void 0 : g.description)
          }, null, 8, ["value"])
        ])) : r(i.value) ? (k(), C("div", OJ, [
          Z(v(Tr), {
            value: r(i.value) || ""
          }, null, 8, ["value"])
        ])) : H("", !0),
        (m = i.value) != null && m.enum ? (k(), C("div", yJ, [
          x("ul", bJ, [
            (k(!0), C(ee, null, _e(i.value.enum, (S) => (k(), C("li", {
              key: S,
              class: "property-enum-value"
            }, te(S), 1))), 128))
          ])
        ])) : H("", !0),
        ((y = i.value) == null ? void 0 : y.type) === "object" && ((O = i.value) != null && O.properties || (b = i.value) != null && b.additionalProperties) ? (k(), C("div", vJ, [
          Z(ns, {
            compact: i.compact,
            level: i.level + 1,
            value: i.value
          }, null, 8, ["compact", "level", "value"])
        ])) : H("", !0),
        (w = i.value) != null && w.items ? (k(), C(ee, { key: 4 }, [
          ["object"].includes(i.value.items.type) ? (k(), C("div", wJ, [
            Z(ns, {
              compact: i.compact,
              level: i.level + 1,
              value: i.value.items
            }, null, 8, ["compact", "level", "value"])
          ])) : H("", !0)
        ], 64)) : H("", !0),
        (k(), C(ee, null, _e(n, (S) => {
          var $, _, Q;
          return k(), C(ee, { key: S }, [
            ($ = i.value) != null && $[S] ? (k(), C("div", $J, [
              (k(!0), C(ee, null, _e(i.value[S], (N, B) => (k(), Y(ns, {
                key: B,
                compact: i.compact,
                level: i.level + 1,
                value: N
              }, null, 8, ["compact", "level", "value"]))), 128))
            ])) : H("", !0),
            (Q = (_ = i.value) == null ? void 0 : _.items) != null && Q[S] && i.level < 3 ? (k(), C("div", SJ, [
              (k(!0), C(ee, null, _e(i.value.items[S], (N, B) => (k(), Y(ns, {
                key: B,
                compact: i.compact,
                level: i.level + 1,
                value: N
              }, null, 8, ["compact", "level", "value"]))), 128))
            ])) : H("", !0)
          ], 64);
        }), 64))
      ], 2);
    };
  }
}), fl = /* @__PURE__ */ oe(kJ, [["__scopeId", "data-v-ce33abd5"]]), _J = (t) => (fr("data-v-30a3168e"), t = t(), hr(), t), PJ = /* @__PURE__ */ _J(() => /* @__PURE__ */ x("polygon", {
  "fill-rule": "nonzero",
  points: "14 8 8 8 8 14 6 14 6 8 0 8 0 6 6 6 6 0 8 0 8 6 14 6"
}, null, -1)), xJ = [
  PJ
], TJ = /* @__PURE__ */ G({
  __name: "Schema",
  props: {
    value: {},
    level: { default: 0 },
    name: {},
    compact: { type: Boolean },
    noncollapsible: { type: Boolean }
  },
  setup(t) {
    const e = t, r = fe(() => !(e.noncollapsible || e.level === 0)), n = fe(() => {
      var s, o;
      return {
        ...typeof e.value == "object" ? e.value : {},
        ...typeof e.value == "object" && typeof ((s = e.value) == null ? void 0 : s.additionalProperties) == "object" ? (o = e.value) == null ? void 0 : o.additionalProperties : {}
      };
    }), i = (s) => e.noncollapsible && s.stopPropagation();
    return (s, o) => typeof s.value == "object" && Object.keys(s.value).length ? (k(), Y(v(zu), {
      key: 0,
      defaultOpen: s.noncollapsible
    }, {
      default: I(({ open: a }) => [
        x("div", {
          class: $e(["schema-card", [
            `schema-card--level-${s.level}`,
            { "schema-card--compact": s.compact, "schema-card--open": a }
          ]])
        }, [
          x("div", {
            class: $e(["schema-properties", { "schema-properties-open": a }])
          }, [
            Ne(Z(v(Xu), {
              as: s.noncollapsible ? "div" : "button",
              class: $e(["schema-card-title", { "schema-card-title--compact": s.compact }]),
              style: Eo({
                top: `calc(var(--refs-header-height) +  calc(var(--schema-title-height) * ${s.level}))`
              }),
              onClickCapture: i
            }, {
              default: I(() => [
                s.compact ? (k(), C(ee, { key: 0 }, [
                  r.value ? (k(), C("svg", {
                    key: 0,
                    class: $e(["schema-card-title-icon", { "schema-card-title-icon--open": a }]),
                    fill: "currentColor",
                    height: "14",
                    viewBox: "0 0 14 14",
                    width: "14",
                    xmlns: "http://www.w3.org/2000/svg"
                  }, xJ, 2)) : H("", !0),
                  a ? (k(), C(ee, { key: 1 }, [
                    re("Hide Child Attributes")
                  ], 64)) : (k(), C(ee, { key: 2 }, [
                    re("Show Child Attributes")
                  ], 64))
                ], 64)) : (k(), C(ee, { key: 1 }, [
                  r.value ? (k(), Y(v($t), {
                    key: 0,
                    class: $e(["schema-card-title-icon", { "schema-card-title-icon--open": a }]),
                    icon: "ChevronRight",
                    size: "md"
                  }, null, 8, ["class"])) : H("", !0),
                  Z(C5, {
                    name: s.name,
                    value: n.value
                  }, null, 8, ["name", "value"])
                ], 64))
              ]),
              _: 2
            }, 1032, ["as", "class", "style"]), [
              [mn, !(s.noncollapsible && s.compact)]
            ]),
            Z(v(Wu), { static: s.noncollapsible }, {
              default: I(() => {
                var l, c, u;
                return [
                  (l = n.value) != null && l.properties ? (k(!0), C(ee, { key: 0 }, _e(Object.keys((c = n.value) == null ? void 0 : c.properties), (d) => {
                    var f;
                    return k(), Y(fl, {
                      key: d,
                      compact: s.compact,
                      level: s.level,
                      name: d,
                      required: n.value.required && n.value.required.length && n.value.required.includes(d),
                      value: (f = n.value.properties) == null ? void 0 : f[d]
                    }, null, 8, ["compact", "level", "name", "required", "value"]);
                  }), 128)) : (k(), Y(fl, {
                    key: 1,
                    compact: s.compact,
                    level: s.level,
                    name: (u = n.value) == null ? void 0 : u.name,
                    value: n.value
                  }, null, 8, ["compact", "level", "name", "value"]))
                ];
              }),
              _: 1
            }, 8, ["static"])
          ], 2)
        ], 2)
      ]),
      _: 1
    }, 8, ["defaultOpen"])) : H("", !0);
  }
}), ns = /* @__PURE__ */ oe(TJ, [["__scopeId", "data-v-30a3168e"]]), CJ = { class: "parameter-item" }, QJ = { class: "parameter-item-container" }, AJ = /* @__PURE__ */ G({
  __name: "ParameterItem",
  props: {
    parameter: {},
    showChildren: { type: Boolean, default: !1 }
  },
  setup(t) {
    return (e, r) => (k(), C("li", CJ, [
      x("div", QJ, [
        Z(v(fl), {
          compact: "",
          description: e.parameter.description,
          level: 0,
          name: e.parameter.name,
          noncollapsible: e.showChildren,
          required: e.parameter.required,
          value: e.parameter.schema
        }, null, 8, ["description", "name", "noncollapsible", "required", "value"])
      ])
    ]));
  }
}), EJ = /* @__PURE__ */ oe(AJ, [["__scopeId", "data-v-163ee83c"]]), RJ = {
  key: 0,
  class: "parameters"
}, IJ = { class: "parameters-title" }, jJ = { class: "parameter-list" }, ZJ = /* @__PURE__ */ G({
  __name: "Parameters",
  props: {
    parameters: {},
    showChildren: { type: Boolean, default: !1 }
  },
  setup(t) {
    return (e, r) => {
      var n;
      return (n = e.parameters) != null && n.length ? (k(), C("div", RJ, [
        x("div", IJ, [
          se(e.$slots, "title", {}, void 0, !0)
        ]),
        x("ul", jJ, [
          (k(!0), C(ee, null, _e(e.parameters, (i) => (k(), Y(EJ, {
            key: i.name,
            parameter: i,
            showChildren: e.showChildren
          }, null, 8, ["parameter", "showChildren"]))), 128))
        ])
      ])) : H("", !0);
    };
  }
}), Mr = /* @__PURE__ */ oe(ZJ, [["__scopeId", "data-v-763a1ede"]]), MJ = { key: 0 }, qJ = { class: "request-body-title" }, NJ = ["value"], DJ = {
  key: 0,
  class: "request-body-schema"
}, zJ = /* @__PURE__ */ G({
  __name: "RequestBody",
  props: {
    requestBody: {}
  },
  setup(t) {
    var i;
    const e = t, r = fe(() => {
      var s;
      return (s = e.requestBody) != null && s.content ? Object.keys(e.requestBody.content) : [];
    }), n = ge("application/json");
    return (i = e.requestBody) != null && i.content && r.value.length > 0 && (n.value = r.value[0]), (s, o) => {
      var a, l, c, u;
      return e != null && e.requestBody ? (k(), C("div", MJ, [
        x("div", qJ, [
          se(s.$slots, "title", {}, void 0, !0),
          x("div", {
            class: $e(["request-body-title-select", { "request-body-title-no-select": r.value.length <= 1 }])
          }, [
            x("span", null, te(n.value), 1),
            e != null && e.requestBody && r.value.length > 1 ? Ne((k(), C("select", {
              key: 0,
              "onUpdate:modelValue": o[0] || (o[0] = (d) => n.value = d)
            }, [
              (k(!0), C(ee, null, _e((a = e.requestBody) == null ? void 0 : a.content, (d, f) => (k(), C("option", {
                key: f,
                value: f
              }, te(f), 9, NJ))), 128))
            ], 512)), [
              [Bb, n.value]
            ]) : H("", !0)
          ], 2)
        ]),
        (l = e == null ? void 0 : e.requestBody.content) != null && l[n.value] ? (k(), C("div", DJ, [
          Z(v(ns), {
            compact: "",
            noncollapsible: "",
            value: (u = (c = e == null ? void 0 : e.requestBody.content) == null ? void 0 : c[n.value]) == null ? void 0 : u.schema
          }, null, 8, ["value"])
        ])) : H("", !0)
      ])) : H("", !0);
    };
  }
}), u0 = /* @__PURE__ */ oe(zJ, [["__scopeId", "data-v-64cd513c"]]), XJ = { class: "endpoint-details" }, WJ = { class: "endpoint-description" }, UJ = /* @__PURE__ */ G({
  __name: "EndpointDetails",
  props: {
    operation: {}
  },
  setup(t) {
    const e = t, { parameterMap: r } = Bm(e), { responses: n } = Fm(e.operation);
    return (i, s) => {
      var o, a;
      return k(), C("div", XJ, [
        x("div", WJ, [
          Z(v(Tr), {
            value: i.operation.description
          }, null, 8, ["value"])
        ]),
        Z(Mr, {
          parameters: v(r).path
        }, {
          title: I(() => [
            re("Path Parameters")
          ]),
          _: 1
        }, 8, ["parameters"]),
        Z(Mr, {
          parameters: v(r).query
        }, {
          title: I(() => [
            re("Query Parameters")
          ]),
          _: 1
        }, 8, ["parameters"]),
        Z(Mr, {
          parameters: v(r).header
        }, {
          title: I(() => [
            re("Headers")
          ]),
          _: 1
        }, 8, ["parameters"]),
        Z(Mr, {
          parameters: v(r).body,
          showChildren: ""
        }, {
          title: I(() => [
            re("Body Parameters")
          ]),
          _: 1
        }, 8, ["parameters"]),
        Z(Mr, {
          parameters: v(r).formData
        }, {
          title: I(() => [
            re("Form Data")
          ]),
          _: 1
        }, 8, ["parameters"]),
        (o = i.operation.information) != null && o.requestBody ? (k(), Y(u0, {
          key: 0,
          requestBody: (a = i.operation.information) == null ? void 0 : a.requestBody
        }, {
          title: I(() => [
            re("Body")
          ]),
          _: 1
        }, 8, ["requestBody"])) : H("", !0),
        Z(Mr, { parameters: v(n) }, {
          title: I(() => [
            re("Responses")
          ]),
          _: 1
        }, 8, ["parameters"])
      ]);
    };
  }
}), VJ = { key: 0 }, LJ = /* @__PURE__ */ G({
  __name: "EndpointPath",
  props: {
    path: {},
    deprecated: { type: Boolean }
  },
  setup(t) {
    const e = t, r = (i) => i.startsWith("{") && i.endsWith("}"), n = fe(() => e.path.split(/({[^}]+})/));
    return (i, s) => (k(), C("span", {
      class: $e(["endpoint-path", { deprecated: i.deprecated }])
    }, [
      (k(!0), C(ee, null, _e(n.value, (o, a) => (k(), C(ee, { key: a }, [
        r(o) ? (k(), C("em", VJ, te(o), 1)) : (k(), C(ee, { key: 1 }, [
          re(te(o), 1)
        ], 64))
      ], 64))), 128))
    ], 2));
  }
}), Vp = /* @__PURE__ */ oe(LJ, [["__scopeId", "data-v-08374039"]]);
function d0(t) {
  return t.reduce((e, r) => (e[r.name] = r.value, e), {});
}
function YJ(t) {
  return /\s|-/.test(t);
}
function Pi(t, e = 0) {
  let r = [], n = " ".repeat(e), i = " ".repeat(e + 2);
  for (const [s, o] of Object.entries(t)) {
    let a = YJ(s) ? `'${s}'` : s;
    if (Array.isArray(o)) {
      const l = o.map((c) => typeof c == "string" ? `'${c}'` : c && typeof c == "object" ? Pi(c, e + 2) : c).join(`, ${i}`);
      r.push(`${i}${a}: [${l}]`);
    } else if (o && typeof o == "object")
      r.push(
        `${i}${a}: ${Pi(
          o,
          e + 2
        )}`
      );
    else if (typeof o == "string") {
      let l = `${o}`;
      if (o.startsWith("JSON.stringify")) {
        const c = o.split(`
`);
        c.length > 1 && (l = c.map((u, d) => d === 0 ? u : `${i}${u}`).join(`
`));
      } else
        l = `'${o}'`;
      r.push(`${i}${a}: ${l}`);
    } else
      r.push(`${i}${a}: ${o}`);
  }
  return `{
${r.join(`,
`)}
${n}}`;
}
function BJ(t) {
  var e, r;
  const n = {
    method: "GET",
    ...t
  };
  n.method = n.method.toUpperCase();
  const i = {
    method: n.method === "GET" ? void 0 : n.method
  }, s = new URLSearchParams(
    n.queryString ? d0(n.queryString) : void 0
  ), o = s.size ? `?${s.toString()}` : "";
  (e = n.headers) != null && e.length && (i.headers = {}, n.headers.forEach((l) => {
    i.headers[l.name] = l.value;
  })), (r = n.cookies) != null && r.length && (i.headers = i.headers || {}, n.cookies.forEach((l) => {
    i.headers["Set-Cookie"] = i.headers["Set-Cookie"] ? `${i.headers["Set-Cookie"]}; ${l.name}=${l.value}` : `${l.name}=${l.value}`;
  })), Object.keys(i).forEach((l) => {
    i[l] === void 0 && delete i[l];
  }), n.postData && (i.body = n.postData.text, n.postData.mimeType === "application/json" && (i.body = `JSON.stringify(${Pi(JSON.parse(i.body))})`));
  const a = Object.keys(i).length ? `, ${Pi(i)}` : "";
  return {
    target: "node",
    client: "undici",
    code: `import { request } from 'undici'

const { statusCode, body } = await request('${n.url}${o}'${a})`
  };
}
function FJ(t) {
  var e, r;
  const n = {
    method: "GET",
    ...t
  };
  n.method = n.method.toUpperCase();
  const i = {
    method: n.method === "GET" ? void 0 : n.method
  }, s = new URLSearchParams(
    n.queryString ? d0(n.queryString) : void 0
  ), o = s.size ? `?${s.toString()}` : "";
  (e = n.headers) != null && e.length && (i.headers = {}, n.headers.forEach((l) => {
    i.headers[l.name] = l.value;
  })), (r = n.cookies) != null && r.length && (i.headers = i.headers || {}, n.cookies.forEach((l) => {
    i.headers["Set-Cookie"] = i.headers["Set-Cookie"] ? `${i.headers["Set-Cookie"]}; ${l.name}=${l.value}` : `${l.name}=${l.value}`;
  })), Object.keys(i).forEach((l) => {
    i[l] === void 0 && delete i[l];
  }), n.postData && (i.body = n.postData.text, n.postData.mimeType === "application/json" && (i.body = `JSON.stringify(${Pi(
    JSON.parse(i.body)
  )})`));
  const a = Object.keys(i).length ? `, ${Pi(i)}` : "";
  return {
    target: "node",
    client: "fetch",
    code: `fetch('${n.url}${o}'${a})`
  };
}
function HJ(t) {
  var e, r;
  const n = {
    method: "GET",
    ...t
  };
  n.method = n.method.toUpperCase();
  const i = {
    method: n.method === "GET" ? void 0 : n.method
  }, s = new URLSearchParams(
    n.queryString ? d0(n.queryString) : void 0
  ), o = s.size ? `?${s.toString()}` : "";
  (e = n.headers) != null && e.length && (i.headers = {}, n.headers.forEach((l) => {
    i.headers[l.name] = l.value;
  })), (r = n.cookies) != null && r.length && (i.headers = i.headers || {}, n.cookies.forEach((l) => {
    i.headers["Set-Cookie"] = i.headers["Set-Cookie"] ? `${i.headers["Set-Cookie"]}; ${l.name}=${l.value}` : `${l.name}=${l.value}`;
  })), Object.keys(i).forEach((l) => {
    i[l] === void 0 && delete i[l];
  }), n.postData && (i.body = n.postData.text, n.postData.mimeType === "application/json" && (i.body = `JSON.stringify(${Pi(
    JSON.parse(i.body)
  )})`));
  const a = Object.keys(i).length ? `, ${Pi(i)}` : "";
  return {
    target: "js",
    client: "fetch",
    code: `fetch('${n.url}${o}'${a})`
  };
}
function Vb() {
  const t = [BJ, FJ, HJ];
  return {
    get(e, r, n) {
      const i = this.findPlugin(e, r);
      if (i)
        return i(n);
    },
    print(e, r, n) {
      var i;
      return (i = this.get(e, r, n)) == null ? void 0 : i.code;
    },
    targets() {
      return t.map((e) => e().target).filter((e, r, n) => n.indexOf(e) === r);
    },
    clients() {
      return t.map((e) => e().client);
    },
    plugins() {
      return t.map((e) => {
        const r = e();
        return {
          target: r.target,
          client: r.client
        };
      });
    },
    findPlugin(e, r) {
      return t.find((n) => {
        const i = n();
        return i.target === e && i.client === r;
      });
    },
    hasPlugin(e, r) {
      return !!this.findPlugin(e, r);
    }
  };
}
const GJ = /* @__PURE__ */ G({
  __name: "ExamplePicker",
  props: {
    examples: {}
  },
  emits: ["update:modelValue"],
  setup(t, { emit: e }) {
    const r = t, n = e, i = ge(Object.keys(r.examples)[0]);
    function s(a) {
      a && (i.value = a);
    }
    Ve(
      () => r.examples,
      () => {
        s(Object.keys(r.examples)[0]);
      },
      { immediate: !0 }
    ), Ve(
      i,
      () => {
        i.value && n("update:modelValue", i.value);
      },
      { immediate: !0 }
    );
    function o(a) {
      if (!a)
        return "Select an example";
      const l = r.examples[a];
      return (l == null ? void 0 : l.summary) ?? a;
    }
    return (a, l) => (k(), Y(c0, {
      modelValue: i.value,
      "onUpdate:modelValue": l[0] || (l[0] = (c) => i.value = c),
      class: "example-selector",
      options: Object.keys(a.examples).map((c) => ({
        label: o(c),
        value: c
      }))
    }, {
      default: I(() => [
        re(te(o(i.value)), 1)
      ]),
      _: 1
    }, 8, ["modelValue", "options"]));
  }
}), Q5 = /* @__PURE__ */ oe(GJ, [["__scopeId", "data-v-652a7e14"]]), KJ = { class: "request-header" }, JJ = { class: "code-snippet" }, eee = {
  key: 0,
  class: "request-card-footer-addon"
}, tee = /* @__PURE__ */ G({
  __name: "ExampleRequest",
  props: {
    operation: {}
  },
  setup(t) {
    const e = t, r = ge(""), n = ge(), { copyToClipboard: i } = Xo(), { state: s, setItem: o, getClientTitle: a, getTargetTitle: l } = o0(), { availableTargets: c } = xl(), { server: u, authentication: d } = Ti(), f = fe(
      () => {
        var p, g, m, y, O, b, w;
        return ((y = (m = (g = (p = e.operation.information) == null ? void 0 : p.requestBody) == null ? void 0 : g.content) == null ? void 0 : m["application/json"]) == null ? void 0 : y.examples) && Object.keys(
          (w = (b = (O = e.operation.information) == null ? void 0 : O.requestBody) == null ? void 0 : b.content) == null ? void 0 : w["application/json"].examples
        ).length > 1;
      }
    ), h = async () => {
      var g;
      const p = H$(
        {
          url: np(u) ?? window.location.origin
        },
        rp(
          e.operation,
          {
            replaceVariables: !0
          },
          n.value
        ),
        K$(
          d,
          (g = e.operation.information) == null ? void 0 : g.security
        )
      );
      try {
        return Vb().hasPlugin(
          s.selectedClient.targetKey.replace("javascript", "js"),
          // @ts-ignore
          s.selectedClient.clientKey
        ) ? Vb().print(
          // @ts-ignore
          s.selectedClient.targetKey.replace("javascript", "js"),
          s.selectedClient.clientKey,
          p
        ) ?? "" : await new $3(p).convert(
          s.selectedClient.targetKey,
          s.selectedClient.clientKey
        );
      } catch (m) {
        return console.error("[ExampleRequest]", m), "";
      }
    };
    return Ve(
      [
        // Update snippet when a different client is selected
        () => s.selectedClient,
        // â€¦ or the global server state changed
        () => u,
        // â€¦ or the global authentication state changed
        () => d,
        // â€¦ or the selected example key
        () => n
      ],
      async () => {
        r.value = await h();
      },
      {
        deep: !0,
        immediate: !0
      }
    ), fe(() => F$({
      serverState: u,
      authenticationState: d,
      operation: e.operation
    })), (p, g) => (k(), Y(v(vs), { class: "dark-mode" }, {
      default: I(() => [
        Z(v(ws), { muted: "" }, {
          actions: I(() => [
            Z(c0, {
              class: "request-client-picker",
              modelValue: JSON.stringify(v(s).selectedClient),
              options: v(c).map((m) => ({
                value: m.key,
                label: m.title,
                options: m.clients.map((y) => ({
                  value: JSON.stringify({
                    targetKey: m.key,
                    clientKey: y.key
                  }),
                  label: y.title
                }))
              })),
              "onUpdate:modelValue": g[0] || (g[0] = (m) => v(o)("selectedClient", JSON.parse(m)))
            }, {
              default: I(() => [
                re(te(v(l)(v(s).selectedClient)) + " " + te(v(a)(v(s).selectedClient)), 1)
              ]),
              _: 1
            }, 8, ["modelValue", "options"]),
            x("button", {
              class: "copy-button",
              type: "button",
              onClick: g[1] || (g[1] = (m) => v(i)(r.value))
            }, [
              Z(v($t), {
                icon: "Clipboard",
                width: "10px"
              })
            ])
          ]),
          default: I(() => [
            x("div", KJ, [
              Z(v(xi), {
                as: "span",
                class: "request-method",
                method: p.operation.httpVerb
              }, null, 8, ["method"]),
              se(p.$slots, "header", {}, void 0, !0)
            ])
          ]),
          _: 3
        }),
        Z(v(bn), {
          borderless: "",
          class: "request-editor-section custom-scroll",
          frameless: ""
        }, {
          default: I(() => [
            x("div", JJ, [
              Z(v(Qn), {
                content: r.value,
                hideCredentials: v(MR)(v(d)),
                lang: v(s).selectedClient.targetKey,
                lineNumbers: ""
              }, null, 8, ["content", "hideCredentials", "lang"])
            ])
          ]),
          _: 1
        }),
        f.value || p.$slots.footer ? (k(), Y(v(Id), {
          key: 0,
          class: "request-card-footer",
          contrast: ""
        }, {
          default: I(() => {
            var m, y, O, b;
            return [
              f.value ? (k(), C("div", eee, [
                Z(Q5, {
                  class: "request-example-selector",
                  examples: ((b = (O = (y = (m = p.operation.information) == null ? void 0 : m.requestBody) == null ? void 0 : y.content) == null ? void 0 : O["application/json"]) == null ? void 0 : b.examples) ?? [],
                  "onUpdate:modelValue": g[2] || (g[2] = (w) => n.value = w)
                }, null, 8, ["examples"])
              ])) : H("", !0),
              se(p.$slots, "footer", {}, void 0, !0)
            ];
          }),
          _: 3
        })) : H("", !0)
      ]),
      _: 3
    }));
  }
}), A5 = /* @__PURE__ */ oe(tee, [["__scopeId", "data-v-aadec75b"]]), ree = { key: 0 }, nee = { key: 1 }, iee = {
  key: 0,
  class: "rule"
}, see = { class: "rule-title" }, oee = { class: "rule-items" }, aee = {
  key: 2,
  class: "empty-state"
}, lee = /* @__PURE__ */ G({
  __name: "ExampleResponse",
  props: {
    response: {}
  },
  setup(t) {
    const e = ["oneOf", "anyOf", "not"], r = (n) => n.reduce((i, s) => ({
      ...i,
      ...s
    }), {});
    return (n, i) => {
      var s, o, a, l, c, u, d;
      return (s = n.response) != null && s.example ? (k(), C("div", ree, [
        Z(v(Qn), {
          content: v(wu)((o = n.response) == null ? void 0 : o.example),
          lang: "json"
        }, null, 8, ["content"])
      ])) : (a = n.response) != null && a.schema ? (k(), C("div", nee, [
        (l = n.response) != null && l.schema.type ? (k(), Y(v(Qn), {
          key: 0,
          content: v(wu)(
            v(Yt)((c = n.response) == null ? void 0 : c.schema, {
              emptyString: "â€¦",
              mode: "read"
            })
          ),
          lang: "json"
        }, null, 8, ["content"])) : H("", !0),
        (k(), C(ee, null, _e(e, (f) => {
          var h, p, g, m, y, O;
          return k(), C(ee, { key: f }, [
            (h = n.response) != null && h.schema[f] && (((p = n.response) == null ? void 0 : p.schema[f].length) > 1 || f === "not") ? (k(), C("div", iee, [
              x("div", see, te(f), 1),
              x("ol", oee, [
                (k(!0), C(ee, null, _e((g = n.response) == null ? void 0 : g.schema[f], (b, w) => (k(), C("li", {
                  key: w,
                  class: "rule-item"
                }, [
                  Z(v(Qn), {
                    content: v(Yt)(b, {
                      emptyString: "â€¦",
                      mode: "read"
                    }),
                    lang: "json"
                  }, null, 8, ["content"])
                ]))), 128))
              ])
            ])) : (m = n.response) != null && m.schema[f] && ((y = n.response) == null ? void 0 : y.schema[f].length) === 1 ? (k(), Y(v(Qn), {
              key: 1,
              content: v(Yt)((O = n.response) == null ? void 0 : O.schema[f][0], {
                emptyString: "â€¦",
                mode: "read"
              }),
              lang: "json"
            }, null, 8, ["content"])) : H("", !0)
          ], 64);
        }), 64)),
        (u = n.response) != null && u.schema.allOf ? (k(), Y(v(Qn), {
          key: 1,
          content: r(
            (d = n.response) == null ? void 0 : d.schema.allOf.map(
              (f) => v(Yt)(f, {
                emptyString: "â€¦",
                mode: "read"
              })
            )
          ),
          lang: "json"
        }, null, 8, ["content"])) : H("", !0)
      ])) : (k(), C("div", aee, " No Body "));
    };
  }
}), Lb = /* @__PURE__ */ oe(lee, [["__scopeId", "data-v-2a82252b"]]), cee = (t) => (fr("data-v-f2d04186"), t = t(), hr(), t), uee = {
  key: 1,
  class: "scalar-card-checkbox"
}, dee = /* @__PURE__ */ cee(() => /* @__PURE__ */ x("span", { class: "scalar-card-checkbox-checkmark" }, null, -1)), fee = { class: "scalar-card-container custom-scroll" }, hee = {
  key: 1,
  class: "response-description"
}, pee = /* @__PURE__ */ G({
  __name: "PathResponses",
  props: {
    operation: {}
  },
  setup(t) {
    const e = t, { copyToClipboard: r } = Xo(), n = ge(), i = fe(() => {
      var f, h;
      return Object.keys(((h = (f = e == null ? void 0 : e.operation) == null ? void 0 : f.information) == null ? void 0 : h.responses) ?? {}).sort(
        (p) => p === "default" ? -1 : 0
      );
    }), s = fe(
      () => !!l.value.examples && Object.keys(l.value.examples).length > 1
    ), o = ge(0), a = fe(() => {
      var h, p;
      const f = i.value[o.value];
      return (p = (h = e.operation.information) == null ? void 0 : h.responses) == null ? void 0 : p[f];
    }), l = fe(
      () => {
        var f, h, p, g, m, y;
        return (
          // OpenAPI 3.x
          ((h = (f = a.value) == null ? void 0 : f.content) == null ? void 0 : h["application/json"]) ?? ((g = (p = a.value) == null ? void 0 : p.content) == null ? void 0 : g["application/json; charset=utf-8"]) ?? ((y = (m = a.value) == null ? void 0 : m.content) == null ? void 0 : y["application/problem+json"]) ?? // Swagger 2.0
          a.value
        );
      }
    ), c = fe(() => ({
      ...l.value,
      example: s.value && n.value ? l.value.examples[n.value] : l.value.example
    })), u = (f) => {
      o.value = f;
    }, d = ge(!1);
    return (f, h) => i.value.length ? (k(), Y(v(vs), { key: 0 }, {
      default: I(() => {
        var p;
        return [
          Z(v(NH), {
            muted: "",
            x: "as",
            onChange: u
          }, {
            actions: I(() => {
              var g, m;
              return [
                (g = l.value) != null && g.example ? (k(), C("button", {
                  key: 0,
                  class: "code-copy",
                  type: "button",
                  onClick: h[0] || (h[0] = () => {
                    var y;
                    return v(r)((y = l.value) == null ? void 0 : y.example);
                  })
                }, [
                  Z(v($t), {
                    icon: "Clipboard",
                    width: "10px",
                    x: "asd"
                  })
                ])) : H("", !0),
                (m = l.value) != null && m.schema ? (k(), C("label", uee, [
                  re(" Show Schema "),
                  Ne(x("input", {
                    "onUpdate:modelValue": h[1] || (h[1] = (y) => d.value = y),
                    class: "scalar-card-checkbox-input",
                    type: "checkbox"
                  }, null, 512), [
                    [Ca, d.value]
                  ]),
                  dee
                ])) : H("", !0)
              ];
            }),
            default: I(() => [
              (k(!0), C(ee, null, _e(i.value, (g) => (k(), Y(v(zH), { key: g }, {
                default: I(() => [
                  re(te(g), 1)
                ]),
                _: 2
              }, 1024))), 128))
            ]),
            _: 1
          }),
          x("div", fee, [
            Z(v(bn), { muted: "" }, {
              default: I(() => {
                var g;
                return [
                  (g = l.value) != null && g.schema ? (k(), C(ee, { key: 0 }, [
                    d.value && c.value ? (k(), Y(v(Qn), {
                      key: 0,
                      content: c.value,
                      lang: "json"
                    }, null, 8, ["content"])) : (k(), Y(Lb, {
                      key: 1,
                      response: c.value
                    }, null, 8, ["response"]))
                  ], 64)) : (k(), Y(Lb, {
                    key: 1,
                    response: c.value
                  }, null, 8, ["response"]))
                ];
              }),
              _: 1
            })
          ]),
          (p = a.value) != null && p.description || s.value ? (k(), Y(v(Id), {
            key: 0,
            class: "response-card-footer",
            muted: ""
          }, {
            default: I(() => {
              var g, m;
              return [
                s.value ? (k(), Y(Q5, {
                  key: 0,
                  class: "response-example-selector",
                  examples: (g = l.value) == null ? void 0 : g.examples,
                  "onUpdate:modelValue": h[2] || (h[2] = (y) => n.value = y)
                }, null, 8, ["examples"])) : (m = a.value) != null && m.description ? (k(), C("div", hee, [
                  Z(v(Tr), {
                    class: "markdown",
                    value: a.value.description
                  }, null, 8, ["value"])
                ])) : H("", !0)
              ];
            }),
            _: 1
          })) : H("", !0)
        ];
      }),
      _: 1
    })) : H("", !0);
  }
}), E5 = /* @__PURE__ */ oe(pee, [["__scopeId", "data-v-f2d04186"]]), mee = (t) => (fr("data-v-be432808"), t = t(), hr(), t), gee = /* @__PURE__ */ mee(() => /* @__PURE__ */ x("span", null, "Test Request", -1)), Oee = /* @__PURE__ */ G({
  __name: "TryRequestButton",
  props: {
    operation: {}
  },
  setup(t) {
    return (e, r) => (k(), Y(v(xi), {
      as: "button",
      class: "show-api-client-button",
      method: e.operation.httpVerb,
      property: "background",
      type: "button",
      onClick: r[0] || (r[0] = hl((n) => v(op)(e.operation), ["stop"]))
    }, {
      default: I(() => [
        gee,
        Z(v($t), { icon: "PaperAirplane" })
      ]),
      _: 1
    }, 8, ["method"]));
  }
}), Lp = /* @__PURE__ */ oe(Oee, [["__scopeId", "data-v-be432808"]]), yee = { class: "examples" }, bee = /* @__PURE__ */ G({
  __name: "Operation",
  props: {
    id: {},
    operation: {}
  },
  setup(t) {
    const e = t, r = fe(() => {
      var i;
      const n = ["x-custom-examples", "x-codeSamples", "x-code-samples"];
      for (const s of n)
        if ((i = e.operation.information) != null && i[s])
          return e.operation.information[s];
      return null;
    });
    return (n, i) => (k(), Y(v(Ho), {
      id: n.id,
      label: n.operation.name
    }, {
      default: I(() => [
        Z(v(Go), null, {
          default: I(() => [
            Z(v(l0), null, {
              default: I(() => [
                Z(v(Ao), null, {
                  default: I(() => {
                    var s, o;
                    return [
                      (s = n.operation.information) != null && s.deprecated ? (k(), Y(v(Qo), { key: 0 }, {
                        default: I(() => [
                          re(" Deprecated ")
                        ]),
                        _: 1
                      })) : H("", !0),
                      x("div", {
                        class: $e((o = n.operation.information) != null && o.deprecated ? "deprecated" : "")
                      }, [
                        Z(v(Ri), { level: 3 }, {
                          default: I(() => [
                            Z(v(Ii), {
                              id: n.id ?? ""
                            }, {
                              default: I(() => [
                                re(te(n.operation.name), 1)
                              ]),
                              _: 1
                            }, 8, ["id"])
                          ]),
                          _: 1
                        })
                      ], 2),
                      Z(UJ, { operation: n.operation }, null, 8, ["operation"])
                    ];
                  }),
                  _: 1
                }),
                Z(v(Ao), null, {
                  default: I(() => [
                    x("div", yee, [
                      r.value ? (k(), Y(JK, {
                        key: 0,
                        examples: r.value,
                        operation: n.operation
                      }, {
                        header: I(() => {
                          var s;
                          return [
                            Z(Vp, {
                              class: "example-path",
                              deprecated: (s = n.operation.information) == null ? void 0 : s.deprecated,
                              path: n.operation.path
                            }, null, 8, ["deprecated", "path"])
                          ];
                        }),
                        footer: I(() => [
                          Z(Lp, { operation: n.operation }, null, 8, ["operation"])
                        ]),
                        _: 1
                      }, 8, ["examples", "operation"])) : (k(), Y(A5, {
                        key: 1,
                        operation: n.operation
                      }, {
                        header: I(() => {
                          var s;
                          return [
                            Z(Vp, {
                              class: "example-path",
                              deprecated: (s = n.operation.information) == null ? void 0 : s.deprecated,
                              path: n.operation.path
                            }, null, 8, ["deprecated", "path"])
                          ];
                        }),
                        footer: I(() => [
                          Z(Lp, { operation: n.operation }, null, 8, ["operation"])
                        ]),
                        _: 1
                      }, 8, ["operation"])),
                      Z(v(E5), {
                        operation: n.operation,
                        style: { "margin-top": "12px" }
                      }, null, 8, ["operation"])
                    ])
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["id", "label"]));
  }
}), R5 = /* @__PURE__ */ oe(bee, [["__scopeId", "data-v-6a096129"]]), vee = { class: "endpoint-details-card" }, wee = /* @__PURE__ */ G({
  __name: "EndpointDetailsCard",
  props: {
    operation: {}
  },
  setup(t) {
    const e = t, { parameterMap: r } = Bm(e), { responses: n } = Fm(e.operation);
    return (i, s) => {
      var o;
      return k(), C("div", vee, [
        Z(Mr, {
          class: "endpoint-details-card-item",
          parameters: v(r).path
        }, {
          title: I(() => [
            re("Path Parameters")
          ]),
          _: 1
        }, 8, ["parameters"]),
        Z(Mr, {
          class: "endpoint-details-card-item",
          parameters: v(r).query
        }, {
          title: I(() => [
            re("Query Parameters")
          ]),
          _: 1
        }, 8, ["parameters"]),
        Z(Mr, {
          class: "endpoint-details-card-item",
          parameters: v(r).header
        }, {
          title: I(() => [
            re("Headers")
          ]),
          _: 1
        }, 8, ["parameters"]),
        Z(u0, {
          class: "endpoint-details-card-item",
          requestBody: (o = i.operation.information) == null ? void 0 : o.requestBody
        }, {
          title: I(() => [
            re("Body")
          ]),
          _: 1
        }, 8, ["requestBody"]),
        Z(Mr, {
          class: "endpoint-details-card-item",
          parameters: v(n)
        }, {
          title: I(() => [
            re("Responses")
          ]),
          _: 1
        }, 8, ["parameters"])
      ]);
    };
  }
}), $ee = /* @__PURE__ */ oe(wee, [["__scopeId", "data-v-0f5233d6"]]), See = { class: "endpoint-header" }, kee = { class: "endpoint-details" }, _ee = { class: "endpoint-label" }, Pee = { class: "endpoint-label-path" }, xee = { class: "endpoint-label-name" }, Tee = { class: "endpoint-content" }, Cee = /* @__PURE__ */ G({
  __name: "OperationAccordion",
  props: {
    id: {},
    operation: {}
  },
  setup(t) {
    const { copyToClipboard: e } = Xo();
    return (r, n) => (k(), Y(v(_5), {
      id: r.id,
      class: "reference-endpoint",
      transparent: ""
    }, Fp({
      title: I(() => [
        x("h3", See, [
          x("div", kee, [
            Z(v(xi), {
              class: "endpoint-type",
              method: r.operation.httpVerb,
              short: ""
            }, null, 8, ["method"]),
            Z(v(Ii), {
              id: r.id ?? "",
              class: "endpoint-anchor"
            }, {
              default: I(() => {
                var i;
                return [
                  x("div", _ee, [
                    x("div", Pee, [
                      Z(Vp, {
                        deprecated: (i = r.operation.information) == null ? void 0 : i.deprecated,
                        path: r.operation.path
                      }, null, 8, ["deprecated", "path"])
                    ]),
                    x("div", xee, te(r.operation.name), 1)
                  ])
                ];
              }),
              _: 1
            }, 8, ["id"])
          ])
        ])
      ]),
      actions: I(({ active: i }) => [
        i ? (k(), Y(Lp, {
          key: 0,
          operation: r.operation
        }, null, 8, ["operation"])) : (k(), Y(v($t), {
          key: 1,
          class: "endpoint-try-hint",
          icon: "PaperAirplane"
        })),
        Z(v(Vm), {
          class: "endpoint-copy",
          icon: "Clipboard",
          label: "Copy endpoint URL",
          size: "sm",
          variant: "ghost",
          onClick: n[0] || (n[0] = hl((s) => v(e)(r.operation.path), ["stop"]))
        })
      ]),
      default: I(() => [
        x("div", Tee, [
          Z($ee, { operation: r.operation }, null, 8, ["operation"]),
          Z(v(E5), { operation: r.operation }, null, 8, ["operation"]),
          Z(A5, { operation: r.operation }, null, 8, ["operation"])
        ])
      ]),
      _: 2
    }, [
      r.operation.description ? {
        name: "description",
        fn: I(() => [
          Z(v(Tr), {
            value: r.operation.description
          }, null, 8, ["value"])
        ]),
        key: "0"
      } : void 0
    ]), 1032, ["id"]));
  }
}), Qee = /* @__PURE__ */ oe(Cee, [["__scopeId", "data-v-e5fa534a"]]), Aee = /* @__PURE__ */ G({
  __name: "ShowMoreButton",
  props: {
    id: {}
  },
  setup(t) {
    const { setCollapsedSidebarItem: e } = Un();
    return (r, n) => (k(), C("button", {
      class: "show-more",
      type: "button",
      onClick: n[0] || (n[0] = (i) => v(e)(r.id, !0))
    }, [
      re(" Show More "),
      Z(v($t), {
        class: "show-more-icon",
        icon: "ChevronDown"
      })
    ]));
  }
}), I5 = /* @__PURE__ */ oe(Aee, [["__scopeId", "data-v-c0788f2e"]]), Eee = { class: "endpoints" }, Ree = ["onClick"], Iee = /* @__PURE__ */ G({
  __name: "Endpoints",
  props: {
    id: {},
    tag: {}
  },
  setup(t) {
    const e = t, { getOperationId: r, getTagId: n } = Jt(), { setCollapsedSidebarItem: i } = Un();
    async function s(o) {
      i(n(e.tag), !0), setTimeout(() => {
        window.location.href = `#${r(o, e.tag)}`;
      }, 0);
    }
    return (o, a) => (k(), Y(v(Ho), {
      id: o.id,
      label: o.tag.name.toUpperCase()
    }, {
      default: I(() => [
        Z(v(Go), null, {
          default: I(() => [
            Z(v(l0), null, {
              default: I(() => [
                Z(v(Ao), null, {
                  default: I(() => [
                    Z(v(Ri), { level: 2 }, {
                      default: I(() => [
                        Z(v(Ii), {
                          id: v(n)(o.tag)
                        }, {
                          default: I(() => [
                            re(te(o.tag.name), 1)
                          ]),
                          _: 1
                        }, 8, ["id"])
                      ]),
                      _: 1
                    }),
                    Z(v(Tr), {
                      value: o.tag.description
                    }, null, 8, ["value"])
                  ]),
                  _: 1
                }),
                Z(v(Ao), null, {
                  default: I(() => {
                    var l;
                    return [
                      ((l = o.tag.operations) == null ? void 0 : l.length) > 0 ? (k(), Y(v(vs), {
                        key: 0,
                        class: "scalar-card-sticky"
                      }, {
                        default: I(() => [
                          Z(v(ws), { muted: "" }, {
                            default: I(() => [
                              re("Endpoints")
                            ]),
                            _: 1
                          }),
                          Z(v(bn), {
                            class: "custom-scroll",
                            muted: ""
                          }, {
                            default: I(() => [
                              x("div", Eee, [
                                (k(!0), C(ee, null, _e(o.tag.operations, (c) => (k(), C("a", {
                                  key: v(r)(c, o.tag),
                                  class: "endpoint",
                                  onClick: (u) => s(c)
                                }, [
                                  Z(v(xi), {
                                    method: c.httpVerb
                                  }, null, 8, ["method"]),
                                  x("span", null, te(c.path), 1)
                                ], 8, Ree))), 128))
                              ])
                            ]),
                            _: 1
                          })
                        ]),
                        _: 1
                      })) : H("", !0)
                    ];
                  }),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["id", "label"]));
  }
}), jee = /* @__PURE__ */ oe(Iee, [["__scopeId", "data-v-45f15e70"]]), Zee = /* @__PURE__ */ G({
  __name: "Tag",
  props: {
    id: {},
    tag: {},
    spec: {}
  },
  setup(t) {
    const e = t, { collapsedSidebarItems: r } = Un(), { getTagId: n } = Jt(), i = (s) => {
      var o;
      return ((o = e.spec.tags) == null ? void 0 : o.length) !== 1 || (s == null ? void 0 : s.name) !== "default" || (s == null ? void 0 : s.description) !== "";
    };
    return (s, o) => (k(), Y(v(Wl), { class: "tag-section-container" }, {
      default: I(() => {
        var a;
        return [
          i(s.tag) ? (k(), Y(jee, {
            key: 0,
            id: s.id,
            tag: s.tag
          }, null, 8, ["id", "tag"])) : H("", !0),
          !v(r)[v(n)(s.tag)] && ((a = s.tag.operations) == null ? void 0 : a.length) > 1 ? (k(), Y(I5, {
            key: 1,
            id: s.id ?? ""
          }, null, 8, ["id"])) : se(s.$slots, "default", { key: 2 }, void 0, !0)
        ];
      }),
      _: 3
    }));
  }
}), j5 = /* @__PURE__ */ oe(Zee, [["__scopeId", "data-v-0090f16b"]]), Mee = /* @__PURE__ */ G({
  __name: "TagAccordion",
  props: {
    tag: {},
    spec: {}
  },
  setup(t) {
    const { getTagId: e } = Jt();
    return (r, n) => (k(), Y(v(P5), { class: "tag-section" }, {
      title: I(() => [
        Z(v(Ri), {
          class: "tag-name",
          level: 2
        }, {
          default: I(() => [
            Z(v(Ii), {
              id: v(e)(r.tag)
            }, {
              default: I(() => [
                re(te(r.tag.name), 1)
              ]),
              _: 1
            }, 8, ["id"])
          ]),
          _: 1
        }),
        Z(v(Tr), {
          class: "tag-description",
          value: r.tag.description
        }, null, 8, ["value"])
      ]),
      default: I(() => [
        se(r.$slots, "default", {}, void 0, !0)
      ]),
      _: 3
    }));
  }
}), qee = /* @__PURE__ */ oe(Mee, [["__scopeId", "data-v-b06f5cf1"]]), Nee = /* @__PURE__ */ G({
  __name: "Loading",
  props: {
    layout: { default: "default" },
    parsedSpec: {},
    server: {}
  },
  setup(t) {
    const e = t, r = ge(!1), n = ge(
      typeof window < "u" && !!window.location.hash && e.layout !== "accordion"
    ), i = ge([]), s = ge([]), { getModelId: o, getSectionId: a, getTagId: l, hash: c, isIntersectionEnabled: u } = Jt();
    Ve(
      () => {
        var f;
        return (f = e.parsedSpec.tags) == null ? void 0 : f.length;
      },
      (f) => {
        var p, g, m;
        if (!c.value || typeof f != "number" || !e.parsedSpec.tags)
          return;
        const h = a();
        if (h.startsWith("tag")) {
          let y = 0;
          const O = ((p = e.parsedSpec.tags) == null ? void 0 : p.findIndex(
            (S) => l(S) === h
          )) ?? 0, b = c.value.match(/tag\/([^/]+)\/([^/]+)\/(.+)/);
          if ((b == null ? void 0 : b.length) === 4) {
            const S = b[2], $ = "/" + b[3];
            y = (g = e.parsedSpec.tags[O]) == null ? void 0 : g.operations.findIndex(
              ({ httpVerb: _, path: Q }) => S === _ && $ === Q
            );
          }
          const w = e.parsedSpec.tags[O];
          if (!w)
            return;
          w.name !== "default" && (r.value = h !== c.value && h.startsWith("tag")), i.value.push({
            ...w,
            lazyOperations: w.operations.slice(
              y,
              y + 2
            )
          });
        } else {
          const y = Object.keys(((m = e.parsedSpec.components) == null ? void 0 : m.schemas) ?? {}), [, O] = c.value.toLowerCase().split("/"), b = c.value === "models" ? 0 : y.findIndex((w) => w.toLowerCase() === O);
          if (b === -1)
            return;
          s.value = y.slice(b, b + 3);
        }
      },
      { immediate: !0 }
    );
    const d = Up.on(({ id: f }) => {
      const h = c.value;
      !h || f !== h || (d(), setTimeout(() => {
        rS(h), n.value = !1, setTimeout(() => u.value = !0, 1e3);
      }, 300));
    });
    return Xn(() => {
      c.value || setTimeout(() => u.value = !0, 1e3);
    }), (f, h) => Ne((k(), C("div", {
      class: $e(["references-loading", {
        "references-loading-hidden-tag": r.value,
        "references-loading-top-spacer": i.value.length
      }])
    }, [
      (k(!0), C(ee, null, _e(i.value, (p) => (k(), C(ee, {
        key: p.id
      }, [
        p.operations && p.operations.length > 0 ? (k(), Y(v(j5), {
          key: 0,
          spec: f.parsedSpec,
          tag: p
        }, {
          default: I(() => [
            (k(!0), C(ee, null, _e(p.lazyOperations, (g) => (k(), Y(v(R5), {
              key: `${g.httpVerb}-${g.operationId}`,
              operation: g,
              server: f.server,
              tag: p
            }, null, 8, ["operation", "server", "tag"]))), 128))
          ]),
          _: 2
        }, 1032, ["spec", "tag"])) : H("", !0)
      ], 64))), 128)),
      s.value.length ? (k(), Y(v(Wl), { key: 0 }, {
        default: I(() => [
          (k(!0), C(ee, null, _e(s.value, (p) => (k(), Y(v(Ho), {
            key: p,
            label: p
          }, {
            default: I(() => {
              var g, m;
              return [
                (m = (g = f.parsedSpec.components) == null ? void 0 : g.schemas) != null && m[p] ? (k(), Y(v(Go), { key: 0 }, {
                  default: I(() => {
                    var y, O;
                    return [
                      Z(v(Ri), { level: 2 }, {
                        default: I(() => [
                          Z(v(Ii), {
                            id: v(o)(p)
                          }, {
                            default: I(() => {
                              var b, w;
                              return [
                                re(te(((w = (b = f.parsedSpec.components) == null ? void 0 : b.schemas) == null ? void 0 : w[p]).title ?? p), 1)
                              ];
                            }),
                            _: 2
                          }, 1032, ["id"])
                        ]),
                        _: 2
                      }, 1024),
                      Z(v(ns), {
                        name: p,
                        noncollapsible: "",
                        value: (O = (y = f.parsedSpec.components) == null ? void 0 : y.schemas) == null ? void 0 : O[p]
                      }, null, 8, ["name", "value"])
                    ];
                  }),
                  _: 2
                }, 1024)) : H("", !0)
              ];
            }),
            _: 2
          }, 1032, ["label"]))), 128))
        ]),
        _: 1
      })) : H("", !0)
    ], 2)), [
      [mn, n.value]
    ]);
  }
}), Dee = (t) => (fr("data-v-f4d0cefa"), t = t(), hr(), t), zee = /* @__PURE__ */ Dee(() => /* @__PURE__ */ x("div", { id: "models" }, null, -1)), Xee = /* @__PURE__ */ G({
  __name: "Models",
  props: {
    components: {}
  },
  setup(t) {
    const e = t, { collapsedSidebarItems: r } = Un(), { getModelId: n } = Jt(), i = fe(
      () => {
        var o;
        return Object.keys(((o = e.components) == null ? void 0 : o.schemas) ?? {}).length <= 3 || r[n()];
      }
    ), s = fe(() => {
      var a;
      const o = Object.keys(((a = e.components) == null ? void 0 : a.schemas) ?? {});
      return i.value ? o : o.slice(0, 3);
    });
    return (o, a) => o.components ? (k(), Y(v(Wl), { key: 0 }, {
      default: I(() => [
        Z(v(Nu), {
          id: "models",
          isLazy: !1
        }, {
          default: I(() => [
            zee
          ]),
          _: 1
        }),
        (k(!0), C(ee, null, _e(s.value, (l, c) => (k(), Y(v(Nu), {
          id: v(n)(l),
          key: l,
          isLazy: ""
        }, {
          default: I(() => [
            Z(v(Ho), {
              id: v(n)(l),
              label: l
            }, {
              default: I(() => {
                var u, d;
                return [
                  (d = (u = o.components) == null ? void 0 : u.schemas) != null && d[l] ? (k(), Y(v(Go), { key: 0 }, {
                    default: I(() => {
                      var f, h;
                      return [
                        Z(v(Ri), { level: 2 }, {
                          default: I(() => [
                            Z(v(Ii), {
                              id: v(n)(l)
                            }, {
                              default: I(() => {
                                var p, g;
                                return [
                                  re(te(((g = (p = o.components) == null ? void 0 : p.schemas) == null ? void 0 : g[l]).title ?? l), 1)
                                ];
                              }),
                              _: 2
                            }, 1032, ["id"])
                          ]),
                          _: 2
                        }, 1024),
                        Z(v(ns), {
                          name: l,
                          noncollapsible: "",
                          value: (h = (f = o.components) == null ? void 0 : f.schemas) == null ? void 0 : h[l]
                        }, null, 8, ["name", "value"]),
                        !i.value && c === s.value.length - 1 ? (k(), Y(I5, {
                          key: 0,
                          id: v(n)(),
                          class: "something-special"
                        }, null, 8, ["id"])) : H("", !0)
                      ];
                    }),
                    _: 2
                  }, 1024)) : H("", !0)
                ];
              }),
              _: 2
            }, 1032, ["id", "label"])
          ]),
          _: 2
        }, 1032, ["id"]))), 128))
      ]),
      _: 1
    })) : H("", !0);
  }
}), Wee = /* @__PURE__ */ oe(Xee, [["__scopeId", "data-v-f4d0cefa"]]), Uee = {
  key: 0,
  class: "properties"
}, Vee = { key: 1 }, Lee = /* @__PURE__ */ G({
  __name: "ModelsAccordion",
  props: {
    components: {}
  },
  setup(t) {
    const e = t, r = fe(() => {
      var i, s;
      return (i = e.components) != null && i.schemas ? Object.entries((s = e.components) == null ? void 0 : s.schemas).map(([o, a]) => ({
        name: o,
        schema: a
      })) : [];
    }), { getModelId: n } = Jt();
    return (i, s) => i.components ? (k(), Y(v(P5), {
      key: 0,
      class: "reference-models"
    }, {
      title: I(() => [
        Z(v(Ri), { level: 2 }, {
          default: I(() => [
            re("Models")
          ]),
          _: 1
        })
      ]),
      default: I(() => [
        (k(!0), C(ee, null, _e(r.value, ({ name: o, schema: a }) => (k(), Y(v(_5), {
          id: v(n)(o),
          key: o,
          label: o
        }, {
          title: I(() => [
            Z(v(Ii), {
              id: v(n)(o),
              class: "reference-models-anchor"
            }, {
              default: I(() => [
                Z(v(C5), {
                  class: "reference-models-label",
                  name: o,
                  value: a
                }, null, 8, ["name", "value"])
              ]),
              _: 2
            }, 1032, ["id"])
          ]),
          default: I(() => [
            a != null && a.properties ? (k(), C("div", Uee, [
              (k(!0), C(ee, null, _e(Object.entries(a.properties), ([l, c]) => (k(), Y(v(fl), {
                key: l,
                name: l,
                required: a.required && !!a.required.length && a.required.includes(l),
                value: c
              }, null, 8, ["name", "required", "value"]))), 128))
            ])) : (k(), C("div", Vee, [
              Z(v(fl), { value: a }, null, 8, ["value"])
            ]))
          ]),
          _: 2
        }, 1032, ["id", "label"]))), 128))
      ]),
      _: 1
    })) : H("", !0);
  }
}), Yee = /* @__PURE__ */ oe(Lee, [["__scopeId", "data-v-c31dbd07"]]), Bee = /* @__PURE__ */ G({
  __name: "Webhook",
  props: {
    webhook: {}
  },
  setup(t) {
    const e = t, { responses: r } = Fm(e.webhook);
    return (n, i) => {
      var s;
      return n.webhook ? (k(), C(ee, { key: 0 }, [
        Z(u0, {
          requestBody: (s = n.webhook.information) == null ? void 0 : s.requestBody
        }, {
          title: I(() => [
            re("Payload")
          ]),
          _: 1
        }, 8, ["requestBody"]),
        Z(Mr, { parameters: v(r) }, {
          title: I(() => [
            re("Responses")
          ]),
          _: 1
        }, 8, ["parameters"])
      ], 64)) : H("", !0);
    };
  }
}), Fee = /* @__PURE__ */ G({
  __name: "Webhooks",
  props: {
    webhooks: {}
  },
  setup(t) {
    const e = t, r = fe(() => Object.keys(e.webhooks ?? {})), { getWebhookId: n } = Jt();
    return (i, s) => r.value.length ? (k(), Y(v(Wl), { key: 0 }, {
      default: I(() => [
        (k(!0), C(ee, null, _e(r.value, (o) => {
          var a;
          return k(), C(ee, { key: o }, [
            (k(!0), C(ee, null, _e(Object.keys(
              (a = i.webhooks) == null ? void 0 : a[o]
            ), (l) => (k(), Y(v(Ho), {
              id: v(n)(o, l),
              key: l,
              label: o
            }, {
              default: I(() => {
                var c;
                return [
                  (c = i.webhooks) != null && c[o] ? (k(), Y(v(Go), { key: 0 }, {
                    default: I(() => {
                      var u, d;
                      return [
                        Z(v(Ri), { level: 2 }, {
                          default: I(() => [
                            Z(v(Ii), {
                              id: v(n)(o, l)
                            }, {
                              default: I(() => {
                                var f;
                                return [
                                  re(te((f = i.webhooks[o][l]) == null ? void 0 : f.name), 1)
                                ];
                              }),
                              _: 2
                            }, 1032, ["id"])
                          ]),
                          _: 2
                        }, 1024),
                        (u = i.webhooks[o][l]) != null && u.description ? (k(), Y(v(Tr), {
                          key: 0,
                          value: (d = i.webhooks[o][l]) == null ? void 0 : d.description
                        }, null, 8, ["value"])) : H("", !0),
                        Z(Bee, {
                          webhook: i.webhooks[o][l]
                        }, null, 8, ["webhook"])
                      ];
                    }),
                    _: 2
                  }, 1024)) : H("", !0)
                ];
              }),
              _: 2
            }, 1032, ["id", "label"]))), 128))
          ], 64);
        }), 128))
      ]),
      _: 1
    })) : H("", !0);
  }
}), Hee = { class: "narrow-references-container" }, Gee = /* @__PURE__ */ G({
  __name: "Content",
  props: {
    parsedSpec: {},
    layout: {}
  },
  setup(t) {
    const e = t, { getOperationId: r, getTagId: n } = Jt(), i = uI(() => ({
      url: window.location.origin
    })), s = fe(() => {
      var u;
      return e.parsedSpec.servers && e.parsedSpec.servers.length > 0 ? e.parsedSpec.servers : e.parsedSpec.host && e.parsedSpec.schemes && e.parsedSpec.schemes.length > 0 ? [
        {
          url: `${e.parsedSpec.schemes[0]}://${e.parsedSpec.host}${((u = e.parsedSpec) == null ? void 0 : u.basePath) ?? ""}`
        }
      ] : i.value ? [i.value] : [{ url: "" }];
    }), o = fe(
      () => e.layout === "accordion" ? qee : j5
    ), a = fe(
      () => e.layout === "accordion" ? Qee : R5
    ), l = fe(
      () => e.layout === "accordion" ? "after" : "aside"
    ), c = e.layout !== "accordion" && typeof window < "u" && !window.location.hash.startsWith("#model");
    return (u, d) => (k(), C("div", Hee, [
      se(u.$slots, "start", {}, void 0, !0),
      Z(v(Nee), {
        layout: u.layout,
        parsedSpec: u.parsedSpec,
        server: s.value[0]
      }, null, 8, ["layout", "parsedSpec", "server"]),
      u.parsedSpec.info.title || u.parsedSpec.info.description ? (k(), Y(v(qK), {
        key: 0,
        info: u.parsedSpec.info,
        parsedSpec: u.parsedSpec
      }, {
        [l.value]: I(() => [
          x("div", {
            class: $e(["introduction-cards", { "introduction-cards-row": u.layout === "accordion" }])
          }, [
            Z(v(DG), { value: s.value }, null, 8, ["value"]),
            Z(v(iK)),
            Z(v(wG), { parsedSpec: u.parsedSpec }, null, 8, ["parsedSpec"])
          ], 2)
        ]),
        _: 2
      }, 1032, ["info", "parsedSpec"])) : se(u.$slots, "empty-state", { key: 1 }, void 0, !0),
      (k(!0), C(ee, null, _e(u.parsedSpec.tags, (f) => (k(), Y(v(Nu), {
        id: v(n)(f),
        key: v(n)(f),
        isLazy: v(c)
      }, {
        default: I(() => [
          f.operations && f.operations.length > 0 ? (k(), Y(Oi(o.value), {
            key: 0,
            id: v(n)(f),
            spec: u.parsedSpec,
            tag: f
          }, {
            default: I(() => [
              (k(!0), C(ee, null, _e(f.operations, (h, p) => (k(), Y(v(Nu), {
                id: v(r)(h, f),
                key: `${h.httpVerb}-${h.operationId}`,
                isLazy: p > 0
              }, {
                default: I(() => [
                  (k(), Y(Oi(a.value), {
                    id: v(r)(h, f),
                    operation: h,
                    server: s.value[0],
                    tag: f
                  }, null, 8, ["id", "operation", "server", "tag"]))
                ]),
                _: 2
              }, 1032, ["id", "isLazy"]))), 128))
            ]),
            _: 2
          }, 1032, ["id", "spec", "tag"])) : H("", !0)
        ]),
        _: 2
      }, 1032, ["id", "isLazy"]))), 128)),
      u.parsedSpec.webhooks ? (k(), Y(v(Fee), {
        key: 2,
        webhooks: u.parsedSpec.webhooks
      }, null, 8, ["webhooks"])) : H("", !0),
      v(tS)(u.parsedSpec) ? (k(), C(ee, { key: 3 }, [
        u.layout === "accordion" ? (k(), Y(v(Yee), {
          key: 0,
          components: u.parsedSpec.components
        }, null, 8, ["components"])) : (k(), Y(v(Wee), {
          key: 1,
          components: u.parsedSpec.components
        }, null, 8, ["components"]))
      ], 64)) : H("", !0),
      se(u.$slots, "end", {}, void 0, !0)
    ]));
  }
}), Kee = /* @__PURE__ */ oe(Gee, [["__scopeId", "data-v-16370f36"]]), Jee = `{
  "openapi": "3.0.2",
  "info": {
    "title": "Swagger Petstore - OpenAPI 3.0",
    "description": "This is a sample Pet Store Server based on the OpenAPI 3.0 specification.  You can find out more about\\nSwagger at [http://swagger.io](http://swagger.io). In the third iteration of the pet store, we've switched to the design first approach!\\nYou can now help us improve the API whether it's by making changes to the definition itself or to the code.\\nThat way, with time, we can improve the API in general, and expose some of the new features in OAS3.\\n\\nSome useful links:\\n- [The Pet Store repository](https://github.com/swagger-api/swagger-petstore)\\n- [The source API definition for the Pet Store](https://github.com/swagger-api/swagger-petstore/blob/master/src/main/resources/openapi.yaml)",
    "termsOfService": "http://swagger.io/terms/",
    "contact": {
      "email": "apiteam@swagger.io"
    },
    "license": {
      "name": "Apache 2.0",
      "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
    },
    "version": "1.0.11"
  },
  "externalDocs": {
    "description": "Find out more about Swagger",
    "url": "http://swagger.io"
  },
  "servers": [
    {
      "url": "https://petstore3.swagger.io/api/v3"
    }
  ],
  "tags": [
    {
      "name": "pet",
      "description": "Everything about your Pets",
      "externalDocs": {
        "description": "Find out more",
        "url": "http://swagger.io"
      }
    },
    {
      "name": "store",
      "description": "Access to Petstore orders",
      "externalDocs": {
        "description": "Find out more about our store",
        "url": "http://swagger.io"
      }
    },
    {
      "name": "user",
      "description": "Operations about user"
    }
  ],
  "paths": {
    "/pet": {
      "put": {
        "tags": ["pet"],
        "summary": "Update an existing pet",
        "description": "Update an existing pet by Id",
        "operationId": "updatePet",
        "requestBody": {
          "description": "Update an existent pet in the store",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Pet"
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/Pet"
              }
            },
            "application/x-www-form-urlencoded": {
              "schema": {
                "$ref": "#/components/schemas/Pet"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful operation",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Pet"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Pet"
                }
              }
            }
          },
          "400": {
            "description": "Invalid ID supplied"
          },
          "404": {
            "description": "Pet not found"
          },
          "405": {
            "description": "Validation exception"
          }
        },
        "security": [
          {
            "petstore_auth": ["write:pets", "read:pets"]
          }
        ]
      },
      "post": {
        "tags": ["pet"],
        "summary": "Add a new pet to the store",
        "description": "Add a new pet to the store",
        "operationId": "addPet",
        "requestBody": {
          "description": "Create a new pet in the store",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Pet"
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/Pet"
              }
            },
            "application/x-www-form-urlencoded": {
              "schema": {
                "$ref": "#/components/schemas/Pet"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful operation",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Pet"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Pet"
                }
              }
            }
          },
          "405": {
            "description": "Invalid input"
          }
        },
        "security": [
          {
            "petstore_auth": ["write:pets", "read:pets"]
          }
        ]
      }
    },
    "/pet/findByStatus": {
      "get": {
        "tags": ["pet"],
        "summary": "Finds Pets by status",
        "description": "Multiple status values can be provided with comma separated strings",
        "operationId": "findPetsByStatus",
        "parameters": [
          {
            "name": "status",
            "in": "query",
            "description": "Status values that need to be considered for filter",
            "required": false,
            "explode": true,
            "schema": {
              "type": "string",
              "default": "available",
              "enum": ["available", "pending", "sold"]
            }
          }
        ],
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/xml": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Pet"
                  }
                }
              },
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Pet"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid status value"
          }
        },
        "security": [
          {
            "petstore_auth": ["write:pets", "read:pets"]
          }
        ]
      }
    },
    "/pet/findByTags": {
      "get": {
        "tags": ["pet"],
        "summary": "Finds Pets by tags",
        "description": "Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.",
        "operationId": "findPetsByTags",
        "parameters": [
          {
            "name": "tags",
            "in": "query",
            "description": "Tags to filter by",
            "required": false,
            "explode": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/xml": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Pet"
                  }
                }
              },
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Pet"
                  }
                }
              }
            }
          },
          "400": {
            "description": "Invalid tag value"
          }
        },
        "security": [
          {
            "petstore_auth": ["write:pets", "read:pets"]
          }
        ]
      }
    },
    "/pet/{petId}": {
      "get": {
        "tags": ["pet"],
        "summary": "Find pet by ID",
        "description": "Returns a single pet",
        "operationId": "getPetById",
        "parameters": [
          {
            "name": "petId",
            "in": "path",
            "description": "ID of pet to return",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Pet"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Pet"
                }
              }
            }
          },
          "400": {
            "description": "Invalid ID supplied"
          },
          "404": {
            "description": "Pet not found"
          }
        },
        "security": [
          {
            "api_key": []
          },
          {
            "petstore_auth": ["write:pets", "read:pets"]
          }
        ]
      },
      "post": {
        "tags": ["pet"],
        "summary": "Updates a pet in the store with form data",
        "description": "",
        "operationId": "updatePetWithForm",
        "parameters": [
          {
            "name": "petId",
            "in": "path",
            "description": "ID of pet that needs to be updated",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "name": "name",
            "in": "query",
            "description": "Name of pet that needs to be updated",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "status",
            "in": "query",
            "description": "Status of pet that needs to be updated",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "405": {
            "description": "Invalid input"
          }
        },
        "security": [
          {
            "petstore_auth": ["write:pets", "read:pets"]
          }
        ]
      },
      "delete": {
        "tags": ["pet"],
        "summary": "Deletes a pet",
        "description": "",
        "operationId": "deletePet",
        "parameters": [
          {
            "name": "api_key",
            "in": "header",
            "description": "",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "petId",
            "in": "path",
            "description": "Pet id to delete",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "400": {
            "description": "Invalid pet value"
          }
        },
        "security": [
          {
            "petstore_auth": ["write:pets", "read:pets"]
          }
        ]
      }
    },
    "/pet/{petId}/uploadImage": {
      "post": {
        "tags": ["pet"],
        "summary": "uploads an image",
        "description": "",
        "operationId": "uploadFile",
        "parameters": [
          {
            "name": "petId",
            "in": "path",
            "description": "ID of pet to update",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "name": "additionalMetadata",
            "in": "query",
            "description": "Additional Metadata",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/octet-stream": {
              "schema": {
                "type": "string",
                "format": "binary"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "petstore_auth": ["write:pets", "read:pets"]
          }
        ]
      }
    },
    "/pet/{petId}/uploadImageForm": {
      "post": {
        "tags": ["pet"],
        "summary": "uploads an image using form data",
        "description": "",
        "operationId": "uploadFileForm",
        "requestBody": {
          "content": {
            "multipart/form-data": {
              "schema": {
                "type": "object",
                "properties": {
                  "petId": {
                    "type": "string",
                    "example": "1"
                  },
                  "additionalMetadata": {
                    "type": "string"
                  },
                  "file": {
                    "type": "string",
                    "format": "binary"
                  }
                },
                "required": ["petId"]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "petstore_auth": ["write:pets", "read:pets"]
          }
        ]
      }
    },
    "/store/inventory": {
      "get": {
        "tags": ["store"],
        "summary": "Returns pet inventories by status",
        "description": "Returns a map of status codes to quantities",
        "operationId": "getInventory",
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "integer",
                    "format": "int32"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "api_key": []
          }
        ]
      }
    },
    "/store/order": {
      "post": {
        "tags": ["store"],
        "summary": "Place an order for a pet",
        "description": "Place a new order in the store",
        "operationId": "placeOrder",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Order"
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/Order"
              }
            },
            "application/x-www-form-urlencoded": {
              "schema": {
                "$ref": "#/components/schemas/Order"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Order"
                }
              }
            }
          },
          "405": {
            "description": "Invalid input"
          }
        }
      }
    },
    "/store/order/{orderId}": {
      "get": {
        "tags": ["store"],
        "summary": "Find purchase order by ID",
        "description": "For valid response try integer IDs with value <= 5 or > 10. Other values will generate exceptions.",
        "operationId": "getOrderById",
        "parameters": [
          {
            "name": "orderId",
            "in": "path",
            "description": "ID of order that needs to be fetched",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/Order"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Order"
                }
              }
            }
          },
          "400": {
            "description": "Invalid ID supplied"
          },
          "404": {
            "description": "Order not found"
          }
        }
      },
      "delete": {
        "tags": ["store"],
        "summary": "Delete purchase order by ID",
        "description": "For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors",
        "operationId": "deleteOrder",
        "parameters": [
          {
            "name": "orderId",
            "in": "path",
            "description": "ID of the order that needs to be deleted",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "400": {
            "description": "Invalid ID supplied"
          },
          "404": {
            "description": "Order not found"
          }
        }
      }
    },
    "/user": {
      "post": {
        "tags": ["user"],
        "summary": "Create user",
        "description": "This can only be done by the logged in user.",
        "operationId": "createUser",
        "requestBody": {
          "description": "Created user object",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/User"
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/User"
              }
            },
            "application/x-www-form-urlencoded": {
              "schema": {
                "$ref": "#/components/schemas/User"
              }
            }
          }
        },
        "responses": {
          "default": {
            "description": "successful operation",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/User"
                }
              },
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/User"
                }
              }
            }
          }
        }
      }
    },
    "/user/createWithList": {
      "post": {
        "tags": ["user"],
        "summary": "Creates list of users with given input array",
        "description": "Creates list of users with given input array",
        "operationId": "createUsersWithListInput",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/User"
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful operation",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/User"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/User"
                }
              }
            }
          },
          "default": {
            "description": "successful operation"
          }
        }
      }
    },
    "/user/login": {
      "get": {
        "tags": ["user"],
        "summary": "Logs user into the system",
        "description": "",
        "operationId": "loginUser",
        "parameters": [
          {
            "name": "username",
            "in": "query",
            "description": "The user name for login",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "password",
            "in": "query",
            "description": "The password for login in clear text",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "successful operation",
            "headers": {
              "X-Rate-Limit": {
                "description": "calls per hour allowed by the user",
                "schema": {
                  "type": "integer",
                  "format": "int32"
                }
              },
              "X-Expires-After": {
                "description": "date in UTC when token expires",
                "schema": {
                  "type": "string",
                  "format": "date-time"
                }
              }
            },
            "content": {
              "application/xml": {
                "schema": {
                  "type": "string"
                }
              },
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Invalid username/password supplied"
          }
        }
      }
    },
    "/user/logout": {
      "get": {
        "tags": ["user"],
        "summary": "Logs out current logged in user session",
        "description": "",
        "operationId": "logoutUser",
        "parameters": [],
        "responses": {
          "default": {
            "description": "successful operation"
          }
        }
      }
    },
    "/user/{username}": {
      "get": {
        "tags": ["user"],
        "summary": "Get user by user name",
        "description": "",
        "operationId": "getUserByName",
        "parameters": [
          {
            "name": "username",
            "in": "path",
            "description": "The name that needs to be fetched. Use user1 for testing. ",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "successful operation",
            "content": {
              "application/xml": {
                "schema": {
                  "$ref": "#/components/schemas/User"
                }
              },
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/User"
                }
              }
            }
          },
          "400": {
            "description": "Invalid username supplied"
          },
          "404": {
            "description": "User not found"
          }
        }
      },
      "put": {
        "tags": ["user"],
        "summary": "Update user",
        "description": "This can only be done by the logged in user.",
        "operationId": "updateUser",
        "parameters": [
          {
            "name": "username",
            "in": "path",
            "description": "name that need to be deleted",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "description": "Update an existent user in the store",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/User"
              }
            },
            "application/xml": {
              "schema": {
                "$ref": "#/components/schemas/User"
              }
            },
            "application/x-www-form-urlencoded": {
              "schema": {
                "$ref": "#/components/schemas/User"
              }
            }
          }
        },
        "responses": {
          "default": {
            "description": "successful operation"
          }
        }
      },
      "delete": {
        "tags": ["user"],
        "summary": "Delete user",
        "description": "This can only be done by the logged in user.",
        "operationId": "deleteUser",
        "parameters": [
          {
            "name": "username",
            "in": "path",
            "description": "The name that needs to be deleted",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "400": {
            "description": "Invalid username supplied"
          },
          "404": {
            "description": "User not found"
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "Order": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64",
            "example": 10
          },
          "petId": {
            "type": "integer",
            "format": "int64",
            "example": 198772
          },
          "quantity": {
            "type": "integer",
            "format": "int32",
            "example": 7
          },
          "shipDate": {
            "type": "string",
            "format": "date-time"
          },
          "status": {
            "type": "string",
            "description": "Order Status",
            "example": "approved",
            "enum": ["placed", "approved", "delivered"]
          },
          "complete": {
            "type": "boolean"
          }
        },
        "xml": {
          "name": "order"
        }
      },
      "Customer": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64",
            "example": 100000
          },
          "username": {
            "type": "string",
            "example": "fehguy"
          },
          "address": {
            "type": "array",
            "xml": {
              "name": "addresses",
              "wrapped": true
            },
            "items": {
              "$ref": "#/components/schemas/Address"
            }
          }
        },
        "xml": {
          "name": "customer"
        }
      },
      "Address": {
        "type": "object",
        "properties": {
          "street": {
            "type": "string",
            "example": "437 Lytton"
          },
          "city": {
            "type": "string",
            "example": "Palo Alto"
          },
          "state": {
            "type": "string",
            "example": "CA"
          },
          "zip": {
            "type": "string",
            "example": "94301"
          }
        },
        "xml": {
          "name": "address"
        }
      },
      "Category": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64",
            "example": 1
          },
          "name": {
            "type": "string",
            "example": "Dogs"
          }
        },
        "xml": {
          "name": "category"
        }
      },
      "User": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64",
            "example": 10
          },
          "username": {
            "type": "string",
            "example": "theUser"
          },
          "firstName": {
            "type": "string",
            "example": "John"
          },
          "lastName": {
            "type": "string",
            "example": "James"
          },
          "email": {
            "type": "string",
            "example": "john@email.com"
          },
          "password": {
            "type": "string",
            "example": "12345"
          },
          "phone": {
            "type": "string",
            "example": "12345"
          },
          "userStatus": {
            "type": "integer",
            "description": "User Status",
            "format": "int32",
            "example": 1
          }
        },
        "xml": {
          "name": "user"
        }
      },
      "Tag": {
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64"
          },
          "name": {
            "type": "string"
          }
        },
        "xml": {
          "name": "tag"
        }
      },
      "Pet": {
        "required": ["name", "photoUrls"],
        "type": "object",
        "properties": {
          "id": {
            "type": "integer",
            "format": "int64",
            "example": 10
          },
          "name": {
            "type": "string",
            "example": "doggie"
          },
          "category": {
            "$ref": "#/components/schemas/Category"
          },
          "photoUrls": {
            "type": "array",
            "xml": {
              "wrapped": true
            },
            "items": {
              "type": "string",
              "xml": {
                "name": "photoUrl"
              }
            }
          },
          "tags": {
            "type": "array",
            "xml": {
              "wrapped": true
            },
            "items": {
              "$ref": "#/components/schemas/Tag"
            }
          },
          "status": {
            "type": "string",
            "description": "pet status in the store",
            "enum": ["available", "pending", "sold"]
          }
        },
        "xml": {
          "name": "pet"
        }
      },
      "ApiResponse": {
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "format": "int32"
          },
          "type": {
            "type": "string"
          },
          "message": {
            "type": "string"
          }
        },
        "xml": {
          "name": "##default"
        }
      }
    },
    "requestBodies": {
      "Pet": {
        "description": "Pet object that needs to be added to the store",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/Pet"
            }
          },
          "application/xml": {
            "schema": {
              "$ref": "#/components/schemas/Pet"
            }
          }
        }
      },
      "UserArray": {
        "description": "List of user object",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/User"
              }
            }
          }
        }
      }
    },
    "securitySchemes": {
      "petstore_auth": {
        "type": "oauth2",
        "flows": {
          "implicit": {
            "authorizationUrl": "https://petstore3.swagger.io/oauth/authorize",
            "scopes": {
              "write:pets": "modify pets in your account",
              "read:pets": "read your pets"
            }
          }
        }
      },
      "api_key": {
        "type": "apiKey",
        "name": "api_key",
        "in": "header"
      }
    }
  }
}
`, ete = (t) => (fr("data-v-ca77ea59"), t = t(), hr(), t), tte = { class: "start custom-scroll" }, rte = { class: "start-copy" }, nte = /* @__PURE__ */ gs('<div class="start-logo" data-v-ca77ea59><svg height="36" viewBox="0 0 36 36" width="36" xmlns="http://www.w3.org/2000/svg" data-v-ca77ea59><path d="M18 0a18 18 0 1 1 0 36 18 18 0 0 1 0-36Zm11.2 6.5c-3.3-3.3-11.1-1-17.4 5.3-6.2 6.3-8.6 14-5.3 17.4 3.3 3.3 11 .9 17.3-5.4 6.3-6.2 8.7-14 5.4-17.3ZM17.6 12a6.3 6.3 0 1 1 0 12.7 6.3 6.3 0 0 1 0-12.7Z" fill="currentColor" fill-rule="evenodd" data-v-ca77ea59></path></svg></div><h1 class="start-h1" data-v-ca77ea59>Swagger Editor</h1><p class="start-p" data-v-ca77ea59> Welcome to the Scalar API References + Swagger Editor, a Free &amp; Open-Source tool that takes your Swagger/OAS file and generates Beautiful API references. </p>', 3), ite = { class: "start-cta" }, ste = { class: "start-row" }, ote = /* @__PURE__ */ gs('<div class="start-section" data-v-ca77ea59><div class="start-h2" data-v-ca77ea59>INTEGRATIONS</div><a class="start-item" href="https://github.com/scalar/scalar/tree/main/packages/fastify-api-reference#readme" target="_blank" data-v-ca77ea59><svg fill="currentColor" height="16" viewBox="0 0 19 16" width="19" xmlns="http://www.w3.org/2000/svg" data-v-ca77ea59><path d="m18.2 3.1.8-2V.9l-4.7 1.3C15.2 1 15 0 15 0s-2.5 1.6-4.3 1.5c-2 0-3.6.8-4 1-1.8 1.2-2.5 3.3-3.2 3.8L0 8.9 2.3 8l-2 2.5c.2.3 1.2 1.6 2.1 1.3l.4-.1 1.6.5-.7-1 .2-.2.9.3-.1-.8.9.3-.1-.8.3-.1 1-3.5 3.7-2.6-.3.7A4 4 0 0 1 8 7l-.6.2c-.5.5-.7.7-.8 2.5a2 2 0 0 1 1 0c1.6.4 2.2 2.3 1.7 2.9l-.7.6H8v.6h-.7v.5l-.2.2c-.7 0-1.4-.6-1.4-.6 0 .5.4 1.3.4 1.3s1.7 1.1 2.7.7c1-.4.7-2.3 2.8-3.2l3.3-.9.8-2.2-1.7.5v-2l2.5-.6.9-2.2-3.4.9v-2l4.2-1.1Z" fill="currentColor" fill-rule="nonzero" data-v-ca77ea59></path></svg><span data-v-ca77ea59>Fastify</span></a><a class="start-item" href="https://github.com/scalar/scalar/tree/main#from-a-cdn" target="_blank" data-v-ca77ea59><svg fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" data-v-ca77ea59><g data-v-ca77ea59><path d="M22.5 1.5h-21A1.5 1.5 0 0 0 0 3v3a1.5 1.5 0 0 0 1.5 1.5h21A1.5 1.5 0 0 0 24 6V3a1.5 1.5 0 0 0-1.5-1.5Zm-19.25 3A1.25 1.25 0 1 1 4.5 5.75 1.25 1.25 0 0 1 3.25 4.5ZM8.5 5.75A1.25 1.25 0 1 1 9.75 4.5 1.25 1.25 0 0 1 8.5 5.75Z" fill="currentColor" data-v-ca77ea59></path><path d="M22.5 9h-21A1.5 1.5 0 0 0 0 10.5v3A1.5 1.5 0 0 0 1.5 15h21a1.5 1.5 0 0 0 1.5-1.5v-3A1.5 1.5 0 0 0 22.5 9ZM3.25 12a1.25 1.25 0 1 1 1.25 1.25A1.25 1.25 0 0 1 3.25 12Zm5.25 1.25A1.25 1.25 0 1 1 9.75 12a1.25 1.25 0 0 1-1.25 1.25Z" fill="currentColor" data-v-ca77ea59></path><path d="M22.5 16.5h-21A1.5 1.5 0 0 0 0 18v3a1.5 1.5 0 0 0 1.5 1.5h21A1.5 1.5 0 0 0 24 21v-3a1.5 1.5 0 0 0-1.5-1.5Zm-19.25 3a1.25 1.25 0 1 1 1.25 1.25 1.25 1.25 0 0 1-1.25-1.25Zm5.25 1.25a1.25 1.25 0 1 1 1.25-1.25 1.25 1.25 0 0 1-1.25 1.25Z" fill="currentColor" data-v-ca77ea59></path></g></svg><span data-v-ca77ea59>CDN</span></a><a class="start-item" href="https://github.com/scalar/scalar/tree/main#with-vuejs" target="_blank" data-v-ca77ea59><svg height="170" viewBox="0 0 196.3 170" width="196.3" xmlns="http://www.w3.org/2000/svg" data-v-ca77ea59><g fill="currentColor" fill-rule="nonzero" data-v-ca77ea59><polygon points="39.23 0 0 0 2.9450761 5.1010782 98.16 170.02 196.32 0 157.06 0 98.16 102.01 42.175701 5.0991171" data-v-ca77ea59></polygon><polygon points="75.5 2.009956e-14 0 2.009956e-14 2.94 5.1 78.44871 5.1 98.16 39.26 117.87937 5.1 193.38 5.1 196.325 0 120.82 7.8065636e-15 114.97322 2.009956e-14 98.16 29.037153 81.35 2.009956e-14" data-v-ca77ea59></polygon></g></svg><span data-v-ca77ea59>Vue</span></a><a class="start-item" href="https://github.com/scalar/scalar/tree/main#with-react" target="_blank" data-v-ca77ea59><svg height="23.3" viewBox="0 0 22 23.3" width="22" xmlns="http://www.w3.org/2000/svg" data-v-ca77ea59><g fill="none" fill-rule="evenodd" data-v-ca77ea59><circle cx="11" cy="11.6" fill="currentColor" fill-rule="nonzero" r="2" data-v-ca77ea59></circle><g stroke="currentColor" data-v-ca77ea59><ellipse cx="11" cy="11.6" rx="11" ry="4.2" data-v-ca77ea59></ellipse><ellipse cx="11" cy="11.6" rx="11" ry="4.2" transform="rotate(60 11 11.6)" data-v-ca77ea59></ellipse><ellipse cx="11" cy="11.6" rx="11" ry="4.2" transform="rotate(120 11 11.6)" data-v-ca77ea59></ellipse></g></g></svg><span data-v-ca77ea59>React</span></a></div>', 1), ate = { class: "start-section start-section-colors" }, lte = /* @__PURE__ */ ete(() => /* @__PURE__ */ x("p", { class: "start-h2" }, "THEMING", -1)), cte = ["onClick"], ute = /* @__PURE__ */ gs('<p class="start-h1" data-v-ca77ea59>Features</p><ul class="start-ul" data-v-ca77ea59><li data-v-ca77ea59><p class="start-h3" data-v-ca77ea59>Customize</p> Bring your typography &amp; color palettes, or use our themes! </li><li data-v-ca77ea59><p class="start-h3" data-v-ca77ea59>Testing</p> A deeply integrated Rest API Client (Also Free &amp; Open-Source) </li><li data-v-ca77ea59><p class="start-h3" data-v-ca77ea59>Search</p> Fully integrated Search (Using fuse.js) </li><li data-v-ca77ea59><p class="start-h3" data-v-ca77ea59>Hosting</p> Free subdomain hosting on https://apidocumentation.com </li><li data-v-ca77ea59><p class="start-h3" data-v-ca77ea59>Openapi &amp; Swagger</p> Support for OpenAPI 3.1, OpenAPI 3.0, and Swagger 2.0 </li><li data-v-ca77ea59><p class="start-h3" data-v-ca77ea59>Code Samples</p> Code samples to show off your API in most popular languages </li></ul>', 2), dte = /* @__PURE__ */ G({
  __name: "GettingStarted",
  props: {
    theme: {}
  },
  emits: ["changeTheme", "loadSwaggerFile", "linkSwaggerFile", "updateContent"],
  setup(t, { emit: e }) {
    const r = e, n = [
      "default",
      "alternate",
      "moon",
      "purple",
      "solarized",
      "bluePlanet",
      "saturn",
      "kepler",
      "mars",
      "deepSpace"
    ];
    function i() {
      r("updateContent", Jee);
    }
    return (s, o) => (k(), C("div", tte, [
      x("div", rte, [
        nte,
        x("div", ite, [
          Z(v(B1), {
            fullWidth: "",
            onClick: i
          }, {
            default: I(() => [
              re(" Test Petstore ")
            ]),
            _: 1
          }),
          Z(v(B1), {
            fullWidth: "",
            variant: "outlined",
            onClick: o[0] || (o[0] = (a) => s.$emit("loadSwaggerFile"))
          }, {
            default: I(() => [
              re(" Upload File ")
            ]),
            _: 1
          })
        ])
      ]),
      x("div", ste, [
        ote,
        x("div", ate, [
          lte,
          (k(), C(ee, null, _e(n, (a) => x("div", {
            key: a,
            class: $e(["start-item", { "start-item-active": a === s.theme }]),
            onClick: (l) => s.$emit("changeTheme", a)
          }, te(a.toLocaleLowerCase()), 11, cte)), 64))
        ])
      ]),
      ute
    ]));
  }
}), fte = /* @__PURE__ */ oe(dte, [["__scopeId", "data-v-ca77ea59"]]), hte = { class: "references-header" }, pte = { class: "references-navigation t-doc__sidebar" }, mte = { class: "references-navigation-list" }, gte = { class: "references-editor" }, Ote = { class: "references-editor-textarea" }, yte = { class: "references-rendered" }, bte = {
  key: 0,
  class: "references-footer"
}, vte = /* @__PURE__ */ G({
  inheritAttrs: !1,
  __name: "ApiReferenceLayout",
  props: {
    configuration: {},
    parsedSpec: {},
    rawSpec: {}
  },
  emits: ["changeTheme", "updateContent", "loadSwaggerFile", "linkSwaggerFile", "toggleDarkMode"],
  setup(t) {
    const e = t, r = Vu("(min-width: 1150px)"), n = ge(0), i = ge(null);
    ev(i, (p) => {
      n.value = p[0].contentRect.height;
    });
    const { breadcrumb: s, setCollapsedSidebarItem: o } = Un(), { enableHashListener: a, getSectionId: l, getTagId: c, hash: u } = Jt();
    a(), Xn(() => {
      var m, y;
      u.value || (m = document.querySelector("#tippy")) == null || m.scrollTo({
        top: 0,
        left: 0
      });
      const p = (y = e.parsedSpec.tags) == null ? void 0 : y[0];
      let g = null;
      u.value ? g = l(u.value) : p && (g = c(p)), g && o(g, !0), iS.on(() => eI(e.rawSpec));
    });
    const d = fe(
      () => r.value || !e.configuration.isEditable
    ), f = m3((p) => {
      (p.target.scrollTop ?? 0) < 50 && (window.history.replaceState(
        {},
        "",
        window.location.pathname + window.location.search
      ), u.value = "");
    }), h = fe(() => ({
      breadcrumb: s.value,
      spec: e.parsedSpec
    }));
    return (p, g) => {
      var m;
      return k(), C(ee, null, [
        Z(v(iv), {
          id: (m = p.configuration) == null ? void 0 : m.theme
        }, null, 8, ["id"]),
        Z(v(av), null, {
          default: I(({ styles: y }) => [
            Z(v(i_), null, {
              default: I(({ styles: O }) => {
                var b, w;
                return [
                  x("div", {
                    ref_key: "documentEl",
                    ref: i,
                    class: $e(["scalar-api-reference references-layout", [
                      {
                        "references-editable": p.configuration.isEditable,
                        "references-sidebar": p.configuration.showSidebar,
                        "references-classic": p.configuration.layout === "classic"
                      },
                      y,
                      O,
                      p.$attrs.class
                    ]]),
                    style: Eo({ "--full-height": `${n.value}px` }),
                    onScrollPassive: g[4] || (g[4] = //@ts-ignore
                    (...S) => v(f) && v(f)(...S))
                  }, [
                    x("div", hte, [
                      se(p.$slots, "header", Ir(jr(h.value)), void 0, !0)
                    ]),
                    Ne(x("aside", pte, [
                      x("div", mte, [
                        Z(v(Wp), { parsedSpec: p.parsedSpec }, {
                          "sidebar-start": I(() => [
                            se(p.$slots, "sidebar-start", Ir(jr(h.value)), void 0, !0)
                          ]),
                          "sidebar-end": I(() => [
                            se(p.$slots, "sidebar-end", Ir(jr(h.value)), void 0, !0)
                          ]),
                          _: 3
                        }, 8, ["parsedSpec"])
                      ])
                    ], 512), [
                      [mn, p.configuration.showSidebar]
                    ]),
                    Ne(x("div", gte, [
                      x("div", Ote, [
                        se(p.$slots, "editor", Ir(jr(h.value)), void 0, !0)
                      ])
                    ], 512), [
                      [mn, p.configuration.isEditable]
                    ]),
                    d.value ? (k(), C(ee, { key: 0 }, [
                      x("div", yte, [
                        Z(v(Kee), {
                          layout: p.configuration.layout === "classic" ? "accordion" : "default",
                          parsedSpec: p.parsedSpec
                        }, Fp({
                          start: I(() => [
                            se(p.$slots, "content-start", Ir(jr(h.value)), void 0, !0)
                          ]),
                          end: I(() => [
                            se(p.$slots, "content-end", Ir(jr(h.value)), void 0, !0)
                          ]),
                          _: 2
                        }, [
                          (b = p.configuration) != null && b.isEditable ? {
                            name: "empty-state",
                            fn: I(() => {
                              var S;
                              return [
                                Z(fte, {
                                  theme: ((S = p.configuration) == null ? void 0 : S.theme) || "default",
                                  onChangeTheme: g[0] || (g[0] = ($) => p.$emit("changeTheme", $)),
                                  onLinkSwaggerFile: g[1] || (g[1] = ($) => p.$emit("linkSwaggerFile")),
                                  onLoadSwaggerFile: g[2] || (g[2] = ($) => p.$emit("loadSwaggerFile")),
                                  onUpdateContent: g[3] || (g[3] = ($) => p.$emit("updateContent", $))
                                }, null, 8, ["theme"])
                              ];
                            }),
                            key: "0"
                          } : void 0
                        ]), 1032, ["layout", "parsedSpec"])
                      ]),
                      p.$slots.footer ? (k(), C("div", bte, [
                        se(p.$slots, "footer", Ir(jr(h.value)), void 0, !0)
                      ])) : H("", !0)
                    ], 64)) : H("", !0),
                    Z(xH, {
                      parsedSpec: p.parsedSpec,
                      proxyUrl: (w = p.configuration) == null ? void 0 : w.proxy
                    }, {
                      "sidebar-start": I(() => [
                        se(p.$slots, "sidebar-start", Ir(jr(h.value)), void 0, !0)
                      ]),
                      "sidebar-end": I(() => [
                        se(p.$slots, "sidebar-end", Ir(jr(h.value)), void 0, !0)
                      ]),
                      _: 3
                    }, 8, ["parsedSpec", "proxyUrl"])
                  ], 38)
                ];
              }),
              _: 2
            }, 1024)
          ]),
          _: 3
        })
      ], 64);
    };
  }
}), Z5 = /* @__PURE__ */ oe(vte, [["__scopeId", "data-v-f5b83f9d"]]), wte = {}, $te = { class: "references-classic-header-container" }, Ste = { class: "references-classic-header" };
function kte(t, e) {
  return k(), C("div", $te, [
    x("div", Ste, [
      se(t.$slots, "default", {}, void 0, !0),
      se(t.$slots, "dark-mode-toggle", {}, void 0, !0)
    ])
  ]);
}
const _te = /* @__PURE__ */ oe(wte, [["render", kte], ["__scopeId", "data-v-1c1eb708"]]), Pte = (t) => (fr("data-v-0acd62b8"), t = t(), hr(), t), xte = { class: "darklight-reference" }, Tte = { key: 0 }, Cte = { key: 1 }, Qte = /* @__PURE__ */ Pte(() => /* @__PURE__ */ x("a", {
  class: "darklight-reference-promo",
  href: "https://www.scalar.com",
  target: "_blank"
}, " Powered by scalar.com ", -1)), Ate = /* @__PURE__ */ G({
  __name: "DarkModeToggle",
  props: {
    isDarkMode: { type: Boolean }
  },
  emits: ["toggleDarkMode"],
  setup(t) {
    return (e, r) => (k(), C("div", xte, [
      x("button", {
        class: "darklight",
        type: "button",
        onClick: r[0] || (r[0] = (n) => e.$emit("toggleDarkMode"))
      }, [
        Z(v($t), { icon: "LightDarkModeToggle" }),
        e.isDarkMode ? (k(), C("span", Tte, "Light Mode")) : (k(), C("span", Cte, "Dark Mode"))
      ]),
      Qte
    ]));
  }
}), Ete = /* @__PURE__ */ oe(Ate, [["__scopeId", "data-v-0acd62b8"]]), Rte = /* @__PURE__ */ G({
  __name: "DarkModeIconToggle",
  props: {
    isDarkMode: { type: Boolean }
  },
  emits: ["toggleDarkMode"],
  setup(t) {
    return (e, r) => (k(), C("button", {
      class: "darklight",
      type: "button",
      onClick: r[0] || (r[0] = (n) => e.$emit("toggleDarkMode"))
    }, [
      Z(v($t), {
        icon: e.isDarkMode ? "DarkMode" : "LightMode"
      }, null, 8, ["icon"]),
      Z(T5, null, {
        default: I(() => [
          re(" Switch to " + te(e.isDarkMode ? "Light" : "Dark") + " Mode ", 1)
        ]),
        _: 1
      })
    ]));
  }
}), Ite = /* @__PURE__ */ oe(Rte, [["__scopeId", "data-v-b04e89bc"]]);
function jte() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1;
}
function Zte(t, e) {
  let r = t;
  const n = e.required && e.required.includes(t);
  return r += n ? " REQUIRED " : " optional ", e.properties[t] && (r += e.properties[t].type, e.properties[t].description && (r += " " + e.properties[t].description)), r;
}
function Mte(t) {
  var n;
  const e = ["Body"], r = (n = t == null ? void 0 : t.schema) == null ? void 0 : n.properties;
  return r && Object.keys(r).forEach((i) => {
    if (!t.schema)
      return;
    e.push(Zte(i, t.schema));
    const s = r[i];
    s.type === "object" && !!s.properties && s.properties && Object.keys(s.properties).forEach((a) => {
      var l, c;
      e.push(`${a} ${(c = (l = s.properties) == null ? void 0 : l[a]) == null ? void 0 : c.type}`);
    });
  }), e;
}
function qte(t) {
  var e, r, n;
  try {
    const i = (n = (r = (e = t == null ? void 0 : t.information) == null ? void 0 : e.requestBody) == null ? void 0 : r.content) == null ? void 0 : n["application/json"];
    if (!i)
      throw new Error("Body not found");
    return Mte(i);
  } catch {
    return !1;
  }
}
const Nte = (t) => (fr("data-v-6b991279"), t = t(), hr(), t), Dte = {
  key: 0,
  class: "ref-search-list custom-scroll"
}, zte = ["id", "href", "onClick", "onFocus"], Xte = {
  key: 0,
  class: "item-entry-title"
}, Wte = {
  key: 1,
  class: "item-entry-path"
}, Ute = {
  key: 2,
  class: "item-entry-description"
}, Vte = /* @__PURE__ */ Nte(() => /* @__PURE__ */ x("div", { class: "ref-search-meta" }, [
  /* @__PURE__ */ x("span", null, "â†‘â†“ Navigate"),
  /* @__PURE__ */ x("span", null, "âŽ Select")
], -1)), Lte = /* @__PURE__ */ G({
  __name: "SearchModal",
  props: {
    parsedSpec: {},
    modalState: {}
  },
  setup(t) {
    const e = t, r = an(e, "parsedSpec"), n = Uu(), i = ge([]), s = ge([]), o = ge(0), a = ge(""), l = ge(null), c = new D3(i.value, {
      keys: ["title", "description", "body"]
    }), u = () => {
      o.value = 0, s.value = c.search(a.value);
    }, d = fe(
      () => y.value[o.value]
    ), { getHeadingId: f, getWebhookId: h, getModelId: p, getOperationId: g, getTagId: m } = Jt();
    Ve(
      () => e.modalState.open,
      (S) => {
        S && (a.value = "", o.value = 0, s.value = []);
      }
    ), Ve(
      r.value,
      async () => {
        var J, U, ue, le, Pe, Ce;
        if (i.value = [], !((U = (J = e.parsedSpec) == null ? void 0 : J.tags) != null && U.length) && !((ue = e.parsedSpec) != null && ue.webhooks)) {
          c.setCollection([]);
          return;
        }
        const S = [], $ = await vu(
          ((le = e.parsedSpec.info) == null ? void 0 : le.description) ?? ""
        );
        $.length && ($.forEach((X) => {
          S.push({
            type: "heading",
            title: `Info > ${X.value}`,
            description: "",
            href: `#${f(X)}`,
            tag: X.slug,
            body: ""
          });
        }), i.value = i.value.concat(S)), (Pe = e.parsedSpec.tags) == null || Pe.forEach((X) => {
          const F = {
            title: X.name,
            href: `#${m(X)}`,
            description: X.description,
            type: "req",
            tag: X.name,
            body: ""
          };
          i.value.push(F), X.operations && X.operations.forEach((K) => {
            const { parameterMap: z } = Bm({ operation: K }), R = qte(K) || z.value;
            let D = null;
            typeof R != "boolean" && (D = R);
            const M = {
              type: "req",
              title: K.name ?? K.path,
              href: `#${g(K, X)}`,
              operationId: K.operationId,
              description: K.description ?? "",
              httpVerb: K.httpVerb,
              path: K.path,
              tag: X.name,
              operation: K
            };
            D && (M.body = D), i.value.push(M);
          });
        });
        const _ = e.parsedSpec.webhooks, Q = [];
        _ && Object.keys(_).forEach((X) => {
          Object.keys(
            _[X]
          ).forEach((K) => {
            var z;
            Q.push({
              type: "webhook",
              title: `Webhook: ${(z = _[X][K]) == null ? void 0 : z.name}`,
              href: `#${h(X, K)}`,
              description: X,
              httpVerb: K,
              tag: X,
              body: ""
            });
          }), i.value = i.value.concat(Q);
        });
        const N = (Ce = e.parsedSpec.components) == null ? void 0 : Ce.schemas, B = [];
        N && (Object.keys(N).forEach((X) => {
          B.push({
            type: "model",
            title: "Model",
            href: `#${p(X)}`,
            description: N[X].title ?? X,
            tag: X,
            body: ""
          });
        }), i.value = i.value.concat(B)), c.setCollection(i.value);
      },
      { immediate: !0 }
    ), Hs(n.enter, () => {
      e.modalState.open && window && (w(d.value), window.location.hash = d.value.item.href, e.modalState.hide());
    }), Hs(n.ArrowDown, () => {
      var S;
      e.modalState.open && window && (o.value < y.value.length - 1 ? o.value++ : o.value = 0, (S = document.getElementById(d.value.item.href)) == null || S.scrollIntoView({
        behavior: "smooth",
        block: "center"
      }));
    }), Hs(n.ArrowUp, () => {
      var S;
      e.modalState.open && window && (o.value > 0 ? o.value-- : o.value = y.value.length - 1, (S = document.getElementById(d.value.item.href)) == null || S.scrollIntoView({
        behavior: "smooth",
        block: "center"
      }));
    });
    const y = fe(
      () => a.value.length === 0 ? i.value.map((S) => ({
        item: S
      })) : s.value
    ), O = /#(tag\/[^/]*)/, { setCollapsedSidebarItem: b } = Un(), w = (S) => {
      let $ = "models";
      const _ = S.item.href.match(O);
      _ != null && _.length && _.length > 1 && ($ = _[1]), b($, !0), e.modalState.hide();
    };
    return (S, $) => (k(), Y(v(H2), {
      state: S.modalState,
      variant: "search"
    }, {
      default: I(() => [
        x("div", {
          ref_key: "searchModalRef",
          ref: l,
          class: "ref-search-container"
        }, [
          Ne(x("input", {
            "onUpdate:modelValue": $[0] || ($[0] = (_) => a.value = _),
            autocapitalize: "off",
            autocomplete: "off",
            autocorrect: "off",
            class: "ref-search-input",
            placeholder: "Search â€¦",
            spellcheck: "false",
            type: "text",
            onInput: u
          }, null, 544), [
            [xt, a.value]
          ])
        ], 512),
        y.value.length ? (k(), C("div", Dte, [
          (k(!0), C(ee, null, _e(y.value, (_, Q) => (k(), C("a", {
            id: _.item.href,
            key: _.refIndex,
            class: $e(["item-entry", {
              "item-entry--active": Q === o.value,
              "item-entry--tag": !_.item.httpVerb
            }]),
            href: _.item.href,
            onClick: (N) => w(_),
            onFocus: (N) => o.value = Q
          }, [
            Z(v(xi), {
              as: "div",
              class: "item-entry-http-verb",
              method: _.item.httpVerb ?? "get",
              short: ""
            }, null, 8, ["method"]),
            _.item.title ? (k(), C("div", Xte, te(_.item.title), 1)) : H("", !0),
            (_.item.httpVerb || _.item.path) && _.item.path !== _.item.title ? (k(), C("div", Wte, te(_.item.path), 1)) : _.item.description ? (k(), C("div", Ute, te(_.item.description), 1)) : H("", !0)
          ], 42, zte))), 128))
        ])) : H("", !0),
        Vte
      ]),
      _: 1
    }, 8, ["state"]));
  }
}), Yte = /* @__PURE__ */ oe(Lte, [["__scopeId", "data-v-6b991279"]]), Bte = (t) => (fr("data-v-fdb2c36b"), t = t(), hr(), t), Fte = { class: "sidebar-search-input" }, Hte = /* @__PURE__ */ Bte(() => /* @__PURE__ */ x("span", { class: "sidebar-search-placeholder" }, "Search", -1)), Gte = { class: "sidebar-search-shortcut" }, Kte = { class: "sidebar-search-key" }, Jte = /* @__PURE__ */ G({
  __name: "SearchButton",
  props: {
    spec: {},
    searchHotKey: { default: "k" }
  },
  setup(t) {
    const e = t, r = G2(), n = Uu();
    return Hs(
      n[`meta_${e.searchHotKey}`],
      () => r.open ? r.hide() : r.show()
    ), (i, s) => (k(), C(ee, null, [
      x("button", {
        class: $e(["sidebar-search", i.$attrs.class]),
        type: "button",
        onClick: s[0] || (s[0] = //@ts-ignore
        (...o) => v(r).show && v(r).show(...o))
      }, [
        Z(v($t), {
          class: "search-icon",
          icon: "Search",
          size: "sm"
        }),
        x("div", Fte, [
          Hte,
          x("span", Gte, [
            x("span", Kte, te(v(jte)() ? "âŒ˜" : "âŒƒ") + te(i.searchHotKey), 1)
          ])
        ])
      ], 2),
      Z(Yte, {
        modalState: v(r),
        parsedSpec: i.spec
      }, null, 8, ["modalState", "parsedSpec"])
    ], 64));
  }
}), M5 = /* @__PURE__ */ oe(Jte, [["__scopeId", "data-v-fdb2c36b"]]), ere = /* @__PURE__ */ G({
  __name: "ClassicLayout",
  props: {
    configuration: {},
    parsedSpec: {},
    rawSpec: {}
  },
  emits: ["toggleDarkMode"],
  setup(t) {
    const e = t, r = fe(() => ({ ...e.configuration, showSidebar: !1 }));
    return (n, i) => (k(), Y(Z5, {
      configuration: r.value,
      parsedSpec: n.parsedSpec,
      rawSpec: n.rawSpec
    }, {
      "content-start": I(({ spec: s }) => [
        Z(_te, null, {
          "dark-mode-toggle": I(() => {
            var o;
            return [
              Z(v(Ite), {
                isDarkMode: !!((o = n.configuration) != null && o.darkMode),
                onToggleDarkMode: i[0] || (i[0] = (a) => n.$emit("toggleDarkMode"))
              }, null, 8, ["isDarkMode"])
            ];
          }),
          default: I(() => [
            Z(M5, {
              class: "t-doc__sidebar",
              searchHotKey: r.value.searchHotKey,
              spec: s
            }, null, 8, ["searchHotKey", "spec"])
          ]),
          _: 2
        }, 1024)
      ]),
      "content-end": I(() => [
        se(n.$slots, "footer")
      ]),
      _: 3
    }, 8, ["configuration", "parsedSpec", "rawSpec"]));
  }
}), tre = { class: "references-mobile-header t-doc__header" }, rre = { class: "references-mobile-breadcrumbs" }, nre = { class: "references-mobile-header-actions" }, ire = /* @__PURE__ */ G({
  __name: "MobileHeader",
  props: {
    open: { type: Boolean }
  },
  emits: ["update:open"],
  setup(t) {
    const { breadcrumb: e } = Un();
    return (r, n) => (k(), C("div", tre, [
      Z(v(Vm), {
        icon: r.open ? "Close" : "Menu",
        label: r.open ? "Close Menu" : "Open Menu",
        size: "md",
        onClick: n[0] || (n[0] = (i) => r.$emit("update:open", !r.open))
      }, null, 8, ["icon", "label"]),
      x("span", rre, te(v(e)), 1),
      x("div", nre, [
        se(r.$slots, "actions", {}, void 0, !0)
      ])
    ]));
  }
}), sre = /* @__PURE__ */ oe(ire, [["__scopeId", "data-v-f34d1ece"]]), ore = { class: "scalar-api-references-standalone-search" }, are = /* @__PURE__ */ G({
  __name: "ModernLayout",
  props: {
    configuration: {},
    parsedSpec: {},
    rawSpec: {}
  },
  emits: ["toggleDarkMode"],
  setup(t) {
    const e = t, r = ge(!1), n = Vu("(max-width: 1000px)");
    Ve(n, (o, a) => {
      o && !a && (r.value = !1);
    });
    const i = fe(() => {
      var a;
      const o = n.value ? r.value : (a = e.configuration) == null ? void 0 : a.showSidebar;
      return { ...e.configuration, showSidebar: o };
    }), { hash: s } = Jt();
    return Ve(s, (o, a) => {
      o && o !== a && (r.value = !1);
    }), (o, a) => (k(), Y(Z5, {
      class: $e({ "scalar-api-references-standalone-mobile": v(n) }),
      configuration: i.value,
      parsedSpec: o.parsedSpec,
      rawSpec: o.rawSpec
    }, Fp({
      "sidebar-start": I(({ spec: l }) => {
        var c;
        return [
          x("div", ore, [
            Z(M5, {
              searchHotKey: (c = e.configuration) == null ? void 0 : c.searchHotKey,
              spec: l
            }, null, 8, ["searchHotKey", "spec"])
          ])
        ];
      }),
      "sidebar-end": I(() => {
        var l;
        return [
          Z(v(Ete), {
            isDarkMode: !!((l = o.configuration) != null && l.darkMode),
            onToggleDarkMode: a[1] || (a[1] = (c) => o.$emit("toggleDarkMode"))
          }, null, 8, ["isDarkMode"])
        ];
      }),
      "content-end": I(() => [
        se(o.$slots, "footer", {}, void 0, !0)
      ]),
      _: 2
    }, [
      v(n) ? {
        name: "header",
        fn: I(() => [
          Z(sre, {
            open: r.value,
            "onUpdate:open": a[0] || (a[0] = (l) => r.value = l)
          }, null, 8, ["open"])
        ]),
        key: "0"
      } : void 0
    ]), 1032, ["class", "configuration", "parsedSpec", "rawSpec"]));
  }
}), lre = /* @__PURE__ */ oe(are, [["__scopeId", "data-v-a00acb42"]]), cre = {
  modern: lre,
  classic: ere
}, Bre = /* @__PURE__ */ G({
  __name: "ApiReference",
  props: {
    configuration: {}
  },
  emits: ["updateContent"],
  setup(t) {
    var d;
    const e = t, r = fe(() => {
      var f;
      return {
        spec: {
          content: void 0,
          url: void 0,
          ...(f = e.configuration) == null ? void 0 : f.spec
        },
        proxy: void 0,
        theme: "default",
        showSidebar: !0,
        isEditable: !1,
        ...e.configuration
      };
    }), { initializeToasts: n } = oS();
    n((f) => {
      P3(f);
    }), (d = r.value) != null && d.metaData && (S3(), k3(r.value.metaData));
    function i(f, h) {
      Ve(
        () => {
          var p;
          return (p = r.value) == null ? void 0 : p[f];
        },
        (p) => {
          typeof p < "u" && h(p);
        },
        { immediate: !0 }
      );
    }
    const { toggleDarkMode: s, setDarkMode: o } = nI();
    i("darkMode", (f) => {
      f !== void 0 && o(f);
    });
    const { setAuthentication: a } = Ti();
    i("authentication", a);
    const { setExcludedClients: l } = xl();
    i("hiddenClients", l);
    const { parsedSpec: c, rawSpec: u } = dF({
      proxy: an(() => {
        var f;
        return ((f = e.configuration) == null ? void 0 : f.proxy) || "";
      }),
      specConfig: an(() => {
        var f;
        return ((f = e.configuration) == null ? void 0 : f.spec) || {};
      })
    });
    return (f, h) => {
      var p, g;
      return k(), C(ee, null, [
        (p = r.value) != null && p.customCss ? (k(), Y(Oi("style"), { key: 0 }, {
          default: I(() => [
            re(te(r.value.customCss), 1)
          ]),
          _: 1
        })) : H("", !0),
        (k(), Y(Oi(v(cre)[((g = r.value) == null ? void 0 : g.layout) || "modern"]), {
          configuration: r.value,
          parsedSpec: v(c),
          rawSpec: v(u),
          onToggleDarkMode: h[0] || (h[0] = () => v(s)()),
          onUpdateContent: h[1] || (h[1] = (m) => f.$emit("updateContent", m))
        }, {
          footer: I(() => [
            se(f.$slots, "footer")
          ]),
          _: 3
        }, 40, ["configuration", "parsedSpec", "rawSpec"])),
        Z(TH)
      ], 64);
    };
  }
});
export {
  xH as ApiClientModal,
  Bre as ApiReference,
  Z5 as ApiReferenceLayout,
  vs as Card,
  bn as CardContent,
  Id as CardFooter,
  ws as CardHeader,
  zH as CardTab,
  NH as CardTabHeader,
  Ite as DarkModeIconToggle,
  Ete as DarkModeToggle,
  Kee as RenderedReference,
  M5 as SearchButton,
  Yte as SearchModal,
  Wp as Sidebar,
  UR as createEmptyAuthenticationState,
  LR as createEmptyServerState,
  ER as deepMerge,
  iS as downloadSpecBus,
  eI as downloadSpecFile,
  F$ as getApiClientRequest,
  J$ as getBase64Token,
  Yt as getExampleFromSchema,
  H$ as getHarRequest,
  vu as getHeadingsFromMarkdown,
  G$ as getLowestHeadingLevel,
  oo as getParametersFromOperation,
  jR as getRequestBodyFromOperation,
  K$ as getRequestFromAuthentication,
  rp as getRequestFromOperation,
  MR as getSecretCredentialsFromAuthentication,
  np as getUrlFromServerState,
  Nre as getVariableNames,
  tS as hasModels,
  qR as hasSecuritySchemes,
  NR as hasWebhooks,
  DR as isValidUrl,
  zR as json2xml,
  XR as mapFromObject,
  Dre as mergeAllObjects,
  WR as objectMerge,
  op as openClientFor,
  wu as prettyPrintJson,
  eS as replaceVariables,
  rS as scrollToId,
  nS as sleep,
  tI as splitMarkdownInSections,
  Gp as useApiClientStore,
  Ti as useGlobalStore,
  dF as useReactiveSpec
};

"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildParamsFromCalls = exports.assertActionChangeIsValid = void 0;
const set_1 = __importDefault(require("lodash/set"));
const get_1 = __importDefault(require("lodash/get"));
const unset_1 = __importDefault(require("lodash/unset"));
const merge_1 = __importDefault(require("lodash/merge"));
const lodash_1 = require("lodash");
const targets_1 = require("./targets");
const actions_1 = require("./actions");
const extractNestedActions_1 = require("./extractNestedActions");
const cloneParams_1 = require("./cloneParams");
function addWriteArgsToParams(params, target, updatedParams) {
    var _a;
    const toOneRelation = !((_a = updatedParams.scope) === null || _a === void 0 ? void 0 : _a.relations.to.isList);
    const targetPath = (0, targets_1.buildWriteTargetPath)(target);
    const targetArgs = (0, get_1.default)(params.args, targetPath);
    // it's possible to target args that have already been updated if the user
    // has reused the same object in multiple places when changing action, in this
    // case we can just return
    if (targetArgs === updatedParams.args) {
        return;
    }
    // if target doesn't exist or is a boolean action, we can just set the args
    if (!targetArgs || typeof targetArgs === "boolean") {
        (0, set_1.default)(params.args, targetPath, updatedParams.args);
        return;
    }
    // createMany operations cannot be turned into arrays of operations so merge
    // their data fields
    if (target.action === "createMany") {
        (0, set_1.default)(params.args, [...targetPath, "data"], [...targetArgs.data, ...updatedParams.args.data]);
        return;
    }
    // to one relations have actions that cannot be turned into arrays of operations
    // so merge their args
    if (toOneRelation && actions_1.toOneRelationNonListActions.includes(target.action)) {
        (0, merge_1.default)((0, get_1.default)(params.args, targetPath), updatedParams.args);
        return;
    }
    // if target is an array of operations push args as another operation
    if (Array.isArray(targetArgs)) {
        targetArgs.push(updatedParams.args);
        return;
    }
    // convert target to an array of operations with the target args as the
    // first operation and passed args as the second
    (0, set_1.default)(params.args, targetPath, [targetArgs, updatedParams.args]);
}
function removeWriteArgsFromParams(params, target) {
    // remove args from target
    const targetPath = (0, targets_1.buildWriteTargetPath)(target);
    (0, unset_1.default)(params.args, targetPath);
    // if target parent is now an empty object or array we must remove it
    const targetParentPath = targetPath.slice(0, -1);
    const targetParent = (0, get_1.default)(params.args, targetParentPath);
    if (Object.keys(targetParent).length === 0) {
        (0, unset_1.default)(params.args, targetParentPath);
    }
}
function removeReadArgsFromParams(params, target) {
    // remove args from target
    const targetPath = (0, targets_1.buildReadTargetPath)(target);
    (0, unset_1.default)(params.args, targetPath);
    // if target parent is an array with only unset values we must remove it
    const targetParentPath = targetPath.slice(0, -1);
    const targetParent = (0, get_1.default)(params.args, targetParentPath);
    if (Object.keys(targetParent).length === 0) {
        (0, unset_1.default)(params.args, targetParentPath);
    }
}
function assertActionChangeIsValid(previousAction, nextAction) {
    if ((0, actions_1.isReadAction)(previousAction) && (0, actions_1.isWriteAction)(nextAction)) {
        throw new Error("Changing a read action to a write action is not supported");
    }
    if ((0, actions_1.isWriteAction)(previousAction) && (0, actions_1.isReadAction)(nextAction)) {
        throw new Error("Changing a write action to a read action is not supported");
    }
    if ((0, actions_1.isQueryAction)(previousAction) && !(0, actions_1.isQueryAction)(nextAction)) {
        throw new Error("Changing a query action to a non-query action is not supported");
    }
}
exports.assertActionChangeIsValid = assertActionChangeIsValid;
function moveActionChangesToEnd(callA, callB) {
    if (callA.target.action !== callA.origin.action) {
        return 1;
    }
    if (callB.target.action !== callB.origin.action) {
        return -1;
    }
    return 0;
}
function findParentCall(calls, origin) {
    return calls.find((call) => origin.parentTarget &&
        (0, targets_1.buildTargetPath)(origin.parentTarget).join(".") ===
            (0, targets_1.buildTargetPath)(call.origin).join("."));
}
function buildParamsFromCalls(calls, parentParams) {
    const finalParams = (0, cloneParams_1.cloneParams)(parentParams);
    // calls should update the parent calls updated params
    // sort calls so we set from deepest to shallowest
    // actions that are at the same depth should put action changes at the end
    const sortedCalls = calls.sort((a, b) => {
        const aDepth = (0, targets_1.targetChainLength)(a.target);
        const bDepth = (0, targets_1.targetChainLength)(b.target);
        if (aDepth === bDepth) {
            return moveActionChangesToEnd(a, b);
        }
        return bDepth - aDepth;
    });
    // eslint-disable-next-line complexity
    sortedCalls.forEach((call, i) => {
        var _a;
        const parentCall = findParentCall(calls.slice(i), call.origin);
        const targetParams = (parentCall === null || parentCall === void 0 ? void 0 : parentCall.updatedParams) || finalParams;
        const origin = (0, lodash_1.omit)(call.origin, "parentTarget");
        const target = (0, lodash_1.omit)(call.target, "parentTarget");
        if (origin.action !== target.action) {
            assertActionChangeIsValid(origin.action, target.action);
        }
        if ((0, targets_1.isWriteTarget)(target) && (0, targets_1.isWriteTarget)(origin)) {
            // if action has not changed use normal target to set args
            if (target.action === origin.action) {
                const targetPath = (0, targets_1.buildWriteTargetPath)(target);
                const targetArgs = (0, get_1.default)(targetParams.args, targetPath);
                // if target hasn't changed but is an array it has been merged
                // the original target must be the first element of the array
                if (Array.isArray(targetArgs)) {
                    targetArgs[0] = call.updatedParams.args;
                    return;
                }
                // set the updated args if the target hasn't changed
                (0, set_1.default)(targetParams.args, targetPath, call.updatedParams.args);
                return;
            }
            // if parent action has not changed we can use our normal targets
            if (targetParams.action === ((_a = call.updatedParams.scope) === null || _a === void 0 ? void 0 : _a.parentParams.action)) {
                addWriteArgsToParams(targetParams, target, call.updatedParams);
                removeWriteArgsFromParams(targetParams, origin);
                return;
            }
            // if parent action has changed we must modify out target to match the
            // parent action
            const fields = extractNestedActions_1.fieldsByWriteAction[targetParams.action];
            fields.forEach((field) => {
                const newOrigin = { ...origin, field };
                const newTarget = { ...target, field };
                if ((0, get_1.default)(targetParams.args, (0, targets_1.buildWriteTargetPath)(newOrigin))) {
                    // if action has changed we add merge args with target and remove the
                    // args from the origin
                    addWriteArgsToParams(targetParams, newTarget, call.updatedParams);
                    removeWriteArgsFromParams(targetParams, newOrigin);
                }
            });
        }
        if ((0, targets_1.isReadTarget)(target) && (0, targets_1.isReadTarget)(origin)) {
            const targetPath = (0, targets_1.buildReadTargetPath)(target);
            // Do nothing if the target action has changed and already exists. Having
            // a select and include at the same level is not supported so we should
            // pass this through so Prisma can throw an error to let the user know.
            if (origin.action !== target.action &&
                typeof (0, get_1.default)(targetParams, targetPath) !== "undefined") {
                return;
            }
            // because includes and selects cannot be at the same level we can safely
            // set target path to be the updated args without worrying about
            // overwriting the original args
            (0, set_1.default)(targetParams.args, targetPath, call.updatedParams.args);
            // remove the origin args if the action has changed
            if (target.action !== origin.action) {
                removeReadArgsFromParams(targetParams, origin);
            }
        }
        if ((0, targets_1.isQueryTarget)(target) && (0, targets_1.isQueryTarget)(origin)) {
            if (target.readAction) {
                (0, set_1.default)(targetParams.args, "where", call.updatedParams.args);
                return;
            }
            const basePath = parentCall ? [] : ["where"];
            (0, set_1.default)(targetParams.args, [...basePath, ...(0, targets_1.buildQueryTargetPath)(target)], call.updatedParams.args);
        }
    });
    return finalParams;
}
exports.buildParamsFromCalls = buildParamsFromCalls;
